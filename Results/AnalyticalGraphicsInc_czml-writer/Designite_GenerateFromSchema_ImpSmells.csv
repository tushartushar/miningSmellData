Implementation smell,Namespace,Class,File,Method,Description
Long Method,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The method has 983 lines of code.
Long Method,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The method has 480 lines of code.
Long Method,GenerateFromSchema,MarkdownGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\MarkdownGenerator.cs,Generate,The method has 125 lines of code.
Complex Method,GenerateFromSchema,CSharpGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteLeafProperty,Cyclomatic complexity of the method is 8
Complex Method,GenerateFromSchema,CSharpGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,GetOverloadsForProperty,Cyclomatic complexity of the method is 9
Complex Method,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,Cyclomatic complexity of the method is 90
Complex Method,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,Cyclomatic complexity of the method is 48
Complex Method,GenerateFromSchema,MarkdownGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\MarkdownGenerator.cs,Generate,Cyclomatic complexity of the method is 20
Complex Method,GenerateFromSchema,MarkdownGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\MarkdownGenerator.cs,JsonSchemaTypesToLabel,Cyclomatic complexity of the method is 10
Long Parameter List,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,WriteValue,The method has 7 parameters. Parameters: writer' openWriterName' valueName' valueProperty' parentProperty' isExtension' propertyName
Long Parameter List,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,WriteValues,The method has 7 parameters. Parameters: writer' openWriterName' valueName' valueProperty' parentProperty' isExtension' propertyName
Long Parameter List,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The method has 9 parameters. Parameters: propertyName' valueName' valueProperty' parentProperty' value' valueSuffix' assertionValue' assertionEpsilon' valueType
Long Statement,GenerateFromSchema,CSharpGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteUsingStatements,The length of the statement  "                                      .SelectMany(property => GetOverloadsForProperty(property).Concat(property.ValueType.Properties.SelectMany(GetOverloadsForProperty))) " is 132.
Long Statement,GenerateFromSchema,CSharpGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteDescriptionAsClassSummary,The length of the statement  "            WriteSummaryText(writer' "Writes a <c>{0}</c> to a <see cref=\"CesiumOutputStream\"/>. A <c>{0}</c> is {1}"' schema.Name' description); " is 135.
Long Statement,GenerateFromSchema,CSharpGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteProperties,The length of the statement  "                WriteSummaryText(writer' "Gets a new writer for a <c>{0}</c> property. The returned instance must be opened by calling the <see cref=\"CesiumElementWriter.Open\"/> method before it can be used for writing. A <c>{0}</c> property defines {1}"' additionalPropertiesValueType.Name' GetDescription(additionalProperties)); " is 316.
Long Statement,GenerateFromSchema,CSharpGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteProperties,The length of the statement  "                WriteSummaryText(writer' "Opens and returns a new writer for a <c>{0}</c> property. A <c>{0}</c> property defines {1}"' additionalPropertiesValueType.Name' GetDescription(additionalProperties)); " is 194.
Long Statement,GenerateFromSchema,CSharpGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteProperties,The length of the statement  "                writer.WriteLine("public {0} Open{1}Property(string name)"' writerType' additionalPropertiesValueType.NameWithPascalCase); " is 122.
Long Statement,GenerateFromSchema,CSharpGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteIntervalsProperty,The length of the statement  "            WriteSummaryText(writer' "Gets the writer for the <c>{0}</c> property. The returned instance must be opened by calling the <see cref=\"CesiumElementWriter.Open\"/> method before it can be used for writing. The <c>{0}</c> property defines {1}"' property.Name' GetDescription(property)); " is 285.
Long Statement,GenerateFromSchema,CSharpGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteIntervalsProperty,The length of the statement  "            WriteSummaryText(writer' "Opens and returns the writer for the <c>{0}</c> property. The <c>{0}</c> property defines {1}"' property.Name' GetDescription(property)); " is 163.
Long Statement,GenerateFromSchema,CSharpGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteIntervalsProperty,The length of the statement  "                    WriteSummaryText(writer' "Writes a value for the <c>{0}</c> property as a <c>{1}</c> value. The <c>{0}</c> property specifies {2}"' property.Name' nestedProperty.Name' GetDescription(property)); " is 194.
Long Statement,GenerateFromSchema,CSharpGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteIntervalsProperty,The length of the statement  "                    writer.WriteLine("public void Write{0}Property{1}({2})"' property.NameWithPascalCase' subPropertyName' overload.FormattedParameters); " is 133.
Long Statement,GenerateFromSchema,CSharpGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteIntervalsProperty,The length of the statement  "                            writer.WriteLine("writer.Write{0}({1});"' nestedProperty.NameWithPascalCase' string.Join("' "' Array.ConvertAll(overload.Parameters' p => p.Name))); " is 148.
Long Statement,GenerateFromSchema,CSharpGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteLeafProperty,The length of the statement  "                WriteSummaryText(writer' "Writes the value expressed as a <c>{0}</c>' which is {1}"' property.Name' GetDescription(property)); " is 126.
Long Statement,GenerateFromSchema,CSharpGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteAsTypeMethods,The length of the statement  "                WriteSummaryText(writer' "Returns a wrapper for this instance that implements <see cref=\"ICesium{0}ValuePropertyWriter\"/>. Because the returned instance is a wrapper for this instance' you may call <see cref=\"ICesiumElementWriter.Close\"/> on either this instance or the wrapper' but you must not call it on both."' property.ValueType.NameWithPascalCase); " is 358.
Long Statement,GenerateFromSchema,ParameterInfo,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,Format,The length of the statement  "                string attributes = string.Join(" "' Array.ConvertAll(Attributes ?? Array.Empty<string>()' attribute => $"[{attribute}]")); " is 123.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                        writer.WriteLine("private readonly JulianDate m_documentStartDate = new GregorianDate(2016' 6' 17' 12' 0' 0).ToJulianDate();"); " is 127.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                        writer.WriteLine("private readonly JulianDate m_documentStopDate = new GregorianDate(2016' 6' 17' 13' 0' 0).ToJulianDate();"); " is 126.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                            writer.WriteLine("using (m_assertionsWriter = File.CreateText(Path.Combine(dir' \"ValidationDocumentAssertions.js\")))"); " is 121.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                            writer.WriteLine("using (m_extensionsAssertionsWriter = File.CreateText(Path.Combine(dir' \"ValidationDocumentExtensionAssertions.js\")))"); " is 140.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                WriteAssertionBoth(writer' "return CzmlDataSource.load('Data/CZML/ValidationDocument.czml').then(function(dataSource) {"); " is 122.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                // Java has a limit on the size of a single method (65535 bytes) so we have to break up all this code in multiple methods " is 121.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                        WriteValue(writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' $"{propertyName}.{subPropertyName}"); " is 128.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                                        WriteValue(writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' $"{propertyName}.{subPropertyName}.{materialSubProperty.Name}"); " is 206.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                                            WriteValue(writer' "w3"' id + property.Name' firstValueProperty' additionalSubProperty' isExtension' $"{propertyName}.{subPropertyName}.prop.{additionalSubProperty.Name}"); " is 172.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                                        WriteValue(writer' "a"' id + property.Name' firstValueProperty' additionalProperties' isExtension' $"{propertyName}.{subPropertyName}.prop"); " is 141.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                WriteValue(writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' $"{propertyName}.{subPropertyName}"); " is 123.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                        WriteValue(writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' $"{propertyName}.{subPropertyName}.{materialSubProperty.Name}"); " is 206.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                                WriteValue(writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' $"{propertyName}.{subPropertyName}.{materialSubProperty.Name}"); " is 206.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                            WriteValue(writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' $"{propertyName}.{subPropertyName}.{materialSubProperty.Name}"); " is 201.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                    string id = $"constant_{propertyName}_{subProperty.Name}_{additionalProperties.ValueType.Name}_{additionalSubProperty.Name}"; " is 125.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                    writer.WriteLine("using (var a = w2.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName); " is 125.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                        WriteValue(writer' "w3"' id + property.Name + subProperty.Name' valueProperty' additionalSubProperty' isExtension' $"{propertyName}.{subPropertyName}.{propName}.{additionalSubProperty.Name}"); " is 192.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                            writer.WriteLine("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName); " is 125.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                WriteValue(writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' $"{propertiesProperty.Name}.{propName}"); " is 135.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                        WriteValue(writer' "w2"' id + property.Name' firstValueProperty' subProperty' false' $"{property.Name}.{subProperty.Name}"); " is 124.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                            WriteAssertion(writer' isExtension' "expect(e.{0}.getValue(date)).toEqual(constant.{0}.getValue(date));"' propertyName); " is 120.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                        writer.WriteLine("w2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\")));"' propertyName' subPropertyName); " is 129.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                        WriteAssertion(writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual(constant.{0}.{1}.getValue(date));"' propertyName' subPropertyName); " is 145.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                        writer.WriteLine("w2.WriteReferences(CreateList(new Reference(\"Constant{0}1\"' CreateList({1}))' new Reference(\"Constant{0}2\"' CreateList({1}))));"' targetId' string.Join("' "' referencePropertyNames.Select(n => $"\"{n}\""))); " is 229.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                        WriteAssertion(writer' isExtension' "expect(e.{0}.{1}.getValue(date){4}).toEqual([dataSource.entities.getById('Constant{2}1').{3}.getValue(date)' dataSource.entities.getById('Constant{2}2').{3}.getValue(date)]);"' propertyName' subPropertyName' targetId' string.Join("."' referencePropertyNames)' valueSuffix); " is 310.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                        writer.WriteLine("w2.WriteReferences(CreateList(CreateList(new Reference(\"Constant{0}1\"' CreateList({1}))' new Reference(\"Constant{0}2\"' CreateList({1}))' new Reference(\"Constant{0}3\"' CreateList({1})))));"' targetId' string.Join("' "' referencePropertyNames.Select(n => $"\"{n}\""))); " is 291.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                        WriteAssertion(writer' isExtension' "expect(e.{0}.{1}.getValue(date){4}).toEqual([ new PolygonHierarchy([ dataSource.entities.getById('Constant{2}1').{3}.getValue(date)' dataSource.entities.getById('Constant{2}2').{3}.getValue(date)' dataSource.entities.getById('Constant{2}3').{3}.getValue(date) ])]);"' propertyName' subPropertyName' targetId' string.Join("."' referencePropertyNames)' valueSuffix); " is 401.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                                writer.WriteLine("m2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"{2}\")));"' propertyName' subPropertyName' materialSubProperty.Name); " is 164.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                                WriteAssertion(writer' isExtension' "expect(e.{0}.{1}.{2}.getValue(date)).toEqual(constant.{0}.{1}.{2}.getValue(date));"' propertyName' subPropertyName' materialSubProperty.Name); " is 179.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                        writer.WriteLine("using (var a = w2.Open{0}Property(\"referenceProp\"))"' additionalProperties.ValueType.NameWithPascalCase); " is 125.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                                    writer.WriteLine("w3.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"prop\"' \"{2}\")));"' propertyName' subPropertyName' additionalSubProperty.Name); " is 176.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                                    WriteAssertion(writer' isExtension' "expect(e.{0}.{1}.referenceProp.{2}.getValue(date)).toEqual(constant.{0}.{1}.prop.{2}.getValue(date));"' propertyName' subPropertyName' additionalSubProperty.Name); " is 200.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                                writer.WriteLine("a.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"prop\")));"' propertyName' subPropertyName); " is 138.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                                WriteAssertion(writer' isExtension' "expect(e.{0}.{1}.referenceProp.getValue(date)).toEqual(constant.{0}.{1}.prop.getValue(date));"' propertyName' subPropertyName); " is 164.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                    writer.WriteLine("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2); " is 157.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                    WriteAssertion(writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2); " is 168.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                WriteAssertion(writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ); " is 249.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                            writer.WriteLine("m2.WriteReference(new Reference(\"{0}\"' CreateList(\"{1}\"' \"{2}\"' \"{3}\")));"' targetId' propertyName' subPropertyName' materialSubProperty.Name); " is 169.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                            WriteAssertion(writer' isExtension' "expect(e.{1}.{2}.{3}.getValue(date)).toEqual(dataSource.entities.getById('{0}').{1}.{2}.{3}.getValue(date));"' targetId' propertyName' subPropertyName' materialSubProperty.Name); " is 215.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                            var firstValueProperty = properties.First(p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array); " is 132.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                        var subProperties = properties.Where(p => !p.IsValue && (p.IsInterpolatable || p.ValueType.Name.Contains("Material"))).ToList(); " is 128.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                            var firstValueProperty = properties.First(p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array); " is 132.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                            WriteValues(writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' $"{propertyName}.{subPropertyName}"); " is 129.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                                        var firstValueProperty = properties.First(p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array); " is 132.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                                        WriteValues(writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' $"{propertyName}.{subPropertyName}.{materialSubProperty.Name}"); " is 207.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                    foreach (var valueProperty in properties.Where(p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip(1)) " is 145.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                            foreach (var valueProperty in properties.Where(p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip(1)) " is 145.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                        WriteValues(writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' $"{propertyName}.{subPropertyName}"); " is 124.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                foreach (var valueProperty in properties.Where(p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip(1)) " is 145.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                            WriteValues(writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' $"{propertyName}.{subPropertyName}.{materialSubProperty.Name}"); " is 207.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                                var firstValueProperty = properties.First(p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array); " is 132.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                                WriteValues(writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' $"{propertyName}.{subPropertyName}.{materialSubProperty.Name}"); " is 207.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                    foreach (var valueProperty in properties.Where(p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip(1)) " is 145.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                                WriteValues(writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' $"{propertyName}.{subPropertyName}.{materialSubProperty.Name}"); " is 202.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                        foreach (var valueProperty in additionalProperties.ValueType.Properties.Where(p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array)) " is 168.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                            writer.WriteLine("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName); " is 125.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "                                                WriteValues(writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' $"{propertiesProperty.Name}.{propName}"); " is 136.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,WriteValue,The length of the statement  "            GetUniqueValue(propertyName' valueName' valueProperty' parentProperty' out string value' out string valueSuffix' out string assertionValue' out string assertionEpsilon' out _); " is 176.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,WriteValues,The length of the statement  "            GetUniqueValue(propertyName' valueName + 1' valueProperty' parentProperty' out string value1' out string valueSuffix1' out string assertionValue1' out string assertionEpsilon1' out _); " is 184.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,WriteValues,The length of the statement  "            GetUniqueValue(propertyName' valueName + 2' valueProperty' parentProperty' out string value2' out string valueSuffix2' out string assertionValue2' out string assertionEpsilon2' out _); " is 184.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,WriteValues,The length of the statement  "            writer.WriteLine("{0}.Write{1}(CreateList(m_documentStartDate' m_documentStopDate)' CreateList({2}' {3}));"' openWriterName' valueProperty.NameWithPascalCase' value1' value2); " is 175.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The length of the statement  "                    assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]"; " is 123.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The length of the statement  "                        return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})"; " is 150.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The length of the statement  "                        return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})"; " is 151.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The length of the statement  "                    string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]"; " is 150.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The length of the statement  "                    assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]"; " is 123.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The length of the statement  "                    value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))"; " is 134.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The length of the statement  "                    assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]"; " is 147.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The length of the statement  "                        return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})"; " is 162.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The length of the statement  "                    string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})"; " is 129.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The length of the statement  "                        return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})"; " is 168.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The length of the statement  "                    string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]"; " is 127.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The length of the statement  "                    string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]"; " is 162.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,WriteAssertion,The length of the statement  "            writer.WriteLine("{0}.WriteLine(\"{1}{2}\");"' isExtension ? "m_extensionsAssertionsWriter" : "m_assertionsWriter"' AssertionIndent' assertion); " is 144.
Long Statement,GenerateFromSchema,MarkdownGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\MarkdownGenerator.cs,Generate,The length of the statement  "                output.WriteLine("This page describes the possible content of a CZML document or stream. Please read [[CZML Structure]] for an explanation of how a CZML document is put together."); " is 181.
Long Statement,GenerateFromSchema,MarkdownGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\MarkdownGenerator.cs,Generate,The length of the statement  "                    output.WriteLine("This type represents a key-value mapping' where values are of type [[{0}]]."' propertyValueType.Name); " is 120.
Long Statement,GenerateFromSchema,SchemaLoader,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\SchemaLoader.cs,LoadSchema,The length of the statement  "            schema.Extends.AddRange(GetValues<string>(schemaJson' "allOf..$ref").Select(extend => LoadRelativeSchema(schemaFileName' extend))); " is 131.
Complex Conditional,GenerateFromSchema,CSharpGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,GetOverloadsForProperty,The conditional expression  "type.HasFlag(JsonSchemaType.Object) ||                      type.HasFlag(JsonSchemaType.Array) ||                      type.HasFlag(JsonSchemaType.Null) ||                      type.HasFlag(JsonSchemaType.Any) ||                      type == JsonSchemaType.None"  is complex.
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: i <= 3
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: double dy = 2.0;
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: double dz = 3.0;
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: double deltaTime = 60.0;
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: double y1 = 2.0;
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: double z1 = 3.0;
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: double expectedY = 2.0;
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: double expectedZ = 3.0;
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,WriteValues,The following statement contains a magic number: GetUniqueValue(propertyName' valueName + 2' valueProperty' parentProperty' out string value2' out string valueSuffix2' out string assertionValue2' out string assertionEpsilon2' out _);
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: return BitConverter.ToUInt16(hash.Value' n % 8);
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Magic Number,GenerateFromSchema,MarkdownGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\MarkdownGenerator.cs,JsonSchemaTypesToLabel,The following statement contains a magic number: var types = new string[6];
Magic Number,GenerateFromSchema,MarkdownGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\MarkdownGenerator.cs,JsonSchemaTypesToLabel,The following statement contains a magic number: switch (index)              {                  case 0:                      return "";                  case 1:                      return types[0];                  case 2:                      return types[0] + " or " + types[1];                  default:                      return string.Join("' "' types' 0' index - 1) + "' or " + types[index - 1];              }
Missing Default,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following switch statement is missing a default case: switch (valueTypeName)              {                  case "Boolean":                  {                      value = assertionValue = "true";                      valueType = "bool";                      return;                  }                  case "Double":                  {                      value = assertionValue = GetNumber(0).ToString("#.0");                      valueType = "double";                      return;                  }                  case "Integer":                  {                      value = assertionValue = GetNumber(0).ToString();                      valueType = "int";                      return;                  }                  case "DoubleList":                  {                      int v1 = GetNumber(0);                      int v2 = GetNumber(1);                      value = $"CreateList<double>({v1}' {v2})";                      assertionValue = $"[ {v1}' {v2} ]";                      valueType = "List<double>";                      return;                  }                  case "String":                  {                      string v = $"string{GetNumber(0)}";                      value = $"\"{v}\"";                      assertionValue = $"'{v}'";                      valueType = "string";                      return;                  }                  case "Cartesian3":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                        value = $"new Cartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Cartesian";                      return;                  }                  case "Cartesian3List":                  {                      int x1 = GetNumber(0);                      int y1 = GetNumber(1);                      int z1 = GetNumber(2);                      int x2 = GetNumber(3);                      int y2 = GetNumber(4);                      int z2 = GetNumber(5);                        value = $"CreateList(new Cartesian({x1}' {y1}' {z1})' new Cartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      else if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                        assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "Cartesian3ListOfLists":                  {                      const int valuesPerCartesian = 3;                      double[] values = new double[7 * valuesPerCartesian];                      for (int i = 0; i < values.Length; i += valuesPerCartesian)                      {                          double x = GetNumber(i + 0);                          double y = GetNumber(i + 1);                          double z = GetNumber(i + 2);                          values[i + 0] = x;                          values[i + 1] = y;                          values[i + 2] = z;                      }                        string CreateCartesian(int index)                      {                          return $"new Cartesian({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartesian(0)}' {CreateCartesian(1)}' {CreateCartesian(2)})";                      string list2 = $"CreateList({CreateCartesian(3)}' {CreateCartesian(4)}' {CreateCartesian(5)}' {CreateCartesian(6)})";                        value = $"CreateList({list1}' {list2})";                        string CreateCartesianJavaScript(int index)                      {                          return $"new Cartesian3({values[valuesPerCartesian * index + 0]}' {values[valuesPerCartesian * index + 1]}' {values[valuesPerCartesian * index + 2]})";                      }                        string array1 = $"[ {CreateCartesianJavaScript(0)}' {CreateCartesianJavaScript(1)}' {CreateCartesianJavaScript(2)} ]";                      string array2 = $"[ {CreateCartesianJavaScript(3)}' {CreateCartesianJavaScript(4)}' {CreateCartesianJavaScript(5)}' {CreateCartesianJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "UnitCartesian3":                  {                      double x = GetNumber(0);                      double y = GetNumber(1);                      double z = GetNumber(2);                      NormalizeCartesian(ref x' ref y' ref z);                        value = $"new UnitCartesian({x}' {y}' {z})";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "UnitCartesian";                      assertionEpsilon = "1e-14";                      return;                  }                  case "UnitCartesian3List":                  {                      double x1 = GetNumber(0);                      double y1 = GetNumber(1);                      double z1 = GetNumber(2);                      NormalizeCartesian(ref x1' ref y1' ref z1);                      double x2 = GetNumber(3);                      double y2 = GetNumber(4);                      double z2 = GetNumber(5);                      NormalizeCartesian(ref x2' ref y2' ref z2);                        value = $"CreateList(new UnitCartesian({x1}' {y1}' {z1})' new UnitCartesian({x2}' {y2}' {z2}))";                      string prefix = "";                      string suffix = "";                      if (parentProperty.ValueType.Name == "DirectionList")                      {                          prefix = "Spherical.fromCartesian3(";                          suffix = ")";                      }                      assertionValue = $"[ {prefix}new Cartesian3({x1}' {y1}' {z1}){suffix}' {prefix}new Cartesian3({x2}' {y2}' {z2}){suffix} ]";                      assertionEpsilon = "1e-14";                      valueType = "List<UnitCartesian>";                      return;                  }                  case "Cartesian3Velocity":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int z = GetNumber(2);                      int dX = GetNumber(3);                      int dY = GetNumber(4);                      int dZ = GetNumber(5);                        value = $"new Motion<Cartesian>(new Cartesian({x}' {y}' {z})' new Cartesian({dX}' {dY}' {dZ}))";                      assertionValue = $"new Cartesian3({x}' {y}' {z})";                      valueType = "Motion<Cartesian>";                      return;                  }                  case "CartographicDegrees":                  case "CartographicRadians":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height = GetNumber(2);                        value = $"new Cartographic({longitude}' {latitude}' {height})";                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"Cartesian3.from{units}({longitude}' {latitude}' {height})";                      valueType = "Cartographic";                      return;                  }                  case "CartographicDegreesList":                  case "CartographicRadiansList":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      double longitude1 = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double latitude1 = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double height1 = GetNumber(2);                      double longitude2 = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                      double latitude2 = GetNumber(4) % (isDegrees ? 45 : Math.PI / 2);                      double height2 = GetNumber(5);                        value = $"CreateList(new Cartographic({longitude1}' {latitude1}' {height1})' new Cartographic({longitude2}' {latitude2}' {height2}))";                      if (propertyName == "polygon.hierarchy")                      {                          valueSuffix = ".positions";                      }                      string units = isDegrees ? "Degrees" : "Radians";                      assertionValue = $"[ Cartesian3.from{units}({longitude1}' {latitude1}' {height1})' Cartesian3.from{units}({longitude2}' {latitude2}' {height2}) ]";                      valueType = "List<Cartesian>";                      return;                  }                  case "CartographicDegreesListOfLists":                  case "CartographicRadiansListOfLists":                  {                      bool isDegrees = valueProperty.Name == "cartographicDegrees";                      const int valuesPerCartographic = 3;                      double[] values = new double[7 * valuesPerCartographic];                      for (int i = 0; i < values.Length; i += valuesPerCartographic)                      {                          double longitude = GetNumber(i + 0) % (isDegrees ? 45 : Math.PI / 2);                          double latitude = GetNumber(i + 1) % (isDegrees ? 45 : Math.PI / 2);                          double height = GetNumber(i + 2);                          values[i + 0] = longitude;                          values[i + 1] = latitude;                          values[i + 2] = height;                      }                        string CreateCartographic(int index)                      {                          return $"new Cartographic({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string list1 = $"CreateList({CreateCartographic(0)}' {CreateCartographic(1)}' {CreateCartographic(2)})";                      string list2 = $"CreateList({CreateCartographic(3)}' {CreateCartographic(4)}' {CreateCartographic(5)}' {CreateCartographic(6)})";                        value = $"CreateList({list1}' {list2})";                      string units = isDegrees ? "Degrees" : "Radians";                        string CreateCartographicJavaScript(int index)                      {                          return $"Cartesian3.from{units}({values[valuesPerCartographic * index + 0]}' {values[valuesPerCartographic * index + 1]}' {values[valuesPerCartographic * index + 2]})";                      }                        string array1 = $"[ {CreateCartographicJavaScript(0)}' {CreateCartographicJavaScript(1)}' {CreateCartographicJavaScript(2)} ]";                      string array2 = $"[ {CreateCartographicJavaScript(3)}' {CreateCartographicJavaScript(4)}' {CreateCartographicJavaScript(5)}' {CreateCartographicJavaScript(6)} ]";                        if (parentProperty.Name == "holes")                      {                          valueSuffix = ".holes";                          array1 = $"new PolygonHierarchy({array1})";                          array2 = $"new PolygonHierarchy({array2})";                      }                        assertionValue = $"[ {array1}' {array2} ]";                      valueType = "List<List<Cartesian>>";                      return;                  }                  case "Cartesian2":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                        value = $"new Rectangular({x}' {y})";                      assertionValue = $"new Cartesian2({x}' {y})";                      valueType = "Rectangular";                      return;                  }                  case "Spherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                      int magnitude = GetNumber(2);                        value = $"new Spherical({clock}' {cone}' {magnitude})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}' {magnitude}))";                      valueType = "Spherical";                      return;                  }                  case "SphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int magnitude1 = GetNumber(2);                      int clock2 = GetNumber(3);                      int cone2 = GetNumber(4);                      int magnitude2 = GetNumber(5);                        value = $"CreateList(new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1}' {magnitude1})' new Spherical({clock2}' {cone2}' {magnitude2}) ]";                      valueType = "List<Spherical>";                      return;                  }                  case "UnitSpherical":                  {                      int clock = GetNumber(0);                      int cone = GetNumber(1);                        value = $"new UnitSpherical({clock}' {cone})";                      assertionValue = $"Cartesian3.fromSpherical(new Spherical({clock}' {cone}))";                      assertionEpsilon = "1e-14";                      valueType = "UnitSpherical";                      return;                  }                  case "UnitSphericalList":                  {                      int clock1 = GetNumber(0);                      int cone1 = GetNumber(1);                      int clock2 = GetNumber(2);                      int cone2 = GetNumber(3);                        value = $"CreateList(new UnitSpherical({clock1}' {cone1})' new UnitSpherical({clock2}' {cone2}))";                      assertionValue = $"[ new Spherical({clock1}' {cone1})' new Spherical({clock2}' {cone2}) ]";                      valueType = "List<UnitSpherical>";                      return;                  }                  case "UnitQuaternion":                  {                      double w = GetNumber(0);                      double x = GetNumber(1);                      double y = GetNumber(2);                      double z = GetNumber(3);                        double magnitude = Math.Sqrt(w * w + x * x + y * y + z * z);                        w /= magnitude;                      x /= magnitude;                      y /= magnitude;                      z /= magnitude;                      value = $"new UnitQuaternion({w}' {x}' {y}' {z})";                      assertionValue = $"new Quaternion({x}' {y}' {z}' {w})";                      assertionEpsilon = "1e-14";                      valueType = "UnitQuaternion";                      return;                  }                  case "Rgba":                  case "Rgbaf":                  {                      int a = GetNumber(0) % 255;                      int r = GetNumber(1) % 255;                      int g = GetNumber(2) % 255;                      int b = GetNumber(3) % 255;                        value = $"Color.FromArgb({a}' {r}' {g}' {b})";                      switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }                        valueType = "Color";                      return;                  }                  case "VerticalOrigin":                  {                      value = "CesiumVerticalOrigin.Bottom";                      assertionValue = "VerticalOrigin.BOTTOM";                      valueType = "CesiumVerticalOrigin";                      return;                  }                  case "HorizontalOrigin":                  {                      value = "CesiumHorizontalOrigin.Left";                      assertionValue = "HorizontalOrigin.LEFT";                      valueType = "CesiumHorizontalOrigin";                      return;                  }                  case "HeightReference":                  {                      value = "CesiumHeightReference.ClampToGround";                      assertionValue = "HeightReference.CLAMP_TO_GROUND";                      valueType = "CesiumHeightReference";                      return;                  }                  case "LabelStyle":                  {                      value = "CesiumLabelStyle.FillAndOutline";                      assertionValue = "LabelStyle.FILL_AND_OUTLINE";                      valueType = "CesiumLabelStyle";                      return;                  }                  case "ArcType":                  {                      value = "CesiumArcType.Rhumb";                      assertionValue = "ArcType.RHUMB";                      valueType = "CesiumArcType";                      return;                  }                  case "CornerType":                  {                      value = "CesiumCornerType.Beveled";                      assertionValue = "CornerType.BEVELED";                      valueType = "CesiumCornerType";                      return;                  }                  case "ShadowMode":                  {                      value = "CesiumShadowMode.CastOnly";                      assertionValue = "ShadowMode.CAST_ONLY";                      valueType = "CesiumShadowMode";                      return;                  }                  case "ClassificationType":                  {                      value = "CesiumClassificationType.Terrain";                      assertionValue = "ClassificationType.TERRAIN";                      valueType = "CesiumClassificationType";                      return;                  }                  case "ColorBlendMode":                  {                      value = "CesiumColorBlendMode.Replace";                      assertionValue = "ColorBlendMode.REPLACE";                      valueType = "CesiumColorBlendMode";                      return;                  }                  case "StripeOrientation":                  {                      value = "CesiumStripeOrientation.Vertical";                      assertionValue = "StripeOrientation.VERTICAL";                      valueType = "CesiumStripeOrientation";                      return;                  }                  case "SensorVolumePortionToDisplay":                  {                      value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";                      assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";                      valueType = "CesiumSensorVolumePortionToDisplay";                      return;                  }                  case "Font":                  {                      string s = $"{(GetNumber(0) + 5) % 25}px sans-serif";                      value = $"\"{s}\"";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "Uri":                  {                      string s = $"http://example.com/{GetNumber(0)}";                      value = $"\"{s}\"' CesiumResourceBehavior.LinkTo";                      valueSuffix = ".url";                      assertionValue = $"'{s}'";                      valueType = "string";                      return;                  }                  case "NearFarScalar":                  {                      int nearDistance = GetNumber(0);                      int nearValue = GetNumber(1);                      int farDistance = GetNumber(2);                      int farValue = GetNumber(3);                        value = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      assertionValue = $"new NearFarScalar({nearDistance}' {nearValue}' {farDistance}' {farValue})";                      valueType = "NearFarScalar";                      return;                  }                  case "DistanceDisplayCondition":                  {                      int nearDistance = GetNumber(0);                      int farDistance = GetNumber(1);                      // near must be less than far                      if (nearDistance > farDistance)                      {                          int temp = nearDistance;                          nearDistance = farDistance;                          farDistance = temp;                      }                        value = $"new Bounds({nearDistance}' {farDistance})";                      assertionValue = $"new DistanceDisplayCondition({nearDistance}' {farDistance})";                      valueType = "Bounds";                      return;                  }                  case "BoundingRectangle":                  {                      int x = GetNumber(0);                      int y = GetNumber(1);                      int width = GetNumber(2);                      int height = GetNumber(3);                        value = $"BoundingRectangle.FromWidthHeight({x}' {y}' {width}' {height})";                      assertionValue = $"new BoundingRectangle({x}' {y}' {width}' {height})";                      valueType = "BoundingRectangle";                      return;                  }                  case "CartographicRectangleDegrees":                  case "CartographicRectangleRadians":                  {                      bool isDegrees = valueProperty.Name == "wsenDegrees";                      double w = GetNumber(0) % (isDegrees ? 45 : Math.PI / 2);                      double s = GetNumber(1) % (isDegrees ? 45 : Math.PI / 2);                      double e = GetNumber(2) % (isDegrees ? 45 : Math.PI / 2);                      double n = GetNumber(3) % (isDegrees ? 45 : Math.PI / 2);                        value = $"new CartographicExtent({w}' {s}' {e}' {n})";                      assertionValue = $"{(isDegrees ? "Rectangle.fromDegrees" : "new Rectangle")}({w}' {s}' {e}' {n})";                      valueType = "CartographicExtent";                      return;                  }              }
Missing Default,GenerateFromSchema,ValidationDocumentGenerator,D:\research\architectureSmells\repos\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following switch statement is missing a default case: switch (valueTypeName)                      {                          case "Rgba":                              assertionValue = $"Color.fromBytes({r}' {g}' {b}' {a})";                              break;                          case "Rgbaf":                              assertionValue = $"new Color({r / 255.0}' {g / 255.0}' {b / 255.0}' {a / 255.0})";                              assertionEpsilon = "1e-14";                              break;                      }
