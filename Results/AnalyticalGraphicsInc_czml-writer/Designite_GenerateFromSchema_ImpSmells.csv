Implementation smell,Namespace,Class,File,Method,Description
Long Method,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The method has 764 lines of code.
Long Method,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The method has 307 lines of code.
Complex Method,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,GenerateWriterClass,Cyclomatic complexity of the method is 8
Complex Method,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteNamespaces,Cyclomatic complexity of the method is 10
Complex Method,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteProperties,Cyclomatic complexity of the method is 9
Complex Method,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteIntervalsProperty,Cyclomatic complexity of the method is 16
Complex Method,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteLeafProperty,Cyclomatic complexity of the method is 15
Complex Method,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteAsTypeMethods,Cyclomatic complexity of the method is 12
Complex Method,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,GetOverloadsForProperty,Cyclomatic complexity of the method is 10
Complex Method,GenerateFromSchema,GenerateFromSchema,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\GenerateFromSchema.cs,Main,Cyclomatic complexity of the method is 13
Complex Method,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,Cyclomatic complexity of the method is 253
Complex Method,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,Cyclomatic complexity of the method is 68
Complex Method,GenerateFromSchema,MarkdownGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\MarkdownGenerator.cs,Generate,Cyclomatic complexity of the method is 20
Complex Method,GenerateFromSchema,MarkdownGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\MarkdownGenerator.cs,JsonSchemaTypesToLabel,Cyclomatic complexity of the method is 10
Long Parameter List,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,WriteValue,The method has 7 parameters.
Long Parameter List,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,WriteValues,The method has 7 parameters.
Long Parameter List,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The method has 7 parameters.
Long Identifier,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WritePropertyLazyFields,The length of the parameter firstOverloadFirstParameterType is 31.
Long Identifier,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteAsTypeMethods,The length of the parameter firstOverloadFirstParameterType is 31.
Long Statement,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,GenerateWriterClass,The length of the statement  "	using (CodeWriter writer = new CodeWriter (Path.Combine (m_outputDirectory' schema.NameWithPascalCase + "CesiumWriter.cs"))) { " is 126.
Long Statement,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,GenerateWriterClass,The length of the statement  "				writer.WriteLine ("{0} class {1}CesiumWriter : CesiumInterpolatablePropertyWriter<{1}CesiumWriter>"' m_configuration.Access' schema.NameWithPascalCase); " is 152.
Long Statement,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,GenerateWriterClass,The length of the statement  "				writer.WriteLine ("{0} class {1}CesiumWriter : CesiumPropertyWriter<{1}CesiumWriter>"' m_configuration.Access' schema.NameWithPascalCase); " is 138.
Long Statement,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteDescriptionAsClassSummary,The length of the statement  "	WriteSummaryText (writer' string.Format ("Writes a <c>{0}</c> to a <see cref=\"CesiumOutputStream\" />.  A <c>{0}</c> is {1}"' schema.Name' description)); " is 154.
Long Statement,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WritePropertyLazyFields,The length of the statement  "				writer.WriteLine ("private readonly Lazy<{0}<{1}>> m_as{2};"' interfaceName' firstOverloadFirstParameterType' property.NameWithPascalCase); " is 139.
Long Statement,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WritePropertyLazyFields,The length of the statement  "			writer.WriteLine ("private readonly Lazy<{0}CesiumWriter> m_{1} = new Lazy<{0}CesiumWriter>(() => new {0}CesiumWriter({2}PropertyName)' false);"' property.ValueType.NameWithPascalCase' property.Name' property.NameWithPascalCase); " is 229.
Long Statement,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteProperties,The length of the statement  "		WriteSummaryText (writer' string.Format ("Gets a new writer for a <c>{0}</c> property.  The returned instance must be opened by calling the <see cref=\"CesiumElementWriter.Open\"/> method before it can be used for writing.  A <c>{0}</c> property defines {1}"' additionalPropertiesValueType.Name' GetDescription (additionalProperties))); " is 336.
Long Statement,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteProperties,The length of the statement  "		writer.WriteLine ("public {0}CesiumWriter Get{0}Writer(string name)"' additionalPropertiesValueType.NameWithPascalCase); " is 120.
Long Statement,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteProperties,The length of the statement  "		WriteSummaryText (writer' string.Format ("Opens and returns a new writer for a <c>{0}</c> property.  A <c>{0}</c> property defines {1}"' additionalPropertiesValueType.Name' GetDescription (additionalProperties))); " is 213.
Long Statement,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteProperties,The length of the statement  "		writer.WriteLine ("public {0}CesiumWriter Open{0}Property(string name)"' additionalPropertiesValueType.NameWithPascalCase); " is 123.
Long Statement,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteProperties,The length of the statement  "			writer.WriteLine ("return OpenAndReturn(new {0}CesiumWriter(name));"' additionalPropertiesValueType.NameWithPascalCase); " is 120.
Long Statement,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteIntervalsProperty,The length of the statement  "	WriteSummaryText (writer' string.Format ("Gets the writer for the <c>{0}</c> property.  The returned instance must be opened by calling the <see cref=\"CesiumElementWriter.Open\"/> method before it can be used for writing.  The <c>{0}</c> property defines {1}"' property.Name' GetDescription (property))); " is 305.
Long Statement,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteIntervalsProperty,The length of the statement  "	writer.WriteLine ("public {0}CesiumWriter {1}Writer"' property.ValueType.NameWithPascalCase' property.NameWithPascalCase); " is 122.
Long Statement,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteIntervalsProperty,The length of the statement  "	WriteSummaryText (writer' string.Format ("Opens and returns the writer for the <c>{0}</c> property.  The <c>{0}</c> property defines {1}"' property.Name' GetDescription (property))); " is 182.
Long Statement,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteIntervalsProperty,The length of the statement  "	writer.WriteLine ("public {0}CesiumWriter Open{1}Property()"' property.ValueType.NameWithPascalCase' property.NameWithPascalCase); " is 130.
Long Statement,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteIntervalsProperty,The length of the statement  "			WriteSummaryText (writer' string.Format ("Writes a value for the <c>{0}</c> property as a <c>{1}</c> value.  The <c>{0}</c> property specifies {2}"' property.Name' nestedProperty.Name' GetDescription (property))); " is 213.
Long Statement,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteIntervalsProperty,The length of the statement  "			writer.WriteLine ("public void Write{0}Property{1}({2})"' property.NameWithPascalCase' subPropertyName' overload.FormattedParameters); " is 134.
Long Statement,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteIntervalsProperty,The length of the statement  "					writer.WriteLine ("writer.Write{0}({1});"' nestedProperty.NameWithPascalCase' string.Join ("' "' Array.ConvertAll (overload.Parameters' p => p.Name))); " is 151.
Long Statement,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteLeafProperty,The length of the statement  "		WriteSummaryText (writer' string.Format ("Writes the value expressed as a <c>{0}</c>' which is {1}"' property.Name' GetDescription (property))); " is 144.
Long Statement,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteAsTypeLazyInitialization,The length of the statement  "			writer.WriteLine ("m_as{0} = new Lazy<{1}<{2}>>(Create{0}Adaptor' false);"' property.NameWithPascalCase' interfaceName' firstOverload.Parameters [0].Type); " is 155.
Long Statement,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteAsTypeMethods,The length of the statement  "			WriteSummaryText (writer' string.Format ("Returns a wrapper for this instance that implements <see cref=\"{0}{{T}}\" /> to write a value in <c>{1}</c> format.  Because the returned instance is a wrapper for this instance' you may call <see cref=\"ICesiumElementWriter.Close\" /> on either this instance or the wrapper' but you must not call it on both."' interfaceName' property.NameWithPascalCase)); " is 400.
Long Statement,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteAsTypeMethods,The length of the statement  "			writer.WriteLine ("public {0}<{1}> As{2}()"' interfaceName' firstOverloadFirstParameterType' property.NameWithPascalCase); " is 122.
Long Statement,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteAsTypeMethods,The length of the statement  "			writer.WriteLine ("private {0}<{1}> Create{2}Adaptor()"' interfaceName' firstOverloadFirstParameterType' property.NameWithPascalCase); " is 134.
Long Statement,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteAsTypeMethods,The length of the statement  "					extraParameter = string.Format ("' (me' dates' values' startIndex' length) => me.Write{0}(dates' values' startIndex' length)"' property.NameWithPascalCase); " is 156.
Long Statement,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,WriteAsTypeMethods,The length of the statement  "				writer.WriteLine ("return new {0}<{1}CesiumWriter' {2}>(this' (me' value) => me.Write{3}(value){4});"' adaptorName' schema.NameWithPascalCase' firstOverloadFirstParameterType' property.NameWithPascalCase' extraParameter); " is 221.
Long Statement,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,GetOverloadsForProperty,The length of the statement  "		if (type.HasFlag (JsonSchemaType.Object) || type.HasFlag (JsonSchemaType.Array) || type.HasFlag (JsonSchemaType.Null) || type.HasFlag (JsonSchemaType.Any) || type == JsonSchemaType.None) { " is 188.
Long Statement,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,GetOverloadsForProperty,The length of the statement  "			throw new Exception (string.Format ("Property '{0}' does not specify a $ref to a schema' nor is it a simple JSON type."' property.Name)); " is 137.
Long Statement,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,IsSampledDataOverload,The length of the statement  "	return overload.Parameters.Length == 4 && overload.Parameters [0].Type == "IList<JulianDate>" && overload.Parameters [1].Type.StartsWith ("IList<") && overload.Parameters [2].Type == "int" && overload.Parameters [3].Type == "int"; " is 230.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "				writer.WriteLine ("private readonly JulianDate m_documentStartDate = new GregorianDate(2016' 6' 17' 12' 0' 0).ToJulianDate();"); " is 128.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "				writer.WriteLine ("private readonly JulianDate m_documentStopDate = new GregorianDate(2016' 6' 17' 13' 0' 0).ToJulianDate();"); " is 127.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "				var schemaProperties = schema.Properties.Where (p => p.Name != "clock" && p.Name != "availability" && !p.ValueType.IsSchemaFromType).Where (p => p.Name != "properties").ToList (); " is 179.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "					writer.WriteLine ("using (m_extensionsAssertionsWriter = new StreamWriter(\"ValidationDocumentExtensionAssertions.js\"))"); " is 123.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "						WriteAssertionBoth (writer' "return CzmlDataSource.load('Data/CZML/ValidationDocument.czml').then(function(dataSource) {"); " is 123.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "						// Java has a limit on the size of a single method (65535 bytes) so we have to break up all this code in multiple methods " is 121.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "												WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName)); " is 150.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "																WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name)); " is 231.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "																	WriteValue (writer' "w3"' id + property.Name' firstValueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' "prop"' additionalProperty.Name)); " is 198.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "						foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) { " is 121.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "							foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) { " is 121.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "										WriteValue (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName)); " is 145.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "									foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) { " is 121.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "											string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name); " is 140.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "												WriteValue (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name)); " is 231.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "														WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name)); " is 231.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "										foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) { " is 121.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "												string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name); " is 135.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "													WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name)); " is 226.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "									foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) { " is 121.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "											string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' additionalProperties.ValueType.Name' additionalProperty.Name); " is 148.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "											writer.WriteLine ("using (var a = w2.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName); " is 126.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "												WriteValue (writer' "w3"' id + property.Name + subProperty.Name' valueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' propName' additionalProperty.Name)); " is 214.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "										writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName); " is 126.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "											WriteValue (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName)); " is 157.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "								WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' false' string.Format ("{0}.{1}"' property.Name' subProperty.Name)); " is 146.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "									WriteAssertion (writer' isExtension' "expect(e.{0}.getValue(date)).toEqual(constant.{0}.getValue(date));"' propertyName); " is 121.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "												writer.WriteLine ("w2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\")));"' propertyName' subPropertyName); " is 130.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "												WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual(constant.{0}.{1}.getValue(date));"' propertyName' subPropertyName); " is 146.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "												writer.WriteLine ("w2.WriteReferences(CreateList(new Reference(\"Constant{0}1\"' CreateList({1}))' new Reference(\"Constant{0}2\"' CreateList({1}))));"' targetId' string.Join ("' "' referencePropertyNames.Select (n => string.Format ("\"{0}\""' n)))); " is 250.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "												WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual([dataSource.entities.getById('Constant{2}1').{3}.getValue(date)' dataSource.entities.getById('Constant{2}2').{3}.getValue(date)]);"' propertyName' subPropertyName' targetId' string.Join ("."' referencePropertyNames)); " is 296.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "														writer.WriteLine ("m2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"{2}\")));"' propertyName' subPropertyName' materialSubProperty.Name); " is 165.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "														WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.{2}.getValue(date)).toEqual(constant.{0}.{1}.{2}.getValue(date));"' propertyName' subPropertyName' materialSubProperty.Name); " is 180.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "												writer.WriteLine ("using (var a = w2.Open{0}Property(\"referenceProp\"))"' additionalProperties.ValueType.NameWithPascalCase); " is 126.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "															writer.WriteLine ("w3.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"prop\"' \"{2}\")));"' propertyName' subPropertyName' additionalProperty.Name); " is 174.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "															WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.referenceProp.{2}.getValue(date)).toEqual(constant.{0}.{1}.prop.{2}.getValue(date));"' propertyName' subPropertyName' additionalProperty.Name); " is 198.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "							writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2); " is 158.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "							WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2); " is 169.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "										WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ); " is 250.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "													writer.WriteLine ("m2.WriteReference(new Reference(\"{0}\"' CreateList(\"{1}\"' \"{2}\"' \"{3}\")));"' targetId' propertyName' subPropertyName' materialSubProperty.Name); " is 170.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "													WriteAssertion (writer' isExtension' "expect(e.{1}.{2}.{3}.getValue(date)).toEqual(dataSource.entities.getById('{0}').{1}.{2}.{3}.getValue(date));"' targetId' propertyName' subPropertyName' materialSubProperty.Name); " is 216.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "									var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array); " is 133.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "								var subProperties = properties.Where (p => !p.IsValue && (p.IsInterpolatable || p.ValueType.Name.Contains ("Material"))).ToList (); " is 131.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "													var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array); " is 133.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "													WriteValues (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName)); " is 151.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "																var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array); " is 133.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "																WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name)); " is 232.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "							foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) { " is 149.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "									foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) { " is 149.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "												WriteValues (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName)); " is 146.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "										foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) { " is 149.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "												string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name); " is 139.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "													WriteValues (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name)); " is 232.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "														var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array); " is 133.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "														WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name)); " is 232.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "											foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) { " is 149.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "													string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name); " is 134.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "														WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name)); " is 227.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "									foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array)) { " is 171.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "										writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName); " is 126.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The length of the statement  "											WriteValues (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName)); " is 158.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,WriteValue,The length of the statement  "	GetUniqueValue (valueName' valueProperty' parentProperty' out value' out assertionValue' out assertionEpsilon' out valueType); " is 126.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,WriteValue,The length of the statement  "	WriteAssertion (writer' isExtension' "expect(e.{0}.getValue(date)).toEqual{1}({2}{3});"' propertyName' assertionEpsilon == null ? "" : "Epsilon"' assertionValue' assertionEpsilon == null ? "" : string.Format ("' {0}"' assertionEpsilon)); " is 237.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,WriteValues,The length of the statement  "	GetUniqueValue (valueName + 1' valueProperty' parentProperty' out value1' out assertionValue1' out assertionEpsilon1' out valueType1); " is 134.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,WriteValues,The length of the statement  "	GetUniqueValue (valueName + 2' valueProperty' parentProperty' out value2' out assertionValue2' out assertionEpsilon2' out valueType2); " is 134.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,WriteValues,The length of the statement  "	writer.WriteLine ("{0}.Write{1}(CreateList(m_documentStartDate' m_documentStopDate)' CreateList({3}' {4}));"' openWriterName' valueProperty.NameWithPascalCase' valueType1' value1' value2); " is 188.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,WriteValues,The length of the statement  "	WriteAssertion (writer' isExtension' "expect(e.{0}.getValue(documentStartDate)).toEqual{1}({2}{3});"' propertyName' assertionEpsilon1 == null ? "" : "Epsilon"' assertionValue1' assertionEpsilon1 == null ? "" : string.Format ("' {0}"' assertionEpsilon1)); " is 254.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,WriteValues,The length of the statement  "	WriteAssertion (writer' isExtension' "expect(e.{0}.getValue(documentStopDate)).toEqual{1}({2}{3});"' propertyName' assertionEpsilon2 == null ? "" : "Epsilon"' assertionValue2' assertionEpsilon2 == null ? "" : string.Format ("' {0}"' assertionEpsilon2)); " is 253.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The length of the statement  "		value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2); " is 121.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The length of the statement  "		assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : ""); " is 282.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The length of the statement  "		value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2); " is 129.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The length of the statement  "		assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : ""); " is 282.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The length of the statement  "		value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ); " is 129.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The length of the statement  "		assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians"); " is 133.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The length of the statement  "		value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2); " is 167.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The length of the statement  "		assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians"); " is 207.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The length of the statement  "		value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2); " is 151.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The length of the statement  "		assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2); " is 152.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The length of the statement  "		value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2); " is 125.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The length of the statement  "		assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue); " is 121.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The length of the statement  "		assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle"); " is 126.
Long Statement,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,WriteAssertion,The length of the statement  "	writer.WriteLine (string.Format ("{0}.WriteLine(\"{1}{2}\");"' isExtension ? "m_extensionsAssertionsWriter" : "m_assertionsWriter"' AssertionIndent' assertion)); " is 161.
Long Statement,GenerateFromSchema,MarkdownGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\MarkdownGenerator.cs,Generate,The length of the statement  "		output.WriteLine ("This page describes the possible content of a CZML document or stream.  Please read [[CZML Structure]] for an explanation of how a CZML document is put together."); " is 183.
Long Statement,GenerateFromSchema,MarkdownGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\MarkdownGenerator.cs,Generate,The length of the statement  "				string type = propertyValueType.IsSchemaFromType ? JsonSchemaTypesToLabel (property.ValueType.JsonTypes) : string.Format ("[[{0}{1}]]"' propertyValueType.Name' property.IsValue ? "Value" : ""); " is 193.
Long Statement,GenerateFromSchema,MarkdownGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\MarkdownGenerator.cs,Generate,The length of the statement  "			output.WriteLine ("This type represents a key-value mapping' where values are of type [[{0}]]."' propertyValueType.Name); " is 121.
Complex Conditional,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,GetOverloadsForProperty,The conditional expression  "type.HasFlag (JsonSchemaType.Object) || type.HasFlag (JsonSchemaType.Array) || type.HasFlag (JsonSchemaType.Null) || type.HasFlag (JsonSchemaType.Any) || type == JsonSchemaType.None"  is complex.
Magic Number,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,IsSampledDataOverload,The following statement contains a magic number: return overload.Parameters.Length == 4 && overload.Parameters [0].Type == "IList<JulianDate>" && overload.Parameters [1].Type.StartsWith ("IList<") && overload.Parameters [2].Type == "int" && overload.Parameters [3].Type == "int";  
Magic Number,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,IsSampledDataOverload,The following statement contains a magic number: return overload.Parameters.Length == 4 && overload.Parameters [0].Type == "IList<JulianDate>" && overload.Parameters [1].Type.StartsWith ("IList<") && overload.Parameters [2].Type == "int" && overload.Parameters [3].Type == "int";  
Magic Number,GenerateFromSchema,CSharpGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\CSharpGenerator.cs,IsSampledDataOverload,The following statement contains a magic number: return overload.Parameters.Length == 4 && overload.Parameters [0].Type == "IList<JulianDate>" && overload.Parameters [1].Type.StartsWith ("IList<") && overload.Parameters [2].Type == "int" && overload.Parameters [3].Type == "int";  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (CodeWriter writer = new CodeWriter (Path.Combine (m_outputDirectory' "TestGenerateValidationDocument.cs"))) {  	writer.WriteLine ("// This file was generated automatically by GenerateFromSchema.  Do NOT edit it.");  	writer.WriteLine ("// https://github.com/AnalyticalGraphicsInc/czml-writer");  	writer.WriteLine ();  	writer.WriteLine ("using System.Collections.Generic;");  	writer.WriteLine ("using System.Diagnostics.CodeAnalysis;");  	writer.WriteLine ("using System.Drawing;");  	writer.WriteLine ("using System.IO;");  	writer.WriteLine ("using CesiumLanguageWriter;");  	writer.WriteLine ("using NUnit.Framework;");  	writer.WriteLine ();  	writer.WriteLine ("namespace {0}"' "CesiumLanguageWriterTests");  	using (writer.OpenScope ()) {  		writer.WriteLine ("[TestFixture]");  		writer.WriteLine ("[SuppressMessage(\"ReSharper\"' \"MemberCanBeMadeStatic.Local\")]");  		writer.WriteLine ("public class TestGenerateValidationDocument");  		using (writer.OpenScope ()) {  			writer.WriteLine ("private readonly JulianDate m_documentStartDate = new GregorianDate(2016' 6' 17' 12' 0' 0).ToJulianDate();");  			writer.WriteLine ("private readonly JulianDate m_documentStopDate = new GregorianDate(2016' 6' 17' 13' 0' 0).ToJulianDate();");  			writer.WriteLine ("private TextWriter m_streamWriter;");  			writer.WriteLine ("private TextWriter m_assertionsWriter;");  			writer.WriteLine ("private TextWriter m_extensionsAssertionsWriter;");  			writer.WriteLine ("private CesiumOutputStream m_output;");  			writer.WriteLine ("private CesiumStreamWriter m_writer;");  			writer.WriteLine ("private void WriteAssertionBoth(string s)");  			using (writer.OpenScope ()) {  				writer.WriteLine ("m_assertionsWriter.WriteLine(s);");  				writer.WriteLine ("m_extensionsAssertionsWriter.WriteLine(s);");  			}  			writer.WriteLine ("private static IList<T> CreateList<T>(T t1' T t2)");  			using (writer.OpenScope ()) {  				writer.WriteLine ("return new List<T> { t1' t2 };");  			}  			writer.WriteLine ("private static IList<T> CreateList<T>(params T[] ts)");  			using (writer.OpenScope ()) {  				writer.WriteLine ("return ts;");  			}  			writer.WriteLine ("[Test]");  			writer.WriteLine ("public void GenerateValidationDocument()");  			var schemaProperties = schema.Properties.Where (p => p.Name != "clock" && p.Name != "availability" && !p.ValueType.IsSchemaFromType).Where (p => p.Name != "properties").ToList ();  			using (writer.OpenScope ()) {  				writer.WriteLine ("using (m_streamWriter = new StreamWriter(\"ValidationDocument.czml\"))");  				writer.WriteLine ("using (m_assertionsWriter = new StreamWriter(\"ValidationDocumentAssertions.js\"))");  				writer.WriteLine ("using (m_extensionsAssertionsWriter = new StreamWriter(\"ValidationDocumentExtensionAssertions.js\"))");  				using (writer.OpenScope ()) {  					WriteAssertionBoth (writer' "return CzmlDataSource.load('Data/CZML/ValidationDocument.czml').then(function(dataSource) {");  					s_assertionIndent++;  					WriteAssertionBoth (writer' "/*jshint -W120 */");  					WriteAssertionBoth (writer' "var e;");  					WriteAssertionBoth (writer' "var date;");  					WriteAssertionBoth (writer' "var documentStartDate = JulianDate.fromIso8601('2016-06-17T12:00:00Z');");  					WriteAssertionBoth (writer' "var documentStopDate = JulianDate.fromIso8601('2016-06-17T13:00:00Z');");  					writer.WriteLine ("m_output = new CesiumOutputStream(m_streamWriter) { PrettyFormatting = true };");  					writer.WriteLine ("m_writer = new CesiumStreamWriter();");  					writer.WriteLine ("m_output.WriteStartSequence();");  					// Java has a limit on the size of a single method (65535 bytes) so we have to break up all this code in multiple methods  					writer.WriteLine ("WriteClock();");  					writer.WriteLine ("WriteConstantValues();");  					writer.WriteLine ("WriteReferenceValues();");  					writer.WriteLine ("WriteSampledValues();");  					writer.WriteLine ("m_output.WriteEndSequence();");  					s_assertionIndent--;  					WriteAssertionBoth (writer' "});");  					s_assertionIndent++;  				}  			}  			writer.WriteLine ("private void WriteClock()");  			using (writer.OpenScope ()) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					writer.WriteLine ("packet.WriteId(\"document\");");  					writer.WriteLine ("packet.WriteName(\"ValidationDocument\");");  					writer.WriteLine ("packet.WriteVersion(\"1.0\");");  					writer.WriteLine ("using (var clock = packet.OpenClockProperty())");  					using (writer.OpenScope ()) {  						writer.WriteLine ("clock.WriteInterval(m_documentStartDate' m_documentStopDate);");  						WriteAssertion (writer' false' "expect(dataSource.clock.startTime).toEqual(documentStartDate);");  						WriteAssertion (writer' false' "expect(dataSource.clock.stopTime).toEqual(documentStopDate);");  						writer.WriteLine ("clock.WriteCurrentTime(m_documentStartDate);");  						WriteAssertion (writer' false' "expect(dataSource.clock.currentTime).toEqual(documentStartDate);");  						writer.WriteLine ("clock.WriteMultiplier(1.0);");  						WriteAssertion (writer' false' "expect(dataSource.clock.multiplier).toEqual(1.0);");  						writer.WriteLine ("clock.WriteRange(ClockRange.Unbounded);");  						WriteAssertion (writer' false' "expect(dataSource.clock.clockRange).toEqual(ClockRange.UNBOUNDED);");  						writer.WriteLine ("clock.WriteStep(ClockStep.SystemClockMultiplier);");  						WriteAssertion (writer' false' "expect(dataSource.clock.clockStep).toEqual(ClockStep.SYSTEM_CLOCK_MULTIPLIER);");  					}  				}  			}  			writer.WriteLine ("private void WriteConstantValues()");  			using (writer.OpenScope ()) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					const string id = "Constant";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "var constant = e = dataSource.entities.getById('Constant');");  					WriteAssertionBoth (writer' "expect(e).toBeDefined();");  					WriteAssertionBoth (writer' "date = JulianDate.now();");  					// Write one packet with first value types for each property  					foreach (var property in schemaProperties) {  						string propertyName = property.Name;  						bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  						if (isExtension)  							propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var properties = property.ValueType.Properties;  							var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  							if (firstValueProperty != null) {  								WriteValue (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  							} else {  								foreach (var subProperty in properties.Where (p => !p.IsValue)) {  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = subProperty.ValueType.Properties;  										firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  										string subPropertyName = GetSubPropertyName (propertyName' subProperty);  										if (firstValueProperty != null) {  											WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  										} else if (subProperty.ValueType.Name.Contains ("Material")) {  											Property materialProperty = properties.First ();  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialProperty.ValueType.Properties;  												foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  													writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														properties = materialSubProperty.ValueType.Properties;  														firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  														if (firstValueProperty != null) {  															WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  														}  													}  												}  											}  										} else {  											var additionalProperties = subProperty.ValueType.AdditionalProperties;  											if (additionalProperties != null) {  												writer.WriteLine ("using (var a = w2.Open{0}Property(\"prop\"))"' additionalProperties.ValueType.NameWithPascalCase);  												using (writer.OpenScope ()) {  													foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  														writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  														using (writer.OpenScope ()) {  															properties = additionalProperty.ValueType.Properties;  															firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  															if (firstValueProperty != null) {  																WriteValue (writer' "w3"' id + property.Name' firstValueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' "prop"' additionalProperty.Name));  															}  														}  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  				writer.WriteLine ("WriteConstantValuesIndividual();");  				writer.WriteLine ("WriteConstantValuesCustomProperties();");  			}  			writer.WriteLine ("private void WriteConstantValuesIndividual()");  			using (writer.OpenScope ()) {  				// write other value types as individual packets  				foreach (var property in schemaProperties) {  					writer.WriteLine ("WriteConstantValuesIndividual{0}();"' property.NameWithPascalCase);  				}  			}  			foreach (var property in schemaProperties) {  				writer.WriteLine ("private void WriteConstantValuesIndividual{0}()"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("constant_{0}_{1}"' property.Name' valueProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								WriteValue (writer' "w"' id' valueProperty' property' isExtension' propertyName);  							}  						}  					}  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						string subPropertyName = GetSubPropertyName (propertyName' subProperty);  						properties = subProperty.ValueType.Properties;  						foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("constant_{0}_{1}_{2}"' property.Name' subPropertyName' valueProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValue (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  								}  							}  						}  						if (subProperty.ValueType.Name.Contains ("Material")) {  							// write other values for the first material  							// then write first values for other materials   							// then write remaining values for other materials individually  							var firstMaterialProperty = properties.First ();  							properties = firstMaterialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValue (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialSubProperty.ValueType.Properties;  												var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  												if (firstValueProperty != null) {  													WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  									properties = materialSubProperty.ValueType.Properties;  									foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  										writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  										using (writer.OpenScope ()) {  											string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  											writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  											WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  											writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  						}  						var additionalProperties = subProperty.ValueType.AdditionalProperties;  						if (additionalProperties != null) {  							foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  								int i = 0;  								properties = additionalProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' additionalProperties.ValueType.Name' additionalProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										string propName = string.Format ("{0}{1}"' "prop"' i++);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var a = w2.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  										writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValue (writer' "w3"' id + property.Name + subProperty.Name' valueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' propName' additionalProperty.Name));  										}  									}  								}  							}  						}  					}  				}  			}  			// create all types of custom properties  			writer.WriteLine ("private void WriteConstantValuesCustomProperties()");  			using (writer.OpenScope ()) {  				var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  				if (propertiesProperty != null) {  					var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  					if (additionalProperties != null) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = "constant_custom";  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue)) {  									string propName = string.Format ("custom_{0}"' valueProperty.Name);  									writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  									using (writer.OpenScope ()) {  										WriteValue (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  									}  								}  							}  						}  					}  				}  			}  			// create entities using references  			writer.WriteLine ("private void WriteReferenceValues()");  			using (writer.OpenScope ()) {  				// write some positions and double values to use to create reference lists for position lists and double lists later  				for (int i = 1; i <= 2; ++i) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("ConstantPosition{0}"' i);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantPosition{0}')).toBeDefined();"' i);  						var property = schemaProperties.First (p => p.Name == "position");  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var properties = property.ValueType.Properties;  							var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  							WriteValue (writer' "w"' id' firstValueProperty' property' false' property.Name);  						}  					}  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("ConstantDouble{0}"' i);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantDouble{0}')).toBeDefined();"' i);  						var property = schemaProperties.First (p => p.Name == "billboard");  						var properties = property.ValueType.Properties;  						var subProperty = properties.First (p => p.Name == "scale");  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							properties = subProperty.ValueType.Properties;  							var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  							WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' false' string.Format ("{0}.{1}"' property.Name' subProperty.Name));  						}  					}  				}  				// write one big packet with references for everything  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					writer.WriteLine ("packet.WriteId(\"Reference\");");  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Reference')).toBeDefined();");  					foreach (var property in schemaProperties) {  						string propertyName = property.Name;  						bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  						if (isExtension)  							propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var properties = property.ValueType.Properties;  							if (properties.Any (p => p.ValueType.Name == "Reference")) {  								writer.WriteLine ("w.WriteReference(new Reference(\"Constant\"' \"{0}\"));"' propertyName);  								WriteAssertion (writer' isExtension' "expect(e.{0}.getValue(date)).toEqual(constant.{0}.getValue(date));"' propertyName);  							} else {  								foreach (var subProperty in properties.Where (p => !p.IsValue)) {  									properties = subProperty.ValueType.Properties;  									string subPropertyName = GetSubPropertyName (propertyName' subProperty);  									if (properties.Any (p => p.ValueType.Name == "Reference")) {  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("w2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\")));"' propertyName' subPropertyName);  											WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual(constant.{0}.{1}.getValue(date));"' propertyName' subPropertyName);  										}  									} else if (properties.Any (p => p.ValueType.Name == "ReferenceList")) {  										string targetId = "";  										string[] referencePropertyNames =  {    										};  										if (subProperty.ValueType.Name == "PositionList") {  											targetId = "Position";  											referencePropertyNames = new[] {  												"position"  											};  										} else if (subProperty.ValueType.Name == "DoubleList") {  											targetId = "Double";  											referencePropertyNames = new[] {  												"billboard"'  												"scale"  											};  										}  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("w2.WriteReferences(CreateList(new Reference(\"Constant{0}1\"' CreateList({1}))' new Reference(\"Constant{0}2\"' CreateList({1}))));"' targetId' string.Join ("' "' referencePropertyNames.Select (n => string.Format ("\"{0}\""' n))));  											WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual([dataSource.entities.getById('Constant{2}1').{3}.getValue(date)' dataSource.entities.getById('Constant{2}2').{3}.getValue(date)]);"' propertyName' subPropertyName' targetId' string.Join ("."' referencePropertyNames));  										}  									} else if (subProperty.ValueType.Name.Contains ("Material")) {  										Property materialProperty = properties.First ();  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													writer.WriteLine ("m2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"{2}\")));"' propertyName' subPropertyName' materialSubProperty.Name);  													WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.{2}.getValue(date)).toEqual(constant.{0}.{1}.{2}.getValue(date));"' propertyName' subPropertyName' materialSubProperty.Name);  												}  											}  										}  									} else {  										var additionalProperties = subProperty.ValueType.AdditionalProperties;  										if (additionalProperties != null) {  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var a = w2.Open{0}Property(\"referenceProp\"))"' additionalProperties.ValueType.NameWithPascalCase);  											using (writer.OpenScope ()) {  												foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  													writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														writer.WriteLine ("w3.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"prop\"' \"{2}\")));"' propertyName' subPropertyName' additionalProperty.Name);  														WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.referenceProp.{2}.getValue(date)).toEqual(constant.{0}.{1}.prop.{2}.getValue(date));"' propertyName' subPropertyName' additionalProperty.Name);  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  				writer.WriteLine ("WriteReferenceValuesIndividual();");  			}  			writer.WriteLine ("private void WriteReferenceValuesIndividual()");  			using (writer.OpenScope ()) {  				// write other materials as individual packets  				foreach (var property in schemaProperties) {  					writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  				}  				// special case - velocity reference  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  					var property = schemaProperties.First (p => p.Name == "position");  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						// construct a position with specific velocity  						double dx = 1.0;  						double dy = 2.0;  						double dz = 3.0;  						double deltaTime = 60.0;  						double x1 = 1.0;  						double x2 = x1 + dx * deltaTime;  						double y1 = 2.0;  						double y2 = y1 + dy * deltaTime;  						double z1 = 3.0;  						double z2 = z1 + dz * deltaTime;  						string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  						string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  						string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  						string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  						writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  						WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  						WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  					}  				}  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						properties = subProperty.ValueType.Properties;  						if (properties.Any (p => p.Name == "velocityReference")) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  									double expectedX = 1.0;  									double expectedY = 2.0;  									double expectedZ = 3.0;  									bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  									if (isNormalized) {  										NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  									}  									WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  								}  							}  						}  					}  				}  			}  			// write other materials as individual packets  			foreach (var property in schemaProperties) {  				writer.WriteLine ("private void WriteReferenceValuesIndividual{0}()"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						string subPropertyName = GetSubPropertyName (propertyName' subProperty);  						if (subProperty.ValueType.Name.Contains ("Material")) {  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string targetId = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  									string id = string.Format ("reference_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												writer.WriteLine ("m2.WriteReference(new Reference(\"{0}\"' CreateList(\"{1}\"' \"{2}\"' \"{3}\")));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  												WriteAssertion (writer' isExtension' "expect(e.{1}.{2}.{3}.getValue(date)).toEqual(dataSource.entities.getById('{0}').{1}.{2}.{3}.getValue(date));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  											}  										}  									}  								}  							}  						}  					}  				}  			}  			// test sampled properties  			writer.WriteLine ("private void WriteSampledValues()");  			using (writer.OpenScope ()) {  				// Write one packet with first value types for each property  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					const string id = "Sampled";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Sampled')).toBeDefined();");  					foreach (var property in schemaProperties) {  						string propertyName = property.Name;  						bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  						if (isExtension)  							propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  						var properties = property.ValueType.Properties;  						if (property.IsInterpolatable) {  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  								WriteValues (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  							}  						} else {  							var subProperties = properties.Where (p => !p.IsValue && (p.IsInterpolatable || p.ValueType.Name.Contains ("Material"))).ToList ();  							if (subProperties.Any ()) {  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								using (writer.OpenScope ()) {  									foreach (var subProperty in subProperties) {  										properties = subProperty.ValueType.Properties;  										string subPropertyName = GetSubPropertyName (propertyName' subProperty);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											if (subProperty.IsInterpolatable) {  												var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  												WriteValues (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  											} else if (subProperty.ValueType.Name.Contains ("Material")) {  												Property materialProperty = properties.First ();  												writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialProperty.ValueType.Properties;  													foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  														writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  														using (writer.OpenScope ()) {  															properties = materialSubProperty.ValueType.Properties;  															var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  															WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  														}  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  				writer.WriteLine ("WriteSampledValuesIndividual();");  				writer.WriteLine ("WriteSampledValuesCustomProperties();");  			}  			writer.WriteLine ("private void WriteSampledValuesIndividual()");  			using (writer.OpenScope ()) {  				// write other value types as individual packets  				// split method into multiple methods  				foreach (var property in schemaProperties) {  					writer.WriteLine ("WriteSampledValuesIndividual{0}();"' property.NameWithPascalCase);  				}  			}  			foreach (var property in schemaProperties) {  				writer.WriteLine ("private void WriteSampledValuesIndividual{0}()"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					if (property.IsInterpolatable) {  						foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("sampled_{0}_{1}"' propertyName' valueProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValues (writer' "w"' id' valueProperty' property' isExtension' propertyName);  								}  							}  						}  					} else {  						foreach (var subProperty in properties.Where (p => !p.IsValue)) {  							string subPropertyName = GetSubPropertyName (propertyName' subProperty);  							properties = subProperty.ValueType.Properties;  							if (subProperty.IsInterpolatable) {  								foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' valueProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValues (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  										}  									}  								}  							} else if (subProperty.ValueType.Name.Contains ("Material")) {  								// write other values for the first material  								// then write first values for other materials   								// then write remaining values for other materials individually  								var firstMaterialProperty = properties.First ();  								properties = firstMaterialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  									properties = materialSubProperty.ValueType.Properties;  									foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  										writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  										using (writer.OpenScope ()) {  											string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  											writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  											WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  											writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												WriteValues (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  								properties = subProperty.ValueType.Properties;  								foreach (var materialProperty in properties.Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialSubProperty.ValueType.Properties;  													var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  													WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  								properties = subProperty.ValueType.Properties;  								foreach (var materialProperty in properties.Skip (1)) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  										properties = materialSubProperty.ValueType.Properties;  										foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  											writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  											using (writer.OpenScope ()) {  												string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  												writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  												WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  												writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  												writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  												writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			// create all types of custom properties  			writer.WriteLine ("private void WriteSampledValuesCustomProperties()");  			using (writer.OpenScope ()) {  				var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  				if (propertiesProperty != null) {  					var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  					if (additionalProperties != null) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = "sampled_custom";  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array)) {  									string propName = string.Format ("custom_{0}"' valueProperty.Name);  									writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  									using (writer.OpenScope ()) {  										WriteValues (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  									}  								}  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (CodeWriter writer = new CodeWriter (Path.Combine (m_outputDirectory' "TestGenerateValidationDocument.cs"))) {  	writer.WriteLine ("// This file was generated automatically by GenerateFromSchema.  Do NOT edit it.");  	writer.WriteLine ("// https://github.com/AnalyticalGraphicsInc/czml-writer");  	writer.WriteLine ();  	writer.WriteLine ("using System.Collections.Generic;");  	writer.WriteLine ("using System.Diagnostics.CodeAnalysis;");  	writer.WriteLine ("using System.Drawing;");  	writer.WriteLine ("using System.IO;");  	writer.WriteLine ("using CesiumLanguageWriter;");  	writer.WriteLine ("using NUnit.Framework;");  	writer.WriteLine ();  	writer.WriteLine ("namespace {0}"' "CesiumLanguageWriterTests");  	using (writer.OpenScope ()) {  		writer.WriteLine ("[TestFixture]");  		writer.WriteLine ("[SuppressMessage(\"ReSharper\"' \"MemberCanBeMadeStatic.Local\")]");  		writer.WriteLine ("public class TestGenerateValidationDocument");  		using (writer.OpenScope ()) {  			writer.WriteLine ("private readonly JulianDate m_documentStartDate = new GregorianDate(2016' 6' 17' 12' 0' 0).ToJulianDate();");  			writer.WriteLine ("private readonly JulianDate m_documentStopDate = new GregorianDate(2016' 6' 17' 13' 0' 0).ToJulianDate();");  			writer.WriteLine ("private TextWriter m_streamWriter;");  			writer.WriteLine ("private TextWriter m_assertionsWriter;");  			writer.WriteLine ("private TextWriter m_extensionsAssertionsWriter;");  			writer.WriteLine ("private CesiumOutputStream m_output;");  			writer.WriteLine ("private CesiumStreamWriter m_writer;");  			writer.WriteLine ("private void WriteAssertionBoth(string s)");  			using (writer.OpenScope ()) {  				writer.WriteLine ("m_assertionsWriter.WriteLine(s);");  				writer.WriteLine ("m_extensionsAssertionsWriter.WriteLine(s);");  			}  			writer.WriteLine ("private static IList<T> CreateList<T>(T t1' T t2)");  			using (writer.OpenScope ()) {  				writer.WriteLine ("return new List<T> { t1' t2 };");  			}  			writer.WriteLine ("private static IList<T> CreateList<T>(params T[] ts)");  			using (writer.OpenScope ()) {  				writer.WriteLine ("return ts;");  			}  			writer.WriteLine ("[Test]");  			writer.WriteLine ("public void GenerateValidationDocument()");  			var schemaProperties = schema.Properties.Where (p => p.Name != "clock" && p.Name != "availability" && !p.ValueType.IsSchemaFromType).Where (p => p.Name != "properties").ToList ();  			using (writer.OpenScope ()) {  				writer.WriteLine ("using (m_streamWriter = new StreamWriter(\"ValidationDocument.czml\"))");  				writer.WriteLine ("using (m_assertionsWriter = new StreamWriter(\"ValidationDocumentAssertions.js\"))");  				writer.WriteLine ("using (m_extensionsAssertionsWriter = new StreamWriter(\"ValidationDocumentExtensionAssertions.js\"))");  				using (writer.OpenScope ()) {  					WriteAssertionBoth (writer' "return CzmlDataSource.load('Data/CZML/ValidationDocument.czml').then(function(dataSource) {");  					s_assertionIndent++;  					WriteAssertionBoth (writer' "/*jshint -W120 */");  					WriteAssertionBoth (writer' "var e;");  					WriteAssertionBoth (writer' "var date;");  					WriteAssertionBoth (writer' "var documentStartDate = JulianDate.fromIso8601('2016-06-17T12:00:00Z');");  					WriteAssertionBoth (writer' "var documentStopDate = JulianDate.fromIso8601('2016-06-17T13:00:00Z');");  					writer.WriteLine ("m_output = new CesiumOutputStream(m_streamWriter) { PrettyFormatting = true };");  					writer.WriteLine ("m_writer = new CesiumStreamWriter();");  					writer.WriteLine ("m_output.WriteStartSequence();");  					// Java has a limit on the size of a single method (65535 bytes) so we have to break up all this code in multiple methods  					writer.WriteLine ("WriteClock();");  					writer.WriteLine ("WriteConstantValues();");  					writer.WriteLine ("WriteReferenceValues();");  					writer.WriteLine ("WriteSampledValues();");  					writer.WriteLine ("m_output.WriteEndSequence();");  					s_assertionIndent--;  					WriteAssertionBoth (writer' "});");  					s_assertionIndent++;  				}  			}  			writer.WriteLine ("private void WriteClock()");  			using (writer.OpenScope ()) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					writer.WriteLine ("packet.WriteId(\"document\");");  					writer.WriteLine ("packet.WriteName(\"ValidationDocument\");");  					writer.WriteLine ("packet.WriteVersion(\"1.0\");");  					writer.WriteLine ("using (var clock = packet.OpenClockProperty())");  					using (writer.OpenScope ()) {  						writer.WriteLine ("clock.WriteInterval(m_documentStartDate' m_documentStopDate);");  						WriteAssertion (writer' false' "expect(dataSource.clock.startTime).toEqual(documentStartDate);");  						WriteAssertion (writer' false' "expect(dataSource.clock.stopTime).toEqual(documentStopDate);");  						writer.WriteLine ("clock.WriteCurrentTime(m_documentStartDate);");  						WriteAssertion (writer' false' "expect(dataSource.clock.currentTime).toEqual(documentStartDate);");  						writer.WriteLine ("clock.WriteMultiplier(1.0);");  						WriteAssertion (writer' false' "expect(dataSource.clock.multiplier).toEqual(1.0);");  						writer.WriteLine ("clock.WriteRange(ClockRange.Unbounded);");  						WriteAssertion (writer' false' "expect(dataSource.clock.clockRange).toEqual(ClockRange.UNBOUNDED);");  						writer.WriteLine ("clock.WriteStep(ClockStep.SystemClockMultiplier);");  						WriteAssertion (writer' false' "expect(dataSource.clock.clockStep).toEqual(ClockStep.SYSTEM_CLOCK_MULTIPLIER);");  					}  				}  			}  			writer.WriteLine ("private void WriteConstantValues()");  			using (writer.OpenScope ()) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					const string id = "Constant";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "var constant = e = dataSource.entities.getById('Constant');");  					WriteAssertionBoth (writer' "expect(e).toBeDefined();");  					WriteAssertionBoth (writer' "date = JulianDate.now();");  					// Write one packet with first value types for each property  					foreach (var property in schemaProperties) {  						string propertyName = property.Name;  						bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  						if (isExtension)  							propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var properties = property.ValueType.Properties;  							var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  							if (firstValueProperty != null) {  								WriteValue (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  							} else {  								foreach (var subProperty in properties.Where (p => !p.IsValue)) {  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = subProperty.ValueType.Properties;  										firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  										string subPropertyName = GetSubPropertyName (propertyName' subProperty);  										if (firstValueProperty != null) {  											WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  										} else if (subProperty.ValueType.Name.Contains ("Material")) {  											Property materialProperty = properties.First ();  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialProperty.ValueType.Properties;  												foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  													writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														properties = materialSubProperty.ValueType.Properties;  														firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  														if (firstValueProperty != null) {  															WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  														}  													}  												}  											}  										} else {  											var additionalProperties = subProperty.ValueType.AdditionalProperties;  											if (additionalProperties != null) {  												writer.WriteLine ("using (var a = w2.Open{0}Property(\"prop\"))"' additionalProperties.ValueType.NameWithPascalCase);  												using (writer.OpenScope ()) {  													foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  														writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  														using (writer.OpenScope ()) {  															properties = additionalProperty.ValueType.Properties;  															firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  															if (firstValueProperty != null) {  																WriteValue (writer' "w3"' id + property.Name' firstValueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' "prop"' additionalProperty.Name));  															}  														}  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  				writer.WriteLine ("WriteConstantValuesIndividual();");  				writer.WriteLine ("WriteConstantValuesCustomProperties();");  			}  			writer.WriteLine ("private void WriteConstantValuesIndividual()");  			using (writer.OpenScope ()) {  				// write other value types as individual packets  				foreach (var property in schemaProperties) {  					writer.WriteLine ("WriteConstantValuesIndividual{0}();"' property.NameWithPascalCase);  				}  			}  			foreach (var property in schemaProperties) {  				writer.WriteLine ("private void WriteConstantValuesIndividual{0}()"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("constant_{0}_{1}"' property.Name' valueProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								WriteValue (writer' "w"' id' valueProperty' property' isExtension' propertyName);  							}  						}  					}  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						string subPropertyName = GetSubPropertyName (propertyName' subProperty);  						properties = subProperty.ValueType.Properties;  						foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("constant_{0}_{1}_{2}"' property.Name' subPropertyName' valueProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValue (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  								}  							}  						}  						if (subProperty.ValueType.Name.Contains ("Material")) {  							// write other values for the first material  							// then write first values for other materials   							// then write remaining values for other materials individually  							var firstMaterialProperty = properties.First ();  							properties = firstMaterialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValue (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialSubProperty.ValueType.Properties;  												var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  												if (firstValueProperty != null) {  													WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  									properties = materialSubProperty.ValueType.Properties;  									foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  										writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  										using (writer.OpenScope ()) {  											string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  											writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  											WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  											writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  						}  						var additionalProperties = subProperty.ValueType.AdditionalProperties;  						if (additionalProperties != null) {  							foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  								int i = 0;  								properties = additionalProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' additionalProperties.ValueType.Name' additionalProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										string propName = string.Format ("{0}{1}"' "prop"' i++);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var a = w2.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  										writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValue (writer' "w3"' id + property.Name + subProperty.Name' valueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' propName' additionalProperty.Name));  										}  									}  								}  							}  						}  					}  				}  			}  			// create all types of custom properties  			writer.WriteLine ("private void WriteConstantValuesCustomProperties()");  			using (writer.OpenScope ()) {  				var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  				if (propertiesProperty != null) {  					var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  					if (additionalProperties != null) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = "constant_custom";  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue)) {  									string propName = string.Format ("custom_{0}"' valueProperty.Name);  									writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  									using (writer.OpenScope ()) {  										WriteValue (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  									}  								}  							}  						}  					}  				}  			}  			// create entities using references  			writer.WriteLine ("private void WriteReferenceValues()");  			using (writer.OpenScope ()) {  				// write some positions and double values to use to create reference lists for position lists and double lists later  				for (int i = 1; i <= 2; ++i) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("ConstantPosition{0}"' i);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantPosition{0}')).toBeDefined();"' i);  						var property = schemaProperties.First (p => p.Name == "position");  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var properties = property.ValueType.Properties;  							var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  							WriteValue (writer' "w"' id' firstValueProperty' property' false' property.Name);  						}  					}  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("ConstantDouble{0}"' i);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantDouble{0}')).toBeDefined();"' i);  						var property = schemaProperties.First (p => p.Name == "billboard");  						var properties = property.ValueType.Properties;  						var subProperty = properties.First (p => p.Name == "scale");  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							properties = subProperty.ValueType.Properties;  							var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  							WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' false' string.Format ("{0}.{1}"' property.Name' subProperty.Name));  						}  					}  				}  				// write one big packet with references for everything  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					writer.WriteLine ("packet.WriteId(\"Reference\");");  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Reference')).toBeDefined();");  					foreach (var property in schemaProperties) {  						string propertyName = property.Name;  						bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  						if (isExtension)  							propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var properties = property.ValueType.Properties;  							if (properties.Any (p => p.ValueType.Name == "Reference")) {  								writer.WriteLine ("w.WriteReference(new Reference(\"Constant\"' \"{0}\"));"' propertyName);  								WriteAssertion (writer' isExtension' "expect(e.{0}.getValue(date)).toEqual(constant.{0}.getValue(date));"' propertyName);  							} else {  								foreach (var subProperty in properties.Where (p => !p.IsValue)) {  									properties = subProperty.ValueType.Properties;  									string subPropertyName = GetSubPropertyName (propertyName' subProperty);  									if (properties.Any (p => p.ValueType.Name == "Reference")) {  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("w2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\")));"' propertyName' subPropertyName);  											WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual(constant.{0}.{1}.getValue(date));"' propertyName' subPropertyName);  										}  									} else if (properties.Any (p => p.ValueType.Name == "ReferenceList")) {  										string targetId = "";  										string[] referencePropertyNames =  {    										};  										if (subProperty.ValueType.Name == "PositionList") {  											targetId = "Position";  											referencePropertyNames = new[] {  												"position"  											};  										} else if (subProperty.ValueType.Name == "DoubleList") {  											targetId = "Double";  											referencePropertyNames = new[] {  												"billboard"'  												"scale"  											};  										}  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("w2.WriteReferences(CreateList(new Reference(\"Constant{0}1\"' CreateList({1}))' new Reference(\"Constant{0}2\"' CreateList({1}))));"' targetId' string.Join ("' "' referencePropertyNames.Select (n => string.Format ("\"{0}\""' n))));  											WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual([dataSource.entities.getById('Constant{2}1').{3}.getValue(date)' dataSource.entities.getById('Constant{2}2').{3}.getValue(date)]);"' propertyName' subPropertyName' targetId' string.Join ("."' referencePropertyNames));  										}  									} else if (subProperty.ValueType.Name.Contains ("Material")) {  										Property materialProperty = properties.First ();  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													writer.WriteLine ("m2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"{2}\")));"' propertyName' subPropertyName' materialSubProperty.Name);  													WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.{2}.getValue(date)).toEqual(constant.{0}.{1}.{2}.getValue(date));"' propertyName' subPropertyName' materialSubProperty.Name);  												}  											}  										}  									} else {  										var additionalProperties = subProperty.ValueType.AdditionalProperties;  										if (additionalProperties != null) {  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var a = w2.Open{0}Property(\"referenceProp\"))"' additionalProperties.ValueType.NameWithPascalCase);  											using (writer.OpenScope ()) {  												foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  													writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														writer.WriteLine ("w3.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"prop\"' \"{2}\")));"' propertyName' subPropertyName' additionalProperty.Name);  														WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.referenceProp.{2}.getValue(date)).toEqual(constant.{0}.{1}.prop.{2}.getValue(date));"' propertyName' subPropertyName' additionalProperty.Name);  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  				writer.WriteLine ("WriteReferenceValuesIndividual();");  			}  			writer.WriteLine ("private void WriteReferenceValuesIndividual()");  			using (writer.OpenScope ()) {  				// write other materials as individual packets  				foreach (var property in schemaProperties) {  					writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  				}  				// special case - velocity reference  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  					var property = schemaProperties.First (p => p.Name == "position");  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						// construct a position with specific velocity  						double dx = 1.0;  						double dy = 2.0;  						double dz = 3.0;  						double deltaTime = 60.0;  						double x1 = 1.0;  						double x2 = x1 + dx * deltaTime;  						double y1 = 2.0;  						double y2 = y1 + dy * deltaTime;  						double z1 = 3.0;  						double z2 = z1 + dz * deltaTime;  						string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  						string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  						string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  						string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  						writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  						WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  						WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  					}  				}  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						properties = subProperty.ValueType.Properties;  						if (properties.Any (p => p.Name == "velocityReference")) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  									double expectedX = 1.0;  									double expectedY = 2.0;  									double expectedZ = 3.0;  									bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  									if (isNormalized) {  										NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  									}  									WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  								}  							}  						}  					}  				}  			}  			// write other materials as individual packets  			foreach (var property in schemaProperties) {  				writer.WriteLine ("private void WriteReferenceValuesIndividual{0}()"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						string subPropertyName = GetSubPropertyName (propertyName' subProperty);  						if (subProperty.ValueType.Name.Contains ("Material")) {  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string targetId = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  									string id = string.Format ("reference_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												writer.WriteLine ("m2.WriteReference(new Reference(\"{0}\"' CreateList(\"{1}\"' \"{2}\"' \"{3}\")));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  												WriteAssertion (writer' isExtension' "expect(e.{1}.{2}.{3}.getValue(date)).toEqual(dataSource.entities.getById('{0}').{1}.{2}.{3}.getValue(date));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  											}  										}  									}  								}  							}  						}  					}  				}  			}  			// test sampled properties  			writer.WriteLine ("private void WriteSampledValues()");  			using (writer.OpenScope ()) {  				// Write one packet with first value types for each property  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					const string id = "Sampled";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Sampled')).toBeDefined();");  					foreach (var property in schemaProperties) {  						string propertyName = property.Name;  						bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  						if (isExtension)  							propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  						var properties = property.ValueType.Properties;  						if (property.IsInterpolatable) {  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  								WriteValues (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  							}  						} else {  							var subProperties = properties.Where (p => !p.IsValue && (p.IsInterpolatable || p.ValueType.Name.Contains ("Material"))).ToList ();  							if (subProperties.Any ()) {  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								using (writer.OpenScope ()) {  									foreach (var subProperty in subProperties) {  										properties = subProperty.ValueType.Properties;  										string subPropertyName = GetSubPropertyName (propertyName' subProperty);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											if (subProperty.IsInterpolatable) {  												var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  												WriteValues (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  											} else if (subProperty.ValueType.Name.Contains ("Material")) {  												Property materialProperty = properties.First ();  												writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialProperty.ValueType.Properties;  													foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  														writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  														using (writer.OpenScope ()) {  															properties = materialSubProperty.ValueType.Properties;  															var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  															WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  														}  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  				writer.WriteLine ("WriteSampledValuesIndividual();");  				writer.WriteLine ("WriteSampledValuesCustomProperties();");  			}  			writer.WriteLine ("private void WriteSampledValuesIndividual()");  			using (writer.OpenScope ()) {  				// write other value types as individual packets  				// split method into multiple methods  				foreach (var property in schemaProperties) {  					writer.WriteLine ("WriteSampledValuesIndividual{0}();"' property.NameWithPascalCase);  				}  			}  			foreach (var property in schemaProperties) {  				writer.WriteLine ("private void WriteSampledValuesIndividual{0}()"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					if (property.IsInterpolatable) {  						foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("sampled_{0}_{1}"' propertyName' valueProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValues (writer' "w"' id' valueProperty' property' isExtension' propertyName);  								}  							}  						}  					} else {  						foreach (var subProperty in properties.Where (p => !p.IsValue)) {  							string subPropertyName = GetSubPropertyName (propertyName' subProperty);  							properties = subProperty.ValueType.Properties;  							if (subProperty.IsInterpolatable) {  								foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' valueProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValues (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  										}  									}  								}  							} else if (subProperty.ValueType.Name.Contains ("Material")) {  								// write other values for the first material  								// then write first values for other materials   								// then write remaining values for other materials individually  								var firstMaterialProperty = properties.First ();  								properties = firstMaterialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  									properties = materialSubProperty.ValueType.Properties;  									foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  										writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  										using (writer.OpenScope ()) {  											string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  											writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  											WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  											writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												WriteValues (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  								properties = subProperty.ValueType.Properties;  								foreach (var materialProperty in properties.Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialSubProperty.ValueType.Properties;  													var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  													WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  								properties = subProperty.ValueType.Properties;  								foreach (var materialProperty in properties.Skip (1)) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  										properties = materialSubProperty.ValueType.Properties;  										foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  											writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  											using (writer.OpenScope ()) {  												string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  												writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  												WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  												writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  												writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  												writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			// create all types of custom properties  			writer.WriteLine ("private void WriteSampledValuesCustomProperties()");  			using (writer.OpenScope ()) {  				var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  				if (propertiesProperty != null) {  					var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  					if (additionalProperties != null) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = "sampled_custom";  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array)) {  									string propName = string.Format ("custom_{0}"' valueProperty.Name);  									writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  									using (writer.OpenScope ()) {  										WriteValues (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  									}  								}  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (CodeWriter writer = new CodeWriter (Path.Combine (m_outputDirectory' "TestGenerateValidationDocument.cs"))) {  	writer.WriteLine ("// This file was generated automatically by GenerateFromSchema.  Do NOT edit it.");  	writer.WriteLine ("// https://github.com/AnalyticalGraphicsInc/czml-writer");  	writer.WriteLine ();  	writer.WriteLine ("using System.Collections.Generic;");  	writer.WriteLine ("using System.Diagnostics.CodeAnalysis;");  	writer.WriteLine ("using System.Drawing;");  	writer.WriteLine ("using System.IO;");  	writer.WriteLine ("using CesiumLanguageWriter;");  	writer.WriteLine ("using NUnit.Framework;");  	writer.WriteLine ();  	writer.WriteLine ("namespace {0}"' "CesiumLanguageWriterTests");  	using (writer.OpenScope ()) {  		writer.WriteLine ("[TestFixture]");  		writer.WriteLine ("[SuppressMessage(\"ReSharper\"' \"MemberCanBeMadeStatic.Local\")]");  		writer.WriteLine ("public class TestGenerateValidationDocument");  		using (writer.OpenScope ()) {  			writer.WriteLine ("private readonly JulianDate m_documentStartDate = new GregorianDate(2016' 6' 17' 12' 0' 0).ToJulianDate();");  			writer.WriteLine ("private readonly JulianDate m_documentStopDate = new GregorianDate(2016' 6' 17' 13' 0' 0).ToJulianDate();");  			writer.WriteLine ("private TextWriter m_streamWriter;");  			writer.WriteLine ("private TextWriter m_assertionsWriter;");  			writer.WriteLine ("private TextWriter m_extensionsAssertionsWriter;");  			writer.WriteLine ("private CesiumOutputStream m_output;");  			writer.WriteLine ("private CesiumStreamWriter m_writer;");  			writer.WriteLine ("private void WriteAssertionBoth(string s)");  			using (writer.OpenScope ()) {  				writer.WriteLine ("m_assertionsWriter.WriteLine(s);");  				writer.WriteLine ("m_extensionsAssertionsWriter.WriteLine(s);");  			}  			writer.WriteLine ("private static IList<T> CreateList<T>(T t1' T t2)");  			using (writer.OpenScope ()) {  				writer.WriteLine ("return new List<T> { t1' t2 };");  			}  			writer.WriteLine ("private static IList<T> CreateList<T>(params T[] ts)");  			using (writer.OpenScope ()) {  				writer.WriteLine ("return ts;");  			}  			writer.WriteLine ("[Test]");  			writer.WriteLine ("public void GenerateValidationDocument()");  			var schemaProperties = schema.Properties.Where (p => p.Name != "clock" && p.Name != "availability" && !p.ValueType.IsSchemaFromType).Where (p => p.Name != "properties").ToList ();  			using (writer.OpenScope ()) {  				writer.WriteLine ("using (m_streamWriter = new StreamWriter(\"ValidationDocument.czml\"))");  				writer.WriteLine ("using (m_assertionsWriter = new StreamWriter(\"ValidationDocumentAssertions.js\"))");  				writer.WriteLine ("using (m_extensionsAssertionsWriter = new StreamWriter(\"ValidationDocumentExtensionAssertions.js\"))");  				using (writer.OpenScope ()) {  					WriteAssertionBoth (writer' "return CzmlDataSource.load('Data/CZML/ValidationDocument.czml').then(function(dataSource) {");  					s_assertionIndent++;  					WriteAssertionBoth (writer' "/*jshint -W120 */");  					WriteAssertionBoth (writer' "var e;");  					WriteAssertionBoth (writer' "var date;");  					WriteAssertionBoth (writer' "var documentStartDate = JulianDate.fromIso8601('2016-06-17T12:00:00Z');");  					WriteAssertionBoth (writer' "var documentStopDate = JulianDate.fromIso8601('2016-06-17T13:00:00Z');");  					writer.WriteLine ("m_output = new CesiumOutputStream(m_streamWriter) { PrettyFormatting = true };");  					writer.WriteLine ("m_writer = new CesiumStreamWriter();");  					writer.WriteLine ("m_output.WriteStartSequence();");  					// Java has a limit on the size of a single method (65535 bytes) so we have to break up all this code in multiple methods  					writer.WriteLine ("WriteClock();");  					writer.WriteLine ("WriteConstantValues();");  					writer.WriteLine ("WriteReferenceValues();");  					writer.WriteLine ("WriteSampledValues();");  					writer.WriteLine ("m_output.WriteEndSequence();");  					s_assertionIndent--;  					WriteAssertionBoth (writer' "});");  					s_assertionIndent++;  				}  			}  			writer.WriteLine ("private void WriteClock()");  			using (writer.OpenScope ()) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					writer.WriteLine ("packet.WriteId(\"document\");");  					writer.WriteLine ("packet.WriteName(\"ValidationDocument\");");  					writer.WriteLine ("packet.WriteVersion(\"1.0\");");  					writer.WriteLine ("using (var clock = packet.OpenClockProperty())");  					using (writer.OpenScope ()) {  						writer.WriteLine ("clock.WriteInterval(m_documentStartDate' m_documentStopDate);");  						WriteAssertion (writer' false' "expect(dataSource.clock.startTime).toEqual(documentStartDate);");  						WriteAssertion (writer' false' "expect(dataSource.clock.stopTime).toEqual(documentStopDate);");  						writer.WriteLine ("clock.WriteCurrentTime(m_documentStartDate);");  						WriteAssertion (writer' false' "expect(dataSource.clock.currentTime).toEqual(documentStartDate);");  						writer.WriteLine ("clock.WriteMultiplier(1.0);");  						WriteAssertion (writer' false' "expect(dataSource.clock.multiplier).toEqual(1.0);");  						writer.WriteLine ("clock.WriteRange(ClockRange.Unbounded);");  						WriteAssertion (writer' false' "expect(dataSource.clock.clockRange).toEqual(ClockRange.UNBOUNDED);");  						writer.WriteLine ("clock.WriteStep(ClockStep.SystemClockMultiplier);");  						WriteAssertion (writer' false' "expect(dataSource.clock.clockStep).toEqual(ClockStep.SYSTEM_CLOCK_MULTIPLIER);");  					}  				}  			}  			writer.WriteLine ("private void WriteConstantValues()");  			using (writer.OpenScope ()) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					const string id = "Constant";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "var constant = e = dataSource.entities.getById('Constant');");  					WriteAssertionBoth (writer' "expect(e).toBeDefined();");  					WriteAssertionBoth (writer' "date = JulianDate.now();");  					// Write one packet with first value types for each property  					foreach (var property in schemaProperties) {  						string propertyName = property.Name;  						bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  						if (isExtension)  							propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var properties = property.ValueType.Properties;  							var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  							if (firstValueProperty != null) {  								WriteValue (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  							} else {  								foreach (var subProperty in properties.Where (p => !p.IsValue)) {  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = subProperty.ValueType.Properties;  										firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  										string subPropertyName = GetSubPropertyName (propertyName' subProperty);  										if (firstValueProperty != null) {  											WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  										} else if (subProperty.ValueType.Name.Contains ("Material")) {  											Property materialProperty = properties.First ();  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialProperty.ValueType.Properties;  												foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  													writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														properties = materialSubProperty.ValueType.Properties;  														firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  														if (firstValueProperty != null) {  															WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  														}  													}  												}  											}  										} else {  											var additionalProperties = subProperty.ValueType.AdditionalProperties;  											if (additionalProperties != null) {  												writer.WriteLine ("using (var a = w2.Open{0}Property(\"prop\"))"' additionalProperties.ValueType.NameWithPascalCase);  												using (writer.OpenScope ()) {  													foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  														writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  														using (writer.OpenScope ()) {  															properties = additionalProperty.ValueType.Properties;  															firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  															if (firstValueProperty != null) {  																WriteValue (writer' "w3"' id + property.Name' firstValueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' "prop"' additionalProperty.Name));  															}  														}  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  				writer.WriteLine ("WriteConstantValuesIndividual();");  				writer.WriteLine ("WriteConstantValuesCustomProperties();");  			}  			writer.WriteLine ("private void WriteConstantValuesIndividual()");  			using (writer.OpenScope ()) {  				// write other value types as individual packets  				foreach (var property in schemaProperties) {  					writer.WriteLine ("WriteConstantValuesIndividual{0}();"' property.NameWithPascalCase);  				}  			}  			foreach (var property in schemaProperties) {  				writer.WriteLine ("private void WriteConstantValuesIndividual{0}()"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("constant_{0}_{1}"' property.Name' valueProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								WriteValue (writer' "w"' id' valueProperty' property' isExtension' propertyName);  							}  						}  					}  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						string subPropertyName = GetSubPropertyName (propertyName' subProperty);  						properties = subProperty.ValueType.Properties;  						foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("constant_{0}_{1}_{2}"' property.Name' subPropertyName' valueProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValue (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  								}  							}  						}  						if (subProperty.ValueType.Name.Contains ("Material")) {  							// write other values for the first material  							// then write first values for other materials   							// then write remaining values for other materials individually  							var firstMaterialProperty = properties.First ();  							properties = firstMaterialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValue (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialSubProperty.ValueType.Properties;  												var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  												if (firstValueProperty != null) {  													WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  									properties = materialSubProperty.ValueType.Properties;  									foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  										writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  										using (writer.OpenScope ()) {  											string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  											writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  											WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  											writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  						}  						var additionalProperties = subProperty.ValueType.AdditionalProperties;  						if (additionalProperties != null) {  							foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  								int i = 0;  								properties = additionalProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' additionalProperties.ValueType.Name' additionalProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										string propName = string.Format ("{0}{1}"' "prop"' i++);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var a = w2.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  										writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValue (writer' "w3"' id + property.Name + subProperty.Name' valueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' propName' additionalProperty.Name));  										}  									}  								}  							}  						}  					}  				}  			}  			// create all types of custom properties  			writer.WriteLine ("private void WriteConstantValuesCustomProperties()");  			using (writer.OpenScope ()) {  				var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  				if (propertiesProperty != null) {  					var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  					if (additionalProperties != null) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = "constant_custom";  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue)) {  									string propName = string.Format ("custom_{0}"' valueProperty.Name);  									writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  									using (writer.OpenScope ()) {  										WriteValue (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  									}  								}  							}  						}  					}  				}  			}  			// create entities using references  			writer.WriteLine ("private void WriteReferenceValues()");  			using (writer.OpenScope ()) {  				// write some positions and double values to use to create reference lists for position lists and double lists later  				for (int i = 1; i <= 2; ++i) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("ConstantPosition{0}"' i);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantPosition{0}')).toBeDefined();"' i);  						var property = schemaProperties.First (p => p.Name == "position");  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var properties = property.ValueType.Properties;  							var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  							WriteValue (writer' "w"' id' firstValueProperty' property' false' property.Name);  						}  					}  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("ConstantDouble{0}"' i);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantDouble{0}')).toBeDefined();"' i);  						var property = schemaProperties.First (p => p.Name == "billboard");  						var properties = property.ValueType.Properties;  						var subProperty = properties.First (p => p.Name == "scale");  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							properties = subProperty.ValueType.Properties;  							var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  							WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' false' string.Format ("{0}.{1}"' property.Name' subProperty.Name));  						}  					}  				}  				// write one big packet with references for everything  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					writer.WriteLine ("packet.WriteId(\"Reference\");");  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Reference')).toBeDefined();");  					foreach (var property in schemaProperties) {  						string propertyName = property.Name;  						bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  						if (isExtension)  							propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var properties = property.ValueType.Properties;  							if (properties.Any (p => p.ValueType.Name == "Reference")) {  								writer.WriteLine ("w.WriteReference(new Reference(\"Constant\"' \"{0}\"));"' propertyName);  								WriteAssertion (writer' isExtension' "expect(e.{0}.getValue(date)).toEqual(constant.{0}.getValue(date));"' propertyName);  							} else {  								foreach (var subProperty in properties.Where (p => !p.IsValue)) {  									properties = subProperty.ValueType.Properties;  									string subPropertyName = GetSubPropertyName (propertyName' subProperty);  									if (properties.Any (p => p.ValueType.Name == "Reference")) {  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("w2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\")));"' propertyName' subPropertyName);  											WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual(constant.{0}.{1}.getValue(date));"' propertyName' subPropertyName);  										}  									} else if (properties.Any (p => p.ValueType.Name == "ReferenceList")) {  										string targetId = "";  										string[] referencePropertyNames =  {    										};  										if (subProperty.ValueType.Name == "PositionList") {  											targetId = "Position";  											referencePropertyNames = new[] {  												"position"  											};  										} else if (subProperty.ValueType.Name == "DoubleList") {  											targetId = "Double";  											referencePropertyNames = new[] {  												"billboard"'  												"scale"  											};  										}  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("w2.WriteReferences(CreateList(new Reference(\"Constant{0}1\"' CreateList({1}))' new Reference(\"Constant{0}2\"' CreateList({1}))));"' targetId' string.Join ("' "' referencePropertyNames.Select (n => string.Format ("\"{0}\""' n))));  											WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual([dataSource.entities.getById('Constant{2}1').{3}.getValue(date)' dataSource.entities.getById('Constant{2}2').{3}.getValue(date)]);"' propertyName' subPropertyName' targetId' string.Join ("."' referencePropertyNames));  										}  									} else if (subProperty.ValueType.Name.Contains ("Material")) {  										Property materialProperty = properties.First ();  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													writer.WriteLine ("m2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"{2}\")));"' propertyName' subPropertyName' materialSubProperty.Name);  													WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.{2}.getValue(date)).toEqual(constant.{0}.{1}.{2}.getValue(date));"' propertyName' subPropertyName' materialSubProperty.Name);  												}  											}  										}  									} else {  										var additionalProperties = subProperty.ValueType.AdditionalProperties;  										if (additionalProperties != null) {  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var a = w2.Open{0}Property(\"referenceProp\"))"' additionalProperties.ValueType.NameWithPascalCase);  											using (writer.OpenScope ()) {  												foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  													writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														writer.WriteLine ("w3.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"prop\"' \"{2}\")));"' propertyName' subPropertyName' additionalProperty.Name);  														WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.referenceProp.{2}.getValue(date)).toEqual(constant.{0}.{1}.prop.{2}.getValue(date));"' propertyName' subPropertyName' additionalProperty.Name);  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  				writer.WriteLine ("WriteReferenceValuesIndividual();");  			}  			writer.WriteLine ("private void WriteReferenceValuesIndividual()");  			using (writer.OpenScope ()) {  				// write other materials as individual packets  				foreach (var property in schemaProperties) {  					writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  				}  				// special case - velocity reference  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  					var property = schemaProperties.First (p => p.Name == "position");  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						// construct a position with specific velocity  						double dx = 1.0;  						double dy = 2.0;  						double dz = 3.0;  						double deltaTime = 60.0;  						double x1 = 1.0;  						double x2 = x1 + dx * deltaTime;  						double y1 = 2.0;  						double y2 = y1 + dy * deltaTime;  						double z1 = 3.0;  						double z2 = z1 + dz * deltaTime;  						string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  						string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  						string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  						string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  						writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  						WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  						WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  					}  				}  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						properties = subProperty.ValueType.Properties;  						if (properties.Any (p => p.Name == "velocityReference")) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  									double expectedX = 1.0;  									double expectedY = 2.0;  									double expectedZ = 3.0;  									bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  									if (isNormalized) {  										NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  									}  									WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  								}  							}  						}  					}  				}  			}  			// write other materials as individual packets  			foreach (var property in schemaProperties) {  				writer.WriteLine ("private void WriteReferenceValuesIndividual{0}()"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						string subPropertyName = GetSubPropertyName (propertyName' subProperty);  						if (subProperty.ValueType.Name.Contains ("Material")) {  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string targetId = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  									string id = string.Format ("reference_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												writer.WriteLine ("m2.WriteReference(new Reference(\"{0}\"' CreateList(\"{1}\"' \"{2}\"' \"{3}\")));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  												WriteAssertion (writer' isExtension' "expect(e.{1}.{2}.{3}.getValue(date)).toEqual(dataSource.entities.getById('{0}').{1}.{2}.{3}.getValue(date));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  											}  										}  									}  								}  							}  						}  					}  				}  			}  			// test sampled properties  			writer.WriteLine ("private void WriteSampledValues()");  			using (writer.OpenScope ()) {  				// Write one packet with first value types for each property  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					const string id = "Sampled";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Sampled')).toBeDefined();");  					foreach (var property in schemaProperties) {  						string propertyName = property.Name;  						bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  						if (isExtension)  							propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  						var properties = property.ValueType.Properties;  						if (property.IsInterpolatable) {  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  								WriteValues (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  							}  						} else {  							var subProperties = properties.Where (p => !p.IsValue && (p.IsInterpolatable || p.ValueType.Name.Contains ("Material"))).ToList ();  							if (subProperties.Any ()) {  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								using (writer.OpenScope ()) {  									foreach (var subProperty in subProperties) {  										properties = subProperty.ValueType.Properties;  										string subPropertyName = GetSubPropertyName (propertyName' subProperty);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											if (subProperty.IsInterpolatable) {  												var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  												WriteValues (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  											} else if (subProperty.ValueType.Name.Contains ("Material")) {  												Property materialProperty = properties.First ();  												writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialProperty.ValueType.Properties;  													foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  														writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  														using (writer.OpenScope ()) {  															properties = materialSubProperty.ValueType.Properties;  															var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  															WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  														}  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  				writer.WriteLine ("WriteSampledValuesIndividual();");  				writer.WriteLine ("WriteSampledValuesCustomProperties();");  			}  			writer.WriteLine ("private void WriteSampledValuesIndividual()");  			using (writer.OpenScope ()) {  				// write other value types as individual packets  				// split method into multiple methods  				foreach (var property in schemaProperties) {  					writer.WriteLine ("WriteSampledValuesIndividual{0}();"' property.NameWithPascalCase);  				}  			}  			foreach (var property in schemaProperties) {  				writer.WriteLine ("private void WriteSampledValuesIndividual{0}()"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					if (property.IsInterpolatable) {  						foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("sampled_{0}_{1}"' propertyName' valueProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValues (writer' "w"' id' valueProperty' property' isExtension' propertyName);  								}  							}  						}  					} else {  						foreach (var subProperty in properties.Where (p => !p.IsValue)) {  							string subPropertyName = GetSubPropertyName (propertyName' subProperty);  							properties = subProperty.ValueType.Properties;  							if (subProperty.IsInterpolatable) {  								foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' valueProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValues (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  										}  									}  								}  							} else if (subProperty.ValueType.Name.Contains ("Material")) {  								// write other values for the first material  								// then write first values for other materials   								// then write remaining values for other materials individually  								var firstMaterialProperty = properties.First ();  								properties = firstMaterialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  									properties = materialSubProperty.ValueType.Properties;  									foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  										writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  										using (writer.OpenScope ()) {  											string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  											writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  											WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  											writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												WriteValues (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  								properties = subProperty.ValueType.Properties;  								foreach (var materialProperty in properties.Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialSubProperty.ValueType.Properties;  													var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  													WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  								properties = subProperty.ValueType.Properties;  								foreach (var materialProperty in properties.Skip (1)) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  										properties = materialSubProperty.ValueType.Properties;  										foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  											writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  											using (writer.OpenScope ()) {  												string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  												writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  												WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  												writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  												writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  												writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			// create all types of custom properties  			writer.WriteLine ("private void WriteSampledValuesCustomProperties()");  			using (writer.OpenScope ()) {  				var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  				if (propertiesProperty != null) {  					var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  					if (additionalProperties != null) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = "sampled_custom";  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array)) {  									string propName = string.Format ("custom_{0}"' valueProperty.Name);  									writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  									using (writer.OpenScope ()) {  										WriteValues (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  									}  								}  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (CodeWriter writer = new CodeWriter (Path.Combine (m_outputDirectory' "TestGenerateValidationDocument.cs"))) {  	writer.WriteLine ("// This file was generated automatically by GenerateFromSchema.  Do NOT edit it.");  	writer.WriteLine ("// https://github.com/AnalyticalGraphicsInc/czml-writer");  	writer.WriteLine ();  	writer.WriteLine ("using System.Collections.Generic;");  	writer.WriteLine ("using System.Diagnostics.CodeAnalysis;");  	writer.WriteLine ("using System.Drawing;");  	writer.WriteLine ("using System.IO;");  	writer.WriteLine ("using CesiumLanguageWriter;");  	writer.WriteLine ("using NUnit.Framework;");  	writer.WriteLine ();  	writer.WriteLine ("namespace {0}"' "CesiumLanguageWriterTests");  	using (writer.OpenScope ()) {  		writer.WriteLine ("[TestFixture]");  		writer.WriteLine ("[SuppressMessage(\"ReSharper\"' \"MemberCanBeMadeStatic.Local\")]");  		writer.WriteLine ("public class TestGenerateValidationDocument");  		using (writer.OpenScope ()) {  			writer.WriteLine ("private readonly JulianDate m_documentStartDate = new GregorianDate(2016' 6' 17' 12' 0' 0).ToJulianDate();");  			writer.WriteLine ("private readonly JulianDate m_documentStopDate = new GregorianDate(2016' 6' 17' 13' 0' 0).ToJulianDate();");  			writer.WriteLine ("private TextWriter m_streamWriter;");  			writer.WriteLine ("private TextWriter m_assertionsWriter;");  			writer.WriteLine ("private TextWriter m_extensionsAssertionsWriter;");  			writer.WriteLine ("private CesiumOutputStream m_output;");  			writer.WriteLine ("private CesiumStreamWriter m_writer;");  			writer.WriteLine ("private void WriteAssertionBoth(string s)");  			using (writer.OpenScope ()) {  				writer.WriteLine ("m_assertionsWriter.WriteLine(s);");  				writer.WriteLine ("m_extensionsAssertionsWriter.WriteLine(s);");  			}  			writer.WriteLine ("private static IList<T> CreateList<T>(T t1' T t2)");  			using (writer.OpenScope ()) {  				writer.WriteLine ("return new List<T> { t1' t2 };");  			}  			writer.WriteLine ("private static IList<T> CreateList<T>(params T[] ts)");  			using (writer.OpenScope ()) {  				writer.WriteLine ("return ts;");  			}  			writer.WriteLine ("[Test]");  			writer.WriteLine ("public void GenerateValidationDocument()");  			var schemaProperties = schema.Properties.Where (p => p.Name != "clock" && p.Name != "availability" && !p.ValueType.IsSchemaFromType).Where (p => p.Name != "properties").ToList ();  			using (writer.OpenScope ()) {  				writer.WriteLine ("using (m_streamWriter = new StreamWriter(\"ValidationDocument.czml\"))");  				writer.WriteLine ("using (m_assertionsWriter = new StreamWriter(\"ValidationDocumentAssertions.js\"))");  				writer.WriteLine ("using (m_extensionsAssertionsWriter = new StreamWriter(\"ValidationDocumentExtensionAssertions.js\"))");  				using (writer.OpenScope ()) {  					WriteAssertionBoth (writer' "return CzmlDataSource.load('Data/CZML/ValidationDocument.czml').then(function(dataSource) {");  					s_assertionIndent++;  					WriteAssertionBoth (writer' "/*jshint -W120 */");  					WriteAssertionBoth (writer' "var e;");  					WriteAssertionBoth (writer' "var date;");  					WriteAssertionBoth (writer' "var documentStartDate = JulianDate.fromIso8601('2016-06-17T12:00:00Z');");  					WriteAssertionBoth (writer' "var documentStopDate = JulianDate.fromIso8601('2016-06-17T13:00:00Z');");  					writer.WriteLine ("m_output = new CesiumOutputStream(m_streamWriter) { PrettyFormatting = true };");  					writer.WriteLine ("m_writer = new CesiumStreamWriter();");  					writer.WriteLine ("m_output.WriteStartSequence();");  					// Java has a limit on the size of a single method (65535 bytes) so we have to break up all this code in multiple methods  					writer.WriteLine ("WriteClock();");  					writer.WriteLine ("WriteConstantValues();");  					writer.WriteLine ("WriteReferenceValues();");  					writer.WriteLine ("WriteSampledValues();");  					writer.WriteLine ("m_output.WriteEndSequence();");  					s_assertionIndent--;  					WriteAssertionBoth (writer' "});");  					s_assertionIndent++;  				}  			}  			writer.WriteLine ("private void WriteClock()");  			using (writer.OpenScope ()) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					writer.WriteLine ("packet.WriteId(\"document\");");  					writer.WriteLine ("packet.WriteName(\"ValidationDocument\");");  					writer.WriteLine ("packet.WriteVersion(\"1.0\");");  					writer.WriteLine ("using (var clock = packet.OpenClockProperty())");  					using (writer.OpenScope ()) {  						writer.WriteLine ("clock.WriteInterval(m_documentStartDate' m_documentStopDate);");  						WriteAssertion (writer' false' "expect(dataSource.clock.startTime).toEqual(documentStartDate);");  						WriteAssertion (writer' false' "expect(dataSource.clock.stopTime).toEqual(documentStopDate);");  						writer.WriteLine ("clock.WriteCurrentTime(m_documentStartDate);");  						WriteAssertion (writer' false' "expect(dataSource.clock.currentTime).toEqual(documentStartDate);");  						writer.WriteLine ("clock.WriteMultiplier(1.0);");  						WriteAssertion (writer' false' "expect(dataSource.clock.multiplier).toEqual(1.0);");  						writer.WriteLine ("clock.WriteRange(ClockRange.Unbounded);");  						WriteAssertion (writer' false' "expect(dataSource.clock.clockRange).toEqual(ClockRange.UNBOUNDED);");  						writer.WriteLine ("clock.WriteStep(ClockStep.SystemClockMultiplier);");  						WriteAssertion (writer' false' "expect(dataSource.clock.clockStep).toEqual(ClockStep.SYSTEM_CLOCK_MULTIPLIER);");  					}  				}  			}  			writer.WriteLine ("private void WriteConstantValues()");  			using (writer.OpenScope ()) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					const string id = "Constant";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "var constant = e = dataSource.entities.getById('Constant');");  					WriteAssertionBoth (writer' "expect(e).toBeDefined();");  					WriteAssertionBoth (writer' "date = JulianDate.now();");  					// Write one packet with first value types for each property  					foreach (var property in schemaProperties) {  						string propertyName = property.Name;  						bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  						if (isExtension)  							propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var properties = property.ValueType.Properties;  							var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  							if (firstValueProperty != null) {  								WriteValue (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  							} else {  								foreach (var subProperty in properties.Where (p => !p.IsValue)) {  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = subProperty.ValueType.Properties;  										firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  										string subPropertyName = GetSubPropertyName (propertyName' subProperty);  										if (firstValueProperty != null) {  											WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  										} else if (subProperty.ValueType.Name.Contains ("Material")) {  											Property materialProperty = properties.First ();  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialProperty.ValueType.Properties;  												foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  													writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														properties = materialSubProperty.ValueType.Properties;  														firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  														if (firstValueProperty != null) {  															WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  														}  													}  												}  											}  										} else {  											var additionalProperties = subProperty.ValueType.AdditionalProperties;  											if (additionalProperties != null) {  												writer.WriteLine ("using (var a = w2.Open{0}Property(\"prop\"))"' additionalProperties.ValueType.NameWithPascalCase);  												using (writer.OpenScope ()) {  													foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  														writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  														using (writer.OpenScope ()) {  															properties = additionalProperty.ValueType.Properties;  															firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  															if (firstValueProperty != null) {  																WriteValue (writer' "w3"' id + property.Name' firstValueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' "prop"' additionalProperty.Name));  															}  														}  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  				writer.WriteLine ("WriteConstantValuesIndividual();");  				writer.WriteLine ("WriteConstantValuesCustomProperties();");  			}  			writer.WriteLine ("private void WriteConstantValuesIndividual()");  			using (writer.OpenScope ()) {  				// write other value types as individual packets  				foreach (var property in schemaProperties) {  					writer.WriteLine ("WriteConstantValuesIndividual{0}();"' property.NameWithPascalCase);  				}  			}  			foreach (var property in schemaProperties) {  				writer.WriteLine ("private void WriteConstantValuesIndividual{0}()"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("constant_{0}_{1}"' property.Name' valueProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								WriteValue (writer' "w"' id' valueProperty' property' isExtension' propertyName);  							}  						}  					}  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						string subPropertyName = GetSubPropertyName (propertyName' subProperty);  						properties = subProperty.ValueType.Properties;  						foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("constant_{0}_{1}_{2}"' property.Name' subPropertyName' valueProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValue (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  								}  							}  						}  						if (subProperty.ValueType.Name.Contains ("Material")) {  							// write other values for the first material  							// then write first values for other materials   							// then write remaining values for other materials individually  							var firstMaterialProperty = properties.First ();  							properties = firstMaterialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValue (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialSubProperty.ValueType.Properties;  												var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  												if (firstValueProperty != null) {  													WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  									properties = materialSubProperty.ValueType.Properties;  									foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  										writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  										using (writer.OpenScope ()) {  											string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  											writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  											WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  											writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  						}  						var additionalProperties = subProperty.ValueType.AdditionalProperties;  						if (additionalProperties != null) {  							foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  								int i = 0;  								properties = additionalProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' additionalProperties.ValueType.Name' additionalProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										string propName = string.Format ("{0}{1}"' "prop"' i++);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var a = w2.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  										writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValue (writer' "w3"' id + property.Name + subProperty.Name' valueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' propName' additionalProperty.Name));  										}  									}  								}  							}  						}  					}  				}  			}  			// create all types of custom properties  			writer.WriteLine ("private void WriteConstantValuesCustomProperties()");  			using (writer.OpenScope ()) {  				var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  				if (propertiesProperty != null) {  					var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  					if (additionalProperties != null) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = "constant_custom";  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue)) {  									string propName = string.Format ("custom_{0}"' valueProperty.Name);  									writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  									using (writer.OpenScope ()) {  										WriteValue (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  									}  								}  							}  						}  					}  				}  			}  			// create entities using references  			writer.WriteLine ("private void WriteReferenceValues()");  			using (writer.OpenScope ()) {  				// write some positions and double values to use to create reference lists for position lists and double lists later  				for (int i = 1; i <= 2; ++i) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("ConstantPosition{0}"' i);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantPosition{0}')).toBeDefined();"' i);  						var property = schemaProperties.First (p => p.Name == "position");  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var properties = property.ValueType.Properties;  							var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  							WriteValue (writer' "w"' id' firstValueProperty' property' false' property.Name);  						}  					}  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("ConstantDouble{0}"' i);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantDouble{0}')).toBeDefined();"' i);  						var property = schemaProperties.First (p => p.Name == "billboard");  						var properties = property.ValueType.Properties;  						var subProperty = properties.First (p => p.Name == "scale");  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							properties = subProperty.ValueType.Properties;  							var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  							WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' false' string.Format ("{0}.{1}"' property.Name' subProperty.Name));  						}  					}  				}  				// write one big packet with references for everything  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					writer.WriteLine ("packet.WriteId(\"Reference\");");  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Reference')).toBeDefined();");  					foreach (var property in schemaProperties) {  						string propertyName = property.Name;  						bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  						if (isExtension)  							propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var properties = property.ValueType.Properties;  							if (properties.Any (p => p.ValueType.Name == "Reference")) {  								writer.WriteLine ("w.WriteReference(new Reference(\"Constant\"' \"{0}\"));"' propertyName);  								WriteAssertion (writer' isExtension' "expect(e.{0}.getValue(date)).toEqual(constant.{0}.getValue(date));"' propertyName);  							} else {  								foreach (var subProperty in properties.Where (p => !p.IsValue)) {  									properties = subProperty.ValueType.Properties;  									string subPropertyName = GetSubPropertyName (propertyName' subProperty);  									if (properties.Any (p => p.ValueType.Name == "Reference")) {  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("w2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\")));"' propertyName' subPropertyName);  											WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual(constant.{0}.{1}.getValue(date));"' propertyName' subPropertyName);  										}  									} else if (properties.Any (p => p.ValueType.Name == "ReferenceList")) {  										string targetId = "";  										string[] referencePropertyNames =  {    										};  										if (subProperty.ValueType.Name == "PositionList") {  											targetId = "Position";  											referencePropertyNames = new[] {  												"position"  											};  										} else if (subProperty.ValueType.Name == "DoubleList") {  											targetId = "Double";  											referencePropertyNames = new[] {  												"billboard"'  												"scale"  											};  										}  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("w2.WriteReferences(CreateList(new Reference(\"Constant{0}1\"' CreateList({1}))' new Reference(\"Constant{0}2\"' CreateList({1}))));"' targetId' string.Join ("' "' referencePropertyNames.Select (n => string.Format ("\"{0}\""' n))));  											WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual([dataSource.entities.getById('Constant{2}1').{3}.getValue(date)' dataSource.entities.getById('Constant{2}2').{3}.getValue(date)]);"' propertyName' subPropertyName' targetId' string.Join ("."' referencePropertyNames));  										}  									} else if (subProperty.ValueType.Name.Contains ("Material")) {  										Property materialProperty = properties.First ();  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													writer.WriteLine ("m2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"{2}\")));"' propertyName' subPropertyName' materialSubProperty.Name);  													WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.{2}.getValue(date)).toEqual(constant.{0}.{1}.{2}.getValue(date));"' propertyName' subPropertyName' materialSubProperty.Name);  												}  											}  										}  									} else {  										var additionalProperties = subProperty.ValueType.AdditionalProperties;  										if (additionalProperties != null) {  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var a = w2.Open{0}Property(\"referenceProp\"))"' additionalProperties.ValueType.NameWithPascalCase);  											using (writer.OpenScope ()) {  												foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  													writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														writer.WriteLine ("w3.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"prop\"' \"{2}\")));"' propertyName' subPropertyName' additionalProperty.Name);  														WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.referenceProp.{2}.getValue(date)).toEqual(constant.{0}.{1}.prop.{2}.getValue(date));"' propertyName' subPropertyName' additionalProperty.Name);  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  				writer.WriteLine ("WriteReferenceValuesIndividual();");  			}  			writer.WriteLine ("private void WriteReferenceValuesIndividual()");  			using (writer.OpenScope ()) {  				// write other materials as individual packets  				foreach (var property in schemaProperties) {  					writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  				}  				// special case - velocity reference  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  					var property = schemaProperties.First (p => p.Name == "position");  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						// construct a position with specific velocity  						double dx = 1.0;  						double dy = 2.0;  						double dz = 3.0;  						double deltaTime = 60.0;  						double x1 = 1.0;  						double x2 = x1 + dx * deltaTime;  						double y1 = 2.0;  						double y2 = y1 + dy * deltaTime;  						double z1 = 3.0;  						double z2 = z1 + dz * deltaTime;  						string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  						string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  						string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  						string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  						writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  						WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  						WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  					}  				}  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						properties = subProperty.ValueType.Properties;  						if (properties.Any (p => p.Name == "velocityReference")) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  									double expectedX = 1.0;  									double expectedY = 2.0;  									double expectedZ = 3.0;  									bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  									if (isNormalized) {  										NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  									}  									WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  								}  							}  						}  					}  				}  			}  			// write other materials as individual packets  			foreach (var property in schemaProperties) {  				writer.WriteLine ("private void WriteReferenceValuesIndividual{0}()"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						string subPropertyName = GetSubPropertyName (propertyName' subProperty);  						if (subProperty.ValueType.Name.Contains ("Material")) {  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string targetId = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  									string id = string.Format ("reference_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												writer.WriteLine ("m2.WriteReference(new Reference(\"{0}\"' CreateList(\"{1}\"' \"{2}\"' \"{3}\")));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  												WriteAssertion (writer' isExtension' "expect(e.{1}.{2}.{3}.getValue(date)).toEqual(dataSource.entities.getById('{0}').{1}.{2}.{3}.getValue(date));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  											}  										}  									}  								}  							}  						}  					}  				}  			}  			// test sampled properties  			writer.WriteLine ("private void WriteSampledValues()");  			using (writer.OpenScope ()) {  				// Write one packet with first value types for each property  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					const string id = "Sampled";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Sampled')).toBeDefined();");  					foreach (var property in schemaProperties) {  						string propertyName = property.Name;  						bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  						if (isExtension)  							propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  						var properties = property.ValueType.Properties;  						if (property.IsInterpolatable) {  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  								WriteValues (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  							}  						} else {  							var subProperties = properties.Where (p => !p.IsValue && (p.IsInterpolatable || p.ValueType.Name.Contains ("Material"))).ToList ();  							if (subProperties.Any ()) {  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								using (writer.OpenScope ()) {  									foreach (var subProperty in subProperties) {  										properties = subProperty.ValueType.Properties;  										string subPropertyName = GetSubPropertyName (propertyName' subProperty);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											if (subProperty.IsInterpolatable) {  												var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  												WriteValues (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  											} else if (subProperty.ValueType.Name.Contains ("Material")) {  												Property materialProperty = properties.First ();  												writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialProperty.ValueType.Properties;  													foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  														writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  														using (writer.OpenScope ()) {  															properties = materialSubProperty.ValueType.Properties;  															var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  															WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  														}  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  				writer.WriteLine ("WriteSampledValuesIndividual();");  				writer.WriteLine ("WriteSampledValuesCustomProperties();");  			}  			writer.WriteLine ("private void WriteSampledValuesIndividual()");  			using (writer.OpenScope ()) {  				// write other value types as individual packets  				// split method into multiple methods  				foreach (var property in schemaProperties) {  					writer.WriteLine ("WriteSampledValuesIndividual{0}();"' property.NameWithPascalCase);  				}  			}  			foreach (var property in schemaProperties) {  				writer.WriteLine ("private void WriteSampledValuesIndividual{0}()"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					if (property.IsInterpolatable) {  						foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("sampled_{0}_{1}"' propertyName' valueProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValues (writer' "w"' id' valueProperty' property' isExtension' propertyName);  								}  							}  						}  					} else {  						foreach (var subProperty in properties.Where (p => !p.IsValue)) {  							string subPropertyName = GetSubPropertyName (propertyName' subProperty);  							properties = subProperty.ValueType.Properties;  							if (subProperty.IsInterpolatable) {  								foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' valueProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValues (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  										}  									}  								}  							} else if (subProperty.ValueType.Name.Contains ("Material")) {  								// write other values for the first material  								// then write first values for other materials   								// then write remaining values for other materials individually  								var firstMaterialProperty = properties.First ();  								properties = firstMaterialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  									properties = materialSubProperty.ValueType.Properties;  									foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  										writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  										using (writer.OpenScope ()) {  											string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  											writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  											WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  											writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												WriteValues (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  								properties = subProperty.ValueType.Properties;  								foreach (var materialProperty in properties.Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialSubProperty.ValueType.Properties;  													var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  													WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  								properties = subProperty.ValueType.Properties;  								foreach (var materialProperty in properties.Skip (1)) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  										properties = materialSubProperty.ValueType.Properties;  										foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  											writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  											using (writer.OpenScope ()) {  												string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  												writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  												WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  												writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  												writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  												writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			// create all types of custom properties  			writer.WriteLine ("private void WriteSampledValuesCustomProperties()");  			using (writer.OpenScope ()) {  				var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  				if (propertiesProperty != null) {  					var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  					if (additionalProperties != null) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = "sampled_custom";  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array)) {  									string propName = string.Format ("custom_{0}"' valueProperty.Name);  									writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  									using (writer.OpenScope ()) {  										WriteValues (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  									}  								}  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (CodeWriter writer = new CodeWriter (Path.Combine (m_outputDirectory' "TestGenerateValidationDocument.cs"))) {  	writer.WriteLine ("// This file was generated automatically by GenerateFromSchema.  Do NOT edit it.");  	writer.WriteLine ("// https://github.com/AnalyticalGraphicsInc/czml-writer");  	writer.WriteLine ();  	writer.WriteLine ("using System.Collections.Generic;");  	writer.WriteLine ("using System.Diagnostics.CodeAnalysis;");  	writer.WriteLine ("using System.Drawing;");  	writer.WriteLine ("using System.IO;");  	writer.WriteLine ("using CesiumLanguageWriter;");  	writer.WriteLine ("using NUnit.Framework;");  	writer.WriteLine ();  	writer.WriteLine ("namespace {0}"' "CesiumLanguageWriterTests");  	using (writer.OpenScope ()) {  		writer.WriteLine ("[TestFixture]");  		writer.WriteLine ("[SuppressMessage(\"ReSharper\"' \"MemberCanBeMadeStatic.Local\")]");  		writer.WriteLine ("public class TestGenerateValidationDocument");  		using (writer.OpenScope ()) {  			writer.WriteLine ("private readonly JulianDate m_documentStartDate = new GregorianDate(2016' 6' 17' 12' 0' 0).ToJulianDate();");  			writer.WriteLine ("private readonly JulianDate m_documentStopDate = new GregorianDate(2016' 6' 17' 13' 0' 0).ToJulianDate();");  			writer.WriteLine ("private TextWriter m_streamWriter;");  			writer.WriteLine ("private TextWriter m_assertionsWriter;");  			writer.WriteLine ("private TextWriter m_extensionsAssertionsWriter;");  			writer.WriteLine ("private CesiumOutputStream m_output;");  			writer.WriteLine ("private CesiumStreamWriter m_writer;");  			writer.WriteLine ("private void WriteAssertionBoth(string s)");  			using (writer.OpenScope ()) {  				writer.WriteLine ("m_assertionsWriter.WriteLine(s);");  				writer.WriteLine ("m_extensionsAssertionsWriter.WriteLine(s);");  			}  			writer.WriteLine ("private static IList<T> CreateList<T>(T t1' T t2)");  			using (writer.OpenScope ()) {  				writer.WriteLine ("return new List<T> { t1' t2 };");  			}  			writer.WriteLine ("private static IList<T> CreateList<T>(params T[] ts)");  			using (writer.OpenScope ()) {  				writer.WriteLine ("return ts;");  			}  			writer.WriteLine ("[Test]");  			writer.WriteLine ("public void GenerateValidationDocument()");  			var schemaProperties = schema.Properties.Where (p => p.Name != "clock" && p.Name != "availability" && !p.ValueType.IsSchemaFromType).Where (p => p.Name != "properties").ToList ();  			using (writer.OpenScope ()) {  				writer.WriteLine ("using (m_streamWriter = new StreamWriter(\"ValidationDocument.czml\"))");  				writer.WriteLine ("using (m_assertionsWriter = new StreamWriter(\"ValidationDocumentAssertions.js\"))");  				writer.WriteLine ("using (m_extensionsAssertionsWriter = new StreamWriter(\"ValidationDocumentExtensionAssertions.js\"))");  				using (writer.OpenScope ()) {  					WriteAssertionBoth (writer' "return CzmlDataSource.load('Data/CZML/ValidationDocument.czml').then(function(dataSource) {");  					s_assertionIndent++;  					WriteAssertionBoth (writer' "/*jshint -W120 */");  					WriteAssertionBoth (writer' "var e;");  					WriteAssertionBoth (writer' "var date;");  					WriteAssertionBoth (writer' "var documentStartDate = JulianDate.fromIso8601('2016-06-17T12:00:00Z');");  					WriteAssertionBoth (writer' "var documentStopDate = JulianDate.fromIso8601('2016-06-17T13:00:00Z');");  					writer.WriteLine ("m_output = new CesiumOutputStream(m_streamWriter) { PrettyFormatting = true };");  					writer.WriteLine ("m_writer = new CesiumStreamWriter();");  					writer.WriteLine ("m_output.WriteStartSequence();");  					// Java has a limit on the size of a single method (65535 bytes) so we have to break up all this code in multiple methods  					writer.WriteLine ("WriteClock();");  					writer.WriteLine ("WriteConstantValues();");  					writer.WriteLine ("WriteReferenceValues();");  					writer.WriteLine ("WriteSampledValues();");  					writer.WriteLine ("m_output.WriteEndSequence();");  					s_assertionIndent--;  					WriteAssertionBoth (writer' "});");  					s_assertionIndent++;  				}  			}  			writer.WriteLine ("private void WriteClock()");  			using (writer.OpenScope ()) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					writer.WriteLine ("packet.WriteId(\"document\");");  					writer.WriteLine ("packet.WriteName(\"ValidationDocument\");");  					writer.WriteLine ("packet.WriteVersion(\"1.0\");");  					writer.WriteLine ("using (var clock = packet.OpenClockProperty())");  					using (writer.OpenScope ()) {  						writer.WriteLine ("clock.WriteInterval(m_documentStartDate' m_documentStopDate);");  						WriteAssertion (writer' false' "expect(dataSource.clock.startTime).toEqual(documentStartDate);");  						WriteAssertion (writer' false' "expect(dataSource.clock.stopTime).toEqual(documentStopDate);");  						writer.WriteLine ("clock.WriteCurrentTime(m_documentStartDate);");  						WriteAssertion (writer' false' "expect(dataSource.clock.currentTime).toEqual(documentStartDate);");  						writer.WriteLine ("clock.WriteMultiplier(1.0);");  						WriteAssertion (writer' false' "expect(dataSource.clock.multiplier).toEqual(1.0);");  						writer.WriteLine ("clock.WriteRange(ClockRange.Unbounded);");  						WriteAssertion (writer' false' "expect(dataSource.clock.clockRange).toEqual(ClockRange.UNBOUNDED);");  						writer.WriteLine ("clock.WriteStep(ClockStep.SystemClockMultiplier);");  						WriteAssertion (writer' false' "expect(dataSource.clock.clockStep).toEqual(ClockStep.SYSTEM_CLOCK_MULTIPLIER);");  					}  				}  			}  			writer.WriteLine ("private void WriteConstantValues()");  			using (writer.OpenScope ()) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					const string id = "Constant";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "var constant = e = dataSource.entities.getById('Constant');");  					WriteAssertionBoth (writer' "expect(e).toBeDefined();");  					WriteAssertionBoth (writer' "date = JulianDate.now();");  					// Write one packet with first value types for each property  					foreach (var property in schemaProperties) {  						string propertyName = property.Name;  						bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  						if (isExtension)  							propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var properties = property.ValueType.Properties;  							var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  							if (firstValueProperty != null) {  								WriteValue (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  							} else {  								foreach (var subProperty in properties.Where (p => !p.IsValue)) {  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = subProperty.ValueType.Properties;  										firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  										string subPropertyName = GetSubPropertyName (propertyName' subProperty);  										if (firstValueProperty != null) {  											WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  										} else if (subProperty.ValueType.Name.Contains ("Material")) {  											Property materialProperty = properties.First ();  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialProperty.ValueType.Properties;  												foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  													writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														properties = materialSubProperty.ValueType.Properties;  														firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  														if (firstValueProperty != null) {  															WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  														}  													}  												}  											}  										} else {  											var additionalProperties = subProperty.ValueType.AdditionalProperties;  											if (additionalProperties != null) {  												writer.WriteLine ("using (var a = w2.Open{0}Property(\"prop\"))"' additionalProperties.ValueType.NameWithPascalCase);  												using (writer.OpenScope ()) {  													foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  														writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  														using (writer.OpenScope ()) {  															properties = additionalProperty.ValueType.Properties;  															firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  															if (firstValueProperty != null) {  																WriteValue (writer' "w3"' id + property.Name' firstValueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' "prop"' additionalProperty.Name));  															}  														}  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  				writer.WriteLine ("WriteConstantValuesIndividual();");  				writer.WriteLine ("WriteConstantValuesCustomProperties();");  			}  			writer.WriteLine ("private void WriteConstantValuesIndividual()");  			using (writer.OpenScope ()) {  				// write other value types as individual packets  				foreach (var property in schemaProperties) {  					writer.WriteLine ("WriteConstantValuesIndividual{0}();"' property.NameWithPascalCase);  				}  			}  			foreach (var property in schemaProperties) {  				writer.WriteLine ("private void WriteConstantValuesIndividual{0}()"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("constant_{0}_{1}"' property.Name' valueProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								WriteValue (writer' "w"' id' valueProperty' property' isExtension' propertyName);  							}  						}  					}  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						string subPropertyName = GetSubPropertyName (propertyName' subProperty);  						properties = subProperty.ValueType.Properties;  						foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("constant_{0}_{1}_{2}"' property.Name' subPropertyName' valueProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValue (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  								}  							}  						}  						if (subProperty.ValueType.Name.Contains ("Material")) {  							// write other values for the first material  							// then write first values for other materials   							// then write remaining values for other materials individually  							var firstMaterialProperty = properties.First ();  							properties = firstMaterialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValue (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialSubProperty.ValueType.Properties;  												var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  												if (firstValueProperty != null) {  													WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  									properties = materialSubProperty.ValueType.Properties;  									foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  										writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  										using (writer.OpenScope ()) {  											string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  											writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  											WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  											writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  						}  						var additionalProperties = subProperty.ValueType.AdditionalProperties;  						if (additionalProperties != null) {  							foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  								int i = 0;  								properties = additionalProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' additionalProperties.ValueType.Name' additionalProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										string propName = string.Format ("{0}{1}"' "prop"' i++);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var a = w2.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  										writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValue (writer' "w3"' id + property.Name + subProperty.Name' valueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' propName' additionalProperty.Name));  										}  									}  								}  							}  						}  					}  				}  			}  			// create all types of custom properties  			writer.WriteLine ("private void WriteConstantValuesCustomProperties()");  			using (writer.OpenScope ()) {  				var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  				if (propertiesProperty != null) {  					var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  					if (additionalProperties != null) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = "constant_custom";  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue)) {  									string propName = string.Format ("custom_{0}"' valueProperty.Name);  									writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  									using (writer.OpenScope ()) {  										WriteValue (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  									}  								}  							}  						}  					}  				}  			}  			// create entities using references  			writer.WriteLine ("private void WriteReferenceValues()");  			using (writer.OpenScope ()) {  				// write some positions and double values to use to create reference lists for position lists and double lists later  				for (int i = 1; i <= 2; ++i) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("ConstantPosition{0}"' i);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantPosition{0}')).toBeDefined();"' i);  						var property = schemaProperties.First (p => p.Name == "position");  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var properties = property.ValueType.Properties;  							var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  							WriteValue (writer' "w"' id' firstValueProperty' property' false' property.Name);  						}  					}  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("ConstantDouble{0}"' i);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantDouble{0}')).toBeDefined();"' i);  						var property = schemaProperties.First (p => p.Name == "billboard");  						var properties = property.ValueType.Properties;  						var subProperty = properties.First (p => p.Name == "scale");  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							properties = subProperty.ValueType.Properties;  							var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  							WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' false' string.Format ("{0}.{1}"' property.Name' subProperty.Name));  						}  					}  				}  				// write one big packet with references for everything  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					writer.WriteLine ("packet.WriteId(\"Reference\");");  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Reference')).toBeDefined();");  					foreach (var property in schemaProperties) {  						string propertyName = property.Name;  						bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  						if (isExtension)  							propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var properties = property.ValueType.Properties;  							if (properties.Any (p => p.ValueType.Name == "Reference")) {  								writer.WriteLine ("w.WriteReference(new Reference(\"Constant\"' \"{0}\"));"' propertyName);  								WriteAssertion (writer' isExtension' "expect(e.{0}.getValue(date)).toEqual(constant.{0}.getValue(date));"' propertyName);  							} else {  								foreach (var subProperty in properties.Where (p => !p.IsValue)) {  									properties = subProperty.ValueType.Properties;  									string subPropertyName = GetSubPropertyName (propertyName' subProperty);  									if (properties.Any (p => p.ValueType.Name == "Reference")) {  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("w2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\")));"' propertyName' subPropertyName);  											WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual(constant.{0}.{1}.getValue(date));"' propertyName' subPropertyName);  										}  									} else if (properties.Any (p => p.ValueType.Name == "ReferenceList")) {  										string targetId = "";  										string[] referencePropertyNames =  {    										};  										if (subProperty.ValueType.Name == "PositionList") {  											targetId = "Position";  											referencePropertyNames = new[] {  												"position"  											};  										} else if (subProperty.ValueType.Name == "DoubleList") {  											targetId = "Double";  											referencePropertyNames = new[] {  												"billboard"'  												"scale"  											};  										}  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("w2.WriteReferences(CreateList(new Reference(\"Constant{0}1\"' CreateList({1}))' new Reference(\"Constant{0}2\"' CreateList({1}))));"' targetId' string.Join ("' "' referencePropertyNames.Select (n => string.Format ("\"{0}\""' n))));  											WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual([dataSource.entities.getById('Constant{2}1').{3}.getValue(date)' dataSource.entities.getById('Constant{2}2').{3}.getValue(date)]);"' propertyName' subPropertyName' targetId' string.Join ("."' referencePropertyNames));  										}  									} else if (subProperty.ValueType.Name.Contains ("Material")) {  										Property materialProperty = properties.First ();  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													writer.WriteLine ("m2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"{2}\")));"' propertyName' subPropertyName' materialSubProperty.Name);  													WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.{2}.getValue(date)).toEqual(constant.{0}.{1}.{2}.getValue(date));"' propertyName' subPropertyName' materialSubProperty.Name);  												}  											}  										}  									} else {  										var additionalProperties = subProperty.ValueType.AdditionalProperties;  										if (additionalProperties != null) {  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var a = w2.Open{0}Property(\"referenceProp\"))"' additionalProperties.ValueType.NameWithPascalCase);  											using (writer.OpenScope ()) {  												foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  													writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														writer.WriteLine ("w3.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"prop\"' \"{2}\")));"' propertyName' subPropertyName' additionalProperty.Name);  														WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.referenceProp.{2}.getValue(date)).toEqual(constant.{0}.{1}.prop.{2}.getValue(date));"' propertyName' subPropertyName' additionalProperty.Name);  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  				writer.WriteLine ("WriteReferenceValuesIndividual();");  			}  			writer.WriteLine ("private void WriteReferenceValuesIndividual()");  			using (writer.OpenScope ()) {  				// write other materials as individual packets  				foreach (var property in schemaProperties) {  					writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  				}  				// special case - velocity reference  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  					var property = schemaProperties.First (p => p.Name == "position");  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						// construct a position with specific velocity  						double dx = 1.0;  						double dy = 2.0;  						double dz = 3.0;  						double deltaTime = 60.0;  						double x1 = 1.0;  						double x2 = x1 + dx * deltaTime;  						double y1 = 2.0;  						double y2 = y1 + dy * deltaTime;  						double z1 = 3.0;  						double z2 = z1 + dz * deltaTime;  						string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  						string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  						string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  						string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  						writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  						WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  						WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  					}  				}  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						properties = subProperty.ValueType.Properties;  						if (properties.Any (p => p.Name == "velocityReference")) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  									double expectedX = 1.0;  									double expectedY = 2.0;  									double expectedZ = 3.0;  									bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  									if (isNormalized) {  										NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  									}  									WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  								}  							}  						}  					}  				}  			}  			// write other materials as individual packets  			foreach (var property in schemaProperties) {  				writer.WriteLine ("private void WriteReferenceValuesIndividual{0}()"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						string subPropertyName = GetSubPropertyName (propertyName' subProperty);  						if (subProperty.ValueType.Name.Contains ("Material")) {  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string targetId = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  									string id = string.Format ("reference_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												writer.WriteLine ("m2.WriteReference(new Reference(\"{0}\"' CreateList(\"{1}\"' \"{2}\"' \"{3}\")));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  												WriteAssertion (writer' isExtension' "expect(e.{1}.{2}.{3}.getValue(date)).toEqual(dataSource.entities.getById('{0}').{1}.{2}.{3}.getValue(date));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  											}  										}  									}  								}  							}  						}  					}  				}  			}  			// test sampled properties  			writer.WriteLine ("private void WriteSampledValues()");  			using (writer.OpenScope ()) {  				// Write one packet with first value types for each property  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					const string id = "Sampled";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Sampled')).toBeDefined();");  					foreach (var property in schemaProperties) {  						string propertyName = property.Name;  						bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  						if (isExtension)  							propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  						var properties = property.ValueType.Properties;  						if (property.IsInterpolatable) {  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  								WriteValues (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  							}  						} else {  							var subProperties = properties.Where (p => !p.IsValue && (p.IsInterpolatable || p.ValueType.Name.Contains ("Material"))).ToList ();  							if (subProperties.Any ()) {  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								using (writer.OpenScope ()) {  									foreach (var subProperty in subProperties) {  										properties = subProperty.ValueType.Properties;  										string subPropertyName = GetSubPropertyName (propertyName' subProperty);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											if (subProperty.IsInterpolatable) {  												var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  												WriteValues (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  											} else if (subProperty.ValueType.Name.Contains ("Material")) {  												Property materialProperty = properties.First ();  												writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialProperty.ValueType.Properties;  													foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  														writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  														using (writer.OpenScope ()) {  															properties = materialSubProperty.ValueType.Properties;  															var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  															WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  														}  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  				writer.WriteLine ("WriteSampledValuesIndividual();");  				writer.WriteLine ("WriteSampledValuesCustomProperties();");  			}  			writer.WriteLine ("private void WriteSampledValuesIndividual()");  			using (writer.OpenScope ()) {  				// write other value types as individual packets  				// split method into multiple methods  				foreach (var property in schemaProperties) {  					writer.WriteLine ("WriteSampledValuesIndividual{0}();"' property.NameWithPascalCase);  				}  			}  			foreach (var property in schemaProperties) {  				writer.WriteLine ("private void WriteSampledValuesIndividual{0}()"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					if (property.IsInterpolatable) {  						foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("sampled_{0}_{1}"' propertyName' valueProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValues (writer' "w"' id' valueProperty' property' isExtension' propertyName);  								}  							}  						}  					} else {  						foreach (var subProperty in properties.Where (p => !p.IsValue)) {  							string subPropertyName = GetSubPropertyName (propertyName' subProperty);  							properties = subProperty.ValueType.Properties;  							if (subProperty.IsInterpolatable) {  								foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' valueProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValues (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  										}  									}  								}  							} else if (subProperty.ValueType.Name.Contains ("Material")) {  								// write other values for the first material  								// then write first values for other materials   								// then write remaining values for other materials individually  								var firstMaterialProperty = properties.First ();  								properties = firstMaterialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  									properties = materialSubProperty.ValueType.Properties;  									foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  										writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  										using (writer.OpenScope ()) {  											string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  											writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  											WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  											writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												WriteValues (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  								properties = subProperty.ValueType.Properties;  								foreach (var materialProperty in properties.Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialSubProperty.ValueType.Properties;  													var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  													WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  								properties = subProperty.ValueType.Properties;  								foreach (var materialProperty in properties.Skip (1)) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  										properties = materialSubProperty.ValueType.Properties;  										foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  											writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  											using (writer.OpenScope ()) {  												string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  												writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  												WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  												writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  												writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  												writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			// create all types of custom properties  			writer.WriteLine ("private void WriteSampledValuesCustomProperties()");  			using (writer.OpenScope ()) {  				var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  				if (propertiesProperty != null) {  					var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  					if (additionalProperties != null) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = "sampled_custom";  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array)) {  									string propName = string.Format ("custom_{0}"' valueProperty.Name);  									writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  									using (writer.OpenScope ()) {  										WriteValues (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  									}  								}  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (CodeWriter writer = new CodeWriter (Path.Combine (m_outputDirectory' "TestGenerateValidationDocument.cs"))) {  	writer.WriteLine ("// This file was generated automatically by GenerateFromSchema.  Do NOT edit it.");  	writer.WriteLine ("// https://github.com/AnalyticalGraphicsInc/czml-writer");  	writer.WriteLine ();  	writer.WriteLine ("using System.Collections.Generic;");  	writer.WriteLine ("using System.Diagnostics.CodeAnalysis;");  	writer.WriteLine ("using System.Drawing;");  	writer.WriteLine ("using System.IO;");  	writer.WriteLine ("using CesiumLanguageWriter;");  	writer.WriteLine ("using NUnit.Framework;");  	writer.WriteLine ();  	writer.WriteLine ("namespace {0}"' "CesiumLanguageWriterTests");  	using (writer.OpenScope ()) {  		writer.WriteLine ("[TestFixture]");  		writer.WriteLine ("[SuppressMessage(\"ReSharper\"' \"MemberCanBeMadeStatic.Local\")]");  		writer.WriteLine ("public class TestGenerateValidationDocument");  		using (writer.OpenScope ()) {  			writer.WriteLine ("private readonly JulianDate m_documentStartDate = new GregorianDate(2016' 6' 17' 12' 0' 0).ToJulianDate();");  			writer.WriteLine ("private readonly JulianDate m_documentStopDate = new GregorianDate(2016' 6' 17' 13' 0' 0).ToJulianDate();");  			writer.WriteLine ("private TextWriter m_streamWriter;");  			writer.WriteLine ("private TextWriter m_assertionsWriter;");  			writer.WriteLine ("private TextWriter m_extensionsAssertionsWriter;");  			writer.WriteLine ("private CesiumOutputStream m_output;");  			writer.WriteLine ("private CesiumStreamWriter m_writer;");  			writer.WriteLine ("private void WriteAssertionBoth(string s)");  			using (writer.OpenScope ()) {  				writer.WriteLine ("m_assertionsWriter.WriteLine(s);");  				writer.WriteLine ("m_extensionsAssertionsWriter.WriteLine(s);");  			}  			writer.WriteLine ("private static IList<T> CreateList<T>(T t1' T t2)");  			using (writer.OpenScope ()) {  				writer.WriteLine ("return new List<T> { t1' t2 };");  			}  			writer.WriteLine ("private static IList<T> CreateList<T>(params T[] ts)");  			using (writer.OpenScope ()) {  				writer.WriteLine ("return ts;");  			}  			writer.WriteLine ("[Test]");  			writer.WriteLine ("public void GenerateValidationDocument()");  			var schemaProperties = schema.Properties.Where (p => p.Name != "clock" && p.Name != "availability" && !p.ValueType.IsSchemaFromType).Where (p => p.Name != "properties").ToList ();  			using (writer.OpenScope ()) {  				writer.WriteLine ("using (m_streamWriter = new StreamWriter(\"ValidationDocument.czml\"))");  				writer.WriteLine ("using (m_assertionsWriter = new StreamWriter(\"ValidationDocumentAssertions.js\"))");  				writer.WriteLine ("using (m_extensionsAssertionsWriter = new StreamWriter(\"ValidationDocumentExtensionAssertions.js\"))");  				using (writer.OpenScope ()) {  					WriteAssertionBoth (writer' "return CzmlDataSource.load('Data/CZML/ValidationDocument.czml').then(function(dataSource) {");  					s_assertionIndent++;  					WriteAssertionBoth (writer' "/*jshint -W120 */");  					WriteAssertionBoth (writer' "var e;");  					WriteAssertionBoth (writer' "var date;");  					WriteAssertionBoth (writer' "var documentStartDate = JulianDate.fromIso8601('2016-06-17T12:00:00Z');");  					WriteAssertionBoth (writer' "var documentStopDate = JulianDate.fromIso8601('2016-06-17T13:00:00Z');");  					writer.WriteLine ("m_output = new CesiumOutputStream(m_streamWriter) { PrettyFormatting = true };");  					writer.WriteLine ("m_writer = new CesiumStreamWriter();");  					writer.WriteLine ("m_output.WriteStartSequence();");  					// Java has a limit on the size of a single method (65535 bytes) so we have to break up all this code in multiple methods  					writer.WriteLine ("WriteClock();");  					writer.WriteLine ("WriteConstantValues();");  					writer.WriteLine ("WriteReferenceValues();");  					writer.WriteLine ("WriteSampledValues();");  					writer.WriteLine ("m_output.WriteEndSequence();");  					s_assertionIndent--;  					WriteAssertionBoth (writer' "});");  					s_assertionIndent++;  				}  			}  			writer.WriteLine ("private void WriteClock()");  			using (writer.OpenScope ()) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					writer.WriteLine ("packet.WriteId(\"document\");");  					writer.WriteLine ("packet.WriteName(\"ValidationDocument\");");  					writer.WriteLine ("packet.WriteVersion(\"1.0\");");  					writer.WriteLine ("using (var clock = packet.OpenClockProperty())");  					using (writer.OpenScope ()) {  						writer.WriteLine ("clock.WriteInterval(m_documentStartDate' m_documentStopDate);");  						WriteAssertion (writer' false' "expect(dataSource.clock.startTime).toEqual(documentStartDate);");  						WriteAssertion (writer' false' "expect(dataSource.clock.stopTime).toEqual(documentStopDate);");  						writer.WriteLine ("clock.WriteCurrentTime(m_documentStartDate);");  						WriteAssertion (writer' false' "expect(dataSource.clock.currentTime).toEqual(documentStartDate);");  						writer.WriteLine ("clock.WriteMultiplier(1.0);");  						WriteAssertion (writer' false' "expect(dataSource.clock.multiplier).toEqual(1.0);");  						writer.WriteLine ("clock.WriteRange(ClockRange.Unbounded);");  						WriteAssertion (writer' false' "expect(dataSource.clock.clockRange).toEqual(ClockRange.UNBOUNDED);");  						writer.WriteLine ("clock.WriteStep(ClockStep.SystemClockMultiplier);");  						WriteAssertion (writer' false' "expect(dataSource.clock.clockStep).toEqual(ClockStep.SYSTEM_CLOCK_MULTIPLIER);");  					}  				}  			}  			writer.WriteLine ("private void WriteConstantValues()");  			using (writer.OpenScope ()) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					const string id = "Constant";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "var constant = e = dataSource.entities.getById('Constant');");  					WriteAssertionBoth (writer' "expect(e).toBeDefined();");  					WriteAssertionBoth (writer' "date = JulianDate.now();");  					// Write one packet with first value types for each property  					foreach (var property in schemaProperties) {  						string propertyName = property.Name;  						bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  						if (isExtension)  							propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var properties = property.ValueType.Properties;  							var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  							if (firstValueProperty != null) {  								WriteValue (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  							} else {  								foreach (var subProperty in properties.Where (p => !p.IsValue)) {  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = subProperty.ValueType.Properties;  										firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  										string subPropertyName = GetSubPropertyName (propertyName' subProperty);  										if (firstValueProperty != null) {  											WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  										} else if (subProperty.ValueType.Name.Contains ("Material")) {  											Property materialProperty = properties.First ();  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialProperty.ValueType.Properties;  												foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  													writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														properties = materialSubProperty.ValueType.Properties;  														firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  														if (firstValueProperty != null) {  															WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  														}  													}  												}  											}  										} else {  											var additionalProperties = subProperty.ValueType.AdditionalProperties;  											if (additionalProperties != null) {  												writer.WriteLine ("using (var a = w2.Open{0}Property(\"prop\"))"' additionalProperties.ValueType.NameWithPascalCase);  												using (writer.OpenScope ()) {  													foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  														writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  														using (writer.OpenScope ()) {  															properties = additionalProperty.ValueType.Properties;  															firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  															if (firstValueProperty != null) {  																WriteValue (writer' "w3"' id + property.Name' firstValueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' "prop"' additionalProperty.Name));  															}  														}  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  				writer.WriteLine ("WriteConstantValuesIndividual();");  				writer.WriteLine ("WriteConstantValuesCustomProperties();");  			}  			writer.WriteLine ("private void WriteConstantValuesIndividual()");  			using (writer.OpenScope ()) {  				// write other value types as individual packets  				foreach (var property in schemaProperties) {  					writer.WriteLine ("WriteConstantValuesIndividual{0}();"' property.NameWithPascalCase);  				}  			}  			foreach (var property in schemaProperties) {  				writer.WriteLine ("private void WriteConstantValuesIndividual{0}()"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("constant_{0}_{1}"' property.Name' valueProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								WriteValue (writer' "w"' id' valueProperty' property' isExtension' propertyName);  							}  						}  					}  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						string subPropertyName = GetSubPropertyName (propertyName' subProperty);  						properties = subProperty.ValueType.Properties;  						foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("constant_{0}_{1}_{2}"' property.Name' subPropertyName' valueProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValue (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  								}  							}  						}  						if (subProperty.ValueType.Name.Contains ("Material")) {  							// write other values for the first material  							// then write first values for other materials   							// then write remaining values for other materials individually  							var firstMaterialProperty = properties.First ();  							properties = firstMaterialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValue (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialSubProperty.ValueType.Properties;  												var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  												if (firstValueProperty != null) {  													WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  									properties = materialSubProperty.ValueType.Properties;  									foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  										writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  										using (writer.OpenScope ()) {  											string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  											writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  											WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  											writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  						}  						var additionalProperties = subProperty.ValueType.AdditionalProperties;  						if (additionalProperties != null) {  							foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  								int i = 0;  								properties = additionalProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' additionalProperties.ValueType.Name' additionalProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										string propName = string.Format ("{0}{1}"' "prop"' i++);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var a = w2.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  										writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValue (writer' "w3"' id + property.Name + subProperty.Name' valueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' propName' additionalProperty.Name));  										}  									}  								}  							}  						}  					}  				}  			}  			// create all types of custom properties  			writer.WriteLine ("private void WriteConstantValuesCustomProperties()");  			using (writer.OpenScope ()) {  				var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  				if (propertiesProperty != null) {  					var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  					if (additionalProperties != null) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = "constant_custom";  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue)) {  									string propName = string.Format ("custom_{0}"' valueProperty.Name);  									writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  									using (writer.OpenScope ()) {  										WriteValue (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  									}  								}  							}  						}  					}  				}  			}  			// create entities using references  			writer.WriteLine ("private void WriteReferenceValues()");  			using (writer.OpenScope ()) {  				// write some positions and double values to use to create reference lists for position lists and double lists later  				for (int i = 1; i <= 2; ++i) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("ConstantPosition{0}"' i);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantPosition{0}')).toBeDefined();"' i);  						var property = schemaProperties.First (p => p.Name == "position");  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var properties = property.ValueType.Properties;  							var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  							WriteValue (writer' "w"' id' firstValueProperty' property' false' property.Name);  						}  					}  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("ConstantDouble{0}"' i);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantDouble{0}')).toBeDefined();"' i);  						var property = schemaProperties.First (p => p.Name == "billboard");  						var properties = property.ValueType.Properties;  						var subProperty = properties.First (p => p.Name == "scale");  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							properties = subProperty.ValueType.Properties;  							var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  							WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' false' string.Format ("{0}.{1}"' property.Name' subProperty.Name));  						}  					}  				}  				// write one big packet with references for everything  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					writer.WriteLine ("packet.WriteId(\"Reference\");");  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Reference')).toBeDefined();");  					foreach (var property in schemaProperties) {  						string propertyName = property.Name;  						bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  						if (isExtension)  							propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var properties = property.ValueType.Properties;  							if (properties.Any (p => p.ValueType.Name == "Reference")) {  								writer.WriteLine ("w.WriteReference(new Reference(\"Constant\"' \"{0}\"));"' propertyName);  								WriteAssertion (writer' isExtension' "expect(e.{0}.getValue(date)).toEqual(constant.{0}.getValue(date));"' propertyName);  							} else {  								foreach (var subProperty in properties.Where (p => !p.IsValue)) {  									properties = subProperty.ValueType.Properties;  									string subPropertyName = GetSubPropertyName (propertyName' subProperty);  									if (properties.Any (p => p.ValueType.Name == "Reference")) {  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("w2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\")));"' propertyName' subPropertyName);  											WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual(constant.{0}.{1}.getValue(date));"' propertyName' subPropertyName);  										}  									} else if (properties.Any (p => p.ValueType.Name == "ReferenceList")) {  										string targetId = "";  										string[] referencePropertyNames =  {    										};  										if (subProperty.ValueType.Name == "PositionList") {  											targetId = "Position";  											referencePropertyNames = new[] {  												"position"  											};  										} else if (subProperty.ValueType.Name == "DoubleList") {  											targetId = "Double";  											referencePropertyNames = new[] {  												"billboard"'  												"scale"  											};  										}  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("w2.WriteReferences(CreateList(new Reference(\"Constant{0}1\"' CreateList({1}))' new Reference(\"Constant{0}2\"' CreateList({1}))));"' targetId' string.Join ("' "' referencePropertyNames.Select (n => string.Format ("\"{0}\""' n))));  											WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual([dataSource.entities.getById('Constant{2}1').{3}.getValue(date)' dataSource.entities.getById('Constant{2}2').{3}.getValue(date)]);"' propertyName' subPropertyName' targetId' string.Join ("."' referencePropertyNames));  										}  									} else if (subProperty.ValueType.Name.Contains ("Material")) {  										Property materialProperty = properties.First ();  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													writer.WriteLine ("m2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"{2}\")));"' propertyName' subPropertyName' materialSubProperty.Name);  													WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.{2}.getValue(date)).toEqual(constant.{0}.{1}.{2}.getValue(date));"' propertyName' subPropertyName' materialSubProperty.Name);  												}  											}  										}  									} else {  										var additionalProperties = subProperty.ValueType.AdditionalProperties;  										if (additionalProperties != null) {  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var a = w2.Open{0}Property(\"referenceProp\"))"' additionalProperties.ValueType.NameWithPascalCase);  											using (writer.OpenScope ()) {  												foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  													writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														writer.WriteLine ("w3.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"prop\"' \"{2}\")));"' propertyName' subPropertyName' additionalProperty.Name);  														WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.referenceProp.{2}.getValue(date)).toEqual(constant.{0}.{1}.prop.{2}.getValue(date));"' propertyName' subPropertyName' additionalProperty.Name);  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  				writer.WriteLine ("WriteReferenceValuesIndividual();");  			}  			writer.WriteLine ("private void WriteReferenceValuesIndividual()");  			using (writer.OpenScope ()) {  				// write other materials as individual packets  				foreach (var property in schemaProperties) {  					writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  				}  				// special case - velocity reference  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  					var property = schemaProperties.First (p => p.Name == "position");  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						// construct a position with specific velocity  						double dx = 1.0;  						double dy = 2.0;  						double dz = 3.0;  						double deltaTime = 60.0;  						double x1 = 1.0;  						double x2 = x1 + dx * deltaTime;  						double y1 = 2.0;  						double y2 = y1 + dy * deltaTime;  						double z1 = 3.0;  						double z2 = z1 + dz * deltaTime;  						string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  						string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  						string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  						string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  						writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  						WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  						WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  					}  				}  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						properties = subProperty.ValueType.Properties;  						if (properties.Any (p => p.Name == "velocityReference")) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  									double expectedX = 1.0;  									double expectedY = 2.0;  									double expectedZ = 3.0;  									bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  									if (isNormalized) {  										NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  									}  									WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  								}  							}  						}  					}  				}  			}  			// write other materials as individual packets  			foreach (var property in schemaProperties) {  				writer.WriteLine ("private void WriteReferenceValuesIndividual{0}()"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						string subPropertyName = GetSubPropertyName (propertyName' subProperty);  						if (subProperty.ValueType.Name.Contains ("Material")) {  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string targetId = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  									string id = string.Format ("reference_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												writer.WriteLine ("m2.WriteReference(new Reference(\"{0}\"' CreateList(\"{1}\"' \"{2}\"' \"{3}\")));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  												WriteAssertion (writer' isExtension' "expect(e.{1}.{2}.{3}.getValue(date)).toEqual(dataSource.entities.getById('{0}').{1}.{2}.{3}.getValue(date));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  											}  										}  									}  								}  							}  						}  					}  				}  			}  			// test sampled properties  			writer.WriteLine ("private void WriteSampledValues()");  			using (writer.OpenScope ()) {  				// Write one packet with first value types for each property  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					const string id = "Sampled";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Sampled')).toBeDefined();");  					foreach (var property in schemaProperties) {  						string propertyName = property.Name;  						bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  						if (isExtension)  							propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  						var properties = property.ValueType.Properties;  						if (property.IsInterpolatable) {  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  								WriteValues (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  							}  						} else {  							var subProperties = properties.Where (p => !p.IsValue && (p.IsInterpolatable || p.ValueType.Name.Contains ("Material"))).ToList ();  							if (subProperties.Any ()) {  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								using (writer.OpenScope ()) {  									foreach (var subProperty in subProperties) {  										properties = subProperty.ValueType.Properties;  										string subPropertyName = GetSubPropertyName (propertyName' subProperty);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											if (subProperty.IsInterpolatable) {  												var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  												WriteValues (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  											} else if (subProperty.ValueType.Name.Contains ("Material")) {  												Property materialProperty = properties.First ();  												writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialProperty.ValueType.Properties;  													foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  														writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  														using (writer.OpenScope ()) {  															properties = materialSubProperty.ValueType.Properties;  															var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  															WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  														}  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  				writer.WriteLine ("WriteSampledValuesIndividual();");  				writer.WriteLine ("WriteSampledValuesCustomProperties();");  			}  			writer.WriteLine ("private void WriteSampledValuesIndividual()");  			using (writer.OpenScope ()) {  				// write other value types as individual packets  				// split method into multiple methods  				foreach (var property in schemaProperties) {  					writer.WriteLine ("WriteSampledValuesIndividual{0}();"' property.NameWithPascalCase);  				}  			}  			foreach (var property in schemaProperties) {  				writer.WriteLine ("private void WriteSampledValuesIndividual{0}()"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					if (property.IsInterpolatable) {  						foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("sampled_{0}_{1}"' propertyName' valueProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValues (writer' "w"' id' valueProperty' property' isExtension' propertyName);  								}  							}  						}  					} else {  						foreach (var subProperty in properties.Where (p => !p.IsValue)) {  							string subPropertyName = GetSubPropertyName (propertyName' subProperty);  							properties = subProperty.ValueType.Properties;  							if (subProperty.IsInterpolatable) {  								foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' valueProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValues (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  										}  									}  								}  							} else if (subProperty.ValueType.Name.Contains ("Material")) {  								// write other values for the first material  								// then write first values for other materials   								// then write remaining values for other materials individually  								var firstMaterialProperty = properties.First ();  								properties = firstMaterialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  									properties = materialSubProperty.ValueType.Properties;  									foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  										writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  										using (writer.OpenScope ()) {  											string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  											writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  											WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  											writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												WriteValues (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  								properties = subProperty.ValueType.Properties;  								foreach (var materialProperty in properties.Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialSubProperty.ValueType.Properties;  													var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  													WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  								properties = subProperty.ValueType.Properties;  								foreach (var materialProperty in properties.Skip (1)) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  										properties = materialSubProperty.ValueType.Properties;  										foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  											writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  											using (writer.OpenScope ()) {  												string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  												writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  												WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  												writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  												writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  												writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			// create all types of custom properties  			writer.WriteLine ("private void WriteSampledValuesCustomProperties()");  			using (writer.OpenScope ()) {  				var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  				if (propertiesProperty != null) {  					var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  					if (additionalProperties != null) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = "sampled_custom";  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array)) {  									string propName = string.Format ("custom_{0}"' valueProperty.Name);  									writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  									using (writer.OpenScope ()) {  										WriteValues (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  									}  								}  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (CodeWriter writer = new CodeWriter (Path.Combine (m_outputDirectory' "TestGenerateValidationDocument.cs"))) {  	writer.WriteLine ("// This file was generated automatically by GenerateFromSchema.  Do NOT edit it.");  	writer.WriteLine ("// https://github.com/AnalyticalGraphicsInc/czml-writer");  	writer.WriteLine ();  	writer.WriteLine ("using System.Collections.Generic;");  	writer.WriteLine ("using System.Diagnostics.CodeAnalysis;");  	writer.WriteLine ("using System.Drawing;");  	writer.WriteLine ("using System.IO;");  	writer.WriteLine ("using CesiumLanguageWriter;");  	writer.WriteLine ("using NUnit.Framework;");  	writer.WriteLine ();  	writer.WriteLine ("namespace {0}"' "CesiumLanguageWriterTests");  	using (writer.OpenScope ()) {  		writer.WriteLine ("[TestFixture]");  		writer.WriteLine ("[SuppressMessage(\"ReSharper\"' \"MemberCanBeMadeStatic.Local\")]");  		writer.WriteLine ("public class TestGenerateValidationDocument");  		using (writer.OpenScope ()) {  			writer.WriteLine ("private readonly JulianDate m_documentStartDate = new GregorianDate(2016' 6' 17' 12' 0' 0).ToJulianDate();");  			writer.WriteLine ("private readonly JulianDate m_documentStopDate = new GregorianDate(2016' 6' 17' 13' 0' 0).ToJulianDate();");  			writer.WriteLine ("private TextWriter m_streamWriter;");  			writer.WriteLine ("private TextWriter m_assertionsWriter;");  			writer.WriteLine ("private TextWriter m_extensionsAssertionsWriter;");  			writer.WriteLine ("private CesiumOutputStream m_output;");  			writer.WriteLine ("private CesiumStreamWriter m_writer;");  			writer.WriteLine ("private void WriteAssertionBoth(string s)");  			using (writer.OpenScope ()) {  				writer.WriteLine ("m_assertionsWriter.WriteLine(s);");  				writer.WriteLine ("m_extensionsAssertionsWriter.WriteLine(s);");  			}  			writer.WriteLine ("private static IList<T> CreateList<T>(T t1' T t2)");  			using (writer.OpenScope ()) {  				writer.WriteLine ("return new List<T> { t1' t2 };");  			}  			writer.WriteLine ("private static IList<T> CreateList<T>(params T[] ts)");  			using (writer.OpenScope ()) {  				writer.WriteLine ("return ts;");  			}  			writer.WriteLine ("[Test]");  			writer.WriteLine ("public void GenerateValidationDocument()");  			var schemaProperties = schema.Properties.Where (p => p.Name != "clock" && p.Name != "availability" && !p.ValueType.IsSchemaFromType).Where (p => p.Name != "properties").ToList ();  			using (writer.OpenScope ()) {  				writer.WriteLine ("using (m_streamWriter = new StreamWriter(\"ValidationDocument.czml\"))");  				writer.WriteLine ("using (m_assertionsWriter = new StreamWriter(\"ValidationDocumentAssertions.js\"))");  				writer.WriteLine ("using (m_extensionsAssertionsWriter = new StreamWriter(\"ValidationDocumentExtensionAssertions.js\"))");  				using (writer.OpenScope ()) {  					WriteAssertionBoth (writer' "return CzmlDataSource.load('Data/CZML/ValidationDocument.czml').then(function(dataSource) {");  					s_assertionIndent++;  					WriteAssertionBoth (writer' "/*jshint -W120 */");  					WriteAssertionBoth (writer' "var e;");  					WriteAssertionBoth (writer' "var date;");  					WriteAssertionBoth (writer' "var documentStartDate = JulianDate.fromIso8601('2016-06-17T12:00:00Z');");  					WriteAssertionBoth (writer' "var documentStopDate = JulianDate.fromIso8601('2016-06-17T13:00:00Z');");  					writer.WriteLine ("m_output = new CesiumOutputStream(m_streamWriter) { PrettyFormatting = true };");  					writer.WriteLine ("m_writer = new CesiumStreamWriter();");  					writer.WriteLine ("m_output.WriteStartSequence();");  					// Java has a limit on the size of a single method (65535 bytes) so we have to break up all this code in multiple methods  					writer.WriteLine ("WriteClock();");  					writer.WriteLine ("WriteConstantValues();");  					writer.WriteLine ("WriteReferenceValues();");  					writer.WriteLine ("WriteSampledValues();");  					writer.WriteLine ("m_output.WriteEndSequence();");  					s_assertionIndent--;  					WriteAssertionBoth (writer' "});");  					s_assertionIndent++;  				}  			}  			writer.WriteLine ("private void WriteClock()");  			using (writer.OpenScope ()) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					writer.WriteLine ("packet.WriteId(\"document\");");  					writer.WriteLine ("packet.WriteName(\"ValidationDocument\");");  					writer.WriteLine ("packet.WriteVersion(\"1.0\");");  					writer.WriteLine ("using (var clock = packet.OpenClockProperty())");  					using (writer.OpenScope ()) {  						writer.WriteLine ("clock.WriteInterval(m_documentStartDate' m_documentStopDate);");  						WriteAssertion (writer' false' "expect(dataSource.clock.startTime).toEqual(documentStartDate);");  						WriteAssertion (writer' false' "expect(dataSource.clock.stopTime).toEqual(documentStopDate);");  						writer.WriteLine ("clock.WriteCurrentTime(m_documentStartDate);");  						WriteAssertion (writer' false' "expect(dataSource.clock.currentTime).toEqual(documentStartDate);");  						writer.WriteLine ("clock.WriteMultiplier(1.0);");  						WriteAssertion (writer' false' "expect(dataSource.clock.multiplier).toEqual(1.0);");  						writer.WriteLine ("clock.WriteRange(ClockRange.Unbounded);");  						WriteAssertion (writer' false' "expect(dataSource.clock.clockRange).toEqual(ClockRange.UNBOUNDED);");  						writer.WriteLine ("clock.WriteStep(ClockStep.SystemClockMultiplier);");  						WriteAssertion (writer' false' "expect(dataSource.clock.clockStep).toEqual(ClockStep.SYSTEM_CLOCK_MULTIPLIER);");  					}  				}  			}  			writer.WriteLine ("private void WriteConstantValues()");  			using (writer.OpenScope ()) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					const string id = "Constant";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "var constant = e = dataSource.entities.getById('Constant');");  					WriteAssertionBoth (writer' "expect(e).toBeDefined();");  					WriteAssertionBoth (writer' "date = JulianDate.now();");  					// Write one packet with first value types for each property  					foreach (var property in schemaProperties) {  						string propertyName = property.Name;  						bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  						if (isExtension)  							propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var properties = property.ValueType.Properties;  							var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  							if (firstValueProperty != null) {  								WriteValue (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  							} else {  								foreach (var subProperty in properties.Where (p => !p.IsValue)) {  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = subProperty.ValueType.Properties;  										firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  										string subPropertyName = GetSubPropertyName (propertyName' subProperty);  										if (firstValueProperty != null) {  											WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  										} else if (subProperty.ValueType.Name.Contains ("Material")) {  											Property materialProperty = properties.First ();  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialProperty.ValueType.Properties;  												foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  													writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														properties = materialSubProperty.ValueType.Properties;  														firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  														if (firstValueProperty != null) {  															WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  														}  													}  												}  											}  										} else {  											var additionalProperties = subProperty.ValueType.AdditionalProperties;  											if (additionalProperties != null) {  												writer.WriteLine ("using (var a = w2.Open{0}Property(\"prop\"))"' additionalProperties.ValueType.NameWithPascalCase);  												using (writer.OpenScope ()) {  													foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  														writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  														using (writer.OpenScope ()) {  															properties = additionalProperty.ValueType.Properties;  															firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  															if (firstValueProperty != null) {  																WriteValue (writer' "w3"' id + property.Name' firstValueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' "prop"' additionalProperty.Name));  															}  														}  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  				writer.WriteLine ("WriteConstantValuesIndividual();");  				writer.WriteLine ("WriteConstantValuesCustomProperties();");  			}  			writer.WriteLine ("private void WriteConstantValuesIndividual()");  			using (writer.OpenScope ()) {  				// write other value types as individual packets  				foreach (var property in schemaProperties) {  					writer.WriteLine ("WriteConstantValuesIndividual{0}();"' property.NameWithPascalCase);  				}  			}  			foreach (var property in schemaProperties) {  				writer.WriteLine ("private void WriteConstantValuesIndividual{0}()"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("constant_{0}_{1}"' property.Name' valueProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								WriteValue (writer' "w"' id' valueProperty' property' isExtension' propertyName);  							}  						}  					}  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						string subPropertyName = GetSubPropertyName (propertyName' subProperty);  						properties = subProperty.ValueType.Properties;  						foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("constant_{0}_{1}_{2}"' property.Name' subPropertyName' valueProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValue (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  								}  							}  						}  						if (subProperty.ValueType.Name.Contains ("Material")) {  							// write other values for the first material  							// then write first values for other materials   							// then write remaining values for other materials individually  							var firstMaterialProperty = properties.First ();  							properties = firstMaterialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValue (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialSubProperty.ValueType.Properties;  												var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  												if (firstValueProperty != null) {  													WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  									properties = materialSubProperty.ValueType.Properties;  									foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  										writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  										using (writer.OpenScope ()) {  											string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  											writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  											WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  											writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  						}  						var additionalProperties = subProperty.ValueType.AdditionalProperties;  						if (additionalProperties != null) {  							foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  								int i = 0;  								properties = additionalProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' additionalProperties.ValueType.Name' additionalProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										string propName = string.Format ("{0}{1}"' "prop"' i++);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var a = w2.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  										writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValue (writer' "w3"' id + property.Name + subProperty.Name' valueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' propName' additionalProperty.Name));  										}  									}  								}  							}  						}  					}  				}  			}  			// create all types of custom properties  			writer.WriteLine ("private void WriteConstantValuesCustomProperties()");  			using (writer.OpenScope ()) {  				var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  				if (propertiesProperty != null) {  					var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  					if (additionalProperties != null) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = "constant_custom";  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue)) {  									string propName = string.Format ("custom_{0}"' valueProperty.Name);  									writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  									using (writer.OpenScope ()) {  										WriteValue (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  									}  								}  							}  						}  					}  				}  			}  			// create entities using references  			writer.WriteLine ("private void WriteReferenceValues()");  			using (writer.OpenScope ()) {  				// write some positions and double values to use to create reference lists for position lists and double lists later  				for (int i = 1; i <= 2; ++i) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("ConstantPosition{0}"' i);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantPosition{0}')).toBeDefined();"' i);  						var property = schemaProperties.First (p => p.Name == "position");  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var properties = property.ValueType.Properties;  							var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  							WriteValue (writer' "w"' id' firstValueProperty' property' false' property.Name);  						}  					}  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("ConstantDouble{0}"' i);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantDouble{0}')).toBeDefined();"' i);  						var property = schemaProperties.First (p => p.Name == "billboard");  						var properties = property.ValueType.Properties;  						var subProperty = properties.First (p => p.Name == "scale");  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							properties = subProperty.ValueType.Properties;  							var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  							WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' false' string.Format ("{0}.{1}"' property.Name' subProperty.Name));  						}  					}  				}  				// write one big packet with references for everything  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					writer.WriteLine ("packet.WriteId(\"Reference\");");  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Reference')).toBeDefined();");  					foreach (var property in schemaProperties) {  						string propertyName = property.Name;  						bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  						if (isExtension)  							propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var properties = property.ValueType.Properties;  							if (properties.Any (p => p.ValueType.Name == "Reference")) {  								writer.WriteLine ("w.WriteReference(new Reference(\"Constant\"' \"{0}\"));"' propertyName);  								WriteAssertion (writer' isExtension' "expect(e.{0}.getValue(date)).toEqual(constant.{0}.getValue(date));"' propertyName);  							} else {  								foreach (var subProperty in properties.Where (p => !p.IsValue)) {  									properties = subProperty.ValueType.Properties;  									string subPropertyName = GetSubPropertyName (propertyName' subProperty);  									if (properties.Any (p => p.ValueType.Name == "Reference")) {  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("w2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\")));"' propertyName' subPropertyName);  											WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual(constant.{0}.{1}.getValue(date));"' propertyName' subPropertyName);  										}  									} else if (properties.Any (p => p.ValueType.Name == "ReferenceList")) {  										string targetId = "";  										string[] referencePropertyNames =  {    										};  										if (subProperty.ValueType.Name == "PositionList") {  											targetId = "Position";  											referencePropertyNames = new[] {  												"position"  											};  										} else if (subProperty.ValueType.Name == "DoubleList") {  											targetId = "Double";  											referencePropertyNames = new[] {  												"billboard"'  												"scale"  											};  										}  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("w2.WriteReferences(CreateList(new Reference(\"Constant{0}1\"' CreateList({1}))' new Reference(\"Constant{0}2\"' CreateList({1}))));"' targetId' string.Join ("' "' referencePropertyNames.Select (n => string.Format ("\"{0}\""' n))));  											WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual([dataSource.entities.getById('Constant{2}1').{3}.getValue(date)' dataSource.entities.getById('Constant{2}2').{3}.getValue(date)]);"' propertyName' subPropertyName' targetId' string.Join ("."' referencePropertyNames));  										}  									} else if (subProperty.ValueType.Name.Contains ("Material")) {  										Property materialProperty = properties.First ();  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													writer.WriteLine ("m2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"{2}\")));"' propertyName' subPropertyName' materialSubProperty.Name);  													WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.{2}.getValue(date)).toEqual(constant.{0}.{1}.{2}.getValue(date));"' propertyName' subPropertyName' materialSubProperty.Name);  												}  											}  										}  									} else {  										var additionalProperties = subProperty.ValueType.AdditionalProperties;  										if (additionalProperties != null) {  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var a = w2.Open{0}Property(\"referenceProp\"))"' additionalProperties.ValueType.NameWithPascalCase);  											using (writer.OpenScope ()) {  												foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  													writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														writer.WriteLine ("w3.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"prop\"' \"{2}\")));"' propertyName' subPropertyName' additionalProperty.Name);  														WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.referenceProp.{2}.getValue(date)).toEqual(constant.{0}.{1}.prop.{2}.getValue(date));"' propertyName' subPropertyName' additionalProperty.Name);  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  				writer.WriteLine ("WriteReferenceValuesIndividual();");  			}  			writer.WriteLine ("private void WriteReferenceValuesIndividual()");  			using (writer.OpenScope ()) {  				// write other materials as individual packets  				foreach (var property in schemaProperties) {  					writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  				}  				// special case - velocity reference  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  					var property = schemaProperties.First (p => p.Name == "position");  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						// construct a position with specific velocity  						double dx = 1.0;  						double dy = 2.0;  						double dz = 3.0;  						double deltaTime = 60.0;  						double x1 = 1.0;  						double x2 = x1 + dx * deltaTime;  						double y1 = 2.0;  						double y2 = y1 + dy * deltaTime;  						double z1 = 3.0;  						double z2 = z1 + dz * deltaTime;  						string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  						string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  						string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  						string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  						writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  						WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  						WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  					}  				}  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						properties = subProperty.ValueType.Properties;  						if (properties.Any (p => p.Name == "velocityReference")) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  									double expectedX = 1.0;  									double expectedY = 2.0;  									double expectedZ = 3.0;  									bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  									if (isNormalized) {  										NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  									}  									WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  								}  							}  						}  					}  				}  			}  			// write other materials as individual packets  			foreach (var property in schemaProperties) {  				writer.WriteLine ("private void WriteReferenceValuesIndividual{0}()"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						string subPropertyName = GetSubPropertyName (propertyName' subProperty);  						if (subProperty.ValueType.Name.Contains ("Material")) {  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string targetId = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  									string id = string.Format ("reference_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												writer.WriteLine ("m2.WriteReference(new Reference(\"{0}\"' CreateList(\"{1}\"' \"{2}\"' \"{3}\")));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  												WriteAssertion (writer' isExtension' "expect(e.{1}.{2}.{3}.getValue(date)).toEqual(dataSource.entities.getById('{0}').{1}.{2}.{3}.getValue(date));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  											}  										}  									}  								}  							}  						}  					}  				}  			}  			// test sampled properties  			writer.WriteLine ("private void WriteSampledValues()");  			using (writer.OpenScope ()) {  				// Write one packet with first value types for each property  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					const string id = "Sampled";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Sampled')).toBeDefined();");  					foreach (var property in schemaProperties) {  						string propertyName = property.Name;  						bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  						if (isExtension)  							propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  						var properties = property.ValueType.Properties;  						if (property.IsInterpolatable) {  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  								WriteValues (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  							}  						} else {  							var subProperties = properties.Where (p => !p.IsValue && (p.IsInterpolatable || p.ValueType.Name.Contains ("Material"))).ToList ();  							if (subProperties.Any ()) {  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								using (writer.OpenScope ()) {  									foreach (var subProperty in subProperties) {  										properties = subProperty.ValueType.Properties;  										string subPropertyName = GetSubPropertyName (propertyName' subProperty);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											if (subProperty.IsInterpolatable) {  												var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  												WriteValues (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  											} else if (subProperty.ValueType.Name.Contains ("Material")) {  												Property materialProperty = properties.First ();  												writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialProperty.ValueType.Properties;  													foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  														writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  														using (writer.OpenScope ()) {  															properties = materialSubProperty.ValueType.Properties;  															var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  															WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  														}  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  				writer.WriteLine ("WriteSampledValuesIndividual();");  				writer.WriteLine ("WriteSampledValuesCustomProperties();");  			}  			writer.WriteLine ("private void WriteSampledValuesIndividual()");  			using (writer.OpenScope ()) {  				// write other value types as individual packets  				// split method into multiple methods  				foreach (var property in schemaProperties) {  					writer.WriteLine ("WriteSampledValuesIndividual{0}();"' property.NameWithPascalCase);  				}  			}  			foreach (var property in schemaProperties) {  				writer.WriteLine ("private void WriteSampledValuesIndividual{0}()"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					if (property.IsInterpolatable) {  						foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("sampled_{0}_{1}"' propertyName' valueProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValues (writer' "w"' id' valueProperty' property' isExtension' propertyName);  								}  							}  						}  					} else {  						foreach (var subProperty in properties.Where (p => !p.IsValue)) {  							string subPropertyName = GetSubPropertyName (propertyName' subProperty);  							properties = subProperty.ValueType.Properties;  							if (subProperty.IsInterpolatable) {  								foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' valueProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValues (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  										}  									}  								}  							} else if (subProperty.ValueType.Name.Contains ("Material")) {  								// write other values for the first material  								// then write first values for other materials   								// then write remaining values for other materials individually  								var firstMaterialProperty = properties.First ();  								properties = firstMaterialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  									properties = materialSubProperty.ValueType.Properties;  									foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  										writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  										using (writer.OpenScope ()) {  											string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  											writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  											WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  											writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												WriteValues (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  								properties = subProperty.ValueType.Properties;  								foreach (var materialProperty in properties.Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialSubProperty.ValueType.Properties;  													var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  													WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  								properties = subProperty.ValueType.Properties;  								foreach (var materialProperty in properties.Skip (1)) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  										properties = materialSubProperty.ValueType.Properties;  										foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  											writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  											using (writer.OpenScope ()) {  												string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  												writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  												WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  												writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  												writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  												writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			// create all types of custom properties  			writer.WriteLine ("private void WriteSampledValuesCustomProperties()");  			using (writer.OpenScope ()) {  				var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  				if (propertiesProperty != null) {  					var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  					if (additionalProperties != null) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = "sampled_custom";  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array)) {  									string propName = string.Format ("custom_{0}"' valueProperty.Name);  									writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  									using (writer.OpenScope ()) {  										WriteValues (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  									}  								}  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (CodeWriter writer = new CodeWriter (Path.Combine (m_outputDirectory' "TestGenerateValidationDocument.cs"))) {  	writer.WriteLine ("// This file was generated automatically by GenerateFromSchema.  Do NOT edit it.");  	writer.WriteLine ("// https://github.com/AnalyticalGraphicsInc/czml-writer");  	writer.WriteLine ();  	writer.WriteLine ("using System.Collections.Generic;");  	writer.WriteLine ("using System.Diagnostics.CodeAnalysis;");  	writer.WriteLine ("using System.Drawing;");  	writer.WriteLine ("using System.IO;");  	writer.WriteLine ("using CesiumLanguageWriter;");  	writer.WriteLine ("using NUnit.Framework;");  	writer.WriteLine ();  	writer.WriteLine ("namespace {0}"' "CesiumLanguageWriterTests");  	using (writer.OpenScope ()) {  		writer.WriteLine ("[TestFixture]");  		writer.WriteLine ("[SuppressMessage(\"ReSharper\"' \"MemberCanBeMadeStatic.Local\")]");  		writer.WriteLine ("public class TestGenerateValidationDocument");  		using (writer.OpenScope ()) {  			writer.WriteLine ("private readonly JulianDate m_documentStartDate = new GregorianDate(2016' 6' 17' 12' 0' 0).ToJulianDate();");  			writer.WriteLine ("private readonly JulianDate m_documentStopDate = new GregorianDate(2016' 6' 17' 13' 0' 0).ToJulianDate();");  			writer.WriteLine ("private TextWriter m_streamWriter;");  			writer.WriteLine ("private TextWriter m_assertionsWriter;");  			writer.WriteLine ("private TextWriter m_extensionsAssertionsWriter;");  			writer.WriteLine ("private CesiumOutputStream m_output;");  			writer.WriteLine ("private CesiumStreamWriter m_writer;");  			writer.WriteLine ("private void WriteAssertionBoth(string s)");  			using (writer.OpenScope ()) {  				writer.WriteLine ("m_assertionsWriter.WriteLine(s);");  				writer.WriteLine ("m_extensionsAssertionsWriter.WriteLine(s);");  			}  			writer.WriteLine ("private static IList<T> CreateList<T>(T t1' T t2)");  			using (writer.OpenScope ()) {  				writer.WriteLine ("return new List<T> { t1' t2 };");  			}  			writer.WriteLine ("private static IList<T> CreateList<T>(params T[] ts)");  			using (writer.OpenScope ()) {  				writer.WriteLine ("return ts;");  			}  			writer.WriteLine ("[Test]");  			writer.WriteLine ("public void GenerateValidationDocument()");  			var schemaProperties = schema.Properties.Where (p => p.Name != "clock" && p.Name != "availability" && !p.ValueType.IsSchemaFromType).Where (p => p.Name != "properties").ToList ();  			using (writer.OpenScope ()) {  				writer.WriteLine ("using (m_streamWriter = new StreamWriter(\"ValidationDocument.czml\"))");  				writer.WriteLine ("using (m_assertionsWriter = new StreamWriter(\"ValidationDocumentAssertions.js\"))");  				writer.WriteLine ("using (m_extensionsAssertionsWriter = new StreamWriter(\"ValidationDocumentExtensionAssertions.js\"))");  				using (writer.OpenScope ()) {  					WriteAssertionBoth (writer' "return CzmlDataSource.load('Data/CZML/ValidationDocument.czml').then(function(dataSource) {");  					s_assertionIndent++;  					WriteAssertionBoth (writer' "/*jshint -W120 */");  					WriteAssertionBoth (writer' "var e;");  					WriteAssertionBoth (writer' "var date;");  					WriteAssertionBoth (writer' "var documentStartDate = JulianDate.fromIso8601('2016-06-17T12:00:00Z');");  					WriteAssertionBoth (writer' "var documentStopDate = JulianDate.fromIso8601('2016-06-17T13:00:00Z');");  					writer.WriteLine ("m_output = new CesiumOutputStream(m_streamWriter) { PrettyFormatting = true };");  					writer.WriteLine ("m_writer = new CesiumStreamWriter();");  					writer.WriteLine ("m_output.WriteStartSequence();");  					// Java has a limit on the size of a single method (65535 bytes) so we have to break up all this code in multiple methods  					writer.WriteLine ("WriteClock();");  					writer.WriteLine ("WriteConstantValues();");  					writer.WriteLine ("WriteReferenceValues();");  					writer.WriteLine ("WriteSampledValues();");  					writer.WriteLine ("m_output.WriteEndSequence();");  					s_assertionIndent--;  					WriteAssertionBoth (writer' "});");  					s_assertionIndent++;  				}  			}  			writer.WriteLine ("private void WriteClock()");  			using (writer.OpenScope ()) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					writer.WriteLine ("packet.WriteId(\"document\");");  					writer.WriteLine ("packet.WriteName(\"ValidationDocument\");");  					writer.WriteLine ("packet.WriteVersion(\"1.0\");");  					writer.WriteLine ("using (var clock = packet.OpenClockProperty())");  					using (writer.OpenScope ()) {  						writer.WriteLine ("clock.WriteInterval(m_documentStartDate' m_documentStopDate);");  						WriteAssertion (writer' false' "expect(dataSource.clock.startTime).toEqual(documentStartDate);");  						WriteAssertion (writer' false' "expect(dataSource.clock.stopTime).toEqual(documentStopDate);");  						writer.WriteLine ("clock.WriteCurrentTime(m_documentStartDate);");  						WriteAssertion (writer' false' "expect(dataSource.clock.currentTime).toEqual(documentStartDate);");  						writer.WriteLine ("clock.WriteMultiplier(1.0);");  						WriteAssertion (writer' false' "expect(dataSource.clock.multiplier).toEqual(1.0);");  						writer.WriteLine ("clock.WriteRange(ClockRange.Unbounded);");  						WriteAssertion (writer' false' "expect(dataSource.clock.clockRange).toEqual(ClockRange.UNBOUNDED);");  						writer.WriteLine ("clock.WriteStep(ClockStep.SystemClockMultiplier);");  						WriteAssertion (writer' false' "expect(dataSource.clock.clockStep).toEqual(ClockStep.SYSTEM_CLOCK_MULTIPLIER);");  					}  				}  			}  			writer.WriteLine ("private void WriteConstantValues()");  			using (writer.OpenScope ()) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					const string id = "Constant";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "var constant = e = dataSource.entities.getById('Constant');");  					WriteAssertionBoth (writer' "expect(e).toBeDefined();");  					WriteAssertionBoth (writer' "date = JulianDate.now();");  					// Write one packet with first value types for each property  					foreach (var property in schemaProperties) {  						string propertyName = property.Name;  						bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  						if (isExtension)  							propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var properties = property.ValueType.Properties;  							var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  							if (firstValueProperty != null) {  								WriteValue (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  							} else {  								foreach (var subProperty in properties.Where (p => !p.IsValue)) {  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = subProperty.ValueType.Properties;  										firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  										string subPropertyName = GetSubPropertyName (propertyName' subProperty);  										if (firstValueProperty != null) {  											WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  										} else if (subProperty.ValueType.Name.Contains ("Material")) {  											Property materialProperty = properties.First ();  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialProperty.ValueType.Properties;  												foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  													writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														properties = materialSubProperty.ValueType.Properties;  														firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  														if (firstValueProperty != null) {  															WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  														}  													}  												}  											}  										} else {  											var additionalProperties = subProperty.ValueType.AdditionalProperties;  											if (additionalProperties != null) {  												writer.WriteLine ("using (var a = w2.Open{0}Property(\"prop\"))"' additionalProperties.ValueType.NameWithPascalCase);  												using (writer.OpenScope ()) {  													foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  														writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  														using (writer.OpenScope ()) {  															properties = additionalProperty.ValueType.Properties;  															firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  															if (firstValueProperty != null) {  																WriteValue (writer' "w3"' id + property.Name' firstValueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' "prop"' additionalProperty.Name));  															}  														}  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  				writer.WriteLine ("WriteConstantValuesIndividual();");  				writer.WriteLine ("WriteConstantValuesCustomProperties();");  			}  			writer.WriteLine ("private void WriteConstantValuesIndividual()");  			using (writer.OpenScope ()) {  				// write other value types as individual packets  				foreach (var property in schemaProperties) {  					writer.WriteLine ("WriteConstantValuesIndividual{0}();"' property.NameWithPascalCase);  				}  			}  			foreach (var property in schemaProperties) {  				writer.WriteLine ("private void WriteConstantValuesIndividual{0}()"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("constant_{0}_{1}"' property.Name' valueProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								WriteValue (writer' "w"' id' valueProperty' property' isExtension' propertyName);  							}  						}  					}  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						string subPropertyName = GetSubPropertyName (propertyName' subProperty);  						properties = subProperty.ValueType.Properties;  						foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("constant_{0}_{1}_{2}"' property.Name' subPropertyName' valueProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValue (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  								}  							}  						}  						if (subProperty.ValueType.Name.Contains ("Material")) {  							// write other values for the first material  							// then write first values for other materials   							// then write remaining values for other materials individually  							var firstMaterialProperty = properties.First ();  							properties = firstMaterialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValue (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialSubProperty.ValueType.Properties;  												var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  												if (firstValueProperty != null) {  													WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  									properties = materialSubProperty.ValueType.Properties;  									foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  										writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  										using (writer.OpenScope ()) {  											string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  											writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  											WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  											writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  						}  						var additionalProperties = subProperty.ValueType.AdditionalProperties;  						if (additionalProperties != null) {  							foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  								int i = 0;  								properties = additionalProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' additionalProperties.ValueType.Name' additionalProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										string propName = string.Format ("{0}{1}"' "prop"' i++);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var a = w2.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  										writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValue (writer' "w3"' id + property.Name + subProperty.Name' valueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' propName' additionalProperty.Name));  										}  									}  								}  							}  						}  					}  				}  			}  			// create all types of custom properties  			writer.WriteLine ("private void WriteConstantValuesCustomProperties()");  			using (writer.OpenScope ()) {  				var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  				if (propertiesProperty != null) {  					var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  					if (additionalProperties != null) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = "constant_custom";  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue)) {  									string propName = string.Format ("custom_{0}"' valueProperty.Name);  									writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  									using (writer.OpenScope ()) {  										WriteValue (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  									}  								}  							}  						}  					}  				}  			}  			// create entities using references  			writer.WriteLine ("private void WriteReferenceValues()");  			using (writer.OpenScope ()) {  				// write some positions and double values to use to create reference lists for position lists and double lists later  				for (int i = 1; i <= 2; ++i) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("ConstantPosition{0}"' i);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantPosition{0}')).toBeDefined();"' i);  						var property = schemaProperties.First (p => p.Name == "position");  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var properties = property.ValueType.Properties;  							var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  							WriteValue (writer' "w"' id' firstValueProperty' property' false' property.Name);  						}  					}  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("ConstantDouble{0}"' i);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantDouble{0}')).toBeDefined();"' i);  						var property = schemaProperties.First (p => p.Name == "billboard");  						var properties = property.ValueType.Properties;  						var subProperty = properties.First (p => p.Name == "scale");  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							properties = subProperty.ValueType.Properties;  							var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  							WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' false' string.Format ("{0}.{1}"' property.Name' subProperty.Name));  						}  					}  				}  				// write one big packet with references for everything  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					writer.WriteLine ("packet.WriteId(\"Reference\");");  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Reference')).toBeDefined();");  					foreach (var property in schemaProperties) {  						string propertyName = property.Name;  						bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  						if (isExtension)  							propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var properties = property.ValueType.Properties;  							if (properties.Any (p => p.ValueType.Name == "Reference")) {  								writer.WriteLine ("w.WriteReference(new Reference(\"Constant\"' \"{0}\"));"' propertyName);  								WriteAssertion (writer' isExtension' "expect(e.{0}.getValue(date)).toEqual(constant.{0}.getValue(date));"' propertyName);  							} else {  								foreach (var subProperty in properties.Where (p => !p.IsValue)) {  									properties = subProperty.ValueType.Properties;  									string subPropertyName = GetSubPropertyName (propertyName' subProperty);  									if (properties.Any (p => p.ValueType.Name == "Reference")) {  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("w2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\")));"' propertyName' subPropertyName);  											WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual(constant.{0}.{1}.getValue(date));"' propertyName' subPropertyName);  										}  									} else if (properties.Any (p => p.ValueType.Name == "ReferenceList")) {  										string targetId = "";  										string[] referencePropertyNames =  {    										};  										if (subProperty.ValueType.Name == "PositionList") {  											targetId = "Position";  											referencePropertyNames = new[] {  												"position"  											};  										} else if (subProperty.ValueType.Name == "DoubleList") {  											targetId = "Double";  											referencePropertyNames = new[] {  												"billboard"'  												"scale"  											};  										}  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("w2.WriteReferences(CreateList(new Reference(\"Constant{0}1\"' CreateList({1}))' new Reference(\"Constant{0}2\"' CreateList({1}))));"' targetId' string.Join ("' "' referencePropertyNames.Select (n => string.Format ("\"{0}\""' n))));  											WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual([dataSource.entities.getById('Constant{2}1').{3}.getValue(date)' dataSource.entities.getById('Constant{2}2').{3}.getValue(date)]);"' propertyName' subPropertyName' targetId' string.Join ("."' referencePropertyNames));  										}  									} else if (subProperty.ValueType.Name.Contains ("Material")) {  										Property materialProperty = properties.First ();  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													writer.WriteLine ("m2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"{2}\")));"' propertyName' subPropertyName' materialSubProperty.Name);  													WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.{2}.getValue(date)).toEqual(constant.{0}.{1}.{2}.getValue(date));"' propertyName' subPropertyName' materialSubProperty.Name);  												}  											}  										}  									} else {  										var additionalProperties = subProperty.ValueType.AdditionalProperties;  										if (additionalProperties != null) {  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var a = w2.Open{0}Property(\"referenceProp\"))"' additionalProperties.ValueType.NameWithPascalCase);  											using (writer.OpenScope ()) {  												foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  													writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														writer.WriteLine ("w3.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"prop\"' \"{2}\")));"' propertyName' subPropertyName' additionalProperty.Name);  														WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.referenceProp.{2}.getValue(date)).toEqual(constant.{0}.{1}.prop.{2}.getValue(date));"' propertyName' subPropertyName' additionalProperty.Name);  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  				writer.WriteLine ("WriteReferenceValuesIndividual();");  			}  			writer.WriteLine ("private void WriteReferenceValuesIndividual()");  			using (writer.OpenScope ()) {  				// write other materials as individual packets  				foreach (var property in schemaProperties) {  					writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  				}  				// special case - velocity reference  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  					var property = schemaProperties.First (p => p.Name == "position");  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						// construct a position with specific velocity  						double dx = 1.0;  						double dy = 2.0;  						double dz = 3.0;  						double deltaTime = 60.0;  						double x1 = 1.0;  						double x2 = x1 + dx * deltaTime;  						double y1 = 2.0;  						double y2 = y1 + dy * deltaTime;  						double z1 = 3.0;  						double z2 = z1 + dz * deltaTime;  						string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  						string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  						string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  						string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  						writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  						WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  						WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  					}  				}  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						properties = subProperty.ValueType.Properties;  						if (properties.Any (p => p.Name == "velocityReference")) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  									double expectedX = 1.0;  									double expectedY = 2.0;  									double expectedZ = 3.0;  									bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  									if (isNormalized) {  										NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  									}  									WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  								}  							}  						}  					}  				}  			}  			// write other materials as individual packets  			foreach (var property in schemaProperties) {  				writer.WriteLine ("private void WriteReferenceValuesIndividual{0}()"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						string subPropertyName = GetSubPropertyName (propertyName' subProperty);  						if (subProperty.ValueType.Name.Contains ("Material")) {  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string targetId = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  									string id = string.Format ("reference_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												writer.WriteLine ("m2.WriteReference(new Reference(\"{0}\"' CreateList(\"{1}\"' \"{2}\"' \"{3}\")));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  												WriteAssertion (writer' isExtension' "expect(e.{1}.{2}.{3}.getValue(date)).toEqual(dataSource.entities.getById('{0}').{1}.{2}.{3}.getValue(date));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  											}  										}  									}  								}  							}  						}  					}  				}  			}  			// test sampled properties  			writer.WriteLine ("private void WriteSampledValues()");  			using (writer.OpenScope ()) {  				// Write one packet with first value types for each property  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					const string id = "Sampled";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Sampled')).toBeDefined();");  					foreach (var property in schemaProperties) {  						string propertyName = property.Name;  						bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  						if (isExtension)  							propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  						var properties = property.ValueType.Properties;  						if (property.IsInterpolatable) {  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  								WriteValues (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  							}  						} else {  							var subProperties = properties.Where (p => !p.IsValue && (p.IsInterpolatable || p.ValueType.Name.Contains ("Material"))).ToList ();  							if (subProperties.Any ()) {  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								using (writer.OpenScope ()) {  									foreach (var subProperty in subProperties) {  										properties = subProperty.ValueType.Properties;  										string subPropertyName = GetSubPropertyName (propertyName' subProperty);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											if (subProperty.IsInterpolatable) {  												var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  												WriteValues (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  											} else if (subProperty.ValueType.Name.Contains ("Material")) {  												Property materialProperty = properties.First ();  												writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialProperty.ValueType.Properties;  													foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  														writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  														using (writer.OpenScope ()) {  															properties = materialSubProperty.ValueType.Properties;  															var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  															WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  														}  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  				writer.WriteLine ("WriteSampledValuesIndividual();");  				writer.WriteLine ("WriteSampledValuesCustomProperties();");  			}  			writer.WriteLine ("private void WriteSampledValuesIndividual()");  			using (writer.OpenScope ()) {  				// write other value types as individual packets  				// split method into multiple methods  				foreach (var property in schemaProperties) {  					writer.WriteLine ("WriteSampledValuesIndividual{0}();"' property.NameWithPascalCase);  				}  			}  			foreach (var property in schemaProperties) {  				writer.WriteLine ("private void WriteSampledValuesIndividual{0}()"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					if (property.IsInterpolatable) {  						foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("sampled_{0}_{1}"' propertyName' valueProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValues (writer' "w"' id' valueProperty' property' isExtension' propertyName);  								}  							}  						}  					} else {  						foreach (var subProperty in properties.Where (p => !p.IsValue)) {  							string subPropertyName = GetSubPropertyName (propertyName' subProperty);  							properties = subProperty.ValueType.Properties;  							if (subProperty.IsInterpolatable) {  								foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' valueProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValues (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  										}  									}  								}  							} else if (subProperty.ValueType.Name.Contains ("Material")) {  								// write other values for the first material  								// then write first values for other materials   								// then write remaining values for other materials individually  								var firstMaterialProperty = properties.First ();  								properties = firstMaterialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  									properties = materialSubProperty.ValueType.Properties;  									foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  										writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  										using (writer.OpenScope ()) {  											string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  											writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  											WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  											writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												WriteValues (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  								properties = subProperty.ValueType.Properties;  								foreach (var materialProperty in properties.Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialSubProperty.ValueType.Properties;  													var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  													WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  								properties = subProperty.ValueType.Properties;  								foreach (var materialProperty in properties.Skip (1)) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  										properties = materialSubProperty.ValueType.Properties;  										foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  											writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  											using (writer.OpenScope ()) {  												string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  												writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  												WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  												writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  												writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  												writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			// create all types of custom properties  			writer.WriteLine ("private void WriteSampledValuesCustomProperties()");  			using (writer.OpenScope ()) {  				var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  				if (propertiesProperty != null) {  					var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  					if (additionalProperties != null) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = "sampled_custom";  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array)) {  									string propName = string.Format ("custom_{0}"' valueProperty.Name);  									writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  									using (writer.OpenScope ()) {  										WriteValues (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  									}  								}  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	writer.WriteLine ("[TestFixture]");  	writer.WriteLine ("[SuppressMessage(\"ReSharper\"' \"MemberCanBeMadeStatic.Local\")]");  	writer.WriteLine ("public class TestGenerateValidationDocument");  	using (writer.OpenScope ()) {  		writer.WriteLine ("private readonly JulianDate m_documentStartDate = new GregorianDate(2016' 6' 17' 12' 0' 0).ToJulianDate();");  		writer.WriteLine ("private readonly JulianDate m_documentStopDate = new GregorianDate(2016' 6' 17' 13' 0' 0).ToJulianDate();");  		writer.WriteLine ("private TextWriter m_streamWriter;");  		writer.WriteLine ("private TextWriter m_assertionsWriter;");  		writer.WriteLine ("private TextWriter m_extensionsAssertionsWriter;");  		writer.WriteLine ("private CesiumOutputStream m_output;");  		writer.WriteLine ("private CesiumStreamWriter m_writer;");  		writer.WriteLine ("private void WriteAssertionBoth(string s)");  		using (writer.OpenScope ()) {  			writer.WriteLine ("m_assertionsWriter.WriteLine(s);");  			writer.WriteLine ("m_extensionsAssertionsWriter.WriteLine(s);");  		}  		writer.WriteLine ("private static IList<T> CreateList<T>(T t1' T t2)");  		using (writer.OpenScope ()) {  			writer.WriteLine ("return new List<T> { t1' t2 };");  		}  		writer.WriteLine ("private static IList<T> CreateList<T>(params T[] ts)");  		using (writer.OpenScope ()) {  			writer.WriteLine ("return ts;");  		}  		writer.WriteLine ("[Test]");  		writer.WriteLine ("public void GenerateValidationDocument()");  		var schemaProperties = schema.Properties.Where (p => p.Name != "clock" && p.Name != "availability" && !p.ValueType.IsSchemaFromType).Where (p => p.Name != "properties").ToList ();  		using (writer.OpenScope ()) {  			writer.WriteLine ("using (m_streamWriter = new StreamWriter(\"ValidationDocument.czml\"))");  			writer.WriteLine ("using (m_assertionsWriter = new StreamWriter(\"ValidationDocumentAssertions.js\"))");  			writer.WriteLine ("using (m_extensionsAssertionsWriter = new StreamWriter(\"ValidationDocumentExtensionAssertions.js\"))");  			using (writer.OpenScope ()) {  				WriteAssertionBoth (writer' "return CzmlDataSource.load('Data/CZML/ValidationDocument.czml').then(function(dataSource) {");  				s_assertionIndent++;  				WriteAssertionBoth (writer' "/*jshint -W120 */");  				WriteAssertionBoth (writer' "var e;");  				WriteAssertionBoth (writer' "var date;");  				WriteAssertionBoth (writer' "var documentStartDate = JulianDate.fromIso8601('2016-06-17T12:00:00Z');");  				WriteAssertionBoth (writer' "var documentStopDate = JulianDate.fromIso8601('2016-06-17T13:00:00Z');");  				writer.WriteLine ("m_output = new CesiumOutputStream(m_streamWriter) { PrettyFormatting = true };");  				writer.WriteLine ("m_writer = new CesiumStreamWriter();");  				writer.WriteLine ("m_output.WriteStartSequence();");  				// Java has a limit on the size of a single method (65535 bytes) so we have to break up all this code in multiple methods  				writer.WriteLine ("WriteClock();");  				writer.WriteLine ("WriteConstantValues();");  				writer.WriteLine ("WriteReferenceValues();");  				writer.WriteLine ("WriteSampledValues();");  				writer.WriteLine ("m_output.WriteEndSequence();");  				s_assertionIndent--;  				WriteAssertionBoth (writer' "});");  				s_assertionIndent++;  			}  		}  		writer.WriteLine ("private void WriteClock()");  		using (writer.OpenScope ()) {  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				writer.WriteLine ("packet.WriteId(\"document\");");  				writer.WriteLine ("packet.WriteName(\"ValidationDocument\");");  				writer.WriteLine ("packet.WriteVersion(\"1.0\");");  				writer.WriteLine ("using (var clock = packet.OpenClockProperty())");  				using (writer.OpenScope ()) {  					writer.WriteLine ("clock.WriteInterval(m_documentStartDate' m_documentStopDate);");  					WriteAssertion (writer' false' "expect(dataSource.clock.startTime).toEqual(documentStartDate);");  					WriteAssertion (writer' false' "expect(dataSource.clock.stopTime).toEqual(documentStopDate);");  					writer.WriteLine ("clock.WriteCurrentTime(m_documentStartDate);");  					WriteAssertion (writer' false' "expect(dataSource.clock.currentTime).toEqual(documentStartDate);");  					writer.WriteLine ("clock.WriteMultiplier(1.0);");  					WriteAssertion (writer' false' "expect(dataSource.clock.multiplier).toEqual(1.0);");  					writer.WriteLine ("clock.WriteRange(ClockRange.Unbounded);");  					WriteAssertion (writer' false' "expect(dataSource.clock.clockRange).toEqual(ClockRange.UNBOUNDED);");  					writer.WriteLine ("clock.WriteStep(ClockStep.SystemClockMultiplier);");  					WriteAssertion (writer' false' "expect(dataSource.clock.clockStep).toEqual(ClockStep.SYSTEM_CLOCK_MULTIPLIER);");  				}  			}  		}  		writer.WriteLine ("private void WriteConstantValues()");  		using (writer.OpenScope ()) {  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				const string id = "Constant";  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "var constant = e = dataSource.entities.getById('Constant');");  				WriteAssertionBoth (writer' "expect(e).toBeDefined();");  				WriteAssertionBoth (writer' "date = JulianDate.now();");  				// Write one packet with first value types for each property  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var properties = property.ValueType.Properties;  						var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  						if (firstValueProperty != null) {  							WriteValue (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  						} else {  							foreach (var subProperty in properties.Where (p => !p.IsValue)) {  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = subProperty.ValueType.Properties;  									firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  									string subPropertyName = GetSubPropertyName (propertyName' subProperty);  									if (firstValueProperty != null) {  										WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  									} else if (subProperty.ValueType.Name.Contains ("Material")) {  										Property materialProperty = properties.First ();  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialSubProperty.ValueType.Properties;  													firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  													if (firstValueProperty != null) {  														WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  													}  												}  											}  										}  									} else {  										var additionalProperties = subProperty.ValueType.AdditionalProperties;  										if (additionalProperties != null) {  											writer.WriteLine ("using (var a = w2.Open{0}Property(\"prop\"))"' additionalProperties.ValueType.NameWithPascalCase);  											using (writer.OpenScope ()) {  												foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  													writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														properties = additionalProperty.ValueType.Properties;  														firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  														if (firstValueProperty != null) {  															WriteValue (writer' "w3"' id + property.Name' firstValueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' "prop"' additionalProperty.Name));  														}  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			writer.WriteLine ("WriteConstantValuesIndividual();");  			writer.WriteLine ("WriteConstantValuesCustomProperties();");  		}  		writer.WriteLine ("private void WriteConstantValuesIndividual()");  		using (writer.OpenScope ()) {  			// write other value types as individual packets  			foreach (var property in schemaProperties) {  				writer.WriteLine ("WriteConstantValuesIndividual{0}();"' property.NameWithPascalCase);  			}  		}  		foreach (var property in schemaProperties) {  			writer.WriteLine ("private void WriteConstantValuesIndividual{0}()"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("constant_{0}_{1}"' property.Name' valueProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							WriteValue (writer' "w"' id' valueProperty' property' isExtension' propertyName);  						}  					}  				}  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					string subPropertyName = GetSubPropertyName (propertyName' subProperty);  					properties = subProperty.ValueType.Properties;  					foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("constant_{0}_{1}_{2}"' property.Name' subPropertyName' valueProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								WriteValue (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  							}  						}  					}  					if (subProperty.ValueType.Name.Contains ("Material")) {  						// write other values for the first material  						// then write first values for other materials   						// then write remaining values for other materials individually  						var firstMaterialProperty = properties.First ();  						properties = firstMaterialProperty.ValueType.Properties;  						foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  							properties = materialSubProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValue (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialSubProperty.ValueType.Properties;  											var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  											if (firstValueProperty != null) {  												WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							properties = materialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  					}  					var additionalProperties = subProperty.ValueType.AdditionalProperties;  					if (additionalProperties != null) {  						foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  							int i = 0;  							properties = additionalProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' additionalProperties.ValueType.Name' additionalProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									string propName = string.Format ("{0}{1}"' "prop"' i++);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var a = w2.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  									writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValue (writer' "w3"' id + property.Name + subProperty.Name' valueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' propName' additionalProperty.Name));  									}  								}  							}  						}  					}  				}  			}  		}  		// create all types of custom properties  		writer.WriteLine ("private void WriteConstantValuesCustomProperties()");  		using (writer.OpenScope ()) {  			var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  			if (propertiesProperty != null) {  				var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  				if (additionalProperties != null) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = "constant_custom";  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue)) {  								string propName = string.Format ("custom_{0}"' valueProperty.Name);  								writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  								using (writer.OpenScope ()) {  									WriteValue (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  								}  							}  						}  					}  				}  			}  		}  		// create entities using references  		writer.WriteLine ("private void WriteReferenceValues()");  		using (writer.OpenScope ()) {  			// write some positions and double values to use to create reference lists for position lists and double lists later  			for (int i = 1; i <= 2; ++i) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("ConstantPosition{0}"' i);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantPosition{0}')).toBeDefined();"' i);  					var property = schemaProperties.First (p => p.Name == "position");  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var properties = property.ValueType.Properties;  						var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  						WriteValue (writer' "w"' id' firstValueProperty' property' false' property.Name);  					}  				}  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("ConstantDouble{0}"' i);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantDouble{0}')).toBeDefined();"' i);  					var property = schemaProperties.First (p => p.Name == "billboard");  					var properties = property.ValueType.Properties;  					var subProperty = properties.First (p => p.Name == "scale");  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						properties = subProperty.ValueType.Properties;  						var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  						WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' false' string.Format ("{0}.{1}"' property.Name' subProperty.Name));  					}  				}  			}  			// write one big packet with references for everything  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				writer.WriteLine ("packet.WriteId(\"Reference\");");  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Reference')).toBeDefined();");  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var properties = property.ValueType.Properties;  						if (properties.Any (p => p.ValueType.Name == "Reference")) {  							writer.WriteLine ("w.WriteReference(new Reference(\"Constant\"' \"{0}\"));"' propertyName);  							WriteAssertion (writer' isExtension' "expect(e.{0}.getValue(date)).toEqual(constant.{0}.getValue(date));"' propertyName);  						} else {  							foreach (var subProperty in properties.Where (p => !p.IsValue)) {  								properties = subProperty.ValueType.Properties;  								string subPropertyName = GetSubPropertyName (propertyName' subProperty);  								if (properties.Any (p => p.ValueType.Name == "Reference")) {  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										writer.WriteLine ("w2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\")));"' propertyName' subPropertyName);  										WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual(constant.{0}.{1}.getValue(date));"' propertyName' subPropertyName);  									}  								} else if (properties.Any (p => p.ValueType.Name == "ReferenceList")) {  									string targetId = "";  									string[] referencePropertyNames =  {    									};  									if (subProperty.ValueType.Name == "PositionList") {  										targetId = "Position";  										referencePropertyNames = new[] {  											"position"  										};  									} else if (subProperty.ValueType.Name == "DoubleList") {  										targetId = "Double";  										referencePropertyNames = new[] {  											"billboard"'  											"scale"  										};  									}  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										writer.WriteLine ("w2.WriteReferences(CreateList(new Reference(\"Constant{0}1\"' CreateList({1}))' new Reference(\"Constant{0}2\"' CreateList({1}))));"' targetId' string.Join ("' "' referencePropertyNames.Select (n => string.Format ("\"{0}\""' n))));  										WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual([dataSource.entities.getById('Constant{2}1').{3}.getValue(date)' dataSource.entities.getById('Constant{2}2').{3}.getValue(date)]);"' propertyName' subPropertyName' targetId' string.Join ("."' referencePropertyNames));  									}  								} else if (subProperty.ValueType.Name.Contains ("Material")) {  									Property materialProperty = properties.First ();  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												writer.WriteLine ("m2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"{2}\")));"' propertyName' subPropertyName' materialSubProperty.Name);  												WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.{2}.getValue(date)).toEqual(constant.{0}.{1}.{2}.getValue(date));"' propertyName' subPropertyName' materialSubProperty.Name);  											}  										}  									}  								} else {  									var additionalProperties = subProperty.ValueType.AdditionalProperties;  									if (additionalProperties != null) {  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var a = w2.Open{0}Property(\"referenceProp\"))"' additionalProperties.ValueType.NameWithPascalCase);  										using (writer.OpenScope ()) {  											foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													writer.WriteLine ("w3.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"prop\"' \"{2}\")));"' propertyName' subPropertyName' additionalProperty.Name);  													WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.referenceProp.{2}.getValue(date)).toEqual(constant.{0}.{1}.prop.{2}.getValue(date));"' propertyName' subPropertyName' additionalProperty.Name);  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			writer.WriteLine ("WriteReferenceValuesIndividual();");  		}  		writer.WriteLine ("private void WriteReferenceValuesIndividual()");  		using (writer.OpenScope ()) {  			// write other materials as individual packets  			foreach (var property in schemaProperties) {  				writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  			}  			// special case - velocity reference  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  				var property = schemaProperties.First (p => p.Name == "position");  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					// construct a position with specific velocity  					double dx = 1.0;  					double dy = 2.0;  					double dz = 3.0;  					double deltaTime = 60.0;  					double x1 = 1.0;  					double x2 = x1 + dx * deltaTime;  					double y1 = 2.0;  					double y2 = y1 + dy * deltaTime;  					double z1 = 3.0;  					double z2 = z1 + dz * deltaTime;  					string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  					string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  					string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  					string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  					writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  					WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  					WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  				}  			}  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					properties = subProperty.ValueType.Properties;  					if (properties.Any (p => p.Name == "velocityReference")) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  								double expectedX = 1.0;  								double expectedY = 2.0;  								double expectedZ = 3.0;  								bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  								if (isNormalized) {  									NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  								}  								WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  							}  						}  					}  				}  			}  		}  		// write other materials as individual packets  		foreach (var property in schemaProperties) {  			writer.WriteLine ("private void WriteReferenceValuesIndividual{0}()"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					string subPropertyName = GetSubPropertyName (propertyName' subProperty);  					if (subProperty.ValueType.Name.Contains ("Material")) {  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string targetId = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  								string id = string.Format ("reference_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("m2.WriteReference(new Reference(\"{0}\"' CreateList(\"{1}\"' \"{2}\"' \"{3}\")));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  											WriteAssertion (writer' isExtension' "expect(e.{1}.{2}.{3}.getValue(date)).toEqual(dataSource.entities.getById('{0}').{1}.{2}.{3}.getValue(date));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  										}  									}  								}  							}  						}  					}  				}  			}  		}  		// test sampled properties  		writer.WriteLine ("private void WriteSampledValues()");  		using (writer.OpenScope ()) {  			// Write one packet with first value types for each property  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				const string id = "Sampled";  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Sampled')).toBeDefined();");  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					if (property.IsInterpolatable) {  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  							WriteValues (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  						}  					} else {  						var subProperties = properties.Where (p => !p.IsValue && (p.IsInterpolatable || p.ValueType.Name.Contains ("Material"))).ToList ();  						if (subProperties.Any ()) {  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								foreach (var subProperty in subProperties) {  									properties = subProperty.ValueType.Properties;  									string subPropertyName = GetSubPropertyName (propertyName' subProperty);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										if (subProperty.IsInterpolatable) {  											var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  											WriteValues (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  										} else if (subProperty.ValueType.Name.Contains ("Material")) {  											Property materialProperty = properties.First ();  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialProperty.ValueType.Properties;  												foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  													writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														properties = materialSubProperty.ValueType.Properties;  														var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  														WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			writer.WriteLine ("WriteSampledValuesIndividual();");  			writer.WriteLine ("WriteSampledValuesCustomProperties();");  		}  		writer.WriteLine ("private void WriteSampledValuesIndividual()");  		using (writer.OpenScope ()) {  			// write other value types as individual packets  			// split method into multiple methods  			foreach (var property in schemaProperties) {  				writer.WriteLine ("WriteSampledValuesIndividual{0}();"' property.NameWithPascalCase);  			}  		}  		foreach (var property in schemaProperties) {  			writer.WriteLine ("private void WriteSampledValuesIndividual{0}()"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				if (property.IsInterpolatable) {  					foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("sampled_{0}_{1}"' propertyName' valueProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								WriteValues (writer' "w"' id' valueProperty' property' isExtension' propertyName);  							}  						}  					}  				} else {  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						string subPropertyName = GetSubPropertyName (propertyName' subProperty);  						properties = subProperty.ValueType.Properties;  						if (subProperty.IsInterpolatable) {  							foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' valueProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValues (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  									}  								}  							}  						} else if (subProperty.ValueType.Name.Contains ("Material")) {  							// write other values for the first material  							// then write first values for other materials   							// then write remaining values for other materials individually  							var firstMaterialProperty = properties.First ();  							properties = firstMaterialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValues (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialSubProperty.ValueType.Properties;  												var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  												WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  									properties = materialSubProperty.ValueType.Properties;  									foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  										writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  										using (writer.OpenScope ()) {  											string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  											writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  											WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  											writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		// create all types of custom properties  		writer.WriteLine ("private void WriteSampledValuesCustomProperties()");  		using (writer.OpenScope ()) {  			var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  			if (propertiesProperty != null) {  				var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  				if (additionalProperties != null) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = "sampled_custom";  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array)) {  								string propName = string.Format ("custom_{0}"' valueProperty.Name);  								writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  								using (writer.OpenScope ()) {  									WriteValues (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  								}  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	writer.WriteLine ("[TestFixture]");  	writer.WriteLine ("[SuppressMessage(\"ReSharper\"' \"MemberCanBeMadeStatic.Local\")]");  	writer.WriteLine ("public class TestGenerateValidationDocument");  	using (writer.OpenScope ()) {  		writer.WriteLine ("private readonly JulianDate m_documentStartDate = new GregorianDate(2016' 6' 17' 12' 0' 0).ToJulianDate();");  		writer.WriteLine ("private readonly JulianDate m_documentStopDate = new GregorianDate(2016' 6' 17' 13' 0' 0).ToJulianDate();");  		writer.WriteLine ("private TextWriter m_streamWriter;");  		writer.WriteLine ("private TextWriter m_assertionsWriter;");  		writer.WriteLine ("private TextWriter m_extensionsAssertionsWriter;");  		writer.WriteLine ("private CesiumOutputStream m_output;");  		writer.WriteLine ("private CesiumStreamWriter m_writer;");  		writer.WriteLine ("private void WriteAssertionBoth(string s)");  		using (writer.OpenScope ()) {  			writer.WriteLine ("m_assertionsWriter.WriteLine(s);");  			writer.WriteLine ("m_extensionsAssertionsWriter.WriteLine(s);");  		}  		writer.WriteLine ("private static IList<T> CreateList<T>(T t1' T t2)");  		using (writer.OpenScope ()) {  			writer.WriteLine ("return new List<T> { t1' t2 };");  		}  		writer.WriteLine ("private static IList<T> CreateList<T>(params T[] ts)");  		using (writer.OpenScope ()) {  			writer.WriteLine ("return ts;");  		}  		writer.WriteLine ("[Test]");  		writer.WriteLine ("public void GenerateValidationDocument()");  		var schemaProperties = schema.Properties.Where (p => p.Name != "clock" && p.Name != "availability" && !p.ValueType.IsSchemaFromType).Where (p => p.Name != "properties").ToList ();  		using (writer.OpenScope ()) {  			writer.WriteLine ("using (m_streamWriter = new StreamWriter(\"ValidationDocument.czml\"))");  			writer.WriteLine ("using (m_assertionsWriter = new StreamWriter(\"ValidationDocumentAssertions.js\"))");  			writer.WriteLine ("using (m_extensionsAssertionsWriter = new StreamWriter(\"ValidationDocumentExtensionAssertions.js\"))");  			using (writer.OpenScope ()) {  				WriteAssertionBoth (writer' "return CzmlDataSource.load('Data/CZML/ValidationDocument.czml').then(function(dataSource) {");  				s_assertionIndent++;  				WriteAssertionBoth (writer' "/*jshint -W120 */");  				WriteAssertionBoth (writer' "var e;");  				WriteAssertionBoth (writer' "var date;");  				WriteAssertionBoth (writer' "var documentStartDate = JulianDate.fromIso8601('2016-06-17T12:00:00Z');");  				WriteAssertionBoth (writer' "var documentStopDate = JulianDate.fromIso8601('2016-06-17T13:00:00Z');");  				writer.WriteLine ("m_output = new CesiumOutputStream(m_streamWriter) { PrettyFormatting = true };");  				writer.WriteLine ("m_writer = new CesiumStreamWriter();");  				writer.WriteLine ("m_output.WriteStartSequence();");  				// Java has a limit on the size of a single method (65535 bytes) so we have to break up all this code in multiple methods  				writer.WriteLine ("WriteClock();");  				writer.WriteLine ("WriteConstantValues();");  				writer.WriteLine ("WriteReferenceValues();");  				writer.WriteLine ("WriteSampledValues();");  				writer.WriteLine ("m_output.WriteEndSequence();");  				s_assertionIndent--;  				WriteAssertionBoth (writer' "});");  				s_assertionIndent++;  			}  		}  		writer.WriteLine ("private void WriteClock()");  		using (writer.OpenScope ()) {  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				writer.WriteLine ("packet.WriteId(\"document\");");  				writer.WriteLine ("packet.WriteName(\"ValidationDocument\");");  				writer.WriteLine ("packet.WriteVersion(\"1.0\");");  				writer.WriteLine ("using (var clock = packet.OpenClockProperty())");  				using (writer.OpenScope ()) {  					writer.WriteLine ("clock.WriteInterval(m_documentStartDate' m_documentStopDate);");  					WriteAssertion (writer' false' "expect(dataSource.clock.startTime).toEqual(documentStartDate);");  					WriteAssertion (writer' false' "expect(dataSource.clock.stopTime).toEqual(documentStopDate);");  					writer.WriteLine ("clock.WriteCurrentTime(m_documentStartDate);");  					WriteAssertion (writer' false' "expect(dataSource.clock.currentTime).toEqual(documentStartDate);");  					writer.WriteLine ("clock.WriteMultiplier(1.0);");  					WriteAssertion (writer' false' "expect(dataSource.clock.multiplier).toEqual(1.0);");  					writer.WriteLine ("clock.WriteRange(ClockRange.Unbounded);");  					WriteAssertion (writer' false' "expect(dataSource.clock.clockRange).toEqual(ClockRange.UNBOUNDED);");  					writer.WriteLine ("clock.WriteStep(ClockStep.SystemClockMultiplier);");  					WriteAssertion (writer' false' "expect(dataSource.clock.clockStep).toEqual(ClockStep.SYSTEM_CLOCK_MULTIPLIER);");  				}  			}  		}  		writer.WriteLine ("private void WriteConstantValues()");  		using (writer.OpenScope ()) {  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				const string id = "Constant";  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "var constant = e = dataSource.entities.getById('Constant');");  				WriteAssertionBoth (writer' "expect(e).toBeDefined();");  				WriteAssertionBoth (writer' "date = JulianDate.now();");  				// Write one packet with first value types for each property  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var properties = property.ValueType.Properties;  						var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  						if (firstValueProperty != null) {  							WriteValue (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  						} else {  							foreach (var subProperty in properties.Where (p => !p.IsValue)) {  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = subProperty.ValueType.Properties;  									firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  									string subPropertyName = GetSubPropertyName (propertyName' subProperty);  									if (firstValueProperty != null) {  										WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  									} else if (subProperty.ValueType.Name.Contains ("Material")) {  										Property materialProperty = properties.First ();  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialSubProperty.ValueType.Properties;  													firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  													if (firstValueProperty != null) {  														WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  													}  												}  											}  										}  									} else {  										var additionalProperties = subProperty.ValueType.AdditionalProperties;  										if (additionalProperties != null) {  											writer.WriteLine ("using (var a = w2.Open{0}Property(\"prop\"))"' additionalProperties.ValueType.NameWithPascalCase);  											using (writer.OpenScope ()) {  												foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  													writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														properties = additionalProperty.ValueType.Properties;  														firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  														if (firstValueProperty != null) {  															WriteValue (writer' "w3"' id + property.Name' firstValueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' "prop"' additionalProperty.Name));  														}  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			writer.WriteLine ("WriteConstantValuesIndividual();");  			writer.WriteLine ("WriteConstantValuesCustomProperties();");  		}  		writer.WriteLine ("private void WriteConstantValuesIndividual()");  		using (writer.OpenScope ()) {  			// write other value types as individual packets  			foreach (var property in schemaProperties) {  				writer.WriteLine ("WriteConstantValuesIndividual{0}();"' property.NameWithPascalCase);  			}  		}  		foreach (var property in schemaProperties) {  			writer.WriteLine ("private void WriteConstantValuesIndividual{0}()"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("constant_{0}_{1}"' property.Name' valueProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							WriteValue (writer' "w"' id' valueProperty' property' isExtension' propertyName);  						}  					}  				}  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					string subPropertyName = GetSubPropertyName (propertyName' subProperty);  					properties = subProperty.ValueType.Properties;  					foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("constant_{0}_{1}_{2}"' property.Name' subPropertyName' valueProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								WriteValue (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  							}  						}  					}  					if (subProperty.ValueType.Name.Contains ("Material")) {  						// write other values for the first material  						// then write first values for other materials   						// then write remaining values for other materials individually  						var firstMaterialProperty = properties.First ();  						properties = firstMaterialProperty.ValueType.Properties;  						foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  							properties = materialSubProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValue (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialSubProperty.ValueType.Properties;  											var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  											if (firstValueProperty != null) {  												WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							properties = materialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  					}  					var additionalProperties = subProperty.ValueType.AdditionalProperties;  					if (additionalProperties != null) {  						foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  							int i = 0;  							properties = additionalProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' additionalProperties.ValueType.Name' additionalProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									string propName = string.Format ("{0}{1}"' "prop"' i++);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var a = w2.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  									writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValue (writer' "w3"' id + property.Name + subProperty.Name' valueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' propName' additionalProperty.Name));  									}  								}  							}  						}  					}  				}  			}  		}  		// create all types of custom properties  		writer.WriteLine ("private void WriteConstantValuesCustomProperties()");  		using (writer.OpenScope ()) {  			var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  			if (propertiesProperty != null) {  				var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  				if (additionalProperties != null) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = "constant_custom";  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue)) {  								string propName = string.Format ("custom_{0}"' valueProperty.Name);  								writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  								using (writer.OpenScope ()) {  									WriteValue (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  								}  							}  						}  					}  				}  			}  		}  		// create entities using references  		writer.WriteLine ("private void WriteReferenceValues()");  		using (writer.OpenScope ()) {  			// write some positions and double values to use to create reference lists for position lists and double lists later  			for (int i = 1; i <= 2; ++i) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("ConstantPosition{0}"' i);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantPosition{0}')).toBeDefined();"' i);  					var property = schemaProperties.First (p => p.Name == "position");  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var properties = property.ValueType.Properties;  						var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  						WriteValue (writer' "w"' id' firstValueProperty' property' false' property.Name);  					}  				}  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("ConstantDouble{0}"' i);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantDouble{0}')).toBeDefined();"' i);  					var property = schemaProperties.First (p => p.Name == "billboard");  					var properties = property.ValueType.Properties;  					var subProperty = properties.First (p => p.Name == "scale");  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						properties = subProperty.ValueType.Properties;  						var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  						WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' false' string.Format ("{0}.{1}"' property.Name' subProperty.Name));  					}  				}  			}  			// write one big packet with references for everything  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				writer.WriteLine ("packet.WriteId(\"Reference\");");  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Reference')).toBeDefined();");  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var properties = property.ValueType.Properties;  						if (properties.Any (p => p.ValueType.Name == "Reference")) {  							writer.WriteLine ("w.WriteReference(new Reference(\"Constant\"' \"{0}\"));"' propertyName);  							WriteAssertion (writer' isExtension' "expect(e.{0}.getValue(date)).toEqual(constant.{0}.getValue(date));"' propertyName);  						} else {  							foreach (var subProperty in properties.Where (p => !p.IsValue)) {  								properties = subProperty.ValueType.Properties;  								string subPropertyName = GetSubPropertyName (propertyName' subProperty);  								if (properties.Any (p => p.ValueType.Name == "Reference")) {  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										writer.WriteLine ("w2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\")));"' propertyName' subPropertyName);  										WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual(constant.{0}.{1}.getValue(date));"' propertyName' subPropertyName);  									}  								} else if (properties.Any (p => p.ValueType.Name == "ReferenceList")) {  									string targetId = "";  									string[] referencePropertyNames =  {    									};  									if (subProperty.ValueType.Name == "PositionList") {  										targetId = "Position";  										referencePropertyNames = new[] {  											"position"  										};  									} else if (subProperty.ValueType.Name == "DoubleList") {  										targetId = "Double";  										referencePropertyNames = new[] {  											"billboard"'  											"scale"  										};  									}  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										writer.WriteLine ("w2.WriteReferences(CreateList(new Reference(\"Constant{0}1\"' CreateList({1}))' new Reference(\"Constant{0}2\"' CreateList({1}))));"' targetId' string.Join ("' "' referencePropertyNames.Select (n => string.Format ("\"{0}\""' n))));  										WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual([dataSource.entities.getById('Constant{2}1').{3}.getValue(date)' dataSource.entities.getById('Constant{2}2').{3}.getValue(date)]);"' propertyName' subPropertyName' targetId' string.Join ("."' referencePropertyNames));  									}  								} else if (subProperty.ValueType.Name.Contains ("Material")) {  									Property materialProperty = properties.First ();  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												writer.WriteLine ("m2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"{2}\")));"' propertyName' subPropertyName' materialSubProperty.Name);  												WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.{2}.getValue(date)).toEqual(constant.{0}.{1}.{2}.getValue(date));"' propertyName' subPropertyName' materialSubProperty.Name);  											}  										}  									}  								} else {  									var additionalProperties = subProperty.ValueType.AdditionalProperties;  									if (additionalProperties != null) {  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var a = w2.Open{0}Property(\"referenceProp\"))"' additionalProperties.ValueType.NameWithPascalCase);  										using (writer.OpenScope ()) {  											foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													writer.WriteLine ("w3.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"prop\"' \"{2}\")));"' propertyName' subPropertyName' additionalProperty.Name);  													WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.referenceProp.{2}.getValue(date)).toEqual(constant.{0}.{1}.prop.{2}.getValue(date));"' propertyName' subPropertyName' additionalProperty.Name);  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			writer.WriteLine ("WriteReferenceValuesIndividual();");  		}  		writer.WriteLine ("private void WriteReferenceValuesIndividual()");  		using (writer.OpenScope ()) {  			// write other materials as individual packets  			foreach (var property in schemaProperties) {  				writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  			}  			// special case - velocity reference  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  				var property = schemaProperties.First (p => p.Name == "position");  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					// construct a position with specific velocity  					double dx = 1.0;  					double dy = 2.0;  					double dz = 3.0;  					double deltaTime = 60.0;  					double x1 = 1.0;  					double x2 = x1 + dx * deltaTime;  					double y1 = 2.0;  					double y2 = y1 + dy * deltaTime;  					double z1 = 3.0;  					double z2 = z1 + dz * deltaTime;  					string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  					string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  					string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  					string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  					writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  					WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  					WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  				}  			}  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					properties = subProperty.ValueType.Properties;  					if (properties.Any (p => p.Name == "velocityReference")) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  								double expectedX = 1.0;  								double expectedY = 2.0;  								double expectedZ = 3.0;  								bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  								if (isNormalized) {  									NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  								}  								WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  							}  						}  					}  				}  			}  		}  		// write other materials as individual packets  		foreach (var property in schemaProperties) {  			writer.WriteLine ("private void WriteReferenceValuesIndividual{0}()"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					string subPropertyName = GetSubPropertyName (propertyName' subProperty);  					if (subProperty.ValueType.Name.Contains ("Material")) {  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string targetId = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  								string id = string.Format ("reference_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("m2.WriteReference(new Reference(\"{0}\"' CreateList(\"{1}\"' \"{2}\"' \"{3}\")));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  											WriteAssertion (writer' isExtension' "expect(e.{1}.{2}.{3}.getValue(date)).toEqual(dataSource.entities.getById('{0}').{1}.{2}.{3}.getValue(date));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  										}  									}  								}  							}  						}  					}  				}  			}  		}  		// test sampled properties  		writer.WriteLine ("private void WriteSampledValues()");  		using (writer.OpenScope ()) {  			// Write one packet with first value types for each property  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				const string id = "Sampled";  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Sampled')).toBeDefined();");  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					if (property.IsInterpolatable) {  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  							WriteValues (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  						}  					} else {  						var subProperties = properties.Where (p => !p.IsValue && (p.IsInterpolatable || p.ValueType.Name.Contains ("Material"))).ToList ();  						if (subProperties.Any ()) {  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								foreach (var subProperty in subProperties) {  									properties = subProperty.ValueType.Properties;  									string subPropertyName = GetSubPropertyName (propertyName' subProperty);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										if (subProperty.IsInterpolatable) {  											var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  											WriteValues (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  										} else if (subProperty.ValueType.Name.Contains ("Material")) {  											Property materialProperty = properties.First ();  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialProperty.ValueType.Properties;  												foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  													writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														properties = materialSubProperty.ValueType.Properties;  														var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  														WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			writer.WriteLine ("WriteSampledValuesIndividual();");  			writer.WriteLine ("WriteSampledValuesCustomProperties();");  		}  		writer.WriteLine ("private void WriteSampledValuesIndividual()");  		using (writer.OpenScope ()) {  			// write other value types as individual packets  			// split method into multiple methods  			foreach (var property in schemaProperties) {  				writer.WriteLine ("WriteSampledValuesIndividual{0}();"' property.NameWithPascalCase);  			}  		}  		foreach (var property in schemaProperties) {  			writer.WriteLine ("private void WriteSampledValuesIndividual{0}()"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				if (property.IsInterpolatable) {  					foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("sampled_{0}_{1}"' propertyName' valueProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								WriteValues (writer' "w"' id' valueProperty' property' isExtension' propertyName);  							}  						}  					}  				} else {  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						string subPropertyName = GetSubPropertyName (propertyName' subProperty);  						properties = subProperty.ValueType.Properties;  						if (subProperty.IsInterpolatable) {  							foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' valueProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValues (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  									}  								}  							}  						} else if (subProperty.ValueType.Name.Contains ("Material")) {  							// write other values for the first material  							// then write first values for other materials   							// then write remaining values for other materials individually  							var firstMaterialProperty = properties.First ();  							properties = firstMaterialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValues (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialSubProperty.ValueType.Properties;  												var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  												WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  									properties = materialSubProperty.ValueType.Properties;  									foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  										writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  										using (writer.OpenScope ()) {  											string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  											writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  											WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  											writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		// create all types of custom properties  		writer.WriteLine ("private void WriteSampledValuesCustomProperties()");  		using (writer.OpenScope ()) {  			var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  			if (propertiesProperty != null) {  				var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  				if (additionalProperties != null) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = "sampled_custom";  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array)) {  								string propName = string.Format ("custom_{0}"' valueProperty.Name);  								writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  								using (writer.OpenScope ()) {  									WriteValues (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  								}  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	writer.WriteLine ("[TestFixture]");  	writer.WriteLine ("[SuppressMessage(\"ReSharper\"' \"MemberCanBeMadeStatic.Local\")]");  	writer.WriteLine ("public class TestGenerateValidationDocument");  	using (writer.OpenScope ()) {  		writer.WriteLine ("private readonly JulianDate m_documentStartDate = new GregorianDate(2016' 6' 17' 12' 0' 0).ToJulianDate();");  		writer.WriteLine ("private readonly JulianDate m_documentStopDate = new GregorianDate(2016' 6' 17' 13' 0' 0).ToJulianDate();");  		writer.WriteLine ("private TextWriter m_streamWriter;");  		writer.WriteLine ("private TextWriter m_assertionsWriter;");  		writer.WriteLine ("private TextWriter m_extensionsAssertionsWriter;");  		writer.WriteLine ("private CesiumOutputStream m_output;");  		writer.WriteLine ("private CesiumStreamWriter m_writer;");  		writer.WriteLine ("private void WriteAssertionBoth(string s)");  		using (writer.OpenScope ()) {  			writer.WriteLine ("m_assertionsWriter.WriteLine(s);");  			writer.WriteLine ("m_extensionsAssertionsWriter.WriteLine(s);");  		}  		writer.WriteLine ("private static IList<T> CreateList<T>(T t1' T t2)");  		using (writer.OpenScope ()) {  			writer.WriteLine ("return new List<T> { t1' t2 };");  		}  		writer.WriteLine ("private static IList<T> CreateList<T>(params T[] ts)");  		using (writer.OpenScope ()) {  			writer.WriteLine ("return ts;");  		}  		writer.WriteLine ("[Test]");  		writer.WriteLine ("public void GenerateValidationDocument()");  		var schemaProperties = schema.Properties.Where (p => p.Name != "clock" && p.Name != "availability" && !p.ValueType.IsSchemaFromType).Where (p => p.Name != "properties").ToList ();  		using (writer.OpenScope ()) {  			writer.WriteLine ("using (m_streamWriter = new StreamWriter(\"ValidationDocument.czml\"))");  			writer.WriteLine ("using (m_assertionsWriter = new StreamWriter(\"ValidationDocumentAssertions.js\"))");  			writer.WriteLine ("using (m_extensionsAssertionsWriter = new StreamWriter(\"ValidationDocumentExtensionAssertions.js\"))");  			using (writer.OpenScope ()) {  				WriteAssertionBoth (writer' "return CzmlDataSource.load('Data/CZML/ValidationDocument.czml').then(function(dataSource) {");  				s_assertionIndent++;  				WriteAssertionBoth (writer' "/*jshint -W120 */");  				WriteAssertionBoth (writer' "var e;");  				WriteAssertionBoth (writer' "var date;");  				WriteAssertionBoth (writer' "var documentStartDate = JulianDate.fromIso8601('2016-06-17T12:00:00Z');");  				WriteAssertionBoth (writer' "var documentStopDate = JulianDate.fromIso8601('2016-06-17T13:00:00Z');");  				writer.WriteLine ("m_output = new CesiumOutputStream(m_streamWriter) { PrettyFormatting = true };");  				writer.WriteLine ("m_writer = new CesiumStreamWriter();");  				writer.WriteLine ("m_output.WriteStartSequence();");  				// Java has a limit on the size of a single method (65535 bytes) so we have to break up all this code in multiple methods  				writer.WriteLine ("WriteClock();");  				writer.WriteLine ("WriteConstantValues();");  				writer.WriteLine ("WriteReferenceValues();");  				writer.WriteLine ("WriteSampledValues();");  				writer.WriteLine ("m_output.WriteEndSequence();");  				s_assertionIndent--;  				WriteAssertionBoth (writer' "});");  				s_assertionIndent++;  			}  		}  		writer.WriteLine ("private void WriteClock()");  		using (writer.OpenScope ()) {  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				writer.WriteLine ("packet.WriteId(\"document\");");  				writer.WriteLine ("packet.WriteName(\"ValidationDocument\");");  				writer.WriteLine ("packet.WriteVersion(\"1.0\");");  				writer.WriteLine ("using (var clock = packet.OpenClockProperty())");  				using (writer.OpenScope ()) {  					writer.WriteLine ("clock.WriteInterval(m_documentStartDate' m_documentStopDate);");  					WriteAssertion (writer' false' "expect(dataSource.clock.startTime).toEqual(documentStartDate);");  					WriteAssertion (writer' false' "expect(dataSource.clock.stopTime).toEqual(documentStopDate);");  					writer.WriteLine ("clock.WriteCurrentTime(m_documentStartDate);");  					WriteAssertion (writer' false' "expect(dataSource.clock.currentTime).toEqual(documentStartDate);");  					writer.WriteLine ("clock.WriteMultiplier(1.0);");  					WriteAssertion (writer' false' "expect(dataSource.clock.multiplier).toEqual(1.0);");  					writer.WriteLine ("clock.WriteRange(ClockRange.Unbounded);");  					WriteAssertion (writer' false' "expect(dataSource.clock.clockRange).toEqual(ClockRange.UNBOUNDED);");  					writer.WriteLine ("clock.WriteStep(ClockStep.SystemClockMultiplier);");  					WriteAssertion (writer' false' "expect(dataSource.clock.clockStep).toEqual(ClockStep.SYSTEM_CLOCK_MULTIPLIER);");  				}  			}  		}  		writer.WriteLine ("private void WriteConstantValues()");  		using (writer.OpenScope ()) {  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				const string id = "Constant";  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "var constant = e = dataSource.entities.getById('Constant');");  				WriteAssertionBoth (writer' "expect(e).toBeDefined();");  				WriteAssertionBoth (writer' "date = JulianDate.now();");  				// Write one packet with first value types for each property  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var properties = property.ValueType.Properties;  						var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  						if (firstValueProperty != null) {  							WriteValue (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  						} else {  							foreach (var subProperty in properties.Where (p => !p.IsValue)) {  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = subProperty.ValueType.Properties;  									firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  									string subPropertyName = GetSubPropertyName (propertyName' subProperty);  									if (firstValueProperty != null) {  										WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  									} else if (subProperty.ValueType.Name.Contains ("Material")) {  										Property materialProperty = properties.First ();  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialSubProperty.ValueType.Properties;  													firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  													if (firstValueProperty != null) {  														WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  													}  												}  											}  										}  									} else {  										var additionalProperties = subProperty.ValueType.AdditionalProperties;  										if (additionalProperties != null) {  											writer.WriteLine ("using (var a = w2.Open{0}Property(\"prop\"))"' additionalProperties.ValueType.NameWithPascalCase);  											using (writer.OpenScope ()) {  												foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  													writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														properties = additionalProperty.ValueType.Properties;  														firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  														if (firstValueProperty != null) {  															WriteValue (writer' "w3"' id + property.Name' firstValueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' "prop"' additionalProperty.Name));  														}  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			writer.WriteLine ("WriteConstantValuesIndividual();");  			writer.WriteLine ("WriteConstantValuesCustomProperties();");  		}  		writer.WriteLine ("private void WriteConstantValuesIndividual()");  		using (writer.OpenScope ()) {  			// write other value types as individual packets  			foreach (var property in schemaProperties) {  				writer.WriteLine ("WriteConstantValuesIndividual{0}();"' property.NameWithPascalCase);  			}  		}  		foreach (var property in schemaProperties) {  			writer.WriteLine ("private void WriteConstantValuesIndividual{0}()"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("constant_{0}_{1}"' property.Name' valueProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							WriteValue (writer' "w"' id' valueProperty' property' isExtension' propertyName);  						}  					}  				}  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					string subPropertyName = GetSubPropertyName (propertyName' subProperty);  					properties = subProperty.ValueType.Properties;  					foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("constant_{0}_{1}_{2}"' property.Name' subPropertyName' valueProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								WriteValue (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  							}  						}  					}  					if (subProperty.ValueType.Name.Contains ("Material")) {  						// write other values for the first material  						// then write first values for other materials   						// then write remaining values for other materials individually  						var firstMaterialProperty = properties.First ();  						properties = firstMaterialProperty.ValueType.Properties;  						foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  							properties = materialSubProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValue (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialSubProperty.ValueType.Properties;  											var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  											if (firstValueProperty != null) {  												WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							properties = materialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  					}  					var additionalProperties = subProperty.ValueType.AdditionalProperties;  					if (additionalProperties != null) {  						foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  							int i = 0;  							properties = additionalProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' additionalProperties.ValueType.Name' additionalProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									string propName = string.Format ("{0}{1}"' "prop"' i++);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var a = w2.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  									writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValue (writer' "w3"' id + property.Name + subProperty.Name' valueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' propName' additionalProperty.Name));  									}  								}  							}  						}  					}  				}  			}  		}  		// create all types of custom properties  		writer.WriteLine ("private void WriteConstantValuesCustomProperties()");  		using (writer.OpenScope ()) {  			var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  			if (propertiesProperty != null) {  				var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  				if (additionalProperties != null) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = "constant_custom";  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue)) {  								string propName = string.Format ("custom_{0}"' valueProperty.Name);  								writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  								using (writer.OpenScope ()) {  									WriteValue (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  								}  							}  						}  					}  				}  			}  		}  		// create entities using references  		writer.WriteLine ("private void WriteReferenceValues()");  		using (writer.OpenScope ()) {  			// write some positions and double values to use to create reference lists for position lists and double lists later  			for (int i = 1; i <= 2; ++i) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("ConstantPosition{0}"' i);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantPosition{0}')).toBeDefined();"' i);  					var property = schemaProperties.First (p => p.Name == "position");  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var properties = property.ValueType.Properties;  						var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  						WriteValue (writer' "w"' id' firstValueProperty' property' false' property.Name);  					}  				}  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("ConstantDouble{0}"' i);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantDouble{0}')).toBeDefined();"' i);  					var property = schemaProperties.First (p => p.Name == "billboard");  					var properties = property.ValueType.Properties;  					var subProperty = properties.First (p => p.Name == "scale");  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						properties = subProperty.ValueType.Properties;  						var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  						WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' false' string.Format ("{0}.{1}"' property.Name' subProperty.Name));  					}  				}  			}  			// write one big packet with references for everything  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				writer.WriteLine ("packet.WriteId(\"Reference\");");  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Reference')).toBeDefined();");  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var properties = property.ValueType.Properties;  						if (properties.Any (p => p.ValueType.Name == "Reference")) {  							writer.WriteLine ("w.WriteReference(new Reference(\"Constant\"' \"{0}\"));"' propertyName);  							WriteAssertion (writer' isExtension' "expect(e.{0}.getValue(date)).toEqual(constant.{0}.getValue(date));"' propertyName);  						} else {  							foreach (var subProperty in properties.Where (p => !p.IsValue)) {  								properties = subProperty.ValueType.Properties;  								string subPropertyName = GetSubPropertyName (propertyName' subProperty);  								if (properties.Any (p => p.ValueType.Name == "Reference")) {  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										writer.WriteLine ("w2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\")));"' propertyName' subPropertyName);  										WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual(constant.{0}.{1}.getValue(date));"' propertyName' subPropertyName);  									}  								} else if (properties.Any (p => p.ValueType.Name == "ReferenceList")) {  									string targetId = "";  									string[] referencePropertyNames =  {    									};  									if (subProperty.ValueType.Name == "PositionList") {  										targetId = "Position";  										referencePropertyNames = new[] {  											"position"  										};  									} else if (subProperty.ValueType.Name == "DoubleList") {  										targetId = "Double";  										referencePropertyNames = new[] {  											"billboard"'  											"scale"  										};  									}  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										writer.WriteLine ("w2.WriteReferences(CreateList(new Reference(\"Constant{0}1\"' CreateList({1}))' new Reference(\"Constant{0}2\"' CreateList({1}))));"' targetId' string.Join ("' "' referencePropertyNames.Select (n => string.Format ("\"{0}\""' n))));  										WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual([dataSource.entities.getById('Constant{2}1').{3}.getValue(date)' dataSource.entities.getById('Constant{2}2').{3}.getValue(date)]);"' propertyName' subPropertyName' targetId' string.Join ("."' referencePropertyNames));  									}  								} else if (subProperty.ValueType.Name.Contains ("Material")) {  									Property materialProperty = properties.First ();  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												writer.WriteLine ("m2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"{2}\")));"' propertyName' subPropertyName' materialSubProperty.Name);  												WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.{2}.getValue(date)).toEqual(constant.{0}.{1}.{2}.getValue(date));"' propertyName' subPropertyName' materialSubProperty.Name);  											}  										}  									}  								} else {  									var additionalProperties = subProperty.ValueType.AdditionalProperties;  									if (additionalProperties != null) {  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var a = w2.Open{0}Property(\"referenceProp\"))"' additionalProperties.ValueType.NameWithPascalCase);  										using (writer.OpenScope ()) {  											foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													writer.WriteLine ("w3.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"prop\"' \"{2}\")));"' propertyName' subPropertyName' additionalProperty.Name);  													WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.referenceProp.{2}.getValue(date)).toEqual(constant.{0}.{1}.prop.{2}.getValue(date));"' propertyName' subPropertyName' additionalProperty.Name);  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			writer.WriteLine ("WriteReferenceValuesIndividual();");  		}  		writer.WriteLine ("private void WriteReferenceValuesIndividual()");  		using (writer.OpenScope ()) {  			// write other materials as individual packets  			foreach (var property in schemaProperties) {  				writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  			}  			// special case - velocity reference  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  				var property = schemaProperties.First (p => p.Name == "position");  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					// construct a position with specific velocity  					double dx = 1.0;  					double dy = 2.0;  					double dz = 3.0;  					double deltaTime = 60.0;  					double x1 = 1.0;  					double x2 = x1 + dx * deltaTime;  					double y1 = 2.0;  					double y2 = y1 + dy * deltaTime;  					double z1 = 3.0;  					double z2 = z1 + dz * deltaTime;  					string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  					string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  					string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  					string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  					writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  					WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  					WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  				}  			}  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					properties = subProperty.ValueType.Properties;  					if (properties.Any (p => p.Name == "velocityReference")) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  								double expectedX = 1.0;  								double expectedY = 2.0;  								double expectedZ = 3.0;  								bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  								if (isNormalized) {  									NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  								}  								WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  							}  						}  					}  				}  			}  		}  		// write other materials as individual packets  		foreach (var property in schemaProperties) {  			writer.WriteLine ("private void WriteReferenceValuesIndividual{0}()"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					string subPropertyName = GetSubPropertyName (propertyName' subProperty);  					if (subProperty.ValueType.Name.Contains ("Material")) {  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string targetId = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  								string id = string.Format ("reference_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("m2.WriteReference(new Reference(\"{0}\"' CreateList(\"{1}\"' \"{2}\"' \"{3}\")));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  											WriteAssertion (writer' isExtension' "expect(e.{1}.{2}.{3}.getValue(date)).toEqual(dataSource.entities.getById('{0}').{1}.{2}.{3}.getValue(date));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  										}  									}  								}  							}  						}  					}  				}  			}  		}  		// test sampled properties  		writer.WriteLine ("private void WriteSampledValues()");  		using (writer.OpenScope ()) {  			// Write one packet with first value types for each property  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				const string id = "Sampled";  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Sampled')).toBeDefined();");  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					if (property.IsInterpolatable) {  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  							WriteValues (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  						}  					} else {  						var subProperties = properties.Where (p => !p.IsValue && (p.IsInterpolatable || p.ValueType.Name.Contains ("Material"))).ToList ();  						if (subProperties.Any ()) {  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								foreach (var subProperty in subProperties) {  									properties = subProperty.ValueType.Properties;  									string subPropertyName = GetSubPropertyName (propertyName' subProperty);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										if (subProperty.IsInterpolatable) {  											var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  											WriteValues (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  										} else if (subProperty.ValueType.Name.Contains ("Material")) {  											Property materialProperty = properties.First ();  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialProperty.ValueType.Properties;  												foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  													writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														properties = materialSubProperty.ValueType.Properties;  														var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  														WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			writer.WriteLine ("WriteSampledValuesIndividual();");  			writer.WriteLine ("WriteSampledValuesCustomProperties();");  		}  		writer.WriteLine ("private void WriteSampledValuesIndividual()");  		using (writer.OpenScope ()) {  			// write other value types as individual packets  			// split method into multiple methods  			foreach (var property in schemaProperties) {  				writer.WriteLine ("WriteSampledValuesIndividual{0}();"' property.NameWithPascalCase);  			}  		}  		foreach (var property in schemaProperties) {  			writer.WriteLine ("private void WriteSampledValuesIndividual{0}()"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				if (property.IsInterpolatable) {  					foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("sampled_{0}_{1}"' propertyName' valueProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								WriteValues (writer' "w"' id' valueProperty' property' isExtension' propertyName);  							}  						}  					}  				} else {  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						string subPropertyName = GetSubPropertyName (propertyName' subProperty);  						properties = subProperty.ValueType.Properties;  						if (subProperty.IsInterpolatable) {  							foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' valueProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValues (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  									}  								}  							}  						} else if (subProperty.ValueType.Name.Contains ("Material")) {  							// write other values for the first material  							// then write first values for other materials   							// then write remaining values for other materials individually  							var firstMaterialProperty = properties.First ();  							properties = firstMaterialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValues (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialSubProperty.ValueType.Properties;  												var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  												WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  									properties = materialSubProperty.ValueType.Properties;  									foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  										writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  										using (writer.OpenScope ()) {  											string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  											writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  											WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  											writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		// create all types of custom properties  		writer.WriteLine ("private void WriteSampledValuesCustomProperties()");  		using (writer.OpenScope ()) {  			var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  			if (propertiesProperty != null) {  				var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  				if (additionalProperties != null) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = "sampled_custom";  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array)) {  								string propName = string.Format ("custom_{0}"' valueProperty.Name);  								writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  								using (writer.OpenScope ()) {  									WriteValues (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  								}  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	writer.WriteLine ("[TestFixture]");  	writer.WriteLine ("[SuppressMessage(\"ReSharper\"' \"MemberCanBeMadeStatic.Local\")]");  	writer.WriteLine ("public class TestGenerateValidationDocument");  	using (writer.OpenScope ()) {  		writer.WriteLine ("private readonly JulianDate m_documentStartDate = new GregorianDate(2016' 6' 17' 12' 0' 0).ToJulianDate();");  		writer.WriteLine ("private readonly JulianDate m_documentStopDate = new GregorianDate(2016' 6' 17' 13' 0' 0).ToJulianDate();");  		writer.WriteLine ("private TextWriter m_streamWriter;");  		writer.WriteLine ("private TextWriter m_assertionsWriter;");  		writer.WriteLine ("private TextWriter m_extensionsAssertionsWriter;");  		writer.WriteLine ("private CesiumOutputStream m_output;");  		writer.WriteLine ("private CesiumStreamWriter m_writer;");  		writer.WriteLine ("private void WriteAssertionBoth(string s)");  		using (writer.OpenScope ()) {  			writer.WriteLine ("m_assertionsWriter.WriteLine(s);");  			writer.WriteLine ("m_extensionsAssertionsWriter.WriteLine(s);");  		}  		writer.WriteLine ("private static IList<T> CreateList<T>(T t1' T t2)");  		using (writer.OpenScope ()) {  			writer.WriteLine ("return new List<T> { t1' t2 };");  		}  		writer.WriteLine ("private static IList<T> CreateList<T>(params T[] ts)");  		using (writer.OpenScope ()) {  			writer.WriteLine ("return ts;");  		}  		writer.WriteLine ("[Test]");  		writer.WriteLine ("public void GenerateValidationDocument()");  		var schemaProperties = schema.Properties.Where (p => p.Name != "clock" && p.Name != "availability" && !p.ValueType.IsSchemaFromType).Where (p => p.Name != "properties").ToList ();  		using (writer.OpenScope ()) {  			writer.WriteLine ("using (m_streamWriter = new StreamWriter(\"ValidationDocument.czml\"))");  			writer.WriteLine ("using (m_assertionsWriter = new StreamWriter(\"ValidationDocumentAssertions.js\"))");  			writer.WriteLine ("using (m_extensionsAssertionsWriter = new StreamWriter(\"ValidationDocumentExtensionAssertions.js\"))");  			using (writer.OpenScope ()) {  				WriteAssertionBoth (writer' "return CzmlDataSource.load('Data/CZML/ValidationDocument.czml').then(function(dataSource) {");  				s_assertionIndent++;  				WriteAssertionBoth (writer' "/*jshint -W120 */");  				WriteAssertionBoth (writer' "var e;");  				WriteAssertionBoth (writer' "var date;");  				WriteAssertionBoth (writer' "var documentStartDate = JulianDate.fromIso8601('2016-06-17T12:00:00Z');");  				WriteAssertionBoth (writer' "var documentStopDate = JulianDate.fromIso8601('2016-06-17T13:00:00Z');");  				writer.WriteLine ("m_output = new CesiumOutputStream(m_streamWriter) { PrettyFormatting = true };");  				writer.WriteLine ("m_writer = new CesiumStreamWriter();");  				writer.WriteLine ("m_output.WriteStartSequence();");  				// Java has a limit on the size of a single method (65535 bytes) so we have to break up all this code in multiple methods  				writer.WriteLine ("WriteClock();");  				writer.WriteLine ("WriteConstantValues();");  				writer.WriteLine ("WriteReferenceValues();");  				writer.WriteLine ("WriteSampledValues();");  				writer.WriteLine ("m_output.WriteEndSequence();");  				s_assertionIndent--;  				WriteAssertionBoth (writer' "});");  				s_assertionIndent++;  			}  		}  		writer.WriteLine ("private void WriteClock()");  		using (writer.OpenScope ()) {  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				writer.WriteLine ("packet.WriteId(\"document\");");  				writer.WriteLine ("packet.WriteName(\"ValidationDocument\");");  				writer.WriteLine ("packet.WriteVersion(\"1.0\");");  				writer.WriteLine ("using (var clock = packet.OpenClockProperty())");  				using (writer.OpenScope ()) {  					writer.WriteLine ("clock.WriteInterval(m_documentStartDate' m_documentStopDate);");  					WriteAssertion (writer' false' "expect(dataSource.clock.startTime).toEqual(documentStartDate);");  					WriteAssertion (writer' false' "expect(dataSource.clock.stopTime).toEqual(documentStopDate);");  					writer.WriteLine ("clock.WriteCurrentTime(m_documentStartDate);");  					WriteAssertion (writer' false' "expect(dataSource.clock.currentTime).toEqual(documentStartDate);");  					writer.WriteLine ("clock.WriteMultiplier(1.0);");  					WriteAssertion (writer' false' "expect(dataSource.clock.multiplier).toEqual(1.0);");  					writer.WriteLine ("clock.WriteRange(ClockRange.Unbounded);");  					WriteAssertion (writer' false' "expect(dataSource.clock.clockRange).toEqual(ClockRange.UNBOUNDED);");  					writer.WriteLine ("clock.WriteStep(ClockStep.SystemClockMultiplier);");  					WriteAssertion (writer' false' "expect(dataSource.clock.clockStep).toEqual(ClockStep.SYSTEM_CLOCK_MULTIPLIER);");  				}  			}  		}  		writer.WriteLine ("private void WriteConstantValues()");  		using (writer.OpenScope ()) {  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				const string id = "Constant";  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "var constant = e = dataSource.entities.getById('Constant');");  				WriteAssertionBoth (writer' "expect(e).toBeDefined();");  				WriteAssertionBoth (writer' "date = JulianDate.now();");  				// Write one packet with first value types for each property  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var properties = property.ValueType.Properties;  						var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  						if (firstValueProperty != null) {  							WriteValue (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  						} else {  							foreach (var subProperty in properties.Where (p => !p.IsValue)) {  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = subProperty.ValueType.Properties;  									firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  									string subPropertyName = GetSubPropertyName (propertyName' subProperty);  									if (firstValueProperty != null) {  										WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  									} else if (subProperty.ValueType.Name.Contains ("Material")) {  										Property materialProperty = properties.First ();  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialSubProperty.ValueType.Properties;  													firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  													if (firstValueProperty != null) {  														WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  													}  												}  											}  										}  									} else {  										var additionalProperties = subProperty.ValueType.AdditionalProperties;  										if (additionalProperties != null) {  											writer.WriteLine ("using (var a = w2.Open{0}Property(\"prop\"))"' additionalProperties.ValueType.NameWithPascalCase);  											using (writer.OpenScope ()) {  												foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  													writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														properties = additionalProperty.ValueType.Properties;  														firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  														if (firstValueProperty != null) {  															WriteValue (writer' "w3"' id + property.Name' firstValueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' "prop"' additionalProperty.Name));  														}  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			writer.WriteLine ("WriteConstantValuesIndividual();");  			writer.WriteLine ("WriteConstantValuesCustomProperties();");  		}  		writer.WriteLine ("private void WriteConstantValuesIndividual()");  		using (writer.OpenScope ()) {  			// write other value types as individual packets  			foreach (var property in schemaProperties) {  				writer.WriteLine ("WriteConstantValuesIndividual{0}();"' property.NameWithPascalCase);  			}  		}  		foreach (var property in schemaProperties) {  			writer.WriteLine ("private void WriteConstantValuesIndividual{0}()"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("constant_{0}_{1}"' property.Name' valueProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							WriteValue (writer' "w"' id' valueProperty' property' isExtension' propertyName);  						}  					}  				}  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					string subPropertyName = GetSubPropertyName (propertyName' subProperty);  					properties = subProperty.ValueType.Properties;  					foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("constant_{0}_{1}_{2}"' property.Name' subPropertyName' valueProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								WriteValue (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  							}  						}  					}  					if (subProperty.ValueType.Name.Contains ("Material")) {  						// write other values for the first material  						// then write first values for other materials   						// then write remaining values for other materials individually  						var firstMaterialProperty = properties.First ();  						properties = firstMaterialProperty.ValueType.Properties;  						foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  							properties = materialSubProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValue (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialSubProperty.ValueType.Properties;  											var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  											if (firstValueProperty != null) {  												WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							properties = materialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  					}  					var additionalProperties = subProperty.ValueType.AdditionalProperties;  					if (additionalProperties != null) {  						foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  							int i = 0;  							properties = additionalProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' additionalProperties.ValueType.Name' additionalProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									string propName = string.Format ("{0}{1}"' "prop"' i++);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var a = w2.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  									writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValue (writer' "w3"' id + property.Name + subProperty.Name' valueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' propName' additionalProperty.Name));  									}  								}  							}  						}  					}  				}  			}  		}  		// create all types of custom properties  		writer.WriteLine ("private void WriteConstantValuesCustomProperties()");  		using (writer.OpenScope ()) {  			var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  			if (propertiesProperty != null) {  				var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  				if (additionalProperties != null) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = "constant_custom";  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue)) {  								string propName = string.Format ("custom_{0}"' valueProperty.Name);  								writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  								using (writer.OpenScope ()) {  									WriteValue (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  								}  							}  						}  					}  				}  			}  		}  		// create entities using references  		writer.WriteLine ("private void WriteReferenceValues()");  		using (writer.OpenScope ()) {  			// write some positions and double values to use to create reference lists for position lists and double lists later  			for (int i = 1; i <= 2; ++i) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("ConstantPosition{0}"' i);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantPosition{0}')).toBeDefined();"' i);  					var property = schemaProperties.First (p => p.Name == "position");  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var properties = property.ValueType.Properties;  						var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  						WriteValue (writer' "w"' id' firstValueProperty' property' false' property.Name);  					}  				}  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("ConstantDouble{0}"' i);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantDouble{0}')).toBeDefined();"' i);  					var property = schemaProperties.First (p => p.Name == "billboard");  					var properties = property.ValueType.Properties;  					var subProperty = properties.First (p => p.Name == "scale");  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						properties = subProperty.ValueType.Properties;  						var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  						WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' false' string.Format ("{0}.{1}"' property.Name' subProperty.Name));  					}  				}  			}  			// write one big packet with references for everything  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				writer.WriteLine ("packet.WriteId(\"Reference\");");  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Reference')).toBeDefined();");  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var properties = property.ValueType.Properties;  						if (properties.Any (p => p.ValueType.Name == "Reference")) {  							writer.WriteLine ("w.WriteReference(new Reference(\"Constant\"' \"{0}\"));"' propertyName);  							WriteAssertion (writer' isExtension' "expect(e.{0}.getValue(date)).toEqual(constant.{0}.getValue(date));"' propertyName);  						} else {  							foreach (var subProperty in properties.Where (p => !p.IsValue)) {  								properties = subProperty.ValueType.Properties;  								string subPropertyName = GetSubPropertyName (propertyName' subProperty);  								if (properties.Any (p => p.ValueType.Name == "Reference")) {  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										writer.WriteLine ("w2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\")));"' propertyName' subPropertyName);  										WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual(constant.{0}.{1}.getValue(date));"' propertyName' subPropertyName);  									}  								} else if (properties.Any (p => p.ValueType.Name == "ReferenceList")) {  									string targetId = "";  									string[] referencePropertyNames =  {    									};  									if (subProperty.ValueType.Name == "PositionList") {  										targetId = "Position";  										referencePropertyNames = new[] {  											"position"  										};  									} else if (subProperty.ValueType.Name == "DoubleList") {  										targetId = "Double";  										referencePropertyNames = new[] {  											"billboard"'  											"scale"  										};  									}  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										writer.WriteLine ("w2.WriteReferences(CreateList(new Reference(\"Constant{0}1\"' CreateList({1}))' new Reference(\"Constant{0}2\"' CreateList({1}))));"' targetId' string.Join ("' "' referencePropertyNames.Select (n => string.Format ("\"{0}\""' n))));  										WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual([dataSource.entities.getById('Constant{2}1').{3}.getValue(date)' dataSource.entities.getById('Constant{2}2').{3}.getValue(date)]);"' propertyName' subPropertyName' targetId' string.Join ("."' referencePropertyNames));  									}  								} else if (subProperty.ValueType.Name.Contains ("Material")) {  									Property materialProperty = properties.First ();  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												writer.WriteLine ("m2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"{2}\")));"' propertyName' subPropertyName' materialSubProperty.Name);  												WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.{2}.getValue(date)).toEqual(constant.{0}.{1}.{2}.getValue(date));"' propertyName' subPropertyName' materialSubProperty.Name);  											}  										}  									}  								} else {  									var additionalProperties = subProperty.ValueType.AdditionalProperties;  									if (additionalProperties != null) {  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var a = w2.Open{0}Property(\"referenceProp\"))"' additionalProperties.ValueType.NameWithPascalCase);  										using (writer.OpenScope ()) {  											foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													writer.WriteLine ("w3.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"prop\"' \"{2}\")));"' propertyName' subPropertyName' additionalProperty.Name);  													WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.referenceProp.{2}.getValue(date)).toEqual(constant.{0}.{1}.prop.{2}.getValue(date));"' propertyName' subPropertyName' additionalProperty.Name);  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			writer.WriteLine ("WriteReferenceValuesIndividual();");  		}  		writer.WriteLine ("private void WriteReferenceValuesIndividual()");  		using (writer.OpenScope ()) {  			// write other materials as individual packets  			foreach (var property in schemaProperties) {  				writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  			}  			// special case - velocity reference  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  				var property = schemaProperties.First (p => p.Name == "position");  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					// construct a position with specific velocity  					double dx = 1.0;  					double dy = 2.0;  					double dz = 3.0;  					double deltaTime = 60.0;  					double x1 = 1.0;  					double x2 = x1 + dx * deltaTime;  					double y1 = 2.0;  					double y2 = y1 + dy * deltaTime;  					double z1 = 3.0;  					double z2 = z1 + dz * deltaTime;  					string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  					string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  					string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  					string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  					writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  					WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  					WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  				}  			}  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					properties = subProperty.ValueType.Properties;  					if (properties.Any (p => p.Name == "velocityReference")) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  								double expectedX = 1.0;  								double expectedY = 2.0;  								double expectedZ = 3.0;  								bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  								if (isNormalized) {  									NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  								}  								WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  							}  						}  					}  				}  			}  		}  		// write other materials as individual packets  		foreach (var property in schemaProperties) {  			writer.WriteLine ("private void WriteReferenceValuesIndividual{0}()"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					string subPropertyName = GetSubPropertyName (propertyName' subProperty);  					if (subProperty.ValueType.Name.Contains ("Material")) {  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string targetId = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  								string id = string.Format ("reference_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("m2.WriteReference(new Reference(\"{0}\"' CreateList(\"{1}\"' \"{2}\"' \"{3}\")));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  											WriteAssertion (writer' isExtension' "expect(e.{1}.{2}.{3}.getValue(date)).toEqual(dataSource.entities.getById('{0}').{1}.{2}.{3}.getValue(date));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  										}  									}  								}  							}  						}  					}  				}  			}  		}  		// test sampled properties  		writer.WriteLine ("private void WriteSampledValues()");  		using (writer.OpenScope ()) {  			// Write one packet with first value types for each property  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				const string id = "Sampled";  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Sampled')).toBeDefined();");  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					if (property.IsInterpolatable) {  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  							WriteValues (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  						}  					} else {  						var subProperties = properties.Where (p => !p.IsValue && (p.IsInterpolatable || p.ValueType.Name.Contains ("Material"))).ToList ();  						if (subProperties.Any ()) {  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								foreach (var subProperty in subProperties) {  									properties = subProperty.ValueType.Properties;  									string subPropertyName = GetSubPropertyName (propertyName' subProperty);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										if (subProperty.IsInterpolatable) {  											var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  											WriteValues (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  										} else if (subProperty.ValueType.Name.Contains ("Material")) {  											Property materialProperty = properties.First ();  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialProperty.ValueType.Properties;  												foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  													writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														properties = materialSubProperty.ValueType.Properties;  														var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  														WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			writer.WriteLine ("WriteSampledValuesIndividual();");  			writer.WriteLine ("WriteSampledValuesCustomProperties();");  		}  		writer.WriteLine ("private void WriteSampledValuesIndividual()");  		using (writer.OpenScope ()) {  			// write other value types as individual packets  			// split method into multiple methods  			foreach (var property in schemaProperties) {  				writer.WriteLine ("WriteSampledValuesIndividual{0}();"' property.NameWithPascalCase);  			}  		}  		foreach (var property in schemaProperties) {  			writer.WriteLine ("private void WriteSampledValuesIndividual{0}()"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				if (property.IsInterpolatable) {  					foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("sampled_{0}_{1}"' propertyName' valueProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								WriteValues (writer' "w"' id' valueProperty' property' isExtension' propertyName);  							}  						}  					}  				} else {  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						string subPropertyName = GetSubPropertyName (propertyName' subProperty);  						properties = subProperty.ValueType.Properties;  						if (subProperty.IsInterpolatable) {  							foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' valueProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValues (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  									}  								}  							}  						} else if (subProperty.ValueType.Name.Contains ("Material")) {  							// write other values for the first material  							// then write first values for other materials   							// then write remaining values for other materials individually  							var firstMaterialProperty = properties.First ();  							properties = firstMaterialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValues (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialSubProperty.ValueType.Properties;  												var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  												WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  									properties = materialSubProperty.ValueType.Properties;  									foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  										writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  										using (writer.OpenScope ()) {  											string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  											writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  											WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  											writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		// create all types of custom properties  		writer.WriteLine ("private void WriteSampledValuesCustomProperties()");  		using (writer.OpenScope ()) {  			var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  			if (propertiesProperty != null) {  				var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  				if (additionalProperties != null) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = "sampled_custom";  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array)) {  								string propName = string.Format ("custom_{0}"' valueProperty.Name);  								writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  								using (writer.OpenScope ()) {  									WriteValues (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  								}  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	writer.WriteLine ("[TestFixture]");  	writer.WriteLine ("[SuppressMessage(\"ReSharper\"' \"MemberCanBeMadeStatic.Local\")]");  	writer.WriteLine ("public class TestGenerateValidationDocument");  	using (writer.OpenScope ()) {  		writer.WriteLine ("private readonly JulianDate m_documentStartDate = new GregorianDate(2016' 6' 17' 12' 0' 0).ToJulianDate();");  		writer.WriteLine ("private readonly JulianDate m_documentStopDate = new GregorianDate(2016' 6' 17' 13' 0' 0).ToJulianDate();");  		writer.WriteLine ("private TextWriter m_streamWriter;");  		writer.WriteLine ("private TextWriter m_assertionsWriter;");  		writer.WriteLine ("private TextWriter m_extensionsAssertionsWriter;");  		writer.WriteLine ("private CesiumOutputStream m_output;");  		writer.WriteLine ("private CesiumStreamWriter m_writer;");  		writer.WriteLine ("private void WriteAssertionBoth(string s)");  		using (writer.OpenScope ()) {  			writer.WriteLine ("m_assertionsWriter.WriteLine(s);");  			writer.WriteLine ("m_extensionsAssertionsWriter.WriteLine(s);");  		}  		writer.WriteLine ("private static IList<T> CreateList<T>(T t1' T t2)");  		using (writer.OpenScope ()) {  			writer.WriteLine ("return new List<T> { t1' t2 };");  		}  		writer.WriteLine ("private static IList<T> CreateList<T>(params T[] ts)");  		using (writer.OpenScope ()) {  			writer.WriteLine ("return ts;");  		}  		writer.WriteLine ("[Test]");  		writer.WriteLine ("public void GenerateValidationDocument()");  		var schemaProperties = schema.Properties.Where (p => p.Name != "clock" && p.Name != "availability" && !p.ValueType.IsSchemaFromType).Where (p => p.Name != "properties").ToList ();  		using (writer.OpenScope ()) {  			writer.WriteLine ("using (m_streamWriter = new StreamWriter(\"ValidationDocument.czml\"))");  			writer.WriteLine ("using (m_assertionsWriter = new StreamWriter(\"ValidationDocumentAssertions.js\"))");  			writer.WriteLine ("using (m_extensionsAssertionsWriter = new StreamWriter(\"ValidationDocumentExtensionAssertions.js\"))");  			using (writer.OpenScope ()) {  				WriteAssertionBoth (writer' "return CzmlDataSource.load('Data/CZML/ValidationDocument.czml').then(function(dataSource) {");  				s_assertionIndent++;  				WriteAssertionBoth (writer' "/*jshint -W120 */");  				WriteAssertionBoth (writer' "var e;");  				WriteAssertionBoth (writer' "var date;");  				WriteAssertionBoth (writer' "var documentStartDate = JulianDate.fromIso8601('2016-06-17T12:00:00Z');");  				WriteAssertionBoth (writer' "var documentStopDate = JulianDate.fromIso8601('2016-06-17T13:00:00Z');");  				writer.WriteLine ("m_output = new CesiumOutputStream(m_streamWriter) { PrettyFormatting = true };");  				writer.WriteLine ("m_writer = new CesiumStreamWriter();");  				writer.WriteLine ("m_output.WriteStartSequence();");  				// Java has a limit on the size of a single method (65535 bytes) so we have to break up all this code in multiple methods  				writer.WriteLine ("WriteClock();");  				writer.WriteLine ("WriteConstantValues();");  				writer.WriteLine ("WriteReferenceValues();");  				writer.WriteLine ("WriteSampledValues();");  				writer.WriteLine ("m_output.WriteEndSequence();");  				s_assertionIndent--;  				WriteAssertionBoth (writer' "});");  				s_assertionIndent++;  			}  		}  		writer.WriteLine ("private void WriteClock()");  		using (writer.OpenScope ()) {  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				writer.WriteLine ("packet.WriteId(\"document\");");  				writer.WriteLine ("packet.WriteName(\"ValidationDocument\");");  				writer.WriteLine ("packet.WriteVersion(\"1.0\");");  				writer.WriteLine ("using (var clock = packet.OpenClockProperty())");  				using (writer.OpenScope ()) {  					writer.WriteLine ("clock.WriteInterval(m_documentStartDate' m_documentStopDate);");  					WriteAssertion (writer' false' "expect(dataSource.clock.startTime).toEqual(documentStartDate);");  					WriteAssertion (writer' false' "expect(dataSource.clock.stopTime).toEqual(documentStopDate);");  					writer.WriteLine ("clock.WriteCurrentTime(m_documentStartDate);");  					WriteAssertion (writer' false' "expect(dataSource.clock.currentTime).toEqual(documentStartDate);");  					writer.WriteLine ("clock.WriteMultiplier(1.0);");  					WriteAssertion (writer' false' "expect(dataSource.clock.multiplier).toEqual(1.0);");  					writer.WriteLine ("clock.WriteRange(ClockRange.Unbounded);");  					WriteAssertion (writer' false' "expect(dataSource.clock.clockRange).toEqual(ClockRange.UNBOUNDED);");  					writer.WriteLine ("clock.WriteStep(ClockStep.SystemClockMultiplier);");  					WriteAssertion (writer' false' "expect(dataSource.clock.clockStep).toEqual(ClockStep.SYSTEM_CLOCK_MULTIPLIER);");  				}  			}  		}  		writer.WriteLine ("private void WriteConstantValues()");  		using (writer.OpenScope ()) {  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				const string id = "Constant";  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "var constant = e = dataSource.entities.getById('Constant');");  				WriteAssertionBoth (writer' "expect(e).toBeDefined();");  				WriteAssertionBoth (writer' "date = JulianDate.now();");  				// Write one packet with first value types for each property  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var properties = property.ValueType.Properties;  						var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  						if (firstValueProperty != null) {  							WriteValue (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  						} else {  							foreach (var subProperty in properties.Where (p => !p.IsValue)) {  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = subProperty.ValueType.Properties;  									firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  									string subPropertyName = GetSubPropertyName (propertyName' subProperty);  									if (firstValueProperty != null) {  										WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  									} else if (subProperty.ValueType.Name.Contains ("Material")) {  										Property materialProperty = properties.First ();  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialSubProperty.ValueType.Properties;  													firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  													if (firstValueProperty != null) {  														WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  													}  												}  											}  										}  									} else {  										var additionalProperties = subProperty.ValueType.AdditionalProperties;  										if (additionalProperties != null) {  											writer.WriteLine ("using (var a = w2.Open{0}Property(\"prop\"))"' additionalProperties.ValueType.NameWithPascalCase);  											using (writer.OpenScope ()) {  												foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  													writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														properties = additionalProperty.ValueType.Properties;  														firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  														if (firstValueProperty != null) {  															WriteValue (writer' "w3"' id + property.Name' firstValueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' "prop"' additionalProperty.Name));  														}  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			writer.WriteLine ("WriteConstantValuesIndividual();");  			writer.WriteLine ("WriteConstantValuesCustomProperties();");  		}  		writer.WriteLine ("private void WriteConstantValuesIndividual()");  		using (writer.OpenScope ()) {  			// write other value types as individual packets  			foreach (var property in schemaProperties) {  				writer.WriteLine ("WriteConstantValuesIndividual{0}();"' property.NameWithPascalCase);  			}  		}  		foreach (var property in schemaProperties) {  			writer.WriteLine ("private void WriteConstantValuesIndividual{0}()"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("constant_{0}_{1}"' property.Name' valueProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							WriteValue (writer' "w"' id' valueProperty' property' isExtension' propertyName);  						}  					}  				}  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					string subPropertyName = GetSubPropertyName (propertyName' subProperty);  					properties = subProperty.ValueType.Properties;  					foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("constant_{0}_{1}_{2}"' property.Name' subPropertyName' valueProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								WriteValue (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  							}  						}  					}  					if (subProperty.ValueType.Name.Contains ("Material")) {  						// write other values for the first material  						// then write first values for other materials   						// then write remaining values for other materials individually  						var firstMaterialProperty = properties.First ();  						properties = firstMaterialProperty.ValueType.Properties;  						foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  							properties = materialSubProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValue (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialSubProperty.ValueType.Properties;  											var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  											if (firstValueProperty != null) {  												WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							properties = materialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  					}  					var additionalProperties = subProperty.ValueType.AdditionalProperties;  					if (additionalProperties != null) {  						foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  							int i = 0;  							properties = additionalProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' additionalProperties.ValueType.Name' additionalProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									string propName = string.Format ("{0}{1}"' "prop"' i++);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var a = w2.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  									writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValue (writer' "w3"' id + property.Name + subProperty.Name' valueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' propName' additionalProperty.Name));  									}  								}  							}  						}  					}  				}  			}  		}  		// create all types of custom properties  		writer.WriteLine ("private void WriteConstantValuesCustomProperties()");  		using (writer.OpenScope ()) {  			var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  			if (propertiesProperty != null) {  				var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  				if (additionalProperties != null) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = "constant_custom";  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue)) {  								string propName = string.Format ("custom_{0}"' valueProperty.Name);  								writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  								using (writer.OpenScope ()) {  									WriteValue (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  								}  							}  						}  					}  				}  			}  		}  		// create entities using references  		writer.WriteLine ("private void WriteReferenceValues()");  		using (writer.OpenScope ()) {  			// write some positions and double values to use to create reference lists for position lists and double lists later  			for (int i = 1; i <= 2; ++i) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("ConstantPosition{0}"' i);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantPosition{0}')).toBeDefined();"' i);  					var property = schemaProperties.First (p => p.Name == "position");  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var properties = property.ValueType.Properties;  						var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  						WriteValue (writer' "w"' id' firstValueProperty' property' false' property.Name);  					}  				}  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("ConstantDouble{0}"' i);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantDouble{0}')).toBeDefined();"' i);  					var property = schemaProperties.First (p => p.Name == "billboard");  					var properties = property.ValueType.Properties;  					var subProperty = properties.First (p => p.Name == "scale");  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						properties = subProperty.ValueType.Properties;  						var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  						WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' false' string.Format ("{0}.{1}"' property.Name' subProperty.Name));  					}  				}  			}  			// write one big packet with references for everything  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				writer.WriteLine ("packet.WriteId(\"Reference\");");  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Reference')).toBeDefined();");  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var properties = property.ValueType.Properties;  						if (properties.Any (p => p.ValueType.Name == "Reference")) {  							writer.WriteLine ("w.WriteReference(new Reference(\"Constant\"' \"{0}\"));"' propertyName);  							WriteAssertion (writer' isExtension' "expect(e.{0}.getValue(date)).toEqual(constant.{0}.getValue(date));"' propertyName);  						} else {  							foreach (var subProperty in properties.Where (p => !p.IsValue)) {  								properties = subProperty.ValueType.Properties;  								string subPropertyName = GetSubPropertyName (propertyName' subProperty);  								if (properties.Any (p => p.ValueType.Name == "Reference")) {  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										writer.WriteLine ("w2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\")));"' propertyName' subPropertyName);  										WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual(constant.{0}.{1}.getValue(date));"' propertyName' subPropertyName);  									}  								} else if (properties.Any (p => p.ValueType.Name == "ReferenceList")) {  									string targetId = "";  									string[] referencePropertyNames =  {    									};  									if (subProperty.ValueType.Name == "PositionList") {  										targetId = "Position";  										referencePropertyNames = new[] {  											"position"  										};  									} else if (subProperty.ValueType.Name == "DoubleList") {  										targetId = "Double";  										referencePropertyNames = new[] {  											"billboard"'  											"scale"  										};  									}  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										writer.WriteLine ("w2.WriteReferences(CreateList(new Reference(\"Constant{0}1\"' CreateList({1}))' new Reference(\"Constant{0}2\"' CreateList({1}))));"' targetId' string.Join ("' "' referencePropertyNames.Select (n => string.Format ("\"{0}\""' n))));  										WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual([dataSource.entities.getById('Constant{2}1').{3}.getValue(date)' dataSource.entities.getById('Constant{2}2').{3}.getValue(date)]);"' propertyName' subPropertyName' targetId' string.Join ("."' referencePropertyNames));  									}  								} else if (subProperty.ValueType.Name.Contains ("Material")) {  									Property materialProperty = properties.First ();  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												writer.WriteLine ("m2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"{2}\")));"' propertyName' subPropertyName' materialSubProperty.Name);  												WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.{2}.getValue(date)).toEqual(constant.{0}.{1}.{2}.getValue(date));"' propertyName' subPropertyName' materialSubProperty.Name);  											}  										}  									}  								} else {  									var additionalProperties = subProperty.ValueType.AdditionalProperties;  									if (additionalProperties != null) {  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var a = w2.Open{0}Property(\"referenceProp\"))"' additionalProperties.ValueType.NameWithPascalCase);  										using (writer.OpenScope ()) {  											foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													writer.WriteLine ("w3.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"prop\"' \"{2}\")));"' propertyName' subPropertyName' additionalProperty.Name);  													WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.referenceProp.{2}.getValue(date)).toEqual(constant.{0}.{1}.prop.{2}.getValue(date));"' propertyName' subPropertyName' additionalProperty.Name);  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			writer.WriteLine ("WriteReferenceValuesIndividual();");  		}  		writer.WriteLine ("private void WriteReferenceValuesIndividual()");  		using (writer.OpenScope ()) {  			// write other materials as individual packets  			foreach (var property in schemaProperties) {  				writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  			}  			// special case - velocity reference  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  				var property = schemaProperties.First (p => p.Name == "position");  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					// construct a position with specific velocity  					double dx = 1.0;  					double dy = 2.0;  					double dz = 3.0;  					double deltaTime = 60.0;  					double x1 = 1.0;  					double x2 = x1 + dx * deltaTime;  					double y1 = 2.0;  					double y2 = y1 + dy * deltaTime;  					double z1 = 3.0;  					double z2 = z1 + dz * deltaTime;  					string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  					string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  					string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  					string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  					writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  					WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  					WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  				}  			}  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					properties = subProperty.ValueType.Properties;  					if (properties.Any (p => p.Name == "velocityReference")) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  								double expectedX = 1.0;  								double expectedY = 2.0;  								double expectedZ = 3.0;  								bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  								if (isNormalized) {  									NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  								}  								WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  							}  						}  					}  				}  			}  		}  		// write other materials as individual packets  		foreach (var property in schemaProperties) {  			writer.WriteLine ("private void WriteReferenceValuesIndividual{0}()"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					string subPropertyName = GetSubPropertyName (propertyName' subProperty);  					if (subProperty.ValueType.Name.Contains ("Material")) {  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string targetId = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  								string id = string.Format ("reference_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("m2.WriteReference(new Reference(\"{0}\"' CreateList(\"{1}\"' \"{2}\"' \"{3}\")));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  											WriteAssertion (writer' isExtension' "expect(e.{1}.{2}.{3}.getValue(date)).toEqual(dataSource.entities.getById('{0}').{1}.{2}.{3}.getValue(date));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  										}  									}  								}  							}  						}  					}  				}  			}  		}  		// test sampled properties  		writer.WriteLine ("private void WriteSampledValues()");  		using (writer.OpenScope ()) {  			// Write one packet with first value types for each property  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				const string id = "Sampled";  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Sampled')).toBeDefined();");  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					if (property.IsInterpolatable) {  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  							WriteValues (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  						}  					} else {  						var subProperties = properties.Where (p => !p.IsValue && (p.IsInterpolatable || p.ValueType.Name.Contains ("Material"))).ToList ();  						if (subProperties.Any ()) {  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								foreach (var subProperty in subProperties) {  									properties = subProperty.ValueType.Properties;  									string subPropertyName = GetSubPropertyName (propertyName' subProperty);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										if (subProperty.IsInterpolatable) {  											var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  											WriteValues (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  										} else if (subProperty.ValueType.Name.Contains ("Material")) {  											Property materialProperty = properties.First ();  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialProperty.ValueType.Properties;  												foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  													writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														properties = materialSubProperty.ValueType.Properties;  														var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  														WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			writer.WriteLine ("WriteSampledValuesIndividual();");  			writer.WriteLine ("WriteSampledValuesCustomProperties();");  		}  		writer.WriteLine ("private void WriteSampledValuesIndividual()");  		using (writer.OpenScope ()) {  			// write other value types as individual packets  			// split method into multiple methods  			foreach (var property in schemaProperties) {  				writer.WriteLine ("WriteSampledValuesIndividual{0}();"' property.NameWithPascalCase);  			}  		}  		foreach (var property in schemaProperties) {  			writer.WriteLine ("private void WriteSampledValuesIndividual{0}()"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				if (property.IsInterpolatable) {  					foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("sampled_{0}_{1}"' propertyName' valueProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								WriteValues (writer' "w"' id' valueProperty' property' isExtension' propertyName);  							}  						}  					}  				} else {  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						string subPropertyName = GetSubPropertyName (propertyName' subProperty);  						properties = subProperty.ValueType.Properties;  						if (subProperty.IsInterpolatable) {  							foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' valueProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValues (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  									}  								}  							}  						} else if (subProperty.ValueType.Name.Contains ("Material")) {  							// write other values for the first material  							// then write first values for other materials   							// then write remaining values for other materials individually  							var firstMaterialProperty = properties.First ();  							properties = firstMaterialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValues (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialSubProperty.ValueType.Properties;  												var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  												WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  									properties = materialSubProperty.ValueType.Properties;  									foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  										writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  										using (writer.OpenScope ()) {  											string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  											writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  											WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  											writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		// create all types of custom properties  		writer.WriteLine ("private void WriteSampledValuesCustomProperties()");  		using (writer.OpenScope ()) {  			var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  			if (propertiesProperty != null) {  				var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  				if (additionalProperties != null) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = "sampled_custom";  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array)) {  								string propName = string.Format ("custom_{0}"' valueProperty.Name);  								writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  								using (writer.OpenScope ()) {  									WriteValues (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  								}  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	writer.WriteLine ("[TestFixture]");  	writer.WriteLine ("[SuppressMessage(\"ReSharper\"' \"MemberCanBeMadeStatic.Local\")]");  	writer.WriteLine ("public class TestGenerateValidationDocument");  	using (writer.OpenScope ()) {  		writer.WriteLine ("private readonly JulianDate m_documentStartDate = new GregorianDate(2016' 6' 17' 12' 0' 0).ToJulianDate();");  		writer.WriteLine ("private readonly JulianDate m_documentStopDate = new GregorianDate(2016' 6' 17' 13' 0' 0).ToJulianDate();");  		writer.WriteLine ("private TextWriter m_streamWriter;");  		writer.WriteLine ("private TextWriter m_assertionsWriter;");  		writer.WriteLine ("private TextWriter m_extensionsAssertionsWriter;");  		writer.WriteLine ("private CesiumOutputStream m_output;");  		writer.WriteLine ("private CesiumStreamWriter m_writer;");  		writer.WriteLine ("private void WriteAssertionBoth(string s)");  		using (writer.OpenScope ()) {  			writer.WriteLine ("m_assertionsWriter.WriteLine(s);");  			writer.WriteLine ("m_extensionsAssertionsWriter.WriteLine(s);");  		}  		writer.WriteLine ("private static IList<T> CreateList<T>(T t1' T t2)");  		using (writer.OpenScope ()) {  			writer.WriteLine ("return new List<T> { t1' t2 };");  		}  		writer.WriteLine ("private static IList<T> CreateList<T>(params T[] ts)");  		using (writer.OpenScope ()) {  			writer.WriteLine ("return ts;");  		}  		writer.WriteLine ("[Test]");  		writer.WriteLine ("public void GenerateValidationDocument()");  		var schemaProperties = schema.Properties.Where (p => p.Name != "clock" && p.Name != "availability" && !p.ValueType.IsSchemaFromType).Where (p => p.Name != "properties").ToList ();  		using (writer.OpenScope ()) {  			writer.WriteLine ("using (m_streamWriter = new StreamWriter(\"ValidationDocument.czml\"))");  			writer.WriteLine ("using (m_assertionsWriter = new StreamWriter(\"ValidationDocumentAssertions.js\"))");  			writer.WriteLine ("using (m_extensionsAssertionsWriter = new StreamWriter(\"ValidationDocumentExtensionAssertions.js\"))");  			using (writer.OpenScope ()) {  				WriteAssertionBoth (writer' "return CzmlDataSource.load('Data/CZML/ValidationDocument.czml').then(function(dataSource) {");  				s_assertionIndent++;  				WriteAssertionBoth (writer' "/*jshint -W120 */");  				WriteAssertionBoth (writer' "var e;");  				WriteAssertionBoth (writer' "var date;");  				WriteAssertionBoth (writer' "var documentStartDate = JulianDate.fromIso8601('2016-06-17T12:00:00Z');");  				WriteAssertionBoth (writer' "var documentStopDate = JulianDate.fromIso8601('2016-06-17T13:00:00Z');");  				writer.WriteLine ("m_output = new CesiumOutputStream(m_streamWriter) { PrettyFormatting = true };");  				writer.WriteLine ("m_writer = new CesiumStreamWriter();");  				writer.WriteLine ("m_output.WriteStartSequence();");  				// Java has a limit on the size of a single method (65535 bytes) so we have to break up all this code in multiple methods  				writer.WriteLine ("WriteClock();");  				writer.WriteLine ("WriteConstantValues();");  				writer.WriteLine ("WriteReferenceValues();");  				writer.WriteLine ("WriteSampledValues();");  				writer.WriteLine ("m_output.WriteEndSequence();");  				s_assertionIndent--;  				WriteAssertionBoth (writer' "});");  				s_assertionIndent++;  			}  		}  		writer.WriteLine ("private void WriteClock()");  		using (writer.OpenScope ()) {  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				writer.WriteLine ("packet.WriteId(\"document\");");  				writer.WriteLine ("packet.WriteName(\"ValidationDocument\");");  				writer.WriteLine ("packet.WriteVersion(\"1.0\");");  				writer.WriteLine ("using (var clock = packet.OpenClockProperty())");  				using (writer.OpenScope ()) {  					writer.WriteLine ("clock.WriteInterval(m_documentStartDate' m_documentStopDate);");  					WriteAssertion (writer' false' "expect(dataSource.clock.startTime).toEqual(documentStartDate);");  					WriteAssertion (writer' false' "expect(dataSource.clock.stopTime).toEqual(documentStopDate);");  					writer.WriteLine ("clock.WriteCurrentTime(m_documentStartDate);");  					WriteAssertion (writer' false' "expect(dataSource.clock.currentTime).toEqual(documentStartDate);");  					writer.WriteLine ("clock.WriteMultiplier(1.0);");  					WriteAssertion (writer' false' "expect(dataSource.clock.multiplier).toEqual(1.0);");  					writer.WriteLine ("clock.WriteRange(ClockRange.Unbounded);");  					WriteAssertion (writer' false' "expect(dataSource.clock.clockRange).toEqual(ClockRange.UNBOUNDED);");  					writer.WriteLine ("clock.WriteStep(ClockStep.SystemClockMultiplier);");  					WriteAssertion (writer' false' "expect(dataSource.clock.clockStep).toEqual(ClockStep.SYSTEM_CLOCK_MULTIPLIER);");  				}  			}  		}  		writer.WriteLine ("private void WriteConstantValues()");  		using (writer.OpenScope ()) {  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				const string id = "Constant";  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "var constant = e = dataSource.entities.getById('Constant');");  				WriteAssertionBoth (writer' "expect(e).toBeDefined();");  				WriteAssertionBoth (writer' "date = JulianDate.now();");  				// Write one packet with first value types for each property  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var properties = property.ValueType.Properties;  						var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  						if (firstValueProperty != null) {  							WriteValue (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  						} else {  							foreach (var subProperty in properties.Where (p => !p.IsValue)) {  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = subProperty.ValueType.Properties;  									firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  									string subPropertyName = GetSubPropertyName (propertyName' subProperty);  									if (firstValueProperty != null) {  										WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  									} else if (subProperty.ValueType.Name.Contains ("Material")) {  										Property materialProperty = properties.First ();  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialSubProperty.ValueType.Properties;  													firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  													if (firstValueProperty != null) {  														WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  													}  												}  											}  										}  									} else {  										var additionalProperties = subProperty.ValueType.AdditionalProperties;  										if (additionalProperties != null) {  											writer.WriteLine ("using (var a = w2.Open{0}Property(\"prop\"))"' additionalProperties.ValueType.NameWithPascalCase);  											using (writer.OpenScope ()) {  												foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  													writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														properties = additionalProperty.ValueType.Properties;  														firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  														if (firstValueProperty != null) {  															WriteValue (writer' "w3"' id + property.Name' firstValueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' "prop"' additionalProperty.Name));  														}  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			writer.WriteLine ("WriteConstantValuesIndividual();");  			writer.WriteLine ("WriteConstantValuesCustomProperties();");  		}  		writer.WriteLine ("private void WriteConstantValuesIndividual()");  		using (writer.OpenScope ()) {  			// write other value types as individual packets  			foreach (var property in schemaProperties) {  				writer.WriteLine ("WriteConstantValuesIndividual{0}();"' property.NameWithPascalCase);  			}  		}  		foreach (var property in schemaProperties) {  			writer.WriteLine ("private void WriteConstantValuesIndividual{0}()"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("constant_{0}_{1}"' property.Name' valueProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							WriteValue (writer' "w"' id' valueProperty' property' isExtension' propertyName);  						}  					}  				}  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					string subPropertyName = GetSubPropertyName (propertyName' subProperty);  					properties = subProperty.ValueType.Properties;  					foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("constant_{0}_{1}_{2}"' property.Name' subPropertyName' valueProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								WriteValue (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  							}  						}  					}  					if (subProperty.ValueType.Name.Contains ("Material")) {  						// write other values for the first material  						// then write first values for other materials   						// then write remaining values for other materials individually  						var firstMaterialProperty = properties.First ();  						properties = firstMaterialProperty.ValueType.Properties;  						foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  							properties = materialSubProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValue (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialSubProperty.ValueType.Properties;  											var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  											if (firstValueProperty != null) {  												WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							properties = materialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  					}  					var additionalProperties = subProperty.ValueType.AdditionalProperties;  					if (additionalProperties != null) {  						foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  							int i = 0;  							properties = additionalProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' additionalProperties.ValueType.Name' additionalProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									string propName = string.Format ("{0}{1}"' "prop"' i++);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var a = w2.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  									writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValue (writer' "w3"' id + property.Name + subProperty.Name' valueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' propName' additionalProperty.Name));  									}  								}  							}  						}  					}  				}  			}  		}  		// create all types of custom properties  		writer.WriteLine ("private void WriteConstantValuesCustomProperties()");  		using (writer.OpenScope ()) {  			var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  			if (propertiesProperty != null) {  				var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  				if (additionalProperties != null) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = "constant_custom";  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue)) {  								string propName = string.Format ("custom_{0}"' valueProperty.Name);  								writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  								using (writer.OpenScope ()) {  									WriteValue (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  								}  							}  						}  					}  				}  			}  		}  		// create entities using references  		writer.WriteLine ("private void WriteReferenceValues()");  		using (writer.OpenScope ()) {  			// write some positions and double values to use to create reference lists for position lists and double lists later  			for (int i = 1; i <= 2; ++i) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("ConstantPosition{0}"' i);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantPosition{0}')).toBeDefined();"' i);  					var property = schemaProperties.First (p => p.Name == "position");  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var properties = property.ValueType.Properties;  						var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  						WriteValue (writer' "w"' id' firstValueProperty' property' false' property.Name);  					}  				}  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("ConstantDouble{0}"' i);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantDouble{0}')).toBeDefined();"' i);  					var property = schemaProperties.First (p => p.Name == "billboard");  					var properties = property.ValueType.Properties;  					var subProperty = properties.First (p => p.Name == "scale");  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						properties = subProperty.ValueType.Properties;  						var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  						WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' false' string.Format ("{0}.{1}"' property.Name' subProperty.Name));  					}  				}  			}  			// write one big packet with references for everything  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				writer.WriteLine ("packet.WriteId(\"Reference\");");  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Reference')).toBeDefined();");  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var properties = property.ValueType.Properties;  						if (properties.Any (p => p.ValueType.Name == "Reference")) {  							writer.WriteLine ("w.WriteReference(new Reference(\"Constant\"' \"{0}\"));"' propertyName);  							WriteAssertion (writer' isExtension' "expect(e.{0}.getValue(date)).toEqual(constant.{0}.getValue(date));"' propertyName);  						} else {  							foreach (var subProperty in properties.Where (p => !p.IsValue)) {  								properties = subProperty.ValueType.Properties;  								string subPropertyName = GetSubPropertyName (propertyName' subProperty);  								if (properties.Any (p => p.ValueType.Name == "Reference")) {  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										writer.WriteLine ("w2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\")));"' propertyName' subPropertyName);  										WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual(constant.{0}.{1}.getValue(date));"' propertyName' subPropertyName);  									}  								} else if (properties.Any (p => p.ValueType.Name == "ReferenceList")) {  									string targetId = "";  									string[] referencePropertyNames =  {    									};  									if (subProperty.ValueType.Name == "PositionList") {  										targetId = "Position";  										referencePropertyNames = new[] {  											"position"  										};  									} else if (subProperty.ValueType.Name == "DoubleList") {  										targetId = "Double";  										referencePropertyNames = new[] {  											"billboard"'  											"scale"  										};  									}  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										writer.WriteLine ("w2.WriteReferences(CreateList(new Reference(\"Constant{0}1\"' CreateList({1}))' new Reference(\"Constant{0}2\"' CreateList({1}))));"' targetId' string.Join ("' "' referencePropertyNames.Select (n => string.Format ("\"{0}\""' n))));  										WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual([dataSource.entities.getById('Constant{2}1').{3}.getValue(date)' dataSource.entities.getById('Constant{2}2').{3}.getValue(date)]);"' propertyName' subPropertyName' targetId' string.Join ("."' referencePropertyNames));  									}  								} else if (subProperty.ValueType.Name.Contains ("Material")) {  									Property materialProperty = properties.First ();  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												writer.WriteLine ("m2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"{2}\")));"' propertyName' subPropertyName' materialSubProperty.Name);  												WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.{2}.getValue(date)).toEqual(constant.{0}.{1}.{2}.getValue(date));"' propertyName' subPropertyName' materialSubProperty.Name);  											}  										}  									}  								} else {  									var additionalProperties = subProperty.ValueType.AdditionalProperties;  									if (additionalProperties != null) {  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var a = w2.Open{0}Property(\"referenceProp\"))"' additionalProperties.ValueType.NameWithPascalCase);  										using (writer.OpenScope ()) {  											foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													writer.WriteLine ("w3.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"prop\"' \"{2}\")));"' propertyName' subPropertyName' additionalProperty.Name);  													WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.referenceProp.{2}.getValue(date)).toEqual(constant.{0}.{1}.prop.{2}.getValue(date));"' propertyName' subPropertyName' additionalProperty.Name);  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			writer.WriteLine ("WriteReferenceValuesIndividual();");  		}  		writer.WriteLine ("private void WriteReferenceValuesIndividual()");  		using (writer.OpenScope ()) {  			// write other materials as individual packets  			foreach (var property in schemaProperties) {  				writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  			}  			// special case - velocity reference  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  				var property = schemaProperties.First (p => p.Name == "position");  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					// construct a position with specific velocity  					double dx = 1.0;  					double dy = 2.0;  					double dz = 3.0;  					double deltaTime = 60.0;  					double x1 = 1.0;  					double x2 = x1 + dx * deltaTime;  					double y1 = 2.0;  					double y2 = y1 + dy * deltaTime;  					double z1 = 3.0;  					double z2 = z1 + dz * deltaTime;  					string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  					string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  					string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  					string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  					writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  					WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  					WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  				}  			}  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					properties = subProperty.ValueType.Properties;  					if (properties.Any (p => p.Name == "velocityReference")) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  								double expectedX = 1.0;  								double expectedY = 2.0;  								double expectedZ = 3.0;  								bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  								if (isNormalized) {  									NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  								}  								WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  							}  						}  					}  				}  			}  		}  		// write other materials as individual packets  		foreach (var property in schemaProperties) {  			writer.WriteLine ("private void WriteReferenceValuesIndividual{0}()"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					string subPropertyName = GetSubPropertyName (propertyName' subProperty);  					if (subProperty.ValueType.Name.Contains ("Material")) {  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string targetId = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  								string id = string.Format ("reference_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("m2.WriteReference(new Reference(\"{0}\"' CreateList(\"{1}\"' \"{2}\"' \"{3}\")));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  											WriteAssertion (writer' isExtension' "expect(e.{1}.{2}.{3}.getValue(date)).toEqual(dataSource.entities.getById('{0}').{1}.{2}.{3}.getValue(date));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  										}  									}  								}  							}  						}  					}  				}  			}  		}  		// test sampled properties  		writer.WriteLine ("private void WriteSampledValues()");  		using (writer.OpenScope ()) {  			// Write one packet with first value types for each property  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				const string id = "Sampled";  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Sampled')).toBeDefined();");  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					if (property.IsInterpolatable) {  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  							WriteValues (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  						}  					} else {  						var subProperties = properties.Where (p => !p.IsValue && (p.IsInterpolatable || p.ValueType.Name.Contains ("Material"))).ToList ();  						if (subProperties.Any ()) {  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								foreach (var subProperty in subProperties) {  									properties = subProperty.ValueType.Properties;  									string subPropertyName = GetSubPropertyName (propertyName' subProperty);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										if (subProperty.IsInterpolatable) {  											var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  											WriteValues (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  										} else if (subProperty.ValueType.Name.Contains ("Material")) {  											Property materialProperty = properties.First ();  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialProperty.ValueType.Properties;  												foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  													writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														properties = materialSubProperty.ValueType.Properties;  														var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  														WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			writer.WriteLine ("WriteSampledValuesIndividual();");  			writer.WriteLine ("WriteSampledValuesCustomProperties();");  		}  		writer.WriteLine ("private void WriteSampledValuesIndividual()");  		using (writer.OpenScope ()) {  			// write other value types as individual packets  			// split method into multiple methods  			foreach (var property in schemaProperties) {  				writer.WriteLine ("WriteSampledValuesIndividual{0}();"' property.NameWithPascalCase);  			}  		}  		foreach (var property in schemaProperties) {  			writer.WriteLine ("private void WriteSampledValuesIndividual{0}()"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				if (property.IsInterpolatable) {  					foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("sampled_{0}_{1}"' propertyName' valueProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								WriteValues (writer' "w"' id' valueProperty' property' isExtension' propertyName);  							}  						}  					}  				} else {  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						string subPropertyName = GetSubPropertyName (propertyName' subProperty);  						properties = subProperty.ValueType.Properties;  						if (subProperty.IsInterpolatable) {  							foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' valueProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValues (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  									}  								}  							}  						} else if (subProperty.ValueType.Name.Contains ("Material")) {  							// write other values for the first material  							// then write first values for other materials   							// then write remaining values for other materials individually  							var firstMaterialProperty = properties.First ();  							properties = firstMaterialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValues (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialSubProperty.ValueType.Properties;  												var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  												WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  									properties = materialSubProperty.ValueType.Properties;  									foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  										writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  										using (writer.OpenScope ()) {  											string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  											writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  											WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  											writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		// create all types of custom properties  		writer.WriteLine ("private void WriteSampledValuesCustomProperties()");  		using (writer.OpenScope ()) {  			var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  			if (propertiesProperty != null) {  				var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  				if (additionalProperties != null) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = "sampled_custom";  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array)) {  								string propName = string.Format ("custom_{0}"' valueProperty.Name);  								writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  								using (writer.OpenScope ()) {  									WriteValues (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  								}  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	writer.WriteLine ("[TestFixture]");  	writer.WriteLine ("[SuppressMessage(\"ReSharper\"' \"MemberCanBeMadeStatic.Local\")]");  	writer.WriteLine ("public class TestGenerateValidationDocument");  	using (writer.OpenScope ()) {  		writer.WriteLine ("private readonly JulianDate m_documentStartDate = new GregorianDate(2016' 6' 17' 12' 0' 0).ToJulianDate();");  		writer.WriteLine ("private readonly JulianDate m_documentStopDate = new GregorianDate(2016' 6' 17' 13' 0' 0).ToJulianDate();");  		writer.WriteLine ("private TextWriter m_streamWriter;");  		writer.WriteLine ("private TextWriter m_assertionsWriter;");  		writer.WriteLine ("private TextWriter m_extensionsAssertionsWriter;");  		writer.WriteLine ("private CesiumOutputStream m_output;");  		writer.WriteLine ("private CesiumStreamWriter m_writer;");  		writer.WriteLine ("private void WriteAssertionBoth(string s)");  		using (writer.OpenScope ()) {  			writer.WriteLine ("m_assertionsWriter.WriteLine(s);");  			writer.WriteLine ("m_extensionsAssertionsWriter.WriteLine(s);");  		}  		writer.WriteLine ("private static IList<T> CreateList<T>(T t1' T t2)");  		using (writer.OpenScope ()) {  			writer.WriteLine ("return new List<T> { t1' t2 };");  		}  		writer.WriteLine ("private static IList<T> CreateList<T>(params T[] ts)");  		using (writer.OpenScope ()) {  			writer.WriteLine ("return ts;");  		}  		writer.WriteLine ("[Test]");  		writer.WriteLine ("public void GenerateValidationDocument()");  		var schemaProperties = schema.Properties.Where (p => p.Name != "clock" && p.Name != "availability" && !p.ValueType.IsSchemaFromType).Where (p => p.Name != "properties").ToList ();  		using (writer.OpenScope ()) {  			writer.WriteLine ("using (m_streamWriter = new StreamWriter(\"ValidationDocument.czml\"))");  			writer.WriteLine ("using (m_assertionsWriter = new StreamWriter(\"ValidationDocumentAssertions.js\"))");  			writer.WriteLine ("using (m_extensionsAssertionsWriter = new StreamWriter(\"ValidationDocumentExtensionAssertions.js\"))");  			using (writer.OpenScope ()) {  				WriteAssertionBoth (writer' "return CzmlDataSource.load('Data/CZML/ValidationDocument.czml').then(function(dataSource) {");  				s_assertionIndent++;  				WriteAssertionBoth (writer' "/*jshint -W120 */");  				WriteAssertionBoth (writer' "var e;");  				WriteAssertionBoth (writer' "var date;");  				WriteAssertionBoth (writer' "var documentStartDate = JulianDate.fromIso8601('2016-06-17T12:00:00Z');");  				WriteAssertionBoth (writer' "var documentStopDate = JulianDate.fromIso8601('2016-06-17T13:00:00Z');");  				writer.WriteLine ("m_output = new CesiumOutputStream(m_streamWriter) { PrettyFormatting = true };");  				writer.WriteLine ("m_writer = new CesiumStreamWriter();");  				writer.WriteLine ("m_output.WriteStartSequence();");  				// Java has a limit on the size of a single method (65535 bytes) so we have to break up all this code in multiple methods  				writer.WriteLine ("WriteClock();");  				writer.WriteLine ("WriteConstantValues();");  				writer.WriteLine ("WriteReferenceValues();");  				writer.WriteLine ("WriteSampledValues();");  				writer.WriteLine ("m_output.WriteEndSequence();");  				s_assertionIndent--;  				WriteAssertionBoth (writer' "});");  				s_assertionIndent++;  			}  		}  		writer.WriteLine ("private void WriteClock()");  		using (writer.OpenScope ()) {  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				writer.WriteLine ("packet.WriteId(\"document\");");  				writer.WriteLine ("packet.WriteName(\"ValidationDocument\");");  				writer.WriteLine ("packet.WriteVersion(\"1.0\");");  				writer.WriteLine ("using (var clock = packet.OpenClockProperty())");  				using (writer.OpenScope ()) {  					writer.WriteLine ("clock.WriteInterval(m_documentStartDate' m_documentStopDate);");  					WriteAssertion (writer' false' "expect(dataSource.clock.startTime).toEqual(documentStartDate);");  					WriteAssertion (writer' false' "expect(dataSource.clock.stopTime).toEqual(documentStopDate);");  					writer.WriteLine ("clock.WriteCurrentTime(m_documentStartDate);");  					WriteAssertion (writer' false' "expect(dataSource.clock.currentTime).toEqual(documentStartDate);");  					writer.WriteLine ("clock.WriteMultiplier(1.0);");  					WriteAssertion (writer' false' "expect(dataSource.clock.multiplier).toEqual(1.0);");  					writer.WriteLine ("clock.WriteRange(ClockRange.Unbounded);");  					WriteAssertion (writer' false' "expect(dataSource.clock.clockRange).toEqual(ClockRange.UNBOUNDED);");  					writer.WriteLine ("clock.WriteStep(ClockStep.SystemClockMultiplier);");  					WriteAssertion (writer' false' "expect(dataSource.clock.clockStep).toEqual(ClockStep.SYSTEM_CLOCK_MULTIPLIER);");  				}  			}  		}  		writer.WriteLine ("private void WriteConstantValues()");  		using (writer.OpenScope ()) {  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				const string id = "Constant";  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "var constant = e = dataSource.entities.getById('Constant');");  				WriteAssertionBoth (writer' "expect(e).toBeDefined();");  				WriteAssertionBoth (writer' "date = JulianDate.now();");  				// Write one packet with first value types for each property  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var properties = property.ValueType.Properties;  						var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  						if (firstValueProperty != null) {  							WriteValue (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  						} else {  							foreach (var subProperty in properties.Where (p => !p.IsValue)) {  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = subProperty.ValueType.Properties;  									firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  									string subPropertyName = GetSubPropertyName (propertyName' subProperty);  									if (firstValueProperty != null) {  										WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  									} else if (subProperty.ValueType.Name.Contains ("Material")) {  										Property materialProperty = properties.First ();  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialSubProperty.ValueType.Properties;  													firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  													if (firstValueProperty != null) {  														WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  													}  												}  											}  										}  									} else {  										var additionalProperties = subProperty.ValueType.AdditionalProperties;  										if (additionalProperties != null) {  											writer.WriteLine ("using (var a = w2.Open{0}Property(\"prop\"))"' additionalProperties.ValueType.NameWithPascalCase);  											using (writer.OpenScope ()) {  												foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  													writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														properties = additionalProperty.ValueType.Properties;  														firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  														if (firstValueProperty != null) {  															WriteValue (writer' "w3"' id + property.Name' firstValueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' "prop"' additionalProperty.Name));  														}  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			writer.WriteLine ("WriteConstantValuesIndividual();");  			writer.WriteLine ("WriteConstantValuesCustomProperties();");  		}  		writer.WriteLine ("private void WriteConstantValuesIndividual()");  		using (writer.OpenScope ()) {  			// write other value types as individual packets  			foreach (var property in schemaProperties) {  				writer.WriteLine ("WriteConstantValuesIndividual{0}();"' property.NameWithPascalCase);  			}  		}  		foreach (var property in schemaProperties) {  			writer.WriteLine ("private void WriteConstantValuesIndividual{0}()"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("constant_{0}_{1}"' property.Name' valueProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							WriteValue (writer' "w"' id' valueProperty' property' isExtension' propertyName);  						}  					}  				}  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					string subPropertyName = GetSubPropertyName (propertyName' subProperty);  					properties = subProperty.ValueType.Properties;  					foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("constant_{0}_{1}_{2}"' property.Name' subPropertyName' valueProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								WriteValue (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  							}  						}  					}  					if (subProperty.ValueType.Name.Contains ("Material")) {  						// write other values for the first material  						// then write first values for other materials   						// then write remaining values for other materials individually  						var firstMaterialProperty = properties.First ();  						properties = firstMaterialProperty.ValueType.Properties;  						foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  							properties = materialSubProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValue (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialSubProperty.ValueType.Properties;  											var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  											if (firstValueProperty != null) {  												WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							properties = materialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  					}  					var additionalProperties = subProperty.ValueType.AdditionalProperties;  					if (additionalProperties != null) {  						foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  							int i = 0;  							properties = additionalProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' additionalProperties.ValueType.Name' additionalProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									string propName = string.Format ("{0}{1}"' "prop"' i++);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var a = w2.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  									writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValue (writer' "w3"' id + property.Name + subProperty.Name' valueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' propName' additionalProperty.Name));  									}  								}  							}  						}  					}  				}  			}  		}  		// create all types of custom properties  		writer.WriteLine ("private void WriteConstantValuesCustomProperties()");  		using (writer.OpenScope ()) {  			var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  			if (propertiesProperty != null) {  				var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  				if (additionalProperties != null) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = "constant_custom";  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue)) {  								string propName = string.Format ("custom_{0}"' valueProperty.Name);  								writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  								using (writer.OpenScope ()) {  									WriteValue (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  								}  							}  						}  					}  				}  			}  		}  		// create entities using references  		writer.WriteLine ("private void WriteReferenceValues()");  		using (writer.OpenScope ()) {  			// write some positions and double values to use to create reference lists for position lists and double lists later  			for (int i = 1; i <= 2; ++i) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("ConstantPosition{0}"' i);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantPosition{0}')).toBeDefined();"' i);  					var property = schemaProperties.First (p => p.Name == "position");  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var properties = property.ValueType.Properties;  						var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  						WriteValue (writer' "w"' id' firstValueProperty' property' false' property.Name);  					}  				}  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("ConstantDouble{0}"' i);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantDouble{0}')).toBeDefined();"' i);  					var property = schemaProperties.First (p => p.Name == "billboard");  					var properties = property.ValueType.Properties;  					var subProperty = properties.First (p => p.Name == "scale");  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						properties = subProperty.ValueType.Properties;  						var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  						WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' false' string.Format ("{0}.{1}"' property.Name' subProperty.Name));  					}  				}  			}  			// write one big packet with references for everything  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				writer.WriteLine ("packet.WriteId(\"Reference\");");  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Reference')).toBeDefined();");  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var properties = property.ValueType.Properties;  						if (properties.Any (p => p.ValueType.Name == "Reference")) {  							writer.WriteLine ("w.WriteReference(new Reference(\"Constant\"' \"{0}\"));"' propertyName);  							WriteAssertion (writer' isExtension' "expect(e.{0}.getValue(date)).toEqual(constant.{0}.getValue(date));"' propertyName);  						} else {  							foreach (var subProperty in properties.Where (p => !p.IsValue)) {  								properties = subProperty.ValueType.Properties;  								string subPropertyName = GetSubPropertyName (propertyName' subProperty);  								if (properties.Any (p => p.ValueType.Name == "Reference")) {  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										writer.WriteLine ("w2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\")));"' propertyName' subPropertyName);  										WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual(constant.{0}.{1}.getValue(date));"' propertyName' subPropertyName);  									}  								} else if (properties.Any (p => p.ValueType.Name == "ReferenceList")) {  									string targetId = "";  									string[] referencePropertyNames =  {    									};  									if (subProperty.ValueType.Name == "PositionList") {  										targetId = "Position";  										referencePropertyNames = new[] {  											"position"  										};  									} else if (subProperty.ValueType.Name == "DoubleList") {  										targetId = "Double";  										referencePropertyNames = new[] {  											"billboard"'  											"scale"  										};  									}  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										writer.WriteLine ("w2.WriteReferences(CreateList(new Reference(\"Constant{0}1\"' CreateList({1}))' new Reference(\"Constant{0}2\"' CreateList({1}))));"' targetId' string.Join ("' "' referencePropertyNames.Select (n => string.Format ("\"{0}\""' n))));  										WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual([dataSource.entities.getById('Constant{2}1').{3}.getValue(date)' dataSource.entities.getById('Constant{2}2').{3}.getValue(date)]);"' propertyName' subPropertyName' targetId' string.Join ("."' referencePropertyNames));  									}  								} else if (subProperty.ValueType.Name.Contains ("Material")) {  									Property materialProperty = properties.First ();  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												writer.WriteLine ("m2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"{2}\")));"' propertyName' subPropertyName' materialSubProperty.Name);  												WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.{2}.getValue(date)).toEqual(constant.{0}.{1}.{2}.getValue(date));"' propertyName' subPropertyName' materialSubProperty.Name);  											}  										}  									}  								} else {  									var additionalProperties = subProperty.ValueType.AdditionalProperties;  									if (additionalProperties != null) {  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var a = w2.Open{0}Property(\"referenceProp\"))"' additionalProperties.ValueType.NameWithPascalCase);  										using (writer.OpenScope ()) {  											foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													writer.WriteLine ("w3.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"prop\"' \"{2}\")));"' propertyName' subPropertyName' additionalProperty.Name);  													WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.referenceProp.{2}.getValue(date)).toEqual(constant.{0}.{1}.prop.{2}.getValue(date));"' propertyName' subPropertyName' additionalProperty.Name);  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			writer.WriteLine ("WriteReferenceValuesIndividual();");  		}  		writer.WriteLine ("private void WriteReferenceValuesIndividual()");  		using (writer.OpenScope ()) {  			// write other materials as individual packets  			foreach (var property in schemaProperties) {  				writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  			}  			// special case - velocity reference  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  				var property = schemaProperties.First (p => p.Name == "position");  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					// construct a position with specific velocity  					double dx = 1.0;  					double dy = 2.0;  					double dz = 3.0;  					double deltaTime = 60.0;  					double x1 = 1.0;  					double x2 = x1 + dx * deltaTime;  					double y1 = 2.0;  					double y2 = y1 + dy * deltaTime;  					double z1 = 3.0;  					double z2 = z1 + dz * deltaTime;  					string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  					string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  					string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  					string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  					writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  					WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  					WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  				}  			}  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					properties = subProperty.ValueType.Properties;  					if (properties.Any (p => p.Name == "velocityReference")) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  								double expectedX = 1.0;  								double expectedY = 2.0;  								double expectedZ = 3.0;  								bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  								if (isNormalized) {  									NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  								}  								WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  							}  						}  					}  				}  			}  		}  		// write other materials as individual packets  		foreach (var property in schemaProperties) {  			writer.WriteLine ("private void WriteReferenceValuesIndividual{0}()"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					string subPropertyName = GetSubPropertyName (propertyName' subProperty);  					if (subProperty.ValueType.Name.Contains ("Material")) {  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string targetId = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  								string id = string.Format ("reference_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("m2.WriteReference(new Reference(\"{0}\"' CreateList(\"{1}\"' \"{2}\"' \"{3}\")));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  											WriteAssertion (writer' isExtension' "expect(e.{1}.{2}.{3}.getValue(date)).toEqual(dataSource.entities.getById('{0}').{1}.{2}.{3}.getValue(date));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  										}  									}  								}  							}  						}  					}  				}  			}  		}  		// test sampled properties  		writer.WriteLine ("private void WriteSampledValues()");  		using (writer.OpenScope ()) {  			// Write one packet with first value types for each property  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				const string id = "Sampled";  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Sampled')).toBeDefined();");  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					if (property.IsInterpolatable) {  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  							WriteValues (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  						}  					} else {  						var subProperties = properties.Where (p => !p.IsValue && (p.IsInterpolatable || p.ValueType.Name.Contains ("Material"))).ToList ();  						if (subProperties.Any ()) {  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								foreach (var subProperty in subProperties) {  									properties = subProperty.ValueType.Properties;  									string subPropertyName = GetSubPropertyName (propertyName' subProperty);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										if (subProperty.IsInterpolatable) {  											var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  											WriteValues (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  										} else if (subProperty.ValueType.Name.Contains ("Material")) {  											Property materialProperty = properties.First ();  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialProperty.ValueType.Properties;  												foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  													writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														properties = materialSubProperty.ValueType.Properties;  														var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  														WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			writer.WriteLine ("WriteSampledValuesIndividual();");  			writer.WriteLine ("WriteSampledValuesCustomProperties();");  		}  		writer.WriteLine ("private void WriteSampledValuesIndividual()");  		using (writer.OpenScope ()) {  			// write other value types as individual packets  			// split method into multiple methods  			foreach (var property in schemaProperties) {  				writer.WriteLine ("WriteSampledValuesIndividual{0}();"' property.NameWithPascalCase);  			}  		}  		foreach (var property in schemaProperties) {  			writer.WriteLine ("private void WriteSampledValuesIndividual{0}()"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				if (property.IsInterpolatable) {  					foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("sampled_{0}_{1}"' propertyName' valueProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								WriteValues (writer' "w"' id' valueProperty' property' isExtension' propertyName);  							}  						}  					}  				} else {  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						string subPropertyName = GetSubPropertyName (propertyName' subProperty);  						properties = subProperty.ValueType.Properties;  						if (subProperty.IsInterpolatable) {  							foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' valueProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValues (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  									}  								}  							}  						} else if (subProperty.ValueType.Name.Contains ("Material")) {  							// write other values for the first material  							// then write first values for other materials   							// then write remaining values for other materials individually  							var firstMaterialProperty = properties.First ();  							properties = firstMaterialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValues (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialSubProperty.ValueType.Properties;  												var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  												WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  									properties = materialSubProperty.ValueType.Properties;  									foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  										writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  										using (writer.OpenScope ()) {  											string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  											writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  											WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  											writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		// create all types of custom properties  		writer.WriteLine ("private void WriteSampledValuesCustomProperties()");  		using (writer.OpenScope ()) {  			var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  			if (propertiesProperty != null) {  				var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  				if (additionalProperties != null) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = "sampled_custom";  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array)) {  								string propName = string.Format ("custom_{0}"' valueProperty.Name);  								writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  								using (writer.OpenScope ()) {  									WriteValues (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  								}  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	writer.WriteLine ("[TestFixture]");  	writer.WriteLine ("[SuppressMessage(\"ReSharper\"' \"MemberCanBeMadeStatic.Local\")]");  	writer.WriteLine ("public class TestGenerateValidationDocument");  	using (writer.OpenScope ()) {  		writer.WriteLine ("private readonly JulianDate m_documentStartDate = new GregorianDate(2016' 6' 17' 12' 0' 0).ToJulianDate();");  		writer.WriteLine ("private readonly JulianDate m_documentStopDate = new GregorianDate(2016' 6' 17' 13' 0' 0).ToJulianDate();");  		writer.WriteLine ("private TextWriter m_streamWriter;");  		writer.WriteLine ("private TextWriter m_assertionsWriter;");  		writer.WriteLine ("private TextWriter m_extensionsAssertionsWriter;");  		writer.WriteLine ("private CesiumOutputStream m_output;");  		writer.WriteLine ("private CesiumStreamWriter m_writer;");  		writer.WriteLine ("private void WriteAssertionBoth(string s)");  		using (writer.OpenScope ()) {  			writer.WriteLine ("m_assertionsWriter.WriteLine(s);");  			writer.WriteLine ("m_extensionsAssertionsWriter.WriteLine(s);");  		}  		writer.WriteLine ("private static IList<T> CreateList<T>(T t1' T t2)");  		using (writer.OpenScope ()) {  			writer.WriteLine ("return new List<T> { t1' t2 };");  		}  		writer.WriteLine ("private static IList<T> CreateList<T>(params T[] ts)");  		using (writer.OpenScope ()) {  			writer.WriteLine ("return ts;");  		}  		writer.WriteLine ("[Test]");  		writer.WriteLine ("public void GenerateValidationDocument()");  		var schemaProperties = schema.Properties.Where (p => p.Name != "clock" && p.Name != "availability" && !p.ValueType.IsSchemaFromType).Where (p => p.Name != "properties").ToList ();  		using (writer.OpenScope ()) {  			writer.WriteLine ("using (m_streamWriter = new StreamWriter(\"ValidationDocument.czml\"))");  			writer.WriteLine ("using (m_assertionsWriter = new StreamWriter(\"ValidationDocumentAssertions.js\"))");  			writer.WriteLine ("using (m_extensionsAssertionsWriter = new StreamWriter(\"ValidationDocumentExtensionAssertions.js\"))");  			using (writer.OpenScope ()) {  				WriteAssertionBoth (writer' "return CzmlDataSource.load('Data/CZML/ValidationDocument.czml').then(function(dataSource) {");  				s_assertionIndent++;  				WriteAssertionBoth (writer' "/*jshint -W120 */");  				WriteAssertionBoth (writer' "var e;");  				WriteAssertionBoth (writer' "var date;");  				WriteAssertionBoth (writer' "var documentStartDate = JulianDate.fromIso8601('2016-06-17T12:00:00Z');");  				WriteAssertionBoth (writer' "var documentStopDate = JulianDate.fromIso8601('2016-06-17T13:00:00Z');");  				writer.WriteLine ("m_output = new CesiumOutputStream(m_streamWriter) { PrettyFormatting = true };");  				writer.WriteLine ("m_writer = new CesiumStreamWriter();");  				writer.WriteLine ("m_output.WriteStartSequence();");  				// Java has a limit on the size of a single method (65535 bytes) so we have to break up all this code in multiple methods  				writer.WriteLine ("WriteClock();");  				writer.WriteLine ("WriteConstantValues();");  				writer.WriteLine ("WriteReferenceValues();");  				writer.WriteLine ("WriteSampledValues();");  				writer.WriteLine ("m_output.WriteEndSequence();");  				s_assertionIndent--;  				WriteAssertionBoth (writer' "});");  				s_assertionIndent++;  			}  		}  		writer.WriteLine ("private void WriteClock()");  		using (writer.OpenScope ()) {  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				writer.WriteLine ("packet.WriteId(\"document\");");  				writer.WriteLine ("packet.WriteName(\"ValidationDocument\");");  				writer.WriteLine ("packet.WriteVersion(\"1.0\");");  				writer.WriteLine ("using (var clock = packet.OpenClockProperty())");  				using (writer.OpenScope ()) {  					writer.WriteLine ("clock.WriteInterval(m_documentStartDate' m_documentStopDate);");  					WriteAssertion (writer' false' "expect(dataSource.clock.startTime).toEqual(documentStartDate);");  					WriteAssertion (writer' false' "expect(dataSource.clock.stopTime).toEqual(documentStopDate);");  					writer.WriteLine ("clock.WriteCurrentTime(m_documentStartDate);");  					WriteAssertion (writer' false' "expect(dataSource.clock.currentTime).toEqual(documentStartDate);");  					writer.WriteLine ("clock.WriteMultiplier(1.0);");  					WriteAssertion (writer' false' "expect(dataSource.clock.multiplier).toEqual(1.0);");  					writer.WriteLine ("clock.WriteRange(ClockRange.Unbounded);");  					WriteAssertion (writer' false' "expect(dataSource.clock.clockRange).toEqual(ClockRange.UNBOUNDED);");  					writer.WriteLine ("clock.WriteStep(ClockStep.SystemClockMultiplier);");  					WriteAssertion (writer' false' "expect(dataSource.clock.clockStep).toEqual(ClockStep.SYSTEM_CLOCK_MULTIPLIER);");  				}  			}  		}  		writer.WriteLine ("private void WriteConstantValues()");  		using (writer.OpenScope ()) {  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				const string id = "Constant";  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "var constant = e = dataSource.entities.getById('Constant');");  				WriteAssertionBoth (writer' "expect(e).toBeDefined();");  				WriteAssertionBoth (writer' "date = JulianDate.now();");  				// Write one packet with first value types for each property  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var properties = property.ValueType.Properties;  						var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  						if (firstValueProperty != null) {  							WriteValue (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  						} else {  							foreach (var subProperty in properties.Where (p => !p.IsValue)) {  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = subProperty.ValueType.Properties;  									firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  									string subPropertyName = GetSubPropertyName (propertyName' subProperty);  									if (firstValueProperty != null) {  										WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  									} else if (subProperty.ValueType.Name.Contains ("Material")) {  										Property materialProperty = properties.First ();  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialSubProperty.ValueType.Properties;  													firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  													if (firstValueProperty != null) {  														WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  													}  												}  											}  										}  									} else {  										var additionalProperties = subProperty.ValueType.AdditionalProperties;  										if (additionalProperties != null) {  											writer.WriteLine ("using (var a = w2.Open{0}Property(\"prop\"))"' additionalProperties.ValueType.NameWithPascalCase);  											using (writer.OpenScope ()) {  												foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  													writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														properties = additionalProperty.ValueType.Properties;  														firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  														if (firstValueProperty != null) {  															WriteValue (writer' "w3"' id + property.Name' firstValueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' "prop"' additionalProperty.Name));  														}  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			writer.WriteLine ("WriteConstantValuesIndividual();");  			writer.WriteLine ("WriteConstantValuesCustomProperties();");  		}  		writer.WriteLine ("private void WriteConstantValuesIndividual()");  		using (writer.OpenScope ()) {  			// write other value types as individual packets  			foreach (var property in schemaProperties) {  				writer.WriteLine ("WriteConstantValuesIndividual{0}();"' property.NameWithPascalCase);  			}  		}  		foreach (var property in schemaProperties) {  			writer.WriteLine ("private void WriteConstantValuesIndividual{0}()"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("constant_{0}_{1}"' property.Name' valueProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							WriteValue (writer' "w"' id' valueProperty' property' isExtension' propertyName);  						}  					}  				}  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					string subPropertyName = GetSubPropertyName (propertyName' subProperty);  					properties = subProperty.ValueType.Properties;  					foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("constant_{0}_{1}_{2}"' property.Name' subPropertyName' valueProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								WriteValue (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  							}  						}  					}  					if (subProperty.ValueType.Name.Contains ("Material")) {  						// write other values for the first material  						// then write first values for other materials   						// then write remaining values for other materials individually  						var firstMaterialProperty = properties.First ();  						properties = firstMaterialProperty.ValueType.Properties;  						foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  							properties = materialSubProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValue (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialSubProperty.ValueType.Properties;  											var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  											if (firstValueProperty != null) {  												WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							properties = materialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  					}  					var additionalProperties = subProperty.ValueType.AdditionalProperties;  					if (additionalProperties != null) {  						foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  							int i = 0;  							properties = additionalProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' additionalProperties.ValueType.Name' additionalProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									string propName = string.Format ("{0}{1}"' "prop"' i++);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var a = w2.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  									writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValue (writer' "w3"' id + property.Name + subProperty.Name' valueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' propName' additionalProperty.Name));  									}  								}  							}  						}  					}  				}  			}  		}  		// create all types of custom properties  		writer.WriteLine ("private void WriteConstantValuesCustomProperties()");  		using (writer.OpenScope ()) {  			var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  			if (propertiesProperty != null) {  				var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  				if (additionalProperties != null) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = "constant_custom";  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue)) {  								string propName = string.Format ("custom_{0}"' valueProperty.Name);  								writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  								using (writer.OpenScope ()) {  									WriteValue (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  								}  							}  						}  					}  				}  			}  		}  		// create entities using references  		writer.WriteLine ("private void WriteReferenceValues()");  		using (writer.OpenScope ()) {  			// write some positions and double values to use to create reference lists for position lists and double lists later  			for (int i = 1; i <= 2; ++i) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("ConstantPosition{0}"' i);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantPosition{0}')).toBeDefined();"' i);  					var property = schemaProperties.First (p => p.Name == "position");  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var properties = property.ValueType.Properties;  						var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  						WriteValue (writer' "w"' id' firstValueProperty' property' false' property.Name);  					}  				}  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("ConstantDouble{0}"' i);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantDouble{0}')).toBeDefined();"' i);  					var property = schemaProperties.First (p => p.Name == "billboard");  					var properties = property.ValueType.Properties;  					var subProperty = properties.First (p => p.Name == "scale");  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						properties = subProperty.ValueType.Properties;  						var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  						WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' false' string.Format ("{0}.{1}"' property.Name' subProperty.Name));  					}  				}  			}  			// write one big packet with references for everything  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				writer.WriteLine ("packet.WriteId(\"Reference\");");  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Reference')).toBeDefined();");  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var properties = property.ValueType.Properties;  						if (properties.Any (p => p.ValueType.Name == "Reference")) {  							writer.WriteLine ("w.WriteReference(new Reference(\"Constant\"' \"{0}\"));"' propertyName);  							WriteAssertion (writer' isExtension' "expect(e.{0}.getValue(date)).toEqual(constant.{0}.getValue(date));"' propertyName);  						} else {  							foreach (var subProperty in properties.Where (p => !p.IsValue)) {  								properties = subProperty.ValueType.Properties;  								string subPropertyName = GetSubPropertyName (propertyName' subProperty);  								if (properties.Any (p => p.ValueType.Name == "Reference")) {  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										writer.WriteLine ("w2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\")));"' propertyName' subPropertyName);  										WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual(constant.{0}.{1}.getValue(date));"' propertyName' subPropertyName);  									}  								} else if (properties.Any (p => p.ValueType.Name == "ReferenceList")) {  									string targetId = "";  									string[] referencePropertyNames =  {    									};  									if (subProperty.ValueType.Name == "PositionList") {  										targetId = "Position";  										referencePropertyNames = new[] {  											"position"  										};  									} else if (subProperty.ValueType.Name == "DoubleList") {  										targetId = "Double";  										referencePropertyNames = new[] {  											"billboard"'  											"scale"  										};  									}  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										writer.WriteLine ("w2.WriteReferences(CreateList(new Reference(\"Constant{0}1\"' CreateList({1}))' new Reference(\"Constant{0}2\"' CreateList({1}))));"' targetId' string.Join ("' "' referencePropertyNames.Select (n => string.Format ("\"{0}\""' n))));  										WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual([dataSource.entities.getById('Constant{2}1').{3}.getValue(date)' dataSource.entities.getById('Constant{2}2').{3}.getValue(date)]);"' propertyName' subPropertyName' targetId' string.Join ("."' referencePropertyNames));  									}  								} else if (subProperty.ValueType.Name.Contains ("Material")) {  									Property materialProperty = properties.First ();  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												writer.WriteLine ("m2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"{2}\")));"' propertyName' subPropertyName' materialSubProperty.Name);  												WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.{2}.getValue(date)).toEqual(constant.{0}.{1}.{2}.getValue(date));"' propertyName' subPropertyName' materialSubProperty.Name);  											}  										}  									}  								} else {  									var additionalProperties = subProperty.ValueType.AdditionalProperties;  									if (additionalProperties != null) {  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var a = w2.Open{0}Property(\"referenceProp\"))"' additionalProperties.ValueType.NameWithPascalCase);  										using (writer.OpenScope ()) {  											foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													writer.WriteLine ("w3.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"prop\"' \"{2}\")));"' propertyName' subPropertyName' additionalProperty.Name);  													WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.referenceProp.{2}.getValue(date)).toEqual(constant.{0}.{1}.prop.{2}.getValue(date));"' propertyName' subPropertyName' additionalProperty.Name);  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			writer.WriteLine ("WriteReferenceValuesIndividual();");  		}  		writer.WriteLine ("private void WriteReferenceValuesIndividual()");  		using (writer.OpenScope ()) {  			// write other materials as individual packets  			foreach (var property in schemaProperties) {  				writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  			}  			// special case - velocity reference  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  				var property = schemaProperties.First (p => p.Name == "position");  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					// construct a position with specific velocity  					double dx = 1.0;  					double dy = 2.0;  					double dz = 3.0;  					double deltaTime = 60.0;  					double x1 = 1.0;  					double x2 = x1 + dx * deltaTime;  					double y1 = 2.0;  					double y2 = y1 + dy * deltaTime;  					double z1 = 3.0;  					double z2 = z1 + dz * deltaTime;  					string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  					string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  					string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  					string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  					writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  					WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  					WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  				}  			}  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					properties = subProperty.ValueType.Properties;  					if (properties.Any (p => p.Name == "velocityReference")) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  								double expectedX = 1.0;  								double expectedY = 2.0;  								double expectedZ = 3.0;  								bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  								if (isNormalized) {  									NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  								}  								WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  							}  						}  					}  				}  			}  		}  		// write other materials as individual packets  		foreach (var property in schemaProperties) {  			writer.WriteLine ("private void WriteReferenceValuesIndividual{0}()"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					string subPropertyName = GetSubPropertyName (propertyName' subProperty);  					if (subProperty.ValueType.Name.Contains ("Material")) {  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string targetId = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  								string id = string.Format ("reference_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("m2.WriteReference(new Reference(\"{0}\"' CreateList(\"{1}\"' \"{2}\"' \"{3}\")));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  											WriteAssertion (writer' isExtension' "expect(e.{1}.{2}.{3}.getValue(date)).toEqual(dataSource.entities.getById('{0}').{1}.{2}.{3}.getValue(date));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  										}  									}  								}  							}  						}  					}  				}  			}  		}  		// test sampled properties  		writer.WriteLine ("private void WriteSampledValues()");  		using (writer.OpenScope ()) {  			// Write one packet with first value types for each property  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				const string id = "Sampled";  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Sampled')).toBeDefined();");  				foreach (var property in schemaProperties) {  					string propertyName = property.Name;  					bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  					if (isExtension)  						propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  					var properties = property.ValueType.Properties;  					if (property.IsInterpolatable) {  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  							WriteValues (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  						}  					} else {  						var subProperties = properties.Where (p => !p.IsValue && (p.IsInterpolatable || p.ValueType.Name.Contains ("Material"))).ToList ();  						if (subProperties.Any ()) {  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								foreach (var subProperty in subProperties) {  									properties = subProperty.ValueType.Properties;  									string subPropertyName = GetSubPropertyName (propertyName' subProperty);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										if (subProperty.IsInterpolatable) {  											var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  											WriteValues (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  										} else if (subProperty.ValueType.Name.Contains ("Material")) {  											Property materialProperty = properties.First ();  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialProperty.ValueType.Properties;  												foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  													writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  													using (writer.OpenScope ()) {  														properties = materialSubProperty.ValueType.Properties;  														var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  														WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  			writer.WriteLine ("WriteSampledValuesIndividual();");  			writer.WriteLine ("WriteSampledValuesCustomProperties();");  		}  		writer.WriteLine ("private void WriteSampledValuesIndividual()");  		using (writer.OpenScope ()) {  			// write other value types as individual packets  			// split method into multiple methods  			foreach (var property in schemaProperties) {  				writer.WriteLine ("WriteSampledValuesIndividual{0}();"' property.NameWithPascalCase);  			}  		}  		foreach (var property in schemaProperties) {  			writer.WriteLine ("private void WriteSampledValuesIndividual{0}()"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				if (property.IsInterpolatable) {  					foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("sampled_{0}_{1}"' propertyName' valueProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							using (writer.OpenScope ()) {  								WriteValues (writer' "w"' id' valueProperty' property' isExtension' propertyName);  							}  						}  					}  				} else {  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						string subPropertyName = GetSubPropertyName (propertyName' subProperty);  						properties = subProperty.ValueType.Properties;  						if (subProperty.IsInterpolatable) {  							foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' valueProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValues (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  									}  								}  							}  						} else if (subProperty.ValueType.Name.Contains ("Material")) {  							// write other values for the first material  							// then write first values for other materials   							// then write remaining values for other materials individually  							var firstMaterialProperty = properties.First ();  							properties = firstMaterialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValues (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialSubProperty.ValueType.Properties;  												var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  												WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  							properties = subProperty.ValueType.Properties;  							foreach (var materialProperty in properties.Skip (1)) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  									properties = materialSubProperty.ValueType.Properties;  									foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  										writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  										using (writer.OpenScope ()) {  											string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  											writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  											WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  											writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  											writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		// create all types of custom properties  		writer.WriteLine ("private void WriteSampledValuesCustomProperties()");  		using (writer.OpenScope ()) {  			var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  			if (propertiesProperty != null) {  				var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  				if (additionalProperties != null) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = "sampled_custom";  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array)) {  								string propName = string.Format ("custom_{0}"' valueProperty.Name);  								writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  								using (writer.OpenScope ()) {  									WriteValues (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  								}  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	writer.WriteLine ("private readonly JulianDate m_documentStartDate = new GregorianDate(2016' 6' 17' 12' 0' 0).ToJulianDate();");  	writer.WriteLine ("private readonly JulianDate m_documentStopDate = new GregorianDate(2016' 6' 17' 13' 0' 0).ToJulianDate();");  	writer.WriteLine ("private TextWriter m_streamWriter;");  	writer.WriteLine ("private TextWriter m_assertionsWriter;");  	writer.WriteLine ("private TextWriter m_extensionsAssertionsWriter;");  	writer.WriteLine ("private CesiumOutputStream m_output;");  	writer.WriteLine ("private CesiumStreamWriter m_writer;");  	writer.WriteLine ("private void WriteAssertionBoth(string s)");  	using (writer.OpenScope ()) {  		writer.WriteLine ("m_assertionsWriter.WriteLine(s);");  		writer.WriteLine ("m_extensionsAssertionsWriter.WriteLine(s);");  	}  	writer.WriteLine ("private static IList<T> CreateList<T>(T t1' T t2)");  	using (writer.OpenScope ()) {  		writer.WriteLine ("return new List<T> { t1' t2 };");  	}  	writer.WriteLine ("private static IList<T> CreateList<T>(params T[] ts)");  	using (writer.OpenScope ()) {  		writer.WriteLine ("return ts;");  	}  	writer.WriteLine ("[Test]");  	writer.WriteLine ("public void GenerateValidationDocument()");  	var schemaProperties = schema.Properties.Where (p => p.Name != "clock" && p.Name != "availability" && !p.ValueType.IsSchemaFromType).Where (p => p.Name != "properties").ToList ();  	using (writer.OpenScope ()) {  		writer.WriteLine ("using (m_streamWriter = new StreamWriter(\"ValidationDocument.czml\"))");  		writer.WriteLine ("using (m_assertionsWriter = new StreamWriter(\"ValidationDocumentAssertions.js\"))");  		writer.WriteLine ("using (m_extensionsAssertionsWriter = new StreamWriter(\"ValidationDocumentExtensionAssertions.js\"))");  		using (writer.OpenScope ()) {  			WriteAssertionBoth (writer' "return CzmlDataSource.load('Data/CZML/ValidationDocument.czml').then(function(dataSource) {");  			s_assertionIndent++;  			WriteAssertionBoth (writer' "/*jshint -W120 */");  			WriteAssertionBoth (writer' "var e;");  			WriteAssertionBoth (writer' "var date;");  			WriteAssertionBoth (writer' "var documentStartDate = JulianDate.fromIso8601('2016-06-17T12:00:00Z');");  			WriteAssertionBoth (writer' "var documentStopDate = JulianDate.fromIso8601('2016-06-17T13:00:00Z');");  			writer.WriteLine ("m_output = new CesiumOutputStream(m_streamWriter) { PrettyFormatting = true };");  			writer.WriteLine ("m_writer = new CesiumStreamWriter();");  			writer.WriteLine ("m_output.WriteStartSequence();");  			// Java has a limit on the size of a single method (65535 bytes) so we have to break up all this code in multiple methods  			writer.WriteLine ("WriteClock();");  			writer.WriteLine ("WriteConstantValues();");  			writer.WriteLine ("WriteReferenceValues();");  			writer.WriteLine ("WriteSampledValues();");  			writer.WriteLine ("m_output.WriteEndSequence();");  			s_assertionIndent--;  			WriteAssertionBoth (writer' "});");  			s_assertionIndent++;  		}  	}  	writer.WriteLine ("private void WriteClock()");  	using (writer.OpenScope ()) {  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			writer.WriteLine ("packet.WriteId(\"document\");");  			writer.WriteLine ("packet.WriteName(\"ValidationDocument\");");  			writer.WriteLine ("packet.WriteVersion(\"1.0\");");  			writer.WriteLine ("using (var clock = packet.OpenClockProperty())");  			using (writer.OpenScope ()) {  				writer.WriteLine ("clock.WriteInterval(m_documentStartDate' m_documentStopDate);");  				WriteAssertion (writer' false' "expect(dataSource.clock.startTime).toEqual(documentStartDate);");  				WriteAssertion (writer' false' "expect(dataSource.clock.stopTime).toEqual(documentStopDate);");  				writer.WriteLine ("clock.WriteCurrentTime(m_documentStartDate);");  				WriteAssertion (writer' false' "expect(dataSource.clock.currentTime).toEqual(documentStartDate);");  				writer.WriteLine ("clock.WriteMultiplier(1.0);");  				WriteAssertion (writer' false' "expect(dataSource.clock.multiplier).toEqual(1.0);");  				writer.WriteLine ("clock.WriteRange(ClockRange.Unbounded);");  				WriteAssertion (writer' false' "expect(dataSource.clock.clockRange).toEqual(ClockRange.UNBOUNDED);");  				writer.WriteLine ("clock.WriteStep(ClockStep.SystemClockMultiplier);");  				WriteAssertion (writer' false' "expect(dataSource.clock.clockStep).toEqual(ClockStep.SYSTEM_CLOCK_MULTIPLIER);");  			}  		}  	}  	writer.WriteLine ("private void WriteConstantValues()");  	using (writer.OpenScope ()) {  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			const string id = "Constant";  			writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  			WriteAssertionBoth (writer' "var constant = e = dataSource.entities.getById('Constant');");  			WriteAssertionBoth (writer' "expect(e).toBeDefined();");  			WriteAssertionBoth (writer' "date = JulianDate.now();");  			// Write one packet with first value types for each property  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					var properties = property.ValueType.Properties;  					var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  					if (firstValueProperty != null) {  						WriteValue (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  					} else {  						foreach (var subProperty in properties.Where (p => !p.IsValue)) {  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								properties = subProperty.ValueType.Properties;  								firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  								string subPropertyName = GetSubPropertyName (propertyName' subProperty);  								if (firstValueProperty != null) {  									WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  								} else if (subProperty.ValueType.Name.Contains ("Material")) {  									Property materialProperty = properties.First ();  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialSubProperty.ValueType.Properties;  												firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  												if (firstValueProperty != null) {  													WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								} else {  									var additionalProperties = subProperty.ValueType.AdditionalProperties;  									if (additionalProperties != null) {  										writer.WriteLine ("using (var a = w2.Open{0}Property(\"prop\"))"' additionalProperties.ValueType.NameWithPascalCase);  										using (writer.OpenScope ()) {  											foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = additionalProperty.ValueType.Properties;  													firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  													if (firstValueProperty != null) {  														WriteValue (writer' "w3"' id + property.Name' firstValueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' "prop"' additionalProperty.Name));  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		writer.WriteLine ("WriteConstantValuesIndividual();");  		writer.WriteLine ("WriteConstantValuesCustomProperties();");  	}  	writer.WriteLine ("private void WriteConstantValuesIndividual()");  	using (writer.OpenScope ()) {  		// write other value types as individual packets  		foreach (var property in schemaProperties) {  			writer.WriteLine ("WriteConstantValuesIndividual{0}();"' property.NameWithPascalCase);  		}  	}  	foreach (var property in schemaProperties) {  		writer.WriteLine ("private void WriteConstantValuesIndividual{0}()"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("constant_{0}_{1}"' property.Name' valueProperty.Name);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						WriteValue (writer' "w"' id' valueProperty' property' isExtension' propertyName);  					}  				}  			}  			foreach (var subProperty in properties.Where (p => !p.IsValue)) {  				string subPropertyName = GetSubPropertyName (propertyName' subProperty);  				properties = subProperty.ValueType.Properties;  				foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("constant_{0}_{1}_{2}"' property.Name' subPropertyName' valueProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							WriteValue (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  						}  					}  				}  				if (subProperty.ValueType.Name.Contains ("Material")) {  					// write other values for the first material  					// then write first values for other materials   					// then write remaining values for other materials individually  					var firstMaterialProperty = properties.First ();  					properties = firstMaterialProperty.ValueType.Properties;  					foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  						properties = materialSubProperty.ValueType.Properties;  						foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValue (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  								}  							}  						}  					}  					properties = subProperty.ValueType.Properties;  					foreach (var materialProperty in properties.Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialSubProperty.ValueType.Properties;  										var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  										if (firstValueProperty != null) {  											WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  					}  					properties = subProperty.ValueType.Properties;  					foreach (var materialProperty in properties.Skip (1)) {  						properties = materialProperty.ValueType.Properties;  						foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  							properties = materialSubProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  									}  								}  							}  						}  					}  				}  				var additionalProperties = subProperty.ValueType.AdditionalProperties;  				if (additionalProperties != null) {  					foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  						int i = 0;  						properties = additionalProperty.ValueType.Properties;  						foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' additionalProperties.ValueType.Name' additionalProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								string propName = string.Format ("{0}{1}"' "prop"' i++);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var a = w2.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  								writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValue (writer' "w3"' id + property.Name + subProperty.Name' valueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' propName' additionalProperty.Name));  								}  							}  						}  					}  				}  			}  		}  	}  	// create all types of custom properties  	writer.WriteLine ("private void WriteConstantValuesCustomProperties()");  	using (writer.OpenScope ()) {  		var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  		if (propertiesProperty != null) {  			var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  			if (additionalProperties != null) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = "constant_custom";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue)) {  							string propName = string.Format ("custom_{0}"' valueProperty.Name);  							writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  							using (writer.OpenScope ()) {  								WriteValue (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  							}  						}  					}  				}  			}  		}  	}  	// create entities using references  	writer.WriteLine ("private void WriteReferenceValues()");  	using (writer.OpenScope ()) {  		// write some positions and double values to use to create reference lists for position lists and double lists later  		for (int i = 1; i <= 2; ++i) {  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				string id = string.Format ("ConstantPosition{0}"' i);  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantPosition{0}')).toBeDefined();"' i);  				var property = schemaProperties.First (p => p.Name == "position");  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					var properties = property.ValueType.Properties;  					var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  					WriteValue (writer' "w"' id' firstValueProperty' property' false' property.Name);  				}  			}  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				string id = string.Format ("ConstantDouble{0}"' i);  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantDouble{0}')).toBeDefined();"' i);  				var property = schemaProperties.First (p => p.Name == "billboard");  				var properties = property.ValueType.Properties;  				var subProperty = properties.First (p => p.Name == "scale");  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  				using (writer.OpenScope ()) {  					properties = subProperty.ValueType.Properties;  					var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  					WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' false' string.Format ("{0}.{1}"' property.Name' subProperty.Name));  				}  			}  		}  		// write one big packet with references for everything  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			writer.WriteLine ("packet.WriteId(\"Reference\");");  			WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Reference')).toBeDefined();");  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					var properties = property.ValueType.Properties;  					if (properties.Any (p => p.ValueType.Name == "Reference")) {  						writer.WriteLine ("w.WriteReference(new Reference(\"Constant\"' \"{0}\"));"' propertyName);  						WriteAssertion (writer' isExtension' "expect(e.{0}.getValue(date)).toEqual(constant.{0}.getValue(date));"' propertyName);  					} else {  						foreach (var subProperty in properties.Where (p => !p.IsValue)) {  							properties = subProperty.ValueType.Properties;  							string subPropertyName = GetSubPropertyName (propertyName' subProperty);  							if (properties.Any (p => p.ValueType.Name == "Reference")) {  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									writer.WriteLine ("w2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\")));"' propertyName' subPropertyName);  									WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual(constant.{0}.{1}.getValue(date));"' propertyName' subPropertyName);  								}  							} else if (properties.Any (p => p.ValueType.Name == "ReferenceList")) {  								string targetId = "";  								string[] referencePropertyNames =  {    								};  								if (subProperty.ValueType.Name == "PositionList") {  									targetId = "Position";  									referencePropertyNames = new[] {  										"position"  									};  								} else if (subProperty.ValueType.Name == "DoubleList") {  									targetId = "Double";  									referencePropertyNames = new[] {  										"billboard"'  										"scale"  									};  								}  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									writer.WriteLine ("w2.WriteReferences(CreateList(new Reference(\"Constant{0}1\"' CreateList({1}))' new Reference(\"Constant{0}2\"' CreateList({1}))));"' targetId' string.Join ("' "' referencePropertyNames.Select (n => string.Format ("\"{0}\""' n))));  									WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual([dataSource.entities.getById('Constant{2}1').{3}.getValue(date)' dataSource.entities.getById('Constant{2}2').{3}.getValue(date)]);"' propertyName' subPropertyName' targetId' string.Join ("."' referencePropertyNames));  								}  							} else if (subProperty.ValueType.Name.Contains ("Material")) {  								Property materialProperty = properties.First ();  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("m2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"{2}\")));"' propertyName' subPropertyName' materialSubProperty.Name);  											WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.{2}.getValue(date)).toEqual(constant.{0}.{1}.{2}.getValue(date));"' propertyName' subPropertyName' materialSubProperty.Name);  										}  									}  								}  							} else {  								var additionalProperties = subProperty.ValueType.AdditionalProperties;  								if (additionalProperties != null) {  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var a = w2.Open{0}Property(\"referenceProp\"))"' additionalProperties.ValueType.NameWithPascalCase);  									using (writer.OpenScope ()) {  										foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												writer.WriteLine ("w3.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"prop\"' \"{2}\")));"' propertyName' subPropertyName' additionalProperty.Name);  												WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.referenceProp.{2}.getValue(date)).toEqual(constant.{0}.{1}.prop.{2}.getValue(date));"' propertyName' subPropertyName' additionalProperty.Name);  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		writer.WriteLine ("WriteReferenceValuesIndividual();");  	}  	writer.WriteLine ("private void WriteReferenceValuesIndividual()");  	using (writer.OpenScope ()) {  		// write other materials as individual packets  		foreach (var property in schemaProperties) {  			writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  		}  		// special case - velocity reference  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  			WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  			var property = schemaProperties.First (p => p.Name == "position");  			writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				// construct a position with specific velocity  				double dx = 1.0;  				double dy = 2.0;  				double dz = 3.0;  				double deltaTime = 60.0;  				double x1 = 1.0;  				double x2 = x1 + dx * deltaTime;  				double y1 = 2.0;  				double y2 = y1 + dy * deltaTime;  				double z1 = 3.0;  				double z2 = z1 + dz * deltaTime;  				string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  				string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  				string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  				string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  				writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  				WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  				WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  			}  		}  		foreach (var property in schemaProperties) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			foreach (var subProperty in properties.Where (p => !p.IsValue)) {  				properties = subProperty.ValueType.Properties;  				if (properties.Any (p => p.Name == "velocityReference")) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  							double expectedX = 1.0;  							double expectedY = 2.0;  							double expectedZ = 3.0;  							bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  							if (isNormalized) {  								NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  							}  							WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  						}  					}  				}  			}  		}  	}  	// write other materials as individual packets  	foreach (var property in schemaProperties) {  		writer.WriteLine ("private void WriteReferenceValuesIndividual{0}()"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			foreach (var subProperty in properties.Where (p => !p.IsValue)) {  				string subPropertyName = GetSubPropertyName (propertyName' subProperty);  				if (subProperty.ValueType.Name.Contains ("Material")) {  					properties = subProperty.ValueType.Properties;  					foreach (var materialProperty in properties.Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string targetId = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  							string id = string.Format ("reference_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										writer.WriteLine ("m2.WriteReference(new Reference(\"{0}\"' CreateList(\"{1}\"' \"{2}\"' \"{3}\")));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  										WriteAssertion (writer' isExtension' "expect(e.{1}.{2}.{3}.getValue(date)).toEqual(dataSource.entities.getById('{0}').{1}.{2}.{3}.getValue(date));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  									}  								}  							}  						}  					}  				}  			}  		}  	}  	// test sampled properties  	writer.WriteLine ("private void WriteSampledValues()");  	using (writer.OpenScope ()) {  		// Write one packet with first value types for each property  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			const string id = "Sampled";  			writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  			WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Sampled')).toBeDefined();");  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				if (property.IsInterpolatable) {  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  						WriteValues (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  					}  				} else {  					var subProperties = properties.Where (p => !p.IsValue && (p.IsInterpolatable || p.ValueType.Name.Contains ("Material"))).ToList ();  					if (subProperties.Any ()) {  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							foreach (var subProperty in subProperties) {  								properties = subProperty.ValueType.Properties;  								string subPropertyName = GetSubPropertyName (propertyName' subProperty);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									if (subProperty.IsInterpolatable) {  										var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  										WriteValues (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  									} else if (subProperty.ValueType.Name.Contains ("Material")) {  										Property materialProperty = properties.First ();  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialSubProperty.ValueType.Properties;  													var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  													WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		writer.WriteLine ("WriteSampledValuesIndividual();");  		writer.WriteLine ("WriteSampledValuesCustomProperties();");  	}  	writer.WriteLine ("private void WriteSampledValuesIndividual()");  	using (writer.OpenScope ()) {  		// write other value types as individual packets  		// split method into multiple methods  		foreach (var property in schemaProperties) {  			writer.WriteLine ("WriteSampledValuesIndividual{0}();"' property.NameWithPascalCase);  		}  	}  	foreach (var property in schemaProperties) {  		writer.WriteLine ("private void WriteSampledValuesIndividual{0}()"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			if (property.IsInterpolatable) {  				foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("sampled_{0}_{1}"' propertyName' valueProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							WriteValues (writer' "w"' id' valueProperty' property' isExtension' propertyName);  						}  					}  				}  			} else {  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					string subPropertyName = GetSubPropertyName (propertyName' subProperty);  					properties = subProperty.ValueType.Properties;  					if (subProperty.IsInterpolatable) {  						foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' valueProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValues (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  								}  							}  						}  					} else if (subProperty.ValueType.Name.Contains ("Material")) {  						// write other values for the first material  						// then write first values for other materials   						// then write remaining values for other materials individually  						var firstMaterialProperty = properties.First ();  						properties = firstMaterialProperty.ValueType.Properties;  						foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  							properties = materialSubProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValues (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialSubProperty.ValueType.Properties;  											var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  											WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							properties = materialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  					}  				}  			}  		}  	}  	// create all types of custom properties  	writer.WriteLine ("private void WriteSampledValuesCustomProperties()");  	using (writer.OpenScope ()) {  		var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  		if (propertiesProperty != null) {  			var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  			if (additionalProperties != null) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = "sampled_custom";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array)) {  							string propName = string.Format ("custom_{0}"' valueProperty.Name);  							writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  							using (writer.OpenScope ()) {  								WriteValues (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	writer.WriteLine ("private readonly JulianDate m_documentStartDate = new GregorianDate(2016' 6' 17' 12' 0' 0).ToJulianDate();");  	writer.WriteLine ("private readonly JulianDate m_documentStopDate = new GregorianDate(2016' 6' 17' 13' 0' 0).ToJulianDate();");  	writer.WriteLine ("private TextWriter m_streamWriter;");  	writer.WriteLine ("private TextWriter m_assertionsWriter;");  	writer.WriteLine ("private TextWriter m_extensionsAssertionsWriter;");  	writer.WriteLine ("private CesiumOutputStream m_output;");  	writer.WriteLine ("private CesiumStreamWriter m_writer;");  	writer.WriteLine ("private void WriteAssertionBoth(string s)");  	using (writer.OpenScope ()) {  		writer.WriteLine ("m_assertionsWriter.WriteLine(s);");  		writer.WriteLine ("m_extensionsAssertionsWriter.WriteLine(s);");  	}  	writer.WriteLine ("private static IList<T> CreateList<T>(T t1' T t2)");  	using (writer.OpenScope ()) {  		writer.WriteLine ("return new List<T> { t1' t2 };");  	}  	writer.WriteLine ("private static IList<T> CreateList<T>(params T[] ts)");  	using (writer.OpenScope ()) {  		writer.WriteLine ("return ts;");  	}  	writer.WriteLine ("[Test]");  	writer.WriteLine ("public void GenerateValidationDocument()");  	var schemaProperties = schema.Properties.Where (p => p.Name != "clock" && p.Name != "availability" && !p.ValueType.IsSchemaFromType).Where (p => p.Name != "properties").ToList ();  	using (writer.OpenScope ()) {  		writer.WriteLine ("using (m_streamWriter = new StreamWriter(\"ValidationDocument.czml\"))");  		writer.WriteLine ("using (m_assertionsWriter = new StreamWriter(\"ValidationDocumentAssertions.js\"))");  		writer.WriteLine ("using (m_extensionsAssertionsWriter = new StreamWriter(\"ValidationDocumentExtensionAssertions.js\"))");  		using (writer.OpenScope ()) {  			WriteAssertionBoth (writer' "return CzmlDataSource.load('Data/CZML/ValidationDocument.czml').then(function(dataSource) {");  			s_assertionIndent++;  			WriteAssertionBoth (writer' "/*jshint -W120 */");  			WriteAssertionBoth (writer' "var e;");  			WriteAssertionBoth (writer' "var date;");  			WriteAssertionBoth (writer' "var documentStartDate = JulianDate.fromIso8601('2016-06-17T12:00:00Z');");  			WriteAssertionBoth (writer' "var documentStopDate = JulianDate.fromIso8601('2016-06-17T13:00:00Z');");  			writer.WriteLine ("m_output = new CesiumOutputStream(m_streamWriter) { PrettyFormatting = true };");  			writer.WriteLine ("m_writer = new CesiumStreamWriter();");  			writer.WriteLine ("m_output.WriteStartSequence();");  			// Java has a limit on the size of a single method (65535 bytes) so we have to break up all this code in multiple methods  			writer.WriteLine ("WriteClock();");  			writer.WriteLine ("WriteConstantValues();");  			writer.WriteLine ("WriteReferenceValues();");  			writer.WriteLine ("WriteSampledValues();");  			writer.WriteLine ("m_output.WriteEndSequence();");  			s_assertionIndent--;  			WriteAssertionBoth (writer' "});");  			s_assertionIndent++;  		}  	}  	writer.WriteLine ("private void WriteClock()");  	using (writer.OpenScope ()) {  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			writer.WriteLine ("packet.WriteId(\"document\");");  			writer.WriteLine ("packet.WriteName(\"ValidationDocument\");");  			writer.WriteLine ("packet.WriteVersion(\"1.0\");");  			writer.WriteLine ("using (var clock = packet.OpenClockProperty())");  			using (writer.OpenScope ()) {  				writer.WriteLine ("clock.WriteInterval(m_documentStartDate' m_documentStopDate);");  				WriteAssertion (writer' false' "expect(dataSource.clock.startTime).toEqual(documentStartDate);");  				WriteAssertion (writer' false' "expect(dataSource.clock.stopTime).toEqual(documentStopDate);");  				writer.WriteLine ("clock.WriteCurrentTime(m_documentStartDate);");  				WriteAssertion (writer' false' "expect(dataSource.clock.currentTime).toEqual(documentStartDate);");  				writer.WriteLine ("clock.WriteMultiplier(1.0);");  				WriteAssertion (writer' false' "expect(dataSource.clock.multiplier).toEqual(1.0);");  				writer.WriteLine ("clock.WriteRange(ClockRange.Unbounded);");  				WriteAssertion (writer' false' "expect(dataSource.clock.clockRange).toEqual(ClockRange.UNBOUNDED);");  				writer.WriteLine ("clock.WriteStep(ClockStep.SystemClockMultiplier);");  				WriteAssertion (writer' false' "expect(dataSource.clock.clockStep).toEqual(ClockStep.SYSTEM_CLOCK_MULTIPLIER);");  			}  		}  	}  	writer.WriteLine ("private void WriteConstantValues()");  	using (writer.OpenScope ()) {  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			const string id = "Constant";  			writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  			WriteAssertionBoth (writer' "var constant = e = dataSource.entities.getById('Constant');");  			WriteAssertionBoth (writer' "expect(e).toBeDefined();");  			WriteAssertionBoth (writer' "date = JulianDate.now();");  			// Write one packet with first value types for each property  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					var properties = property.ValueType.Properties;  					var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  					if (firstValueProperty != null) {  						WriteValue (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  					} else {  						foreach (var subProperty in properties.Where (p => !p.IsValue)) {  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								properties = subProperty.ValueType.Properties;  								firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  								string subPropertyName = GetSubPropertyName (propertyName' subProperty);  								if (firstValueProperty != null) {  									WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  								} else if (subProperty.ValueType.Name.Contains ("Material")) {  									Property materialProperty = properties.First ();  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialSubProperty.ValueType.Properties;  												firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  												if (firstValueProperty != null) {  													WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								} else {  									var additionalProperties = subProperty.ValueType.AdditionalProperties;  									if (additionalProperties != null) {  										writer.WriteLine ("using (var a = w2.Open{0}Property(\"prop\"))"' additionalProperties.ValueType.NameWithPascalCase);  										using (writer.OpenScope ()) {  											foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = additionalProperty.ValueType.Properties;  													firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  													if (firstValueProperty != null) {  														WriteValue (writer' "w3"' id + property.Name' firstValueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' "prop"' additionalProperty.Name));  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		writer.WriteLine ("WriteConstantValuesIndividual();");  		writer.WriteLine ("WriteConstantValuesCustomProperties();");  	}  	writer.WriteLine ("private void WriteConstantValuesIndividual()");  	using (writer.OpenScope ()) {  		// write other value types as individual packets  		foreach (var property in schemaProperties) {  			writer.WriteLine ("WriteConstantValuesIndividual{0}();"' property.NameWithPascalCase);  		}  	}  	foreach (var property in schemaProperties) {  		writer.WriteLine ("private void WriteConstantValuesIndividual{0}()"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("constant_{0}_{1}"' property.Name' valueProperty.Name);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						WriteValue (writer' "w"' id' valueProperty' property' isExtension' propertyName);  					}  				}  			}  			foreach (var subProperty in properties.Where (p => !p.IsValue)) {  				string subPropertyName = GetSubPropertyName (propertyName' subProperty);  				properties = subProperty.ValueType.Properties;  				foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("constant_{0}_{1}_{2}"' property.Name' subPropertyName' valueProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							WriteValue (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  						}  					}  				}  				if (subProperty.ValueType.Name.Contains ("Material")) {  					// write other values for the first material  					// then write first values for other materials   					// then write remaining values for other materials individually  					var firstMaterialProperty = properties.First ();  					properties = firstMaterialProperty.ValueType.Properties;  					foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  						properties = materialSubProperty.ValueType.Properties;  						foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValue (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  								}  							}  						}  					}  					properties = subProperty.ValueType.Properties;  					foreach (var materialProperty in properties.Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialSubProperty.ValueType.Properties;  										var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  										if (firstValueProperty != null) {  											WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  					}  					properties = subProperty.ValueType.Properties;  					foreach (var materialProperty in properties.Skip (1)) {  						properties = materialProperty.ValueType.Properties;  						foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  							properties = materialSubProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  									}  								}  							}  						}  					}  				}  				var additionalProperties = subProperty.ValueType.AdditionalProperties;  				if (additionalProperties != null) {  					foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  						int i = 0;  						properties = additionalProperty.ValueType.Properties;  						foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' additionalProperties.ValueType.Name' additionalProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								string propName = string.Format ("{0}{1}"' "prop"' i++);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var a = w2.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  								writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValue (writer' "w3"' id + property.Name + subProperty.Name' valueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' propName' additionalProperty.Name));  								}  							}  						}  					}  				}  			}  		}  	}  	// create all types of custom properties  	writer.WriteLine ("private void WriteConstantValuesCustomProperties()");  	using (writer.OpenScope ()) {  		var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  		if (propertiesProperty != null) {  			var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  			if (additionalProperties != null) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = "constant_custom";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue)) {  							string propName = string.Format ("custom_{0}"' valueProperty.Name);  							writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  							using (writer.OpenScope ()) {  								WriteValue (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  							}  						}  					}  				}  			}  		}  	}  	// create entities using references  	writer.WriteLine ("private void WriteReferenceValues()");  	using (writer.OpenScope ()) {  		// write some positions and double values to use to create reference lists for position lists and double lists later  		for (int i = 1; i <= 2; ++i) {  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				string id = string.Format ("ConstantPosition{0}"' i);  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantPosition{0}')).toBeDefined();"' i);  				var property = schemaProperties.First (p => p.Name == "position");  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					var properties = property.ValueType.Properties;  					var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  					WriteValue (writer' "w"' id' firstValueProperty' property' false' property.Name);  				}  			}  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				string id = string.Format ("ConstantDouble{0}"' i);  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantDouble{0}')).toBeDefined();"' i);  				var property = schemaProperties.First (p => p.Name == "billboard");  				var properties = property.ValueType.Properties;  				var subProperty = properties.First (p => p.Name == "scale");  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  				using (writer.OpenScope ()) {  					properties = subProperty.ValueType.Properties;  					var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  					WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' false' string.Format ("{0}.{1}"' property.Name' subProperty.Name));  				}  			}  		}  		// write one big packet with references for everything  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			writer.WriteLine ("packet.WriteId(\"Reference\");");  			WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Reference')).toBeDefined();");  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					var properties = property.ValueType.Properties;  					if (properties.Any (p => p.ValueType.Name == "Reference")) {  						writer.WriteLine ("w.WriteReference(new Reference(\"Constant\"' \"{0}\"));"' propertyName);  						WriteAssertion (writer' isExtension' "expect(e.{0}.getValue(date)).toEqual(constant.{0}.getValue(date));"' propertyName);  					} else {  						foreach (var subProperty in properties.Where (p => !p.IsValue)) {  							properties = subProperty.ValueType.Properties;  							string subPropertyName = GetSubPropertyName (propertyName' subProperty);  							if (properties.Any (p => p.ValueType.Name == "Reference")) {  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									writer.WriteLine ("w2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\")));"' propertyName' subPropertyName);  									WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual(constant.{0}.{1}.getValue(date));"' propertyName' subPropertyName);  								}  							} else if (properties.Any (p => p.ValueType.Name == "ReferenceList")) {  								string targetId = "";  								string[] referencePropertyNames =  {    								};  								if (subProperty.ValueType.Name == "PositionList") {  									targetId = "Position";  									referencePropertyNames = new[] {  										"position"  									};  								} else if (subProperty.ValueType.Name == "DoubleList") {  									targetId = "Double";  									referencePropertyNames = new[] {  										"billboard"'  										"scale"  									};  								}  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									writer.WriteLine ("w2.WriteReferences(CreateList(new Reference(\"Constant{0}1\"' CreateList({1}))' new Reference(\"Constant{0}2\"' CreateList({1}))));"' targetId' string.Join ("' "' referencePropertyNames.Select (n => string.Format ("\"{0}\""' n))));  									WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual([dataSource.entities.getById('Constant{2}1').{3}.getValue(date)' dataSource.entities.getById('Constant{2}2').{3}.getValue(date)]);"' propertyName' subPropertyName' targetId' string.Join ("."' referencePropertyNames));  								}  							} else if (subProperty.ValueType.Name.Contains ("Material")) {  								Property materialProperty = properties.First ();  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("m2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"{2}\")));"' propertyName' subPropertyName' materialSubProperty.Name);  											WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.{2}.getValue(date)).toEqual(constant.{0}.{1}.{2}.getValue(date));"' propertyName' subPropertyName' materialSubProperty.Name);  										}  									}  								}  							} else {  								var additionalProperties = subProperty.ValueType.AdditionalProperties;  								if (additionalProperties != null) {  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var a = w2.Open{0}Property(\"referenceProp\"))"' additionalProperties.ValueType.NameWithPascalCase);  									using (writer.OpenScope ()) {  										foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												writer.WriteLine ("w3.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"prop\"' \"{2}\")));"' propertyName' subPropertyName' additionalProperty.Name);  												WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.referenceProp.{2}.getValue(date)).toEqual(constant.{0}.{1}.prop.{2}.getValue(date));"' propertyName' subPropertyName' additionalProperty.Name);  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		writer.WriteLine ("WriteReferenceValuesIndividual();");  	}  	writer.WriteLine ("private void WriteReferenceValuesIndividual()");  	using (writer.OpenScope ()) {  		// write other materials as individual packets  		foreach (var property in schemaProperties) {  			writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  		}  		// special case - velocity reference  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  			WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  			var property = schemaProperties.First (p => p.Name == "position");  			writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				// construct a position with specific velocity  				double dx = 1.0;  				double dy = 2.0;  				double dz = 3.0;  				double deltaTime = 60.0;  				double x1 = 1.0;  				double x2 = x1 + dx * deltaTime;  				double y1 = 2.0;  				double y2 = y1 + dy * deltaTime;  				double z1 = 3.0;  				double z2 = z1 + dz * deltaTime;  				string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  				string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  				string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  				string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  				writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  				WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  				WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  			}  		}  		foreach (var property in schemaProperties) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			foreach (var subProperty in properties.Where (p => !p.IsValue)) {  				properties = subProperty.ValueType.Properties;  				if (properties.Any (p => p.Name == "velocityReference")) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  							double expectedX = 1.0;  							double expectedY = 2.0;  							double expectedZ = 3.0;  							bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  							if (isNormalized) {  								NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  							}  							WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  						}  					}  				}  			}  		}  	}  	// write other materials as individual packets  	foreach (var property in schemaProperties) {  		writer.WriteLine ("private void WriteReferenceValuesIndividual{0}()"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			foreach (var subProperty in properties.Where (p => !p.IsValue)) {  				string subPropertyName = GetSubPropertyName (propertyName' subProperty);  				if (subProperty.ValueType.Name.Contains ("Material")) {  					properties = subProperty.ValueType.Properties;  					foreach (var materialProperty in properties.Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string targetId = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  							string id = string.Format ("reference_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										writer.WriteLine ("m2.WriteReference(new Reference(\"{0}\"' CreateList(\"{1}\"' \"{2}\"' \"{3}\")));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  										WriteAssertion (writer' isExtension' "expect(e.{1}.{2}.{3}.getValue(date)).toEqual(dataSource.entities.getById('{0}').{1}.{2}.{3}.getValue(date));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  									}  								}  							}  						}  					}  				}  			}  		}  	}  	// test sampled properties  	writer.WriteLine ("private void WriteSampledValues()");  	using (writer.OpenScope ()) {  		// Write one packet with first value types for each property  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			const string id = "Sampled";  			writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  			WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Sampled')).toBeDefined();");  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				if (property.IsInterpolatable) {  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  						WriteValues (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  					}  				} else {  					var subProperties = properties.Where (p => !p.IsValue && (p.IsInterpolatable || p.ValueType.Name.Contains ("Material"))).ToList ();  					if (subProperties.Any ()) {  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							foreach (var subProperty in subProperties) {  								properties = subProperty.ValueType.Properties;  								string subPropertyName = GetSubPropertyName (propertyName' subProperty);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									if (subProperty.IsInterpolatable) {  										var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  										WriteValues (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  									} else if (subProperty.ValueType.Name.Contains ("Material")) {  										Property materialProperty = properties.First ();  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialSubProperty.ValueType.Properties;  													var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  													WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		writer.WriteLine ("WriteSampledValuesIndividual();");  		writer.WriteLine ("WriteSampledValuesCustomProperties();");  	}  	writer.WriteLine ("private void WriteSampledValuesIndividual()");  	using (writer.OpenScope ()) {  		// write other value types as individual packets  		// split method into multiple methods  		foreach (var property in schemaProperties) {  			writer.WriteLine ("WriteSampledValuesIndividual{0}();"' property.NameWithPascalCase);  		}  	}  	foreach (var property in schemaProperties) {  		writer.WriteLine ("private void WriteSampledValuesIndividual{0}()"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			if (property.IsInterpolatable) {  				foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("sampled_{0}_{1}"' propertyName' valueProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							WriteValues (writer' "w"' id' valueProperty' property' isExtension' propertyName);  						}  					}  				}  			} else {  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					string subPropertyName = GetSubPropertyName (propertyName' subProperty);  					properties = subProperty.ValueType.Properties;  					if (subProperty.IsInterpolatable) {  						foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' valueProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValues (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  								}  							}  						}  					} else if (subProperty.ValueType.Name.Contains ("Material")) {  						// write other values for the first material  						// then write first values for other materials   						// then write remaining values for other materials individually  						var firstMaterialProperty = properties.First ();  						properties = firstMaterialProperty.ValueType.Properties;  						foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  							properties = materialSubProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValues (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialSubProperty.ValueType.Properties;  											var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  											WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							properties = materialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  					}  				}  			}  		}  	}  	// create all types of custom properties  	writer.WriteLine ("private void WriteSampledValuesCustomProperties()");  	using (writer.OpenScope ()) {  		var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  		if (propertiesProperty != null) {  			var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  			if (additionalProperties != null) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = "sampled_custom";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array)) {  							string propName = string.Format ("custom_{0}"' valueProperty.Name);  							writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  							using (writer.OpenScope ()) {  								WriteValues (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	writer.WriteLine ("private readonly JulianDate m_documentStartDate = new GregorianDate(2016' 6' 17' 12' 0' 0).ToJulianDate();");  	writer.WriteLine ("private readonly JulianDate m_documentStopDate = new GregorianDate(2016' 6' 17' 13' 0' 0).ToJulianDate();");  	writer.WriteLine ("private TextWriter m_streamWriter;");  	writer.WriteLine ("private TextWriter m_assertionsWriter;");  	writer.WriteLine ("private TextWriter m_extensionsAssertionsWriter;");  	writer.WriteLine ("private CesiumOutputStream m_output;");  	writer.WriteLine ("private CesiumStreamWriter m_writer;");  	writer.WriteLine ("private void WriteAssertionBoth(string s)");  	using (writer.OpenScope ()) {  		writer.WriteLine ("m_assertionsWriter.WriteLine(s);");  		writer.WriteLine ("m_extensionsAssertionsWriter.WriteLine(s);");  	}  	writer.WriteLine ("private static IList<T> CreateList<T>(T t1' T t2)");  	using (writer.OpenScope ()) {  		writer.WriteLine ("return new List<T> { t1' t2 };");  	}  	writer.WriteLine ("private static IList<T> CreateList<T>(params T[] ts)");  	using (writer.OpenScope ()) {  		writer.WriteLine ("return ts;");  	}  	writer.WriteLine ("[Test]");  	writer.WriteLine ("public void GenerateValidationDocument()");  	var schemaProperties = schema.Properties.Where (p => p.Name != "clock" && p.Name != "availability" && !p.ValueType.IsSchemaFromType).Where (p => p.Name != "properties").ToList ();  	using (writer.OpenScope ()) {  		writer.WriteLine ("using (m_streamWriter = new StreamWriter(\"ValidationDocument.czml\"))");  		writer.WriteLine ("using (m_assertionsWriter = new StreamWriter(\"ValidationDocumentAssertions.js\"))");  		writer.WriteLine ("using (m_extensionsAssertionsWriter = new StreamWriter(\"ValidationDocumentExtensionAssertions.js\"))");  		using (writer.OpenScope ()) {  			WriteAssertionBoth (writer' "return CzmlDataSource.load('Data/CZML/ValidationDocument.czml').then(function(dataSource) {");  			s_assertionIndent++;  			WriteAssertionBoth (writer' "/*jshint -W120 */");  			WriteAssertionBoth (writer' "var e;");  			WriteAssertionBoth (writer' "var date;");  			WriteAssertionBoth (writer' "var documentStartDate = JulianDate.fromIso8601('2016-06-17T12:00:00Z');");  			WriteAssertionBoth (writer' "var documentStopDate = JulianDate.fromIso8601('2016-06-17T13:00:00Z');");  			writer.WriteLine ("m_output = new CesiumOutputStream(m_streamWriter) { PrettyFormatting = true };");  			writer.WriteLine ("m_writer = new CesiumStreamWriter();");  			writer.WriteLine ("m_output.WriteStartSequence();");  			// Java has a limit on the size of a single method (65535 bytes) so we have to break up all this code in multiple methods  			writer.WriteLine ("WriteClock();");  			writer.WriteLine ("WriteConstantValues();");  			writer.WriteLine ("WriteReferenceValues();");  			writer.WriteLine ("WriteSampledValues();");  			writer.WriteLine ("m_output.WriteEndSequence();");  			s_assertionIndent--;  			WriteAssertionBoth (writer' "});");  			s_assertionIndent++;  		}  	}  	writer.WriteLine ("private void WriteClock()");  	using (writer.OpenScope ()) {  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			writer.WriteLine ("packet.WriteId(\"document\");");  			writer.WriteLine ("packet.WriteName(\"ValidationDocument\");");  			writer.WriteLine ("packet.WriteVersion(\"1.0\");");  			writer.WriteLine ("using (var clock = packet.OpenClockProperty())");  			using (writer.OpenScope ()) {  				writer.WriteLine ("clock.WriteInterval(m_documentStartDate' m_documentStopDate);");  				WriteAssertion (writer' false' "expect(dataSource.clock.startTime).toEqual(documentStartDate);");  				WriteAssertion (writer' false' "expect(dataSource.clock.stopTime).toEqual(documentStopDate);");  				writer.WriteLine ("clock.WriteCurrentTime(m_documentStartDate);");  				WriteAssertion (writer' false' "expect(dataSource.clock.currentTime).toEqual(documentStartDate);");  				writer.WriteLine ("clock.WriteMultiplier(1.0);");  				WriteAssertion (writer' false' "expect(dataSource.clock.multiplier).toEqual(1.0);");  				writer.WriteLine ("clock.WriteRange(ClockRange.Unbounded);");  				WriteAssertion (writer' false' "expect(dataSource.clock.clockRange).toEqual(ClockRange.UNBOUNDED);");  				writer.WriteLine ("clock.WriteStep(ClockStep.SystemClockMultiplier);");  				WriteAssertion (writer' false' "expect(dataSource.clock.clockStep).toEqual(ClockStep.SYSTEM_CLOCK_MULTIPLIER);");  			}  		}  	}  	writer.WriteLine ("private void WriteConstantValues()");  	using (writer.OpenScope ()) {  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			const string id = "Constant";  			writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  			WriteAssertionBoth (writer' "var constant = e = dataSource.entities.getById('Constant');");  			WriteAssertionBoth (writer' "expect(e).toBeDefined();");  			WriteAssertionBoth (writer' "date = JulianDate.now();");  			// Write one packet with first value types for each property  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					var properties = property.ValueType.Properties;  					var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  					if (firstValueProperty != null) {  						WriteValue (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  					} else {  						foreach (var subProperty in properties.Where (p => !p.IsValue)) {  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								properties = subProperty.ValueType.Properties;  								firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  								string subPropertyName = GetSubPropertyName (propertyName' subProperty);  								if (firstValueProperty != null) {  									WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  								} else if (subProperty.ValueType.Name.Contains ("Material")) {  									Property materialProperty = properties.First ();  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialSubProperty.ValueType.Properties;  												firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  												if (firstValueProperty != null) {  													WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								} else {  									var additionalProperties = subProperty.ValueType.AdditionalProperties;  									if (additionalProperties != null) {  										writer.WriteLine ("using (var a = w2.Open{0}Property(\"prop\"))"' additionalProperties.ValueType.NameWithPascalCase);  										using (writer.OpenScope ()) {  											foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = additionalProperty.ValueType.Properties;  													firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  													if (firstValueProperty != null) {  														WriteValue (writer' "w3"' id + property.Name' firstValueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' "prop"' additionalProperty.Name));  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		writer.WriteLine ("WriteConstantValuesIndividual();");  		writer.WriteLine ("WriteConstantValuesCustomProperties();");  	}  	writer.WriteLine ("private void WriteConstantValuesIndividual()");  	using (writer.OpenScope ()) {  		// write other value types as individual packets  		foreach (var property in schemaProperties) {  			writer.WriteLine ("WriteConstantValuesIndividual{0}();"' property.NameWithPascalCase);  		}  	}  	foreach (var property in schemaProperties) {  		writer.WriteLine ("private void WriteConstantValuesIndividual{0}()"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("constant_{0}_{1}"' property.Name' valueProperty.Name);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						WriteValue (writer' "w"' id' valueProperty' property' isExtension' propertyName);  					}  				}  			}  			foreach (var subProperty in properties.Where (p => !p.IsValue)) {  				string subPropertyName = GetSubPropertyName (propertyName' subProperty);  				properties = subProperty.ValueType.Properties;  				foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("constant_{0}_{1}_{2}"' property.Name' subPropertyName' valueProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							WriteValue (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  						}  					}  				}  				if (subProperty.ValueType.Name.Contains ("Material")) {  					// write other values for the first material  					// then write first values for other materials   					// then write remaining values for other materials individually  					var firstMaterialProperty = properties.First ();  					properties = firstMaterialProperty.ValueType.Properties;  					foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  						properties = materialSubProperty.ValueType.Properties;  						foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValue (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  								}  							}  						}  					}  					properties = subProperty.ValueType.Properties;  					foreach (var materialProperty in properties.Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialSubProperty.ValueType.Properties;  										var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  										if (firstValueProperty != null) {  											WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  					}  					properties = subProperty.ValueType.Properties;  					foreach (var materialProperty in properties.Skip (1)) {  						properties = materialProperty.ValueType.Properties;  						foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  							properties = materialSubProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  									}  								}  							}  						}  					}  				}  				var additionalProperties = subProperty.ValueType.AdditionalProperties;  				if (additionalProperties != null) {  					foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  						int i = 0;  						properties = additionalProperty.ValueType.Properties;  						foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' additionalProperties.ValueType.Name' additionalProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								string propName = string.Format ("{0}{1}"' "prop"' i++);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var a = w2.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  								writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValue (writer' "w3"' id + property.Name + subProperty.Name' valueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' propName' additionalProperty.Name));  								}  							}  						}  					}  				}  			}  		}  	}  	// create all types of custom properties  	writer.WriteLine ("private void WriteConstantValuesCustomProperties()");  	using (writer.OpenScope ()) {  		var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  		if (propertiesProperty != null) {  			var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  			if (additionalProperties != null) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = "constant_custom";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue)) {  							string propName = string.Format ("custom_{0}"' valueProperty.Name);  							writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  							using (writer.OpenScope ()) {  								WriteValue (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  							}  						}  					}  				}  			}  		}  	}  	// create entities using references  	writer.WriteLine ("private void WriteReferenceValues()");  	using (writer.OpenScope ()) {  		// write some positions and double values to use to create reference lists for position lists and double lists later  		for (int i = 1; i <= 2; ++i) {  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				string id = string.Format ("ConstantPosition{0}"' i);  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantPosition{0}')).toBeDefined();"' i);  				var property = schemaProperties.First (p => p.Name == "position");  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					var properties = property.ValueType.Properties;  					var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  					WriteValue (writer' "w"' id' firstValueProperty' property' false' property.Name);  				}  			}  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				string id = string.Format ("ConstantDouble{0}"' i);  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantDouble{0}')).toBeDefined();"' i);  				var property = schemaProperties.First (p => p.Name == "billboard");  				var properties = property.ValueType.Properties;  				var subProperty = properties.First (p => p.Name == "scale");  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  				using (writer.OpenScope ()) {  					properties = subProperty.ValueType.Properties;  					var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  					WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' false' string.Format ("{0}.{1}"' property.Name' subProperty.Name));  				}  			}  		}  		// write one big packet with references for everything  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			writer.WriteLine ("packet.WriteId(\"Reference\");");  			WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Reference')).toBeDefined();");  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					var properties = property.ValueType.Properties;  					if (properties.Any (p => p.ValueType.Name == "Reference")) {  						writer.WriteLine ("w.WriteReference(new Reference(\"Constant\"' \"{0}\"));"' propertyName);  						WriteAssertion (writer' isExtension' "expect(e.{0}.getValue(date)).toEqual(constant.{0}.getValue(date));"' propertyName);  					} else {  						foreach (var subProperty in properties.Where (p => !p.IsValue)) {  							properties = subProperty.ValueType.Properties;  							string subPropertyName = GetSubPropertyName (propertyName' subProperty);  							if (properties.Any (p => p.ValueType.Name == "Reference")) {  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									writer.WriteLine ("w2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\")));"' propertyName' subPropertyName);  									WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual(constant.{0}.{1}.getValue(date));"' propertyName' subPropertyName);  								}  							} else if (properties.Any (p => p.ValueType.Name == "ReferenceList")) {  								string targetId = "";  								string[] referencePropertyNames =  {    								};  								if (subProperty.ValueType.Name == "PositionList") {  									targetId = "Position";  									referencePropertyNames = new[] {  										"position"  									};  								} else if (subProperty.ValueType.Name == "DoubleList") {  									targetId = "Double";  									referencePropertyNames = new[] {  										"billboard"'  										"scale"  									};  								}  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									writer.WriteLine ("w2.WriteReferences(CreateList(new Reference(\"Constant{0}1\"' CreateList({1}))' new Reference(\"Constant{0}2\"' CreateList({1}))));"' targetId' string.Join ("' "' referencePropertyNames.Select (n => string.Format ("\"{0}\""' n))));  									WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual([dataSource.entities.getById('Constant{2}1').{3}.getValue(date)' dataSource.entities.getById('Constant{2}2').{3}.getValue(date)]);"' propertyName' subPropertyName' targetId' string.Join ("."' referencePropertyNames));  								}  							} else if (subProperty.ValueType.Name.Contains ("Material")) {  								Property materialProperty = properties.First ();  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("m2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"{2}\")));"' propertyName' subPropertyName' materialSubProperty.Name);  											WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.{2}.getValue(date)).toEqual(constant.{0}.{1}.{2}.getValue(date));"' propertyName' subPropertyName' materialSubProperty.Name);  										}  									}  								}  							} else {  								var additionalProperties = subProperty.ValueType.AdditionalProperties;  								if (additionalProperties != null) {  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var a = w2.Open{0}Property(\"referenceProp\"))"' additionalProperties.ValueType.NameWithPascalCase);  									using (writer.OpenScope ()) {  										foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												writer.WriteLine ("w3.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"prop\"' \"{2}\")));"' propertyName' subPropertyName' additionalProperty.Name);  												WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.referenceProp.{2}.getValue(date)).toEqual(constant.{0}.{1}.prop.{2}.getValue(date));"' propertyName' subPropertyName' additionalProperty.Name);  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		writer.WriteLine ("WriteReferenceValuesIndividual();");  	}  	writer.WriteLine ("private void WriteReferenceValuesIndividual()");  	using (writer.OpenScope ()) {  		// write other materials as individual packets  		foreach (var property in schemaProperties) {  			writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  		}  		// special case - velocity reference  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  			WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  			var property = schemaProperties.First (p => p.Name == "position");  			writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				// construct a position with specific velocity  				double dx = 1.0;  				double dy = 2.0;  				double dz = 3.0;  				double deltaTime = 60.0;  				double x1 = 1.0;  				double x2 = x1 + dx * deltaTime;  				double y1 = 2.0;  				double y2 = y1 + dy * deltaTime;  				double z1 = 3.0;  				double z2 = z1 + dz * deltaTime;  				string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  				string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  				string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  				string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  				writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  				WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  				WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  			}  		}  		foreach (var property in schemaProperties) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			foreach (var subProperty in properties.Where (p => !p.IsValue)) {  				properties = subProperty.ValueType.Properties;  				if (properties.Any (p => p.Name == "velocityReference")) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  							double expectedX = 1.0;  							double expectedY = 2.0;  							double expectedZ = 3.0;  							bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  							if (isNormalized) {  								NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  							}  							WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  						}  					}  				}  			}  		}  	}  	// write other materials as individual packets  	foreach (var property in schemaProperties) {  		writer.WriteLine ("private void WriteReferenceValuesIndividual{0}()"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			foreach (var subProperty in properties.Where (p => !p.IsValue)) {  				string subPropertyName = GetSubPropertyName (propertyName' subProperty);  				if (subProperty.ValueType.Name.Contains ("Material")) {  					properties = subProperty.ValueType.Properties;  					foreach (var materialProperty in properties.Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string targetId = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  							string id = string.Format ("reference_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										writer.WriteLine ("m2.WriteReference(new Reference(\"{0}\"' CreateList(\"{1}\"' \"{2}\"' \"{3}\")));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  										WriteAssertion (writer' isExtension' "expect(e.{1}.{2}.{3}.getValue(date)).toEqual(dataSource.entities.getById('{0}').{1}.{2}.{3}.getValue(date));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  									}  								}  							}  						}  					}  				}  			}  		}  	}  	// test sampled properties  	writer.WriteLine ("private void WriteSampledValues()");  	using (writer.OpenScope ()) {  		// Write one packet with first value types for each property  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			const string id = "Sampled";  			writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  			WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Sampled')).toBeDefined();");  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				if (property.IsInterpolatable) {  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  						WriteValues (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  					}  				} else {  					var subProperties = properties.Where (p => !p.IsValue && (p.IsInterpolatable || p.ValueType.Name.Contains ("Material"))).ToList ();  					if (subProperties.Any ()) {  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							foreach (var subProperty in subProperties) {  								properties = subProperty.ValueType.Properties;  								string subPropertyName = GetSubPropertyName (propertyName' subProperty);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									if (subProperty.IsInterpolatable) {  										var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  										WriteValues (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  									} else if (subProperty.ValueType.Name.Contains ("Material")) {  										Property materialProperty = properties.First ();  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialSubProperty.ValueType.Properties;  													var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  													WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		writer.WriteLine ("WriteSampledValuesIndividual();");  		writer.WriteLine ("WriteSampledValuesCustomProperties();");  	}  	writer.WriteLine ("private void WriteSampledValuesIndividual()");  	using (writer.OpenScope ()) {  		// write other value types as individual packets  		// split method into multiple methods  		foreach (var property in schemaProperties) {  			writer.WriteLine ("WriteSampledValuesIndividual{0}();"' property.NameWithPascalCase);  		}  	}  	foreach (var property in schemaProperties) {  		writer.WriteLine ("private void WriteSampledValuesIndividual{0}()"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			if (property.IsInterpolatable) {  				foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("sampled_{0}_{1}"' propertyName' valueProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							WriteValues (writer' "w"' id' valueProperty' property' isExtension' propertyName);  						}  					}  				}  			} else {  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					string subPropertyName = GetSubPropertyName (propertyName' subProperty);  					properties = subProperty.ValueType.Properties;  					if (subProperty.IsInterpolatable) {  						foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' valueProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValues (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  								}  							}  						}  					} else if (subProperty.ValueType.Name.Contains ("Material")) {  						// write other values for the first material  						// then write first values for other materials   						// then write remaining values for other materials individually  						var firstMaterialProperty = properties.First ();  						properties = firstMaterialProperty.ValueType.Properties;  						foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  							properties = materialSubProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValues (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialSubProperty.ValueType.Properties;  											var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  											WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							properties = materialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  					}  				}  			}  		}  	}  	// create all types of custom properties  	writer.WriteLine ("private void WriteSampledValuesCustomProperties()");  	using (writer.OpenScope ()) {  		var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  		if (propertiesProperty != null) {  			var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  			if (additionalProperties != null) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = "sampled_custom";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array)) {  							string propName = string.Format ("custom_{0}"' valueProperty.Name);  							writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  							using (writer.OpenScope ()) {  								WriteValues (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	writer.WriteLine ("private readonly JulianDate m_documentStartDate = new GregorianDate(2016' 6' 17' 12' 0' 0).ToJulianDate();");  	writer.WriteLine ("private readonly JulianDate m_documentStopDate = new GregorianDate(2016' 6' 17' 13' 0' 0).ToJulianDate();");  	writer.WriteLine ("private TextWriter m_streamWriter;");  	writer.WriteLine ("private TextWriter m_assertionsWriter;");  	writer.WriteLine ("private TextWriter m_extensionsAssertionsWriter;");  	writer.WriteLine ("private CesiumOutputStream m_output;");  	writer.WriteLine ("private CesiumStreamWriter m_writer;");  	writer.WriteLine ("private void WriteAssertionBoth(string s)");  	using (writer.OpenScope ()) {  		writer.WriteLine ("m_assertionsWriter.WriteLine(s);");  		writer.WriteLine ("m_extensionsAssertionsWriter.WriteLine(s);");  	}  	writer.WriteLine ("private static IList<T> CreateList<T>(T t1' T t2)");  	using (writer.OpenScope ()) {  		writer.WriteLine ("return new List<T> { t1' t2 };");  	}  	writer.WriteLine ("private static IList<T> CreateList<T>(params T[] ts)");  	using (writer.OpenScope ()) {  		writer.WriteLine ("return ts;");  	}  	writer.WriteLine ("[Test]");  	writer.WriteLine ("public void GenerateValidationDocument()");  	var schemaProperties = schema.Properties.Where (p => p.Name != "clock" && p.Name != "availability" && !p.ValueType.IsSchemaFromType).Where (p => p.Name != "properties").ToList ();  	using (writer.OpenScope ()) {  		writer.WriteLine ("using (m_streamWriter = new StreamWriter(\"ValidationDocument.czml\"))");  		writer.WriteLine ("using (m_assertionsWriter = new StreamWriter(\"ValidationDocumentAssertions.js\"))");  		writer.WriteLine ("using (m_extensionsAssertionsWriter = new StreamWriter(\"ValidationDocumentExtensionAssertions.js\"))");  		using (writer.OpenScope ()) {  			WriteAssertionBoth (writer' "return CzmlDataSource.load('Data/CZML/ValidationDocument.czml').then(function(dataSource) {");  			s_assertionIndent++;  			WriteAssertionBoth (writer' "/*jshint -W120 */");  			WriteAssertionBoth (writer' "var e;");  			WriteAssertionBoth (writer' "var date;");  			WriteAssertionBoth (writer' "var documentStartDate = JulianDate.fromIso8601('2016-06-17T12:00:00Z');");  			WriteAssertionBoth (writer' "var documentStopDate = JulianDate.fromIso8601('2016-06-17T13:00:00Z');");  			writer.WriteLine ("m_output = new CesiumOutputStream(m_streamWriter) { PrettyFormatting = true };");  			writer.WriteLine ("m_writer = new CesiumStreamWriter();");  			writer.WriteLine ("m_output.WriteStartSequence();");  			// Java has a limit on the size of a single method (65535 bytes) so we have to break up all this code in multiple methods  			writer.WriteLine ("WriteClock();");  			writer.WriteLine ("WriteConstantValues();");  			writer.WriteLine ("WriteReferenceValues();");  			writer.WriteLine ("WriteSampledValues();");  			writer.WriteLine ("m_output.WriteEndSequence();");  			s_assertionIndent--;  			WriteAssertionBoth (writer' "});");  			s_assertionIndent++;  		}  	}  	writer.WriteLine ("private void WriteClock()");  	using (writer.OpenScope ()) {  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			writer.WriteLine ("packet.WriteId(\"document\");");  			writer.WriteLine ("packet.WriteName(\"ValidationDocument\");");  			writer.WriteLine ("packet.WriteVersion(\"1.0\");");  			writer.WriteLine ("using (var clock = packet.OpenClockProperty())");  			using (writer.OpenScope ()) {  				writer.WriteLine ("clock.WriteInterval(m_documentStartDate' m_documentStopDate);");  				WriteAssertion (writer' false' "expect(dataSource.clock.startTime).toEqual(documentStartDate);");  				WriteAssertion (writer' false' "expect(dataSource.clock.stopTime).toEqual(documentStopDate);");  				writer.WriteLine ("clock.WriteCurrentTime(m_documentStartDate);");  				WriteAssertion (writer' false' "expect(dataSource.clock.currentTime).toEqual(documentStartDate);");  				writer.WriteLine ("clock.WriteMultiplier(1.0);");  				WriteAssertion (writer' false' "expect(dataSource.clock.multiplier).toEqual(1.0);");  				writer.WriteLine ("clock.WriteRange(ClockRange.Unbounded);");  				WriteAssertion (writer' false' "expect(dataSource.clock.clockRange).toEqual(ClockRange.UNBOUNDED);");  				writer.WriteLine ("clock.WriteStep(ClockStep.SystemClockMultiplier);");  				WriteAssertion (writer' false' "expect(dataSource.clock.clockStep).toEqual(ClockStep.SYSTEM_CLOCK_MULTIPLIER);");  			}  		}  	}  	writer.WriteLine ("private void WriteConstantValues()");  	using (writer.OpenScope ()) {  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			const string id = "Constant";  			writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  			WriteAssertionBoth (writer' "var constant = e = dataSource.entities.getById('Constant');");  			WriteAssertionBoth (writer' "expect(e).toBeDefined();");  			WriteAssertionBoth (writer' "date = JulianDate.now();");  			// Write one packet with first value types for each property  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					var properties = property.ValueType.Properties;  					var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  					if (firstValueProperty != null) {  						WriteValue (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  					} else {  						foreach (var subProperty in properties.Where (p => !p.IsValue)) {  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								properties = subProperty.ValueType.Properties;  								firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  								string subPropertyName = GetSubPropertyName (propertyName' subProperty);  								if (firstValueProperty != null) {  									WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  								} else if (subProperty.ValueType.Name.Contains ("Material")) {  									Property materialProperty = properties.First ();  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialSubProperty.ValueType.Properties;  												firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  												if (firstValueProperty != null) {  													WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								} else {  									var additionalProperties = subProperty.ValueType.AdditionalProperties;  									if (additionalProperties != null) {  										writer.WriteLine ("using (var a = w2.Open{0}Property(\"prop\"))"' additionalProperties.ValueType.NameWithPascalCase);  										using (writer.OpenScope ()) {  											foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = additionalProperty.ValueType.Properties;  													firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  													if (firstValueProperty != null) {  														WriteValue (writer' "w3"' id + property.Name' firstValueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' "prop"' additionalProperty.Name));  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		writer.WriteLine ("WriteConstantValuesIndividual();");  		writer.WriteLine ("WriteConstantValuesCustomProperties();");  	}  	writer.WriteLine ("private void WriteConstantValuesIndividual()");  	using (writer.OpenScope ()) {  		// write other value types as individual packets  		foreach (var property in schemaProperties) {  			writer.WriteLine ("WriteConstantValuesIndividual{0}();"' property.NameWithPascalCase);  		}  	}  	foreach (var property in schemaProperties) {  		writer.WriteLine ("private void WriteConstantValuesIndividual{0}()"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("constant_{0}_{1}"' property.Name' valueProperty.Name);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						WriteValue (writer' "w"' id' valueProperty' property' isExtension' propertyName);  					}  				}  			}  			foreach (var subProperty in properties.Where (p => !p.IsValue)) {  				string subPropertyName = GetSubPropertyName (propertyName' subProperty);  				properties = subProperty.ValueType.Properties;  				foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("constant_{0}_{1}_{2}"' property.Name' subPropertyName' valueProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							WriteValue (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  						}  					}  				}  				if (subProperty.ValueType.Name.Contains ("Material")) {  					// write other values for the first material  					// then write first values for other materials   					// then write remaining values for other materials individually  					var firstMaterialProperty = properties.First ();  					properties = firstMaterialProperty.ValueType.Properties;  					foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  						properties = materialSubProperty.ValueType.Properties;  						foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValue (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  								}  							}  						}  					}  					properties = subProperty.ValueType.Properties;  					foreach (var materialProperty in properties.Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialSubProperty.ValueType.Properties;  										var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  										if (firstValueProperty != null) {  											WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  					}  					properties = subProperty.ValueType.Properties;  					foreach (var materialProperty in properties.Skip (1)) {  						properties = materialProperty.ValueType.Properties;  						foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  							properties = materialSubProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  									}  								}  							}  						}  					}  				}  				var additionalProperties = subProperty.ValueType.AdditionalProperties;  				if (additionalProperties != null) {  					foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  						int i = 0;  						properties = additionalProperty.ValueType.Properties;  						foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' additionalProperties.ValueType.Name' additionalProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								string propName = string.Format ("{0}{1}"' "prop"' i++);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var a = w2.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  								writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValue (writer' "w3"' id + property.Name + subProperty.Name' valueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' propName' additionalProperty.Name));  								}  							}  						}  					}  				}  			}  		}  	}  	// create all types of custom properties  	writer.WriteLine ("private void WriteConstantValuesCustomProperties()");  	using (writer.OpenScope ()) {  		var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  		if (propertiesProperty != null) {  			var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  			if (additionalProperties != null) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = "constant_custom";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue)) {  							string propName = string.Format ("custom_{0}"' valueProperty.Name);  							writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  							using (writer.OpenScope ()) {  								WriteValue (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  							}  						}  					}  				}  			}  		}  	}  	// create entities using references  	writer.WriteLine ("private void WriteReferenceValues()");  	using (writer.OpenScope ()) {  		// write some positions and double values to use to create reference lists for position lists and double lists later  		for (int i = 1; i <= 2; ++i) {  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				string id = string.Format ("ConstantPosition{0}"' i);  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantPosition{0}')).toBeDefined();"' i);  				var property = schemaProperties.First (p => p.Name == "position");  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					var properties = property.ValueType.Properties;  					var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  					WriteValue (writer' "w"' id' firstValueProperty' property' false' property.Name);  				}  			}  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				string id = string.Format ("ConstantDouble{0}"' i);  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantDouble{0}')).toBeDefined();"' i);  				var property = schemaProperties.First (p => p.Name == "billboard");  				var properties = property.ValueType.Properties;  				var subProperty = properties.First (p => p.Name == "scale");  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  				using (writer.OpenScope ()) {  					properties = subProperty.ValueType.Properties;  					var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  					WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' false' string.Format ("{0}.{1}"' property.Name' subProperty.Name));  				}  			}  		}  		// write one big packet with references for everything  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			writer.WriteLine ("packet.WriteId(\"Reference\");");  			WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Reference')).toBeDefined();");  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					var properties = property.ValueType.Properties;  					if (properties.Any (p => p.ValueType.Name == "Reference")) {  						writer.WriteLine ("w.WriteReference(new Reference(\"Constant\"' \"{0}\"));"' propertyName);  						WriteAssertion (writer' isExtension' "expect(e.{0}.getValue(date)).toEqual(constant.{0}.getValue(date));"' propertyName);  					} else {  						foreach (var subProperty in properties.Where (p => !p.IsValue)) {  							properties = subProperty.ValueType.Properties;  							string subPropertyName = GetSubPropertyName (propertyName' subProperty);  							if (properties.Any (p => p.ValueType.Name == "Reference")) {  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									writer.WriteLine ("w2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\")));"' propertyName' subPropertyName);  									WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual(constant.{0}.{1}.getValue(date));"' propertyName' subPropertyName);  								}  							} else if (properties.Any (p => p.ValueType.Name == "ReferenceList")) {  								string targetId = "";  								string[] referencePropertyNames =  {    								};  								if (subProperty.ValueType.Name == "PositionList") {  									targetId = "Position";  									referencePropertyNames = new[] {  										"position"  									};  								} else if (subProperty.ValueType.Name == "DoubleList") {  									targetId = "Double";  									referencePropertyNames = new[] {  										"billboard"'  										"scale"  									};  								}  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									writer.WriteLine ("w2.WriteReferences(CreateList(new Reference(\"Constant{0}1\"' CreateList({1}))' new Reference(\"Constant{0}2\"' CreateList({1}))));"' targetId' string.Join ("' "' referencePropertyNames.Select (n => string.Format ("\"{0}\""' n))));  									WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual([dataSource.entities.getById('Constant{2}1').{3}.getValue(date)' dataSource.entities.getById('Constant{2}2').{3}.getValue(date)]);"' propertyName' subPropertyName' targetId' string.Join ("."' referencePropertyNames));  								}  							} else if (subProperty.ValueType.Name.Contains ("Material")) {  								Property materialProperty = properties.First ();  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("m2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"{2}\")));"' propertyName' subPropertyName' materialSubProperty.Name);  											WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.{2}.getValue(date)).toEqual(constant.{0}.{1}.{2}.getValue(date));"' propertyName' subPropertyName' materialSubProperty.Name);  										}  									}  								}  							} else {  								var additionalProperties = subProperty.ValueType.AdditionalProperties;  								if (additionalProperties != null) {  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var a = w2.Open{0}Property(\"referenceProp\"))"' additionalProperties.ValueType.NameWithPascalCase);  									using (writer.OpenScope ()) {  										foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												writer.WriteLine ("w3.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"prop\"' \"{2}\")));"' propertyName' subPropertyName' additionalProperty.Name);  												WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.referenceProp.{2}.getValue(date)).toEqual(constant.{0}.{1}.prop.{2}.getValue(date));"' propertyName' subPropertyName' additionalProperty.Name);  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		writer.WriteLine ("WriteReferenceValuesIndividual();");  	}  	writer.WriteLine ("private void WriteReferenceValuesIndividual()");  	using (writer.OpenScope ()) {  		// write other materials as individual packets  		foreach (var property in schemaProperties) {  			writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  		}  		// special case - velocity reference  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  			WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  			var property = schemaProperties.First (p => p.Name == "position");  			writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				// construct a position with specific velocity  				double dx = 1.0;  				double dy = 2.0;  				double dz = 3.0;  				double deltaTime = 60.0;  				double x1 = 1.0;  				double x2 = x1 + dx * deltaTime;  				double y1 = 2.0;  				double y2 = y1 + dy * deltaTime;  				double z1 = 3.0;  				double z2 = z1 + dz * deltaTime;  				string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  				string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  				string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  				string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  				writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  				WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  				WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  			}  		}  		foreach (var property in schemaProperties) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			foreach (var subProperty in properties.Where (p => !p.IsValue)) {  				properties = subProperty.ValueType.Properties;  				if (properties.Any (p => p.Name == "velocityReference")) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  							double expectedX = 1.0;  							double expectedY = 2.0;  							double expectedZ = 3.0;  							bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  							if (isNormalized) {  								NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  							}  							WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  						}  					}  				}  			}  		}  	}  	// write other materials as individual packets  	foreach (var property in schemaProperties) {  		writer.WriteLine ("private void WriteReferenceValuesIndividual{0}()"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			foreach (var subProperty in properties.Where (p => !p.IsValue)) {  				string subPropertyName = GetSubPropertyName (propertyName' subProperty);  				if (subProperty.ValueType.Name.Contains ("Material")) {  					properties = subProperty.ValueType.Properties;  					foreach (var materialProperty in properties.Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string targetId = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  							string id = string.Format ("reference_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										writer.WriteLine ("m2.WriteReference(new Reference(\"{0}\"' CreateList(\"{1}\"' \"{2}\"' \"{3}\")));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  										WriteAssertion (writer' isExtension' "expect(e.{1}.{2}.{3}.getValue(date)).toEqual(dataSource.entities.getById('{0}').{1}.{2}.{3}.getValue(date));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  									}  								}  							}  						}  					}  				}  			}  		}  	}  	// test sampled properties  	writer.WriteLine ("private void WriteSampledValues()");  	using (writer.OpenScope ()) {  		// Write one packet with first value types for each property  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			const string id = "Sampled";  			writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  			WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Sampled')).toBeDefined();");  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				if (property.IsInterpolatable) {  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  						WriteValues (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  					}  				} else {  					var subProperties = properties.Where (p => !p.IsValue && (p.IsInterpolatable || p.ValueType.Name.Contains ("Material"))).ToList ();  					if (subProperties.Any ()) {  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							foreach (var subProperty in subProperties) {  								properties = subProperty.ValueType.Properties;  								string subPropertyName = GetSubPropertyName (propertyName' subProperty);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									if (subProperty.IsInterpolatable) {  										var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  										WriteValues (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  									} else if (subProperty.ValueType.Name.Contains ("Material")) {  										Property materialProperty = properties.First ();  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialSubProperty.ValueType.Properties;  													var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  													WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		writer.WriteLine ("WriteSampledValuesIndividual();");  		writer.WriteLine ("WriteSampledValuesCustomProperties();");  	}  	writer.WriteLine ("private void WriteSampledValuesIndividual()");  	using (writer.OpenScope ()) {  		// write other value types as individual packets  		// split method into multiple methods  		foreach (var property in schemaProperties) {  			writer.WriteLine ("WriteSampledValuesIndividual{0}();"' property.NameWithPascalCase);  		}  	}  	foreach (var property in schemaProperties) {  		writer.WriteLine ("private void WriteSampledValuesIndividual{0}()"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			if (property.IsInterpolatable) {  				foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("sampled_{0}_{1}"' propertyName' valueProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							WriteValues (writer' "w"' id' valueProperty' property' isExtension' propertyName);  						}  					}  				}  			} else {  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					string subPropertyName = GetSubPropertyName (propertyName' subProperty);  					properties = subProperty.ValueType.Properties;  					if (subProperty.IsInterpolatable) {  						foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' valueProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValues (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  								}  							}  						}  					} else if (subProperty.ValueType.Name.Contains ("Material")) {  						// write other values for the first material  						// then write first values for other materials   						// then write remaining values for other materials individually  						var firstMaterialProperty = properties.First ();  						properties = firstMaterialProperty.ValueType.Properties;  						foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  							properties = materialSubProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValues (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialSubProperty.ValueType.Properties;  											var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  											WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							properties = materialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  					}  				}  			}  		}  	}  	// create all types of custom properties  	writer.WriteLine ("private void WriteSampledValuesCustomProperties()");  	using (writer.OpenScope ()) {  		var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  		if (propertiesProperty != null) {  			var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  			if (additionalProperties != null) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = "sampled_custom";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array)) {  							string propName = string.Format ("custom_{0}"' valueProperty.Name);  							writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  							using (writer.OpenScope ()) {  								WriteValues (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	writer.WriteLine ("private readonly JulianDate m_documentStartDate = new GregorianDate(2016' 6' 17' 12' 0' 0).ToJulianDate();");  	writer.WriteLine ("private readonly JulianDate m_documentStopDate = new GregorianDate(2016' 6' 17' 13' 0' 0).ToJulianDate();");  	writer.WriteLine ("private TextWriter m_streamWriter;");  	writer.WriteLine ("private TextWriter m_assertionsWriter;");  	writer.WriteLine ("private TextWriter m_extensionsAssertionsWriter;");  	writer.WriteLine ("private CesiumOutputStream m_output;");  	writer.WriteLine ("private CesiumStreamWriter m_writer;");  	writer.WriteLine ("private void WriteAssertionBoth(string s)");  	using (writer.OpenScope ()) {  		writer.WriteLine ("m_assertionsWriter.WriteLine(s);");  		writer.WriteLine ("m_extensionsAssertionsWriter.WriteLine(s);");  	}  	writer.WriteLine ("private static IList<T> CreateList<T>(T t1' T t2)");  	using (writer.OpenScope ()) {  		writer.WriteLine ("return new List<T> { t1' t2 };");  	}  	writer.WriteLine ("private static IList<T> CreateList<T>(params T[] ts)");  	using (writer.OpenScope ()) {  		writer.WriteLine ("return ts;");  	}  	writer.WriteLine ("[Test]");  	writer.WriteLine ("public void GenerateValidationDocument()");  	var schemaProperties = schema.Properties.Where (p => p.Name != "clock" && p.Name != "availability" && !p.ValueType.IsSchemaFromType).Where (p => p.Name != "properties").ToList ();  	using (writer.OpenScope ()) {  		writer.WriteLine ("using (m_streamWriter = new StreamWriter(\"ValidationDocument.czml\"))");  		writer.WriteLine ("using (m_assertionsWriter = new StreamWriter(\"ValidationDocumentAssertions.js\"))");  		writer.WriteLine ("using (m_extensionsAssertionsWriter = new StreamWriter(\"ValidationDocumentExtensionAssertions.js\"))");  		using (writer.OpenScope ()) {  			WriteAssertionBoth (writer' "return CzmlDataSource.load('Data/CZML/ValidationDocument.czml').then(function(dataSource) {");  			s_assertionIndent++;  			WriteAssertionBoth (writer' "/*jshint -W120 */");  			WriteAssertionBoth (writer' "var e;");  			WriteAssertionBoth (writer' "var date;");  			WriteAssertionBoth (writer' "var documentStartDate = JulianDate.fromIso8601('2016-06-17T12:00:00Z');");  			WriteAssertionBoth (writer' "var documentStopDate = JulianDate.fromIso8601('2016-06-17T13:00:00Z');");  			writer.WriteLine ("m_output = new CesiumOutputStream(m_streamWriter) { PrettyFormatting = true };");  			writer.WriteLine ("m_writer = new CesiumStreamWriter();");  			writer.WriteLine ("m_output.WriteStartSequence();");  			// Java has a limit on the size of a single method (65535 bytes) so we have to break up all this code in multiple methods  			writer.WriteLine ("WriteClock();");  			writer.WriteLine ("WriteConstantValues();");  			writer.WriteLine ("WriteReferenceValues();");  			writer.WriteLine ("WriteSampledValues();");  			writer.WriteLine ("m_output.WriteEndSequence();");  			s_assertionIndent--;  			WriteAssertionBoth (writer' "});");  			s_assertionIndent++;  		}  	}  	writer.WriteLine ("private void WriteClock()");  	using (writer.OpenScope ()) {  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			writer.WriteLine ("packet.WriteId(\"document\");");  			writer.WriteLine ("packet.WriteName(\"ValidationDocument\");");  			writer.WriteLine ("packet.WriteVersion(\"1.0\");");  			writer.WriteLine ("using (var clock = packet.OpenClockProperty())");  			using (writer.OpenScope ()) {  				writer.WriteLine ("clock.WriteInterval(m_documentStartDate' m_documentStopDate);");  				WriteAssertion (writer' false' "expect(dataSource.clock.startTime).toEqual(documentStartDate);");  				WriteAssertion (writer' false' "expect(dataSource.clock.stopTime).toEqual(documentStopDate);");  				writer.WriteLine ("clock.WriteCurrentTime(m_documentStartDate);");  				WriteAssertion (writer' false' "expect(dataSource.clock.currentTime).toEqual(documentStartDate);");  				writer.WriteLine ("clock.WriteMultiplier(1.0);");  				WriteAssertion (writer' false' "expect(dataSource.clock.multiplier).toEqual(1.0);");  				writer.WriteLine ("clock.WriteRange(ClockRange.Unbounded);");  				WriteAssertion (writer' false' "expect(dataSource.clock.clockRange).toEqual(ClockRange.UNBOUNDED);");  				writer.WriteLine ("clock.WriteStep(ClockStep.SystemClockMultiplier);");  				WriteAssertion (writer' false' "expect(dataSource.clock.clockStep).toEqual(ClockStep.SYSTEM_CLOCK_MULTIPLIER);");  			}  		}  	}  	writer.WriteLine ("private void WriteConstantValues()");  	using (writer.OpenScope ()) {  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			const string id = "Constant";  			writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  			WriteAssertionBoth (writer' "var constant = e = dataSource.entities.getById('Constant');");  			WriteAssertionBoth (writer' "expect(e).toBeDefined();");  			WriteAssertionBoth (writer' "date = JulianDate.now();");  			// Write one packet with first value types for each property  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					var properties = property.ValueType.Properties;  					var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  					if (firstValueProperty != null) {  						WriteValue (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  					} else {  						foreach (var subProperty in properties.Where (p => !p.IsValue)) {  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								properties = subProperty.ValueType.Properties;  								firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  								string subPropertyName = GetSubPropertyName (propertyName' subProperty);  								if (firstValueProperty != null) {  									WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  								} else if (subProperty.ValueType.Name.Contains ("Material")) {  									Property materialProperty = properties.First ();  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialSubProperty.ValueType.Properties;  												firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  												if (firstValueProperty != null) {  													WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								} else {  									var additionalProperties = subProperty.ValueType.AdditionalProperties;  									if (additionalProperties != null) {  										writer.WriteLine ("using (var a = w2.Open{0}Property(\"prop\"))"' additionalProperties.ValueType.NameWithPascalCase);  										using (writer.OpenScope ()) {  											foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = additionalProperty.ValueType.Properties;  													firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  													if (firstValueProperty != null) {  														WriteValue (writer' "w3"' id + property.Name' firstValueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' "prop"' additionalProperty.Name));  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		writer.WriteLine ("WriteConstantValuesIndividual();");  		writer.WriteLine ("WriteConstantValuesCustomProperties();");  	}  	writer.WriteLine ("private void WriteConstantValuesIndividual()");  	using (writer.OpenScope ()) {  		// write other value types as individual packets  		foreach (var property in schemaProperties) {  			writer.WriteLine ("WriteConstantValuesIndividual{0}();"' property.NameWithPascalCase);  		}  	}  	foreach (var property in schemaProperties) {  		writer.WriteLine ("private void WriteConstantValuesIndividual{0}()"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("constant_{0}_{1}"' property.Name' valueProperty.Name);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						WriteValue (writer' "w"' id' valueProperty' property' isExtension' propertyName);  					}  				}  			}  			foreach (var subProperty in properties.Where (p => !p.IsValue)) {  				string subPropertyName = GetSubPropertyName (propertyName' subProperty);  				properties = subProperty.ValueType.Properties;  				foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("constant_{0}_{1}_{2}"' property.Name' subPropertyName' valueProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							WriteValue (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  						}  					}  				}  				if (subProperty.ValueType.Name.Contains ("Material")) {  					// write other values for the first material  					// then write first values for other materials   					// then write remaining values for other materials individually  					var firstMaterialProperty = properties.First ();  					properties = firstMaterialProperty.ValueType.Properties;  					foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  						properties = materialSubProperty.ValueType.Properties;  						foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValue (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  								}  							}  						}  					}  					properties = subProperty.ValueType.Properties;  					foreach (var materialProperty in properties.Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialSubProperty.ValueType.Properties;  										var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  										if (firstValueProperty != null) {  											WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  					}  					properties = subProperty.ValueType.Properties;  					foreach (var materialProperty in properties.Skip (1)) {  						properties = materialProperty.ValueType.Properties;  						foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  							properties = materialSubProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  									}  								}  							}  						}  					}  				}  				var additionalProperties = subProperty.ValueType.AdditionalProperties;  				if (additionalProperties != null) {  					foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  						int i = 0;  						properties = additionalProperty.ValueType.Properties;  						foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' additionalProperties.ValueType.Name' additionalProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								string propName = string.Format ("{0}{1}"' "prop"' i++);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var a = w2.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  								writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValue (writer' "w3"' id + property.Name + subProperty.Name' valueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' propName' additionalProperty.Name));  								}  							}  						}  					}  				}  			}  		}  	}  	// create all types of custom properties  	writer.WriteLine ("private void WriteConstantValuesCustomProperties()");  	using (writer.OpenScope ()) {  		var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  		if (propertiesProperty != null) {  			var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  			if (additionalProperties != null) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = "constant_custom";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue)) {  							string propName = string.Format ("custom_{0}"' valueProperty.Name);  							writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  							using (writer.OpenScope ()) {  								WriteValue (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  							}  						}  					}  				}  			}  		}  	}  	// create entities using references  	writer.WriteLine ("private void WriteReferenceValues()");  	using (writer.OpenScope ()) {  		// write some positions and double values to use to create reference lists for position lists and double lists later  		for (int i = 1; i <= 2; ++i) {  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				string id = string.Format ("ConstantPosition{0}"' i);  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantPosition{0}')).toBeDefined();"' i);  				var property = schemaProperties.First (p => p.Name == "position");  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					var properties = property.ValueType.Properties;  					var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  					WriteValue (writer' "w"' id' firstValueProperty' property' false' property.Name);  				}  			}  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				string id = string.Format ("ConstantDouble{0}"' i);  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantDouble{0}')).toBeDefined();"' i);  				var property = schemaProperties.First (p => p.Name == "billboard");  				var properties = property.ValueType.Properties;  				var subProperty = properties.First (p => p.Name == "scale");  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  				using (writer.OpenScope ()) {  					properties = subProperty.ValueType.Properties;  					var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  					WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' false' string.Format ("{0}.{1}"' property.Name' subProperty.Name));  				}  			}  		}  		// write one big packet with references for everything  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			writer.WriteLine ("packet.WriteId(\"Reference\");");  			WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Reference')).toBeDefined();");  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					var properties = property.ValueType.Properties;  					if (properties.Any (p => p.ValueType.Name == "Reference")) {  						writer.WriteLine ("w.WriteReference(new Reference(\"Constant\"' \"{0}\"));"' propertyName);  						WriteAssertion (writer' isExtension' "expect(e.{0}.getValue(date)).toEqual(constant.{0}.getValue(date));"' propertyName);  					} else {  						foreach (var subProperty in properties.Where (p => !p.IsValue)) {  							properties = subProperty.ValueType.Properties;  							string subPropertyName = GetSubPropertyName (propertyName' subProperty);  							if (properties.Any (p => p.ValueType.Name == "Reference")) {  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									writer.WriteLine ("w2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\")));"' propertyName' subPropertyName);  									WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual(constant.{0}.{1}.getValue(date));"' propertyName' subPropertyName);  								}  							} else if (properties.Any (p => p.ValueType.Name == "ReferenceList")) {  								string targetId = "";  								string[] referencePropertyNames =  {    								};  								if (subProperty.ValueType.Name == "PositionList") {  									targetId = "Position";  									referencePropertyNames = new[] {  										"position"  									};  								} else if (subProperty.ValueType.Name == "DoubleList") {  									targetId = "Double";  									referencePropertyNames = new[] {  										"billboard"'  										"scale"  									};  								}  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									writer.WriteLine ("w2.WriteReferences(CreateList(new Reference(\"Constant{0}1\"' CreateList({1}))' new Reference(\"Constant{0}2\"' CreateList({1}))));"' targetId' string.Join ("' "' referencePropertyNames.Select (n => string.Format ("\"{0}\""' n))));  									WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual([dataSource.entities.getById('Constant{2}1').{3}.getValue(date)' dataSource.entities.getById('Constant{2}2').{3}.getValue(date)]);"' propertyName' subPropertyName' targetId' string.Join ("."' referencePropertyNames));  								}  							} else if (subProperty.ValueType.Name.Contains ("Material")) {  								Property materialProperty = properties.First ();  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("m2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"{2}\")));"' propertyName' subPropertyName' materialSubProperty.Name);  											WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.{2}.getValue(date)).toEqual(constant.{0}.{1}.{2}.getValue(date));"' propertyName' subPropertyName' materialSubProperty.Name);  										}  									}  								}  							} else {  								var additionalProperties = subProperty.ValueType.AdditionalProperties;  								if (additionalProperties != null) {  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var a = w2.Open{0}Property(\"referenceProp\"))"' additionalProperties.ValueType.NameWithPascalCase);  									using (writer.OpenScope ()) {  										foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												writer.WriteLine ("w3.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"prop\"' \"{2}\")));"' propertyName' subPropertyName' additionalProperty.Name);  												WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.referenceProp.{2}.getValue(date)).toEqual(constant.{0}.{1}.prop.{2}.getValue(date));"' propertyName' subPropertyName' additionalProperty.Name);  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		writer.WriteLine ("WriteReferenceValuesIndividual();");  	}  	writer.WriteLine ("private void WriteReferenceValuesIndividual()");  	using (writer.OpenScope ()) {  		// write other materials as individual packets  		foreach (var property in schemaProperties) {  			writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  		}  		// special case - velocity reference  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  			WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  			var property = schemaProperties.First (p => p.Name == "position");  			writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				// construct a position with specific velocity  				double dx = 1.0;  				double dy = 2.0;  				double dz = 3.0;  				double deltaTime = 60.0;  				double x1 = 1.0;  				double x2 = x1 + dx * deltaTime;  				double y1 = 2.0;  				double y2 = y1 + dy * deltaTime;  				double z1 = 3.0;  				double z2 = z1 + dz * deltaTime;  				string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  				string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  				string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  				string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  				writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  				WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  				WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  			}  		}  		foreach (var property in schemaProperties) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			foreach (var subProperty in properties.Where (p => !p.IsValue)) {  				properties = subProperty.ValueType.Properties;  				if (properties.Any (p => p.Name == "velocityReference")) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  							double expectedX = 1.0;  							double expectedY = 2.0;  							double expectedZ = 3.0;  							bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  							if (isNormalized) {  								NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  							}  							WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  						}  					}  				}  			}  		}  	}  	// write other materials as individual packets  	foreach (var property in schemaProperties) {  		writer.WriteLine ("private void WriteReferenceValuesIndividual{0}()"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			foreach (var subProperty in properties.Where (p => !p.IsValue)) {  				string subPropertyName = GetSubPropertyName (propertyName' subProperty);  				if (subProperty.ValueType.Name.Contains ("Material")) {  					properties = subProperty.ValueType.Properties;  					foreach (var materialProperty in properties.Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string targetId = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  							string id = string.Format ("reference_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										writer.WriteLine ("m2.WriteReference(new Reference(\"{0}\"' CreateList(\"{1}\"' \"{2}\"' \"{3}\")));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  										WriteAssertion (writer' isExtension' "expect(e.{1}.{2}.{3}.getValue(date)).toEqual(dataSource.entities.getById('{0}').{1}.{2}.{3}.getValue(date));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  									}  								}  							}  						}  					}  				}  			}  		}  	}  	// test sampled properties  	writer.WriteLine ("private void WriteSampledValues()");  	using (writer.OpenScope ()) {  		// Write one packet with first value types for each property  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			const string id = "Sampled";  			writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  			WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Sampled')).toBeDefined();");  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				if (property.IsInterpolatable) {  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  						WriteValues (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  					}  				} else {  					var subProperties = properties.Where (p => !p.IsValue && (p.IsInterpolatable || p.ValueType.Name.Contains ("Material"))).ToList ();  					if (subProperties.Any ()) {  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							foreach (var subProperty in subProperties) {  								properties = subProperty.ValueType.Properties;  								string subPropertyName = GetSubPropertyName (propertyName' subProperty);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									if (subProperty.IsInterpolatable) {  										var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  										WriteValues (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  									} else if (subProperty.ValueType.Name.Contains ("Material")) {  										Property materialProperty = properties.First ();  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialSubProperty.ValueType.Properties;  													var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  													WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		writer.WriteLine ("WriteSampledValuesIndividual();");  		writer.WriteLine ("WriteSampledValuesCustomProperties();");  	}  	writer.WriteLine ("private void WriteSampledValuesIndividual()");  	using (writer.OpenScope ()) {  		// write other value types as individual packets  		// split method into multiple methods  		foreach (var property in schemaProperties) {  			writer.WriteLine ("WriteSampledValuesIndividual{0}();"' property.NameWithPascalCase);  		}  	}  	foreach (var property in schemaProperties) {  		writer.WriteLine ("private void WriteSampledValuesIndividual{0}()"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			if (property.IsInterpolatable) {  				foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("sampled_{0}_{1}"' propertyName' valueProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							WriteValues (writer' "w"' id' valueProperty' property' isExtension' propertyName);  						}  					}  				}  			} else {  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					string subPropertyName = GetSubPropertyName (propertyName' subProperty);  					properties = subProperty.ValueType.Properties;  					if (subProperty.IsInterpolatable) {  						foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' valueProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValues (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  								}  							}  						}  					} else if (subProperty.ValueType.Name.Contains ("Material")) {  						// write other values for the first material  						// then write first values for other materials   						// then write remaining values for other materials individually  						var firstMaterialProperty = properties.First ();  						properties = firstMaterialProperty.ValueType.Properties;  						foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  							properties = materialSubProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValues (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialSubProperty.ValueType.Properties;  											var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  											WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							properties = materialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  					}  				}  			}  		}  	}  	// create all types of custom properties  	writer.WriteLine ("private void WriteSampledValuesCustomProperties()");  	using (writer.OpenScope ()) {  		var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  		if (propertiesProperty != null) {  			var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  			if (additionalProperties != null) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = "sampled_custom";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array)) {  							string propName = string.Format ("custom_{0}"' valueProperty.Name);  							writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  							using (writer.OpenScope ()) {  								WriteValues (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	writer.WriteLine ("private readonly JulianDate m_documentStartDate = new GregorianDate(2016' 6' 17' 12' 0' 0).ToJulianDate();");  	writer.WriteLine ("private readonly JulianDate m_documentStopDate = new GregorianDate(2016' 6' 17' 13' 0' 0).ToJulianDate();");  	writer.WriteLine ("private TextWriter m_streamWriter;");  	writer.WriteLine ("private TextWriter m_assertionsWriter;");  	writer.WriteLine ("private TextWriter m_extensionsAssertionsWriter;");  	writer.WriteLine ("private CesiumOutputStream m_output;");  	writer.WriteLine ("private CesiumStreamWriter m_writer;");  	writer.WriteLine ("private void WriteAssertionBoth(string s)");  	using (writer.OpenScope ()) {  		writer.WriteLine ("m_assertionsWriter.WriteLine(s);");  		writer.WriteLine ("m_extensionsAssertionsWriter.WriteLine(s);");  	}  	writer.WriteLine ("private static IList<T> CreateList<T>(T t1' T t2)");  	using (writer.OpenScope ()) {  		writer.WriteLine ("return new List<T> { t1' t2 };");  	}  	writer.WriteLine ("private static IList<T> CreateList<T>(params T[] ts)");  	using (writer.OpenScope ()) {  		writer.WriteLine ("return ts;");  	}  	writer.WriteLine ("[Test]");  	writer.WriteLine ("public void GenerateValidationDocument()");  	var schemaProperties = schema.Properties.Where (p => p.Name != "clock" && p.Name != "availability" && !p.ValueType.IsSchemaFromType).Where (p => p.Name != "properties").ToList ();  	using (writer.OpenScope ()) {  		writer.WriteLine ("using (m_streamWriter = new StreamWriter(\"ValidationDocument.czml\"))");  		writer.WriteLine ("using (m_assertionsWriter = new StreamWriter(\"ValidationDocumentAssertions.js\"))");  		writer.WriteLine ("using (m_extensionsAssertionsWriter = new StreamWriter(\"ValidationDocumentExtensionAssertions.js\"))");  		using (writer.OpenScope ()) {  			WriteAssertionBoth (writer' "return CzmlDataSource.load('Data/CZML/ValidationDocument.czml').then(function(dataSource) {");  			s_assertionIndent++;  			WriteAssertionBoth (writer' "/*jshint -W120 */");  			WriteAssertionBoth (writer' "var e;");  			WriteAssertionBoth (writer' "var date;");  			WriteAssertionBoth (writer' "var documentStartDate = JulianDate.fromIso8601('2016-06-17T12:00:00Z');");  			WriteAssertionBoth (writer' "var documentStopDate = JulianDate.fromIso8601('2016-06-17T13:00:00Z');");  			writer.WriteLine ("m_output = new CesiumOutputStream(m_streamWriter) { PrettyFormatting = true };");  			writer.WriteLine ("m_writer = new CesiumStreamWriter();");  			writer.WriteLine ("m_output.WriteStartSequence();");  			// Java has a limit on the size of a single method (65535 bytes) so we have to break up all this code in multiple methods  			writer.WriteLine ("WriteClock();");  			writer.WriteLine ("WriteConstantValues();");  			writer.WriteLine ("WriteReferenceValues();");  			writer.WriteLine ("WriteSampledValues();");  			writer.WriteLine ("m_output.WriteEndSequence();");  			s_assertionIndent--;  			WriteAssertionBoth (writer' "});");  			s_assertionIndent++;  		}  	}  	writer.WriteLine ("private void WriteClock()");  	using (writer.OpenScope ()) {  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			writer.WriteLine ("packet.WriteId(\"document\");");  			writer.WriteLine ("packet.WriteName(\"ValidationDocument\");");  			writer.WriteLine ("packet.WriteVersion(\"1.0\");");  			writer.WriteLine ("using (var clock = packet.OpenClockProperty())");  			using (writer.OpenScope ()) {  				writer.WriteLine ("clock.WriteInterval(m_documentStartDate' m_documentStopDate);");  				WriteAssertion (writer' false' "expect(dataSource.clock.startTime).toEqual(documentStartDate);");  				WriteAssertion (writer' false' "expect(dataSource.clock.stopTime).toEqual(documentStopDate);");  				writer.WriteLine ("clock.WriteCurrentTime(m_documentStartDate);");  				WriteAssertion (writer' false' "expect(dataSource.clock.currentTime).toEqual(documentStartDate);");  				writer.WriteLine ("clock.WriteMultiplier(1.0);");  				WriteAssertion (writer' false' "expect(dataSource.clock.multiplier).toEqual(1.0);");  				writer.WriteLine ("clock.WriteRange(ClockRange.Unbounded);");  				WriteAssertion (writer' false' "expect(dataSource.clock.clockRange).toEqual(ClockRange.UNBOUNDED);");  				writer.WriteLine ("clock.WriteStep(ClockStep.SystemClockMultiplier);");  				WriteAssertion (writer' false' "expect(dataSource.clock.clockStep).toEqual(ClockStep.SYSTEM_CLOCK_MULTIPLIER);");  			}  		}  	}  	writer.WriteLine ("private void WriteConstantValues()");  	using (writer.OpenScope ()) {  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			const string id = "Constant";  			writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  			WriteAssertionBoth (writer' "var constant = e = dataSource.entities.getById('Constant');");  			WriteAssertionBoth (writer' "expect(e).toBeDefined();");  			WriteAssertionBoth (writer' "date = JulianDate.now();");  			// Write one packet with first value types for each property  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					var properties = property.ValueType.Properties;  					var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  					if (firstValueProperty != null) {  						WriteValue (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  					} else {  						foreach (var subProperty in properties.Where (p => !p.IsValue)) {  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								properties = subProperty.ValueType.Properties;  								firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  								string subPropertyName = GetSubPropertyName (propertyName' subProperty);  								if (firstValueProperty != null) {  									WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  								} else if (subProperty.ValueType.Name.Contains ("Material")) {  									Property materialProperty = properties.First ();  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialSubProperty.ValueType.Properties;  												firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  												if (firstValueProperty != null) {  													WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								} else {  									var additionalProperties = subProperty.ValueType.AdditionalProperties;  									if (additionalProperties != null) {  										writer.WriteLine ("using (var a = w2.Open{0}Property(\"prop\"))"' additionalProperties.ValueType.NameWithPascalCase);  										using (writer.OpenScope ()) {  											foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = additionalProperty.ValueType.Properties;  													firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  													if (firstValueProperty != null) {  														WriteValue (writer' "w3"' id + property.Name' firstValueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' "prop"' additionalProperty.Name));  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		writer.WriteLine ("WriteConstantValuesIndividual();");  		writer.WriteLine ("WriteConstantValuesCustomProperties();");  	}  	writer.WriteLine ("private void WriteConstantValuesIndividual()");  	using (writer.OpenScope ()) {  		// write other value types as individual packets  		foreach (var property in schemaProperties) {  			writer.WriteLine ("WriteConstantValuesIndividual{0}();"' property.NameWithPascalCase);  		}  	}  	foreach (var property in schemaProperties) {  		writer.WriteLine ("private void WriteConstantValuesIndividual{0}()"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("constant_{0}_{1}"' property.Name' valueProperty.Name);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						WriteValue (writer' "w"' id' valueProperty' property' isExtension' propertyName);  					}  				}  			}  			foreach (var subProperty in properties.Where (p => !p.IsValue)) {  				string subPropertyName = GetSubPropertyName (propertyName' subProperty);  				properties = subProperty.ValueType.Properties;  				foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("constant_{0}_{1}_{2}"' property.Name' subPropertyName' valueProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							WriteValue (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  						}  					}  				}  				if (subProperty.ValueType.Name.Contains ("Material")) {  					// write other values for the first material  					// then write first values for other materials   					// then write remaining values for other materials individually  					var firstMaterialProperty = properties.First ();  					properties = firstMaterialProperty.ValueType.Properties;  					foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  						properties = materialSubProperty.ValueType.Properties;  						foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValue (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  								}  							}  						}  					}  					properties = subProperty.ValueType.Properties;  					foreach (var materialProperty in properties.Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialSubProperty.ValueType.Properties;  										var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  										if (firstValueProperty != null) {  											WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  					}  					properties = subProperty.ValueType.Properties;  					foreach (var materialProperty in properties.Skip (1)) {  						properties = materialProperty.ValueType.Properties;  						foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  							properties = materialSubProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  									}  								}  							}  						}  					}  				}  				var additionalProperties = subProperty.ValueType.AdditionalProperties;  				if (additionalProperties != null) {  					foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  						int i = 0;  						properties = additionalProperty.ValueType.Properties;  						foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' additionalProperties.ValueType.Name' additionalProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								string propName = string.Format ("{0}{1}"' "prop"' i++);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var a = w2.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  								writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValue (writer' "w3"' id + property.Name + subProperty.Name' valueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' propName' additionalProperty.Name));  								}  							}  						}  					}  				}  			}  		}  	}  	// create all types of custom properties  	writer.WriteLine ("private void WriteConstantValuesCustomProperties()");  	using (writer.OpenScope ()) {  		var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  		if (propertiesProperty != null) {  			var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  			if (additionalProperties != null) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = "constant_custom";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue)) {  							string propName = string.Format ("custom_{0}"' valueProperty.Name);  							writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  							using (writer.OpenScope ()) {  								WriteValue (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  							}  						}  					}  				}  			}  		}  	}  	// create entities using references  	writer.WriteLine ("private void WriteReferenceValues()");  	using (writer.OpenScope ()) {  		// write some positions and double values to use to create reference lists for position lists and double lists later  		for (int i = 1; i <= 2; ++i) {  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				string id = string.Format ("ConstantPosition{0}"' i);  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantPosition{0}')).toBeDefined();"' i);  				var property = schemaProperties.First (p => p.Name == "position");  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					var properties = property.ValueType.Properties;  					var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  					WriteValue (writer' "w"' id' firstValueProperty' property' false' property.Name);  				}  			}  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				string id = string.Format ("ConstantDouble{0}"' i);  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantDouble{0}')).toBeDefined();"' i);  				var property = schemaProperties.First (p => p.Name == "billboard");  				var properties = property.ValueType.Properties;  				var subProperty = properties.First (p => p.Name == "scale");  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  				using (writer.OpenScope ()) {  					properties = subProperty.ValueType.Properties;  					var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  					WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' false' string.Format ("{0}.{1}"' property.Name' subProperty.Name));  				}  			}  		}  		// write one big packet with references for everything  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			writer.WriteLine ("packet.WriteId(\"Reference\");");  			WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Reference')).toBeDefined();");  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					var properties = property.ValueType.Properties;  					if (properties.Any (p => p.ValueType.Name == "Reference")) {  						writer.WriteLine ("w.WriteReference(new Reference(\"Constant\"' \"{0}\"));"' propertyName);  						WriteAssertion (writer' isExtension' "expect(e.{0}.getValue(date)).toEqual(constant.{0}.getValue(date));"' propertyName);  					} else {  						foreach (var subProperty in properties.Where (p => !p.IsValue)) {  							properties = subProperty.ValueType.Properties;  							string subPropertyName = GetSubPropertyName (propertyName' subProperty);  							if (properties.Any (p => p.ValueType.Name == "Reference")) {  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									writer.WriteLine ("w2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\")));"' propertyName' subPropertyName);  									WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual(constant.{0}.{1}.getValue(date));"' propertyName' subPropertyName);  								}  							} else if (properties.Any (p => p.ValueType.Name == "ReferenceList")) {  								string targetId = "";  								string[] referencePropertyNames =  {    								};  								if (subProperty.ValueType.Name == "PositionList") {  									targetId = "Position";  									referencePropertyNames = new[] {  										"position"  									};  								} else if (subProperty.ValueType.Name == "DoubleList") {  									targetId = "Double";  									referencePropertyNames = new[] {  										"billboard"'  										"scale"  									};  								}  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									writer.WriteLine ("w2.WriteReferences(CreateList(new Reference(\"Constant{0}1\"' CreateList({1}))' new Reference(\"Constant{0}2\"' CreateList({1}))));"' targetId' string.Join ("' "' referencePropertyNames.Select (n => string.Format ("\"{0}\""' n))));  									WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual([dataSource.entities.getById('Constant{2}1').{3}.getValue(date)' dataSource.entities.getById('Constant{2}2').{3}.getValue(date)]);"' propertyName' subPropertyName' targetId' string.Join ("."' referencePropertyNames));  								}  							} else if (subProperty.ValueType.Name.Contains ("Material")) {  								Property materialProperty = properties.First ();  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("m2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"{2}\")));"' propertyName' subPropertyName' materialSubProperty.Name);  											WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.{2}.getValue(date)).toEqual(constant.{0}.{1}.{2}.getValue(date));"' propertyName' subPropertyName' materialSubProperty.Name);  										}  									}  								}  							} else {  								var additionalProperties = subProperty.ValueType.AdditionalProperties;  								if (additionalProperties != null) {  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var a = w2.Open{0}Property(\"referenceProp\"))"' additionalProperties.ValueType.NameWithPascalCase);  									using (writer.OpenScope ()) {  										foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												writer.WriteLine ("w3.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"prop\"' \"{2}\")));"' propertyName' subPropertyName' additionalProperty.Name);  												WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.referenceProp.{2}.getValue(date)).toEqual(constant.{0}.{1}.prop.{2}.getValue(date));"' propertyName' subPropertyName' additionalProperty.Name);  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		writer.WriteLine ("WriteReferenceValuesIndividual();");  	}  	writer.WriteLine ("private void WriteReferenceValuesIndividual()");  	using (writer.OpenScope ()) {  		// write other materials as individual packets  		foreach (var property in schemaProperties) {  			writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  		}  		// special case - velocity reference  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  			WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  			var property = schemaProperties.First (p => p.Name == "position");  			writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				// construct a position with specific velocity  				double dx = 1.0;  				double dy = 2.0;  				double dz = 3.0;  				double deltaTime = 60.0;  				double x1 = 1.0;  				double x2 = x1 + dx * deltaTime;  				double y1 = 2.0;  				double y2 = y1 + dy * deltaTime;  				double z1 = 3.0;  				double z2 = z1 + dz * deltaTime;  				string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  				string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  				string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  				string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  				writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  				WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  				WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  			}  		}  		foreach (var property in schemaProperties) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			foreach (var subProperty in properties.Where (p => !p.IsValue)) {  				properties = subProperty.ValueType.Properties;  				if (properties.Any (p => p.Name == "velocityReference")) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  							double expectedX = 1.0;  							double expectedY = 2.0;  							double expectedZ = 3.0;  							bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  							if (isNormalized) {  								NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  							}  							WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  						}  					}  				}  			}  		}  	}  	// write other materials as individual packets  	foreach (var property in schemaProperties) {  		writer.WriteLine ("private void WriteReferenceValuesIndividual{0}()"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			foreach (var subProperty in properties.Where (p => !p.IsValue)) {  				string subPropertyName = GetSubPropertyName (propertyName' subProperty);  				if (subProperty.ValueType.Name.Contains ("Material")) {  					properties = subProperty.ValueType.Properties;  					foreach (var materialProperty in properties.Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string targetId = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  							string id = string.Format ("reference_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										writer.WriteLine ("m2.WriteReference(new Reference(\"{0}\"' CreateList(\"{1}\"' \"{2}\"' \"{3}\")));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  										WriteAssertion (writer' isExtension' "expect(e.{1}.{2}.{3}.getValue(date)).toEqual(dataSource.entities.getById('{0}').{1}.{2}.{3}.getValue(date));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  									}  								}  							}  						}  					}  				}  			}  		}  	}  	// test sampled properties  	writer.WriteLine ("private void WriteSampledValues()");  	using (writer.OpenScope ()) {  		// Write one packet with first value types for each property  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			const string id = "Sampled";  			writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  			WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Sampled')).toBeDefined();");  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				if (property.IsInterpolatable) {  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  						WriteValues (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  					}  				} else {  					var subProperties = properties.Where (p => !p.IsValue && (p.IsInterpolatable || p.ValueType.Name.Contains ("Material"))).ToList ();  					if (subProperties.Any ()) {  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							foreach (var subProperty in subProperties) {  								properties = subProperty.ValueType.Properties;  								string subPropertyName = GetSubPropertyName (propertyName' subProperty);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									if (subProperty.IsInterpolatable) {  										var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  										WriteValues (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  									} else if (subProperty.ValueType.Name.Contains ("Material")) {  										Property materialProperty = properties.First ();  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialSubProperty.ValueType.Properties;  													var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  													WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		writer.WriteLine ("WriteSampledValuesIndividual();");  		writer.WriteLine ("WriteSampledValuesCustomProperties();");  	}  	writer.WriteLine ("private void WriteSampledValuesIndividual()");  	using (writer.OpenScope ()) {  		// write other value types as individual packets  		// split method into multiple methods  		foreach (var property in schemaProperties) {  			writer.WriteLine ("WriteSampledValuesIndividual{0}();"' property.NameWithPascalCase);  		}  	}  	foreach (var property in schemaProperties) {  		writer.WriteLine ("private void WriteSampledValuesIndividual{0}()"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			if (property.IsInterpolatable) {  				foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("sampled_{0}_{1}"' propertyName' valueProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							WriteValues (writer' "w"' id' valueProperty' property' isExtension' propertyName);  						}  					}  				}  			} else {  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					string subPropertyName = GetSubPropertyName (propertyName' subProperty);  					properties = subProperty.ValueType.Properties;  					if (subProperty.IsInterpolatable) {  						foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' valueProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValues (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  								}  							}  						}  					} else if (subProperty.ValueType.Name.Contains ("Material")) {  						// write other values for the first material  						// then write first values for other materials   						// then write remaining values for other materials individually  						var firstMaterialProperty = properties.First ();  						properties = firstMaterialProperty.ValueType.Properties;  						foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  							properties = materialSubProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValues (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialSubProperty.ValueType.Properties;  											var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  											WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							properties = materialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  					}  				}  			}  		}  	}  	// create all types of custom properties  	writer.WriteLine ("private void WriteSampledValuesCustomProperties()");  	using (writer.OpenScope ()) {  		var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  		if (propertiesProperty != null) {  			var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  			if (additionalProperties != null) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = "sampled_custom";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array)) {  							string propName = string.Format ("custom_{0}"' valueProperty.Name);  							writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  							using (writer.OpenScope ()) {  								WriteValues (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	writer.WriteLine ("private readonly JulianDate m_documentStartDate = new GregorianDate(2016' 6' 17' 12' 0' 0).ToJulianDate();");  	writer.WriteLine ("private readonly JulianDate m_documentStopDate = new GregorianDate(2016' 6' 17' 13' 0' 0).ToJulianDate();");  	writer.WriteLine ("private TextWriter m_streamWriter;");  	writer.WriteLine ("private TextWriter m_assertionsWriter;");  	writer.WriteLine ("private TextWriter m_extensionsAssertionsWriter;");  	writer.WriteLine ("private CesiumOutputStream m_output;");  	writer.WriteLine ("private CesiumStreamWriter m_writer;");  	writer.WriteLine ("private void WriteAssertionBoth(string s)");  	using (writer.OpenScope ()) {  		writer.WriteLine ("m_assertionsWriter.WriteLine(s);");  		writer.WriteLine ("m_extensionsAssertionsWriter.WriteLine(s);");  	}  	writer.WriteLine ("private static IList<T> CreateList<T>(T t1' T t2)");  	using (writer.OpenScope ()) {  		writer.WriteLine ("return new List<T> { t1' t2 };");  	}  	writer.WriteLine ("private static IList<T> CreateList<T>(params T[] ts)");  	using (writer.OpenScope ()) {  		writer.WriteLine ("return ts;");  	}  	writer.WriteLine ("[Test]");  	writer.WriteLine ("public void GenerateValidationDocument()");  	var schemaProperties = schema.Properties.Where (p => p.Name != "clock" && p.Name != "availability" && !p.ValueType.IsSchemaFromType).Where (p => p.Name != "properties").ToList ();  	using (writer.OpenScope ()) {  		writer.WriteLine ("using (m_streamWriter = new StreamWriter(\"ValidationDocument.czml\"))");  		writer.WriteLine ("using (m_assertionsWriter = new StreamWriter(\"ValidationDocumentAssertions.js\"))");  		writer.WriteLine ("using (m_extensionsAssertionsWriter = new StreamWriter(\"ValidationDocumentExtensionAssertions.js\"))");  		using (writer.OpenScope ()) {  			WriteAssertionBoth (writer' "return CzmlDataSource.load('Data/CZML/ValidationDocument.czml').then(function(dataSource) {");  			s_assertionIndent++;  			WriteAssertionBoth (writer' "/*jshint -W120 */");  			WriteAssertionBoth (writer' "var e;");  			WriteAssertionBoth (writer' "var date;");  			WriteAssertionBoth (writer' "var documentStartDate = JulianDate.fromIso8601('2016-06-17T12:00:00Z');");  			WriteAssertionBoth (writer' "var documentStopDate = JulianDate.fromIso8601('2016-06-17T13:00:00Z');");  			writer.WriteLine ("m_output = new CesiumOutputStream(m_streamWriter) { PrettyFormatting = true };");  			writer.WriteLine ("m_writer = new CesiumStreamWriter();");  			writer.WriteLine ("m_output.WriteStartSequence();");  			// Java has a limit on the size of a single method (65535 bytes) so we have to break up all this code in multiple methods  			writer.WriteLine ("WriteClock();");  			writer.WriteLine ("WriteConstantValues();");  			writer.WriteLine ("WriteReferenceValues();");  			writer.WriteLine ("WriteSampledValues();");  			writer.WriteLine ("m_output.WriteEndSequence();");  			s_assertionIndent--;  			WriteAssertionBoth (writer' "});");  			s_assertionIndent++;  		}  	}  	writer.WriteLine ("private void WriteClock()");  	using (writer.OpenScope ()) {  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			writer.WriteLine ("packet.WriteId(\"document\");");  			writer.WriteLine ("packet.WriteName(\"ValidationDocument\");");  			writer.WriteLine ("packet.WriteVersion(\"1.0\");");  			writer.WriteLine ("using (var clock = packet.OpenClockProperty())");  			using (writer.OpenScope ()) {  				writer.WriteLine ("clock.WriteInterval(m_documentStartDate' m_documentStopDate);");  				WriteAssertion (writer' false' "expect(dataSource.clock.startTime).toEqual(documentStartDate);");  				WriteAssertion (writer' false' "expect(dataSource.clock.stopTime).toEqual(documentStopDate);");  				writer.WriteLine ("clock.WriteCurrentTime(m_documentStartDate);");  				WriteAssertion (writer' false' "expect(dataSource.clock.currentTime).toEqual(documentStartDate);");  				writer.WriteLine ("clock.WriteMultiplier(1.0);");  				WriteAssertion (writer' false' "expect(dataSource.clock.multiplier).toEqual(1.0);");  				writer.WriteLine ("clock.WriteRange(ClockRange.Unbounded);");  				WriteAssertion (writer' false' "expect(dataSource.clock.clockRange).toEqual(ClockRange.UNBOUNDED);");  				writer.WriteLine ("clock.WriteStep(ClockStep.SystemClockMultiplier);");  				WriteAssertion (writer' false' "expect(dataSource.clock.clockStep).toEqual(ClockStep.SYSTEM_CLOCK_MULTIPLIER);");  			}  		}  	}  	writer.WriteLine ("private void WriteConstantValues()");  	using (writer.OpenScope ()) {  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			const string id = "Constant";  			writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  			WriteAssertionBoth (writer' "var constant = e = dataSource.entities.getById('Constant');");  			WriteAssertionBoth (writer' "expect(e).toBeDefined();");  			WriteAssertionBoth (writer' "date = JulianDate.now();");  			// Write one packet with first value types for each property  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					var properties = property.ValueType.Properties;  					var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  					if (firstValueProperty != null) {  						WriteValue (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  					} else {  						foreach (var subProperty in properties.Where (p => !p.IsValue)) {  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								properties = subProperty.ValueType.Properties;  								firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  								string subPropertyName = GetSubPropertyName (propertyName' subProperty);  								if (firstValueProperty != null) {  									WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  								} else if (subProperty.ValueType.Name.Contains ("Material")) {  									Property materialProperty = properties.First ();  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialSubProperty.ValueType.Properties;  												firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  												if (firstValueProperty != null) {  													WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								} else {  									var additionalProperties = subProperty.ValueType.AdditionalProperties;  									if (additionalProperties != null) {  										writer.WriteLine ("using (var a = w2.Open{0}Property(\"prop\"))"' additionalProperties.ValueType.NameWithPascalCase);  										using (writer.OpenScope ()) {  											foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = additionalProperty.ValueType.Properties;  													firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  													if (firstValueProperty != null) {  														WriteValue (writer' "w3"' id + property.Name' firstValueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' "prop"' additionalProperty.Name));  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		writer.WriteLine ("WriteConstantValuesIndividual();");  		writer.WriteLine ("WriteConstantValuesCustomProperties();");  	}  	writer.WriteLine ("private void WriteConstantValuesIndividual()");  	using (writer.OpenScope ()) {  		// write other value types as individual packets  		foreach (var property in schemaProperties) {  			writer.WriteLine ("WriteConstantValuesIndividual{0}();"' property.NameWithPascalCase);  		}  	}  	foreach (var property in schemaProperties) {  		writer.WriteLine ("private void WriteConstantValuesIndividual{0}()"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("constant_{0}_{1}"' property.Name' valueProperty.Name);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						WriteValue (writer' "w"' id' valueProperty' property' isExtension' propertyName);  					}  				}  			}  			foreach (var subProperty in properties.Where (p => !p.IsValue)) {  				string subPropertyName = GetSubPropertyName (propertyName' subProperty);  				properties = subProperty.ValueType.Properties;  				foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("constant_{0}_{1}_{2}"' property.Name' subPropertyName' valueProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							WriteValue (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  						}  					}  				}  				if (subProperty.ValueType.Name.Contains ("Material")) {  					// write other values for the first material  					// then write first values for other materials   					// then write remaining values for other materials individually  					var firstMaterialProperty = properties.First ();  					properties = firstMaterialProperty.ValueType.Properties;  					foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  						properties = materialSubProperty.ValueType.Properties;  						foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValue (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  								}  							}  						}  					}  					properties = subProperty.ValueType.Properties;  					foreach (var materialProperty in properties.Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialSubProperty.ValueType.Properties;  										var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  										if (firstValueProperty != null) {  											WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  					}  					properties = subProperty.ValueType.Properties;  					foreach (var materialProperty in properties.Skip (1)) {  						properties = materialProperty.ValueType.Properties;  						foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  							properties = materialSubProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  									}  								}  							}  						}  					}  				}  				var additionalProperties = subProperty.ValueType.AdditionalProperties;  				if (additionalProperties != null) {  					foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  						int i = 0;  						properties = additionalProperty.ValueType.Properties;  						foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' additionalProperties.ValueType.Name' additionalProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								string propName = string.Format ("{0}{1}"' "prop"' i++);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var a = w2.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  								writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValue (writer' "w3"' id + property.Name + subProperty.Name' valueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' propName' additionalProperty.Name));  								}  							}  						}  					}  				}  			}  		}  	}  	// create all types of custom properties  	writer.WriteLine ("private void WriteConstantValuesCustomProperties()");  	using (writer.OpenScope ()) {  		var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  		if (propertiesProperty != null) {  			var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  			if (additionalProperties != null) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = "constant_custom";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue)) {  							string propName = string.Format ("custom_{0}"' valueProperty.Name);  							writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  							using (writer.OpenScope ()) {  								WriteValue (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  							}  						}  					}  				}  			}  		}  	}  	// create entities using references  	writer.WriteLine ("private void WriteReferenceValues()");  	using (writer.OpenScope ()) {  		// write some positions and double values to use to create reference lists for position lists and double lists later  		for (int i = 1; i <= 2; ++i) {  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				string id = string.Format ("ConstantPosition{0}"' i);  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantPosition{0}')).toBeDefined();"' i);  				var property = schemaProperties.First (p => p.Name == "position");  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					var properties = property.ValueType.Properties;  					var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  					WriteValue (writer' "w"' id' firstValueProperty' property' false' property.Name);  				}  			}  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				string id = string.Format ("ConstantDouble{0}"' i);  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantDouble{0}')).toBeDefined();"' i);  				var property = schemaProperties.First (p => p.Name == "billboard");  				var properties = property.ValueType.Properties;  				var subProperty = properties.First (p => p.Name == "scale");  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  				using (writer.OpenScope ()) {  					properties = subProperty.ValueType.Properties;  					var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  					WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' false' string.Format ("{0}.{1}"' property.Name' subProperty.Name));  				}  			}  		}  		// write one big packet with references for everything  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			writer.WriteLine ("packet.WriteId(\"Reference\");");  			WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Reference')).toBeDefined();");  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					var properties = property.ValueType.Properties;  					if (properties.Any (p => p.ValueType.Name == "Reference")) {  						writer.WriteLine ("w.WriteReference(new Reference(\"Constant\"' \"{0}\"));"' propertyName);  						WriteAssertion (writer' isExtension' "expect(e.{0}.getValue(date)).toEqual(constant.{0}.getValue(date));"' propertyName);  					} else {  						foreach (var subProperty in properties.Where (p => !p.IsValue)) {  							properties = subProperty.ValueType.Properties;  							string subPropertyName = GetSubPropertyName (propertyName' subProperty);  							if (properties.Any (p => p.ValueType.Name == "Reference")) {  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									writer.WriteLine ("w2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\")));"' propertyName' subPropertyName);  									WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual(constant.{0}.{1}.getValue(date));"' propertyName' subPropertyName);  								}  							} else if (properties.Any (p => p.ValueType.Name == "ReferenceList")) {  								string targetId = "";  								string[] referencePropertyNames =  {    								};  								if (subProperty.ValueType.Name == "PositionList") {  									targetId = "Position";  									referencePropertyNames = new[] {  										"position"  									};  								} else if (subProperty.ValueType.Name == "DoubleList") {  									targetId = "Double";  									referencePropertyNames = new[] {  										"billboard"'  										"scale"  									};  								}  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									writer.WriteLine ("w2.WriteReferences(CreateList(new Reference(\"Constant{0}1\"' CreateList({1}))' new Reference(\"Constant{0}2\"' CreateList({1}))));"' targetId' string.Join ("' "' referencePropertyNames.Select (n => string.Format ("\"{0}\""' n))));  									WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual([dataSource.entities.getById('Constant{2}1').{3}.getValue(date)' dataSource.entities.getById('Constant{2}2').{3}.getValue(date)]);"' propertyName' subPropertyName' targetId' string.Join ("."' referencePropertyNames));  								}  							} else if (subProperty.ValueType.Name.Contains ("Material")) {  								Property materialProperty = properties.First ();  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("m2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"{2}\")));"' propertyName' subPropertyName' materialSubProperty.Name);  											WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.{2}.getValue(date)).toEqual(constant.{0}.{1}.{2}.getValue(date));"' propertyName' subPropertyName' materialSubProperty.Name);  										}  									}  								}  							} else {  								var additionalProperties = subProperty.ValueType.AdditionalProperties;  								if (additionalProperties != null) {  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var a = w2.Open{0}Property(\"referenceProp\"))"' additionalProperties.ValueType.NameWithPascalCase);  									using (writer.OpenScope ()) {  										foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												writer.WriteLine ("w3.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"prop\"' \"{2}\")));"' propertyName' subPropertyName' additionalProperty.Name);  												WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.referenceProp.{2}.getValue(date)).toEqual(constant.{0}.{1}.prop.{2}.getValue(date));"' propertyName' subPropertyName' additionalProperty.Name);  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		writer.WriteLine ("WriteReferenceValuesIndividual();");  	}  	writer.WriteLine ("private void WriteReferenceValuesIndividual()");  	using (writer.OpenScope ()) {  		// write other materials as individual packets  		foreach (var property in schemaProperties) {  			writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  		}  		// special case - velocity reference  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  			WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  			var property = schemaProperties.First (p => p.Name == "position");  			writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				// construct a position with specific velocity  				double dx = 1.0;  				double dy = 2.0;  				double dz = 3.0;  				double deltaTime = 60.0;  				double x1 = 1.0;  				double x2 = x1 + dx * deltaTime;  				double y1 = 2.0;  				double y2 = y1 + dy * deltaTime;  				double z1 = 3.0;  				double z2 = z1 + dz * deltaTime;  				string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  				string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  				string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  				string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  				writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  				WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  				WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  			}  		}  		foreach (var property in schemaProperties) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			foreach (var subProperty in properties.Where (p => !p.IsValue)) {  				properties = subProperty.ValueType.Properties;  				if (properties.Any (p => p.Name == "velocityReference")) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  							double expectedX = 1.0;  							double expectedY = 2.0;  							double expectedZ = 3.0;  							bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  							if (isNormalized) {  								NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  							}  							WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  						}  					}  				}  			}  		}  	}  	// write other materials as individual packets  	foreach (var property in schemaProperties) {  		writer.WriteLine ("private void WriteReferenceValuesIndividual{0}()"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			foreach (var subProperty in properties.Where (p => !p.IsValue)) {  				string subPropertyName = GetSubPropertyName (propertyName' subProperty);  				if (subProperty.ValueType.Name.Contains ("Material")) {  					properties = subProperty.ValueType.Properties;  					foreach (var materialProperty in properties.Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string targetId = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  							string id = string.Format ("reference_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										writer.WriteLine ("m2.WriteReference(new Reference(\"{0}\"' CreateList(\"{1}\"' \"{2}\"' \"{3}\")));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  										WriteAssertion (writer' isExtension' "expect(e.{1}.{2}.{3}.getValue(date)).toEqual(dataSource.entities.getById('{0}').{1}.{2}.{3}.getValue(date));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  									}  								}  							}  						}  					}  				}  			}  		}  	}  	// test sampled properties  	writer.WriteLine ("private void WriteSampledValues()");  	using (writer.OpenScope ()) {  		// Write one packet with first value types for each property  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			const string id = "Sampled";  			writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  			WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Sampled')).toBeDefined();");  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				if (property.IsInterpolatable) {  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  						WriteValues (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  					}  				} else {  					var subProperties = properties.Where (p => !p.IsValue && (p.IsInterpolatable || p.ValueType.Name.Contains ("Material"))).ToList ();  					if (subProperties.Any ()) {  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							foreach (var subProperty in subProperties) {  								properties = subProperty.ValueType.Properties;  								string subPropertyName = GetSubPropertyName (propertyName' subProperty);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									if (subProperty.IsInterpolatable) {  										var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  										WriteValues (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  									} else if (subProperty.ValueType.Name.Contains ("Material")) {  										Property materialProperty = properties.First ();  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialSubProperty.ValueType.Properties;  													var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  													WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		writer.WriteLine ("WriteSampledValuesIndividual();");  		writer.WriteLine ("WriteSampledValuesCustomProperties();");  	}  	writer.WriteLine ("private void WriteSampledValuesIndividual()");  	using (writer.OpenScope ()) {  		// write other value types as individual packets  		// split method into multiple methods  		foreach (var property in schemaProperties) {  			writer.WriteLine ("WriteSampledValuesIndividual{0}();"' property.NameWithPascalCase);  		}  	}  	foreach (var property in schemaProperties) {  		writer.WriteLine ("private void WriteSampledValuesIndividual{0}()"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			if (property.IsInterpolatable) {  				foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("sampled_{0}_{1}"' propertyName' valueProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							WriteValues (writer' "w"' id' valueProperty' property' isExtension' propertyName);  						}  					}  				}  			} else {  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					string subPropertyName = GetSubPropertyName (propertyName' subProperty);  					properties = subProperty.ValueType.Properties;  					if (subProperty.IsInterpolatable) {  						foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' valueProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValues (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  								}  							}  						}  					} else if (subProperty.ValueType.Name.Contains ("Material")) {  						// write other values for the first material  						// then write first values for other materials   						// then write remaining values for other materials individually  						var firstMaterialProperty = properties.First ();  						properties = firstMaterialProperty.ValueType.Properties;  						foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  							properties = materialSubProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValues (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialSubProperty.ValueType.Properties;  											var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  											WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							properties = materialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  					}  				}  			}  		}  	}  	// create all types of custom properties  	writer.WriteLine ("private void WriteSampledValuesCustomProperties()");  	using (writer.OpenScope ()) {  		var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  		if (propertiesProperty != null) {  			var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  			if (additionalProperties != null) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = "sampled_custom";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array)) {  							string propName = string.Format ("custom_{0}"' valueProperty.Name);  							writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  							using (writer.OpenScope ()) {  								WriteValues (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	writer.WriteLine ("private readonly JulianDate m_documentStartDate = new GregorianDate(2016' 6' 17' 12' 0' 0).ToJulianDate();");  	writer.WriteLine ("private readonly JulianDate m_documentStopDate = new GregorianDate(2016' 6' 17' 13' 0' 0).ToJulianDate();");  	writer.WriteLine ("private TextWriter m_streamWriter;");  	writer.WriteLine ("private TextWriter m_assertionsWriter;");  	writer.WriteLine ("private TextWriter m_extensionsAssertionsWriter;");  	writer.WriteLine ("private CesiumOutputStream m_output;");  	writer.WriteLine ("private CesiumStreamWriter m_writer;");  	writer.WriteLine ("private void WriteAssertionBoth(string s)");  	using (writer.OpenScope ()) {  		writer.WriteLine ("m_assertionsWriter.WriteLine(s);");  		writer.WriteLine ("m_extensionsAssertionsWriter.WriteLine(s);");  	}  	writer.WriteLine ("private static IList<T> CreateList<T>(T t1' T t2)");  	using (writer.OpenScope ()) {  		writer.WriteLine ("return new List<T> { t1' t2 };");  	}  	writer.WriteLine ("private static IList<T> CreateList<T>(params T[] ts)");  	using (writer.OpenScope ()) {  		writer.WriteLine ("return ts;");  	}  	writer.WriteLine ("[Test]");  	writer.WriteLine ("public void GenerateValidationDocument()");  	var schemaProperties = schema.Properties.Where (p => p.Name != "clock" && p.Name != "availability" && !p.ValueType.IsSchemaFromType).Where (p => p.Name != "properties").ToList ();  	using (writer.OpenScope ()) {  		writer.WriteLine ("using (m_streamWriter = new StreamWriter(\"ValidationDocument.czml\"))");  		writer.WriteLine ("using (m_assertionsWriter = new StreamWriter(\"ValidationDocumentAssertions.js\"))");  		writer.WriteLine ("using (m_extensionsAssertionsWriter = new StreamWriter(\"ValidationDocumentExtensionAssertions.js\"))");  		using (writer.OpenScope ()) {  			WriteAssertionBoth (writer' "return CzmlDataSource.load('Data/CZML/ValidationDocument.czml').then(function(dataSource) {");  			s_assertionIndent++;  			WriteAssertionBoth (writer' "/*jshint -W120 */");  			WriteAssertionBoth (writer' "var e;");  			WriteAssertionBoth (writer' "var date;");  			WriteAssertionBoth (writer' "var documentStartDate = JulianDate.fromIso8601('2016-06-17T12:00:00Z');");  			WriteAssertionBoth (writer' "var documentStopDate = JulianDate.fromIso8601('2016-06-17T13:00:00Z');");  			writer.WriteLine ("m_output = new CesiumOutputStream(m_streamWriter) { PrettyFormatting = true };");  			writer.WriteLine ("m_writer = new CesiumStreamWriter();");  			writer.WriteLine ("m_output.WriteStartSequence();");  			// Java has a limit on the size of a single method (65535 bytes) so we have to break up all this code in multiple methods  			writer.WriteLine ("WriteClock();");  			writer.WriteLine ("WriteConstantValues();");  			writer.WriteLine ("WriteReferenceValues();");  			writer.WriteLine ("WriteSampledValues();");  			writer.WriteLine ("m_output.WriteEndSequence();");  			s_assertionIndent--;  			WriteAssertionBoth (writer' "});");  			s_assertionIndent++;  		}  	}  	writer.WriteLine ("private void WriteClock()");  	using (writer.OpenScope ()) {  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			writer.WriteLine ("packet.WriteId(\"document\");");  			writer.WriteLine ("packet.WriteName(\"ValidationDocument\");");  			writer.WriteLine ("packet.WriteVersion(\"1.0\");");  			writer.WriteLine ("using (var clock = packet.OpenClockProperty())");  			using (writer.OpenScope ()) {  				writer.WriteLine ("clock.WriteInterval(m_documentStartDate' m_documentStopDate);");  				WriteAssertion (writer' false' "expect(dataSource.clock.startTime).toEqual(documentStartDate);");  				WriteAssertion (writer' false' "expect(dataSource.clock.stopTime).toEqual(documentStopDate);");  				writer.WriteLine ("clock.WriteCurrentTime(m_documentStartDate);");  				WriteAssertion (writer' false' "expect(dataSource.clock.currentTime).toEqual(documentStartDate);");  				writer.WriteLine ("clock.WriteMultiplier(1.0);");  				WriteAssertion (writer' false' "expect(dataSource.clock.multiplier).toEqual(1.0);");  				writer.WriteLine ("clock.WriteRange(ClockRange.Unbounded);");  				WriteAssertion (writer' false' "expect(dataSource.clock.clockRange).toEqual(ClockRange.UNBOUNDED);");  				writer.WriteLine ("clock.WriteStep(ClockStep.SystemClockMultiplier);");  				WriteAssertion (writer' false' "expect(dataSource.clock.clockStep).toEqual(ClockStep.SYSTEM_CLOCK_MULTIPLIER);");  			}  		}  	}  	writer.WriteLine ("private void WriteConstantValues()");  	using (writer.OpenScope ()) {  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			const string id = "Constant";  			writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  			WriteAssertionBoth (writer' "var constant = e = dataSource.entities.getById('Constant');");  			WriteAssertionBoth (writer' "expect(e).toBeDefined();");  			WriteAssertionBoth (writer' "date = JulianDate.now();");  			// Write one packet with first value types for each property  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					var properties = property.ValueType.Properties;  					var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  					if (firstValueProperty != null) {  						WriteValue (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  					} else {  						foreach (var subProperty in properties.Where (p => !p.IsValue)) {  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								properties = subProperty.ValueType.Properties;  								firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  								string subPropertyName = GetSubPropertyName (propertyName' subProperty);  								if (firstValueProperty != null) {  									WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  								} else if (subProperty.ValueType.Name.Contains ("Material")) {  									Property materialProperty = properties.First ();  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialProperty.ValueType.Properties;  										foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												properties = materialSubProperty.ValueType.Properties;  												firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  												if (firstValueProperty != null) {  													WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								} else {  									var additionalProperties = subProperty.ValueType.AdditionalProperties;  									if (additionalProperties != null) {  										writer.WriteLine ("using (var a = w2.Open{0}Property(\"prop\"))"' additionalProperties.ValueType.NameWithPascalCase);  										using (writer.OpenScope ()) {  											foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  												writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = additionalProperty.ValueType.Properties;  													firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  													if (firstValueProperty != null) {  														WriteValue (writer' "w3"' id + property.Name' firstValueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' "prop"' additionalProperty.Name));  													}  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		writer.WriteLine ("WriteConstantValuesIndividual();");  		writer.WriteLine ("WriteConstantValuesCustomProperties();");  	}  	writer.WriteLine ("private void WriteConstantValuesIndividual()");  	using (writer.OpenScope ()) {  		// write other value types as individual packets  		foreach (var property in schemaProperties) {  			writer.WriteLine ("WriteConstantValuesIndividual{0}();"' property.NameWithPascalCase);  		}  	}  	foreach (var property in schemaProperties) {  		writer.WriteLine ("private void WriteConstantValuesIndividual{0}()"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("constant_{0}_{1}"' property.Name' valueProperty.Name);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						WriteValue (writer' "w"' id' valueProperty' property' isExtension' propertyName);  					}  				}  			}  			foreach (var subProperty in properties.Where (p => !p.IsValue)) {  				string subPropertyName = GetSubPropertyName (propertyName' subProperty);  				properties = subProperty.ValueType.Properties;  				foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("constant_{0}_{1}_{2}"' property.Name' subPropertyName' valueProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							WriteValue (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  						}  					}  				}  				if (subProperty.ValueType.Name.Contains ("Material")) {  					// write other values for the first material  					// then write first values for other materials   					// then write remaining values for other materials individually  					var firstMaterialProperty = properties.First ();  					properties = firstMaterialProperty.ValueType.Properties;  					foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  						properties = materialSubProperty.ValueType.Properties;  						foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValue (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  								}  							}  						}  					}  					properties = subProperty.ValueType.Properties;  					foreach (var materialProperty in properties.Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string id = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										properties = materialSubProperty.ValueType.Properties;  										var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  										if (firstValueProperty != null) {  											WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  					}  					properties = subProperty.ValueType.Properties;  					foreach (var materialProperty in properties.Skip (1)) {  						properties = materialProperty.ValueType.Properties;  						foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  							properties = materialSubProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValue (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  									}  								}  							}  						}  					}  				}  				var additionalProperties = subProperty.ValueType.AdditionalProperties;  				if (additionalProperties != null) {  					foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  						int i = 0;  						properties = additionalProperty.ValueType.Properties;  						foreach (var valueProperty in properties.Where (p => p.IsValue && !p.ValueType.Name.StartsWith ("Reference")).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("constant_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' additionalProperties.ValueType.Name' additionalProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								string propName = string.Format ("{0}{1}"' "prop"' i++);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var a = w2.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  								writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValue (writer' "w3"' id + property.Name + subProperty.Name' valueProperty' additionalProperty' isExtension' string.Format ("{0}.{1}.{2}.{3}"' propertyName' subPropertyName' propName' additionalProperty.Name));  								}  							}  						}  					}  				}  			}  		}  	}  	// create all types of custom properties  	writer.WriteLine ("private void WriteConstantValuesCustomProperties()");  	using (writer.OpenScope ()) {  		var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  		if (propertiesProperty != null) {  			var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  			if (additionalProperties != null) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = "constant_custom";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue)) {  							string propName = string.Format ("custom_{0}"' valueProperty.Name);  							writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  							using (writer.OpenScope ()) {  								WriteValue (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  							}  						}  					}  				}  			}  		}  	}  	// create entities using references  	writer.WriteLine ("private void WriteReferenceValues()");  	using (writer.OpenScope ()) {  		// write some positions and double values to use to create reference lists for position lists and double lists later  		for (int i = 1; i <= 2; ++i) {  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				string id = string.Format ("ConstantPosition{0}"' i);  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantPosition{0}')).toBeDefined();"' i);  				var property = schemaProperties.First (p => p.Name == "position");  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					var properties = property.ValueType.Properties;  					var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  					WriteValue (writer' "w"' id' firstValueProperty' property' false' property.Name);  				}  			}  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				string id = string.Format ("ConstantDouble{0}"' i);  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantDouble{0}')).toBeDefined();"' i);  				var property = schemaProperties.First (p => p.Name == "billboard");  				var properties = property.ValueType.Properties;  				var subProperty = properties.First (p => p.Name == "scale");  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  				using (writer.OpenScope ()) {  					properties = subProperty.ValueType.Properties;  					var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  					WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' false' string.Format ("{0}.{1}"' property.Name' subProperty.Name));  				}  			}  		}  		// write one big packet with references for everything  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			writer.WriteLine ("packet.WriteId(\"Reference\");");  			WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Reference')).toBeDefined();");  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				using (writer.OpenScope ()) {  					var properties = property.ValueType.Properties;  					if (properties.Any (p => p.ValueType.Name == "Reference")) {  						writer.WriteLine ("w.WriteReference(new Reference(\"Constant\"' \"{0}\"));"' propertyName);  						WriteAssertion (writer' isExtension' "expect(e.{0}.getValue(date)).toEqual(constant.{0}.getValue(date));"' propertyName);  					} else {  						foreach (var subProperty in properties.Where (p => !p.IsValue)) {  							properties = subProperty.ValueType.Properties;  							string subPropertyName = GetSubPropertyName (propertyName' subProperty);  							if (properties.Any (p => p.ValueType.Name == "Reference")) {  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									writer.WriteLine ("w2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\")));"' propertyName' subPropertyName);  									WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual(constant.{0}.{1}.getValue(date));"' propertyName' subPropertyName);  								}  							} else if (properties.Any (p => p.ValueType.Name == "ReferenceList")) {  								string targetId = "";  								string[] referencePropertyNames =  {    								};  								if (subProperty.ValueType.Name == "PositionList") {  									targetId = "Position";  									referencePropertyNames = new[] {  										"position"  									};  								} else if (subProperty.ValueType.Name == "DoubleList") {  									targetId = "Double";  									referencePropertyNames = new[] {  										"billboard"'  										"scale"  									};  								}  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									writer.WriteLine ("w2.WriteReferences(CreateList(new Reference(\"Constant{0}1\"' CreateList({1}))' new Reference(\"Constant{0}2\"' CreateList({1}))));"' targetId' string.Join ("' "' referencePropertyNames.Select (n => string.Format ("\"{0}\""' n))));  									WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual([dataSource.entities.getById('Constant{2}1').{3}.getValue(date)' dataSource.entities.getById('Constant{2}2').{3}.getValue(date)]);"' propertyName' subPropertyName' targetId' string.Join ("."' referencePropertyNames));  								}  							} else if (subProperty.ValueType.Name.Contains ("Material")) {  								Property materialProperty = properties.First ();  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("m2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"{2}\")));"' propertyName' subPropertyName' materialSubProperty.Name);  											WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.{2}.getValue(date)).toEqual(constant.{0}.{1}.{2}.getValue(date));"' propertyName' subPropertyName' materialSubProperty.Name);  										}  									}  								}  							} else {  								var additionalProperties = subProperty.ValueType.AdditionalProperties;  								if (additionalProperties != null) {  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var a = w2.Open{0}Property(\"referenceProp\"))"' additionalProperties.ValueType.NameWithPascalCase);  									using (writer.OpenScope ()) {  										foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  											writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  											using (writer.OpenScope ()) {  												writer.WriteLine ("w3.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"prop\"' \"{2}\")));"' propertyName' subPropertyName' additionalProperty.Name);  												WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.referenceProp.{2}.getValue(date)).toEqual(constant.{0}.{1}.prop.{2}.getValue(date));"' propertyName' subPropertyName' additionalProperty.Name);  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		writer.WriteLine ("WriteReferenceValuesIndividual();");  	}  	writer.WriteLine ("private void WriteReferenceValuesIndividual()");  	using (writer.OpenScope ()) {  		// write other materials as individual packets  		foreach (var property in schemaProperties) {  			writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  		}  		// special case - velocity reference  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  			WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  			var property = schemaProperties.First (p => p.Name == "position");  			writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				// construct a position with specific velocity  				double dx = 1.0;  				double dy = 2.0;  				double dz = 3.0;  				double deltaTime = 60.0;  				double x1 = 1.0;  				double x2 = x1 + dx * deltaTime;  				double y1 = 2.0;  				double y2 = y1 + dy * deltaTime;  				double z1 = 3.0;  				double z2 = z1 + dz * deltaTime;  				string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  				string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  				string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  				string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  				writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  				WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  				WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  			}  		}  		foreach (var property in schemaProperties) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			foreach (var subProperty in properties.Where (p => !p.IsValue)) {  				properties = subProperty.ValueType.Properties;  				if (properties.Any (p => p.Name == "velocityReference")) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  						using (writer.OpenScope ()) {  							writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  							double expectedX = 1.0;  							double expectedY = 2.0;  							double expectedZ = 3.0;  							bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  							if (isNormalized) {  								NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  							}  							WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  						}  					}  				}  			}  		}  	}  	// write other materials as individual packets  	foreach (var property in schemaProperties) {  		writer.WriteLine ("private void WriteReferenceValuesIndividual{0}()"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			foreach (var subProperty in properties.Where (p => !p.IsValue)) {  				string subPropertyName = GetSubPropertyName (propertyName' subProperty);  				if (subProperty.ValueType.Name.Contains ("Material")) {  					properties = subProperty.ValueType.Properties;  					foreach (var materialProperty in properties.Skip (1)) {  						writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  						using (writer.OpenScope ()) {  							string targetId = string.Format ("material_{0}_{1}_{2}"' propertyName' subProperty.Name' materialProperty.Name);  							string id = string.Format ("reference_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  							writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  							WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  							writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										writer.WriteLine ("m2.WriteReference(new Reference(\"{0}\"' CreateList(\"{1}\"' \"{2}\"' \"{3}\")));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  										WriteAssertion (writer' isExtension' "expect(e.{1}.{2}.{3}.getValue(date)).toEqual(dataSource.entities.getById('{0}').{1}.{2}.{3}.getValue(date));"' targetId' propertyName' subPropertyName' materialSubProperty.Name);  									}  								}  							}  						}  					}  				}  			}  		}  	}  	// test sampled properties  	writer.WriteLine ("private void WriteSampledValues()");  	using (writer.OpenScope ()) {  		// Write one packet with first value types for each property  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			const string id = "Sampled";  			writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  			WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Sampled')).toBeDefined();");  			foreach (var property in schemaProperties) {  				string propertyName = property.Name;  				bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  				if (isExtension)  					propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  				var properties = property.ValueType.Properties;  				if (property.IsInterpolatable) {  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					using (writer.OpenScope ()) {  						var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  						WriteValues (writer' "w"' id' firstValueProperty' property' isExtension' propertyName);  					}  				} else {  					var subProperties = properties.Where (p => !p.IsValue && (p.IsInterpolatable || p.ValueType.Name.Contains ("Material"))).ToList ();  					if (subProperties.Any ()) {  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							foreach (var subProperty in subProperties) {  								properties = subProperty.ValueType.Properties;  								string subPropertyName = GetSubPropertyName (propertyName' subProperty);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									if (subProperty.IsInterpolatable) {  										var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  										WriteValues (writer' "w2"' id + property.Name' firstValueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  									} else if (subProperty.ValueType.Name.Contains ("Material")) {  										Property materialProperty = properties.First ();  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialProperty.ValueType.Properties;  											foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  												writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  												using (writer.OpenScope ()) {  													properties = materialSubProperty.ValueType.Properties;  													var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  													WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  												}  											}  										}  									}  								}  							}  						}  					}  				}  			}  		}  		writer.WriteLine ("WriteSampledValuesIndividual();");  		writer.WriteLine ("WriteSampledValuesCustomProperties();");  	}  	writer.WriteLine ("private void WriteSampledValuesIndividual()");  	using (writer.OpenScope ()) {  		// write other value types as individual packets  		// split method into multiple methods  		foreach (var property in schemaProperties) {  			writer.WriteLine ("WriteSampledValuesIndividual{0}();"' property.NameWithPascalCase);  		}  	}  	foreach (var property in schemaProperties) {  		writer.WriteLine ("private void WriteSampledValuesIndividual{0}()"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			var properties = property.ValueType.Properties;  			if (property.IsInterpolatable) {  				foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  					writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  					using (writer.OpenScope ()) {  						string id = string.Format ("sampled_{0}_{1}"' propertyName' valueProperty.Name);  						writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  						WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  						writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  						using (writer.OpenScope ()) {  							WriteValues (writer' "w"' id' valueProperty' property' isExtension' propertyName);  						}  					}  				}  			} else {  				foreach (var subProperty in properties.Where (p => !p.IsValue)) {  					string subPropertyName = GetSubPropertyName (propertyName' subProperty);  					properties = subProperty.ValueType.Properties;  					if (subProperty.IsInterpolatable) {  						foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' valueProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									WriteValues (writer' "w2"' id + property.Name' valueProperty' subProperty' isExtension' string.Format ("{0}.{1}"' propertyName' subPropertyName));  								}  							}  						}  					} else if (subProperty.ValueType.Name.Contains ("Material")) {  						// write other values for the first material  						// then write first values for other materials   						// then write remaining values for other materials individually  						var firstMaterialProperty = properties.First ();  						properties = firstMaterialProperty.ValueType.Properties;  						foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  							properties = materialSubProperty.ValueType.Properties;  							foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  								writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  								using (writer.OpenScope ()) {  									string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' firstMaterialProperty.Name' materialSubProperty.Name);  									writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  									WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  									writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  									writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m = w2.Open{0}Property())"' firstMaterialProperty.NameWithPascalCase);  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										WriteValues (writer' "m2"' id + property.Name + subProperty.Name + firstMaterialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  							using (writer.OpenScope ()) {  								string id = string.Format ("sampled_{0}_{1}_{2}"' propertyName' subPropertyName' materialProperty.Name);  								writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  								WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  								writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  								using (writer.OpenScope ()) {  									properties = materialProperty.ValueType.Properties;  									foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											properties = materialSubProperty.ValueType.Properties;  											var firstValueProperty = properties.First (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array);  											WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' firstValueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  						properties = subProperty.ValueType.Properties;  						foreach (var materialProperty in properties.Skip (1)) {  							properties = materialProperty.ValueType.Properties;  							foreach (var materialSubProperty in properties.Where (p => p.IsInterpolatable)) {  								properties = materialSubProperty.ValueType.Properties;  								foreach (var valueProperty in properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array).Skip (1)) {  									writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  									using (writer.OpenScope ()) {  										string id = string.Format ("sampled_{0}_{1}_{2}_{3}"' propertyName' subPropertyName' materialProperty.Name' materialSubProperty.Name);  										writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  										WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  										writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  										writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  										writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											WriteValues (writer' "m2"' id + property.Name + subProperty.Name + materialProperty.Name' valueProperty' materialSubProperty' isExtension' string.Format ("{0}.{1}.{2}"' propertyName' subPropertyName' materialSubProperty.Name));  										}  									}  								}  							}  						}  					}  				}  			}  		}  	}  	// create all types of custom properties  	writer.WriteLine ("private void WriteSampledValuesCustomProperties()");  	using (writer.OpenScope ()) {  		var propertiesProperty = schema.Properties.FirstOrDefault (p => p.Name == "properties");  		if (propertiesProperty != null) {  			var additionalProperties = propertiesProperty.ValueType.AdditionalProperties;  			if (additionalProperties != null) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = "sampled_custom";  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' propertiesProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						foreach (var valueProperty in additionalProperties.ValueType.Properties.Where (p => p.IsValue && (p.ValueType.JsonTypes & JsonSchemaType.Array) == JsonSchemaType.Array)) {  							string propName = string.Format ("custom_{0}"' valueProperty.Name);  							writer.WriteLine ("using (var w2 = w.Open{0}Property(\"{1}\"))"' additionalProperties.ValueType.NameWithPascalCase' propName);  							using (writer.OpenScope ()) {  								WriteValues (writer' "w2"' id + valueProperty.Name' valueProperty' additionalProperties' false' string.Format ("{0}.{1}"' propertiesProperty.Name' propName));  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	// write some positions and double values to use to create reference lists for position lists and double lists later  	for (int i = 1; i <= 2; ++i) {  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			string id = string.Format ("ConstantPosition{0}"' i);  			writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  			WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantPosition{0}')).toBeDefined();"' i);  			var property = schemaProperties.First (p => p.Name == "position");  			writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				var properties = property.ValueType.Properties;  				var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  				WriteValue (writer' "w"' id' firstValueProperty' property' false' property.Name);  			}  		}  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			string id = string.Format ("ConstantDouble{0}"' i);  			writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  			WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantDouble{0}')).toBeDefined();"' i);  			var property = schemaProperties.First (p => p.Name == "billboard");  			var properties = property.ValueType.Properties;  			var subProperty = properties.First (p => p.Name == "scale");  			writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  			writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  			using (writer.OpenScope ()) {  				properties = subProperty.ValueType.Properties;  				var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  				WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' false' string.Format ("{0}.{1}"' property.Name' subProperty.Name));  			}  		}  	}  	// write one big packet with references for everything  	writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  	using (writer.OpenScope ()) {  		writer.WriteLine ("packet.WriteId(\"Reference\");");  		WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('Reference')).toBeDefined();");  		foreach (var property in schemaProperties) {  			string propertyName = property.Name;  			bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  			if (isExtension)  				propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  			writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  			using (writer.OpenScope ()) {  				var properties = property.ValueType.Properties;  				if (properties.Any (p => p.ValueType.Name == "Reference")) {  					writer.WriteLine ("w.WriteReference(new Reference(\"Constant\"' \"{0}\"));"' propertyName);  					WriteAssertion (writer' isExtension' "expect(e.{0}.getValue(date)).toEqual(constant.{0}.getValue(date));"' propertyName);  				} else {  					foreach (var subProperty in properties.Where (p => !p.IsValue)) {  						properties = subProperty.ValueType.Properties;  						string subPropertyName = GetSubPropertyName (propertyName' subProperty);  						if (properties.Any (p => p.ValueType.Name == "Reference")) {  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								writer.WriteLine ("w2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\")));"' propertyName' subPropertyName);  								WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual(constant.{0}.{1}.getValue(date));"' propertyName' subPropertyName);  							}  						} else if (properties.Any (p => p.ValueType.Name == "ReferenceList")) {  							string targetId = "";  							string[] referencePropertyNames =  {    							};  							if (subProperty.ValueType.Name == "PositionList") {  								targetId = "Position";  								referencePropertyNames = new[] {  									"position"  								};  							} else if (subProperty.ValueType.Name == "DoubleList") {  								targetId = "Double";  								referencePropertyNames = new[] {  									"billboard"'  									"scale"  								};  							}  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								writer.WriteLine ("w2.WriteReferences(CreateList(new Reference(\"Constant{0}1\"' CreateList({1}))' new Reference(\"Constant{0}2\"' CreateList({1}))));"' targetId' string.Join ("' "' referencePropertyNames.Select (n => string.Format ("\"{0}\""' n))));  								WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(date)).toEqual([dataSource.entities.getById('Constant{2}1').{3}.getValue(date)' dataSource.entities.getById('Constant{2}2').{3}.getValue(date)]);"' propertyName' subPropertyName' targetId' string.Join ("."' referencePropertyNames));  							}  						} else if (subProperty.ValueType.Name.Contains ("Material")) {  							Property materialProperty = properties.First ();  							writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  							writer.WriteLine ("using (var m = w2.Open{0}Property())"' materialProperty.NameWithPascalCase);  							using (writer.OpenScope ()) {  								properties = materialProperty.ValueType.Properties;  								foreach (var materialSubProperty in properties.Where (p => !p.IsValue)) {  									writer.WriteLine ("using (var m2 = m.Open{0}Property())"' materialSubProperty.NameWithPascalCase);  									using (writer.OpenScope ()) {  										writer.WriteLine ("m2.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"{2}\")));"' propertyName' subPropertyName' materialSubProperty.Name);  										WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.{2}.getValue(date)).toEqual(constant.{0}.{1}.{2}.getValue(date));"' propertyName' subPropertyName' materialSubProperty.Name);  									}  								}  							}  						} else {  							var additionalProperties = subProperty.ValueType.AdditionalProperties;  							if (additionalProperties != null) {  								writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  								writer.WriteLine ("using (var a = w2.Open{0}Property(\"referenceProp\"))"' additionalProperties.ValueType.NameWithPascalCase);  								using (writer.OpenScope ()) {  									foreach (var additionalProperty in additionalProperties.ValueType.Properties.Where (p => !p.IsValue)) {  										writer.WriteLine ("using (var w3 = a.Open{0}Property())"' additionalProperty.NameWithPascalCase);  										using (writer.OpenScope ()) {  											writer.WriteLine ("w3.WriteReference(new Reference(\"Constant\"' CreateList(\"{0}\"' \"{1}\"' \"prop\"' \"{2}\")));"' propertyName' subPropertyName' additionalProperty.Name);  											WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.referenceProp.{2}.getValue(date)).toEqual(constant.{0}.{1}.prop.{2}.getValue(date));"' propertyName' subPropertyName' additionalProperty.Name);  										}  									}  								}  							}  						}  					}  				}  			}  		}  	}  	writer.WriteLine ("WriteReferenceValuesIndividual();");  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: for (int i = 1; i <= 2; ++i) {  	writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  	using (writer.OpenScope ()) {  		string id = string.Format ("ConstantPosition{0}"' i);  		writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  		WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantPosition{0}')).toBeDefined();"' i);  		var property = schemaProperties.First (p => p.Name == "position");  		writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			var properties = property.ValueType.Properties;  			var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  			WriteValue (writer' "w"' id' firstValueProperty' property' false' property.Name);  		}  	}  	writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  	using (writer.OpenScope ()) {  		string id = string.Format ("ConstantDouble{0}"' i);  		writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  		WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('ConstantDouble{0}')).toBeDefined();"' i);  		var property = schemaProperties.First (p => p.Name == "billboard");  		var properties = property.ValueType.Properties;  		var subProperty = properties.First (p => p.Name == "scale");  		writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  		writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  		using (writer.OpenScope ()) {  			properties = subProperty.ValueType.Properties;  			var firstValueProperty = properties.FirstOrDefault (p => p.IsValue);  			WriteValue (writer' "w2"' id + property.Name' firstValueProperty' subProperty' false' string.Format ("{0}.{1}"' property.Name' subProperty.Name));  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	// write other materials as individual packets  	foreach (var property in schemaProperties) {  		writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  	}  	// special case - velocity reference  	writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  	using (writer.OpenScope ()) {  		writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  		WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  		var property = schemaProperties.First (p => p.Name == "position");  		writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			// construct a position with specific velocity  			double dx = 1.0;  			double dy = 2.0;  			double dz = 3.0;  			double deltaTime = 60.0;  			double x1 = 1.0;  			double x2 = x1 + dx * deltaTime;  			double y1 = 2.0;  			double y2 = y1 + dy * deltaTime;  			double z1 = 3.0;  			double z2 = z1 + dz * deltaTime;  			string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  			string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  			string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  			string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  			writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  			WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  			WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  		}  	}  	foreach (var property in schemaProperties) {  		string propertyName = property.Name;  		bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  		if (isExtension)  			propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  		var properties = property.ValueType.Properties;  		foreach (var subProperty in properties.Where (p => !p.IsValue)) {  			properties = subProperty.ValueType.Properties;  			if (properties.Any (p => p.Name == "velocityReference")) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  						double expectedX = 1.0;  						double expectedY = 2.0;  						double expectedZ = 3.0;  						bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  						if (isNormalized) {  							NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  						}  						WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	// write other materials as individual packets  	foreach (var property in schemaProperties) {  		writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  	}  	// special case - velocity reference  	writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  	using (writer.OpenScope ()) {  		writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  		WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  		var property = schemaProperties.First (p => p.Name == "position");  		writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			// construct a position with specific velocity  			double dx = 1.0;  			double dy = 2.0;  			double dz = 3.0;  			double deltaTime = 60.0;  			double x1 = 1.0;  			double x2 = x1 + dx * deltaTime;  			double y1 = 2.0;  			double y2 = y1 + dy * deltaTime;  			double z1 = 3.0;  			double z2 = z1 + dz * deltaTime;  			string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  			string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  			string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  			string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  			writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  			WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  			WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  		}  	}  	foreach (var property in schemaProperties) {  		string propertyName = property.Name;  		bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  		if (isExtension)  			propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  		var properties = property.ValueType.Properties;  		foreach (var subProperty in properties.Where (p => !p.IsValue)) {  			properties = subProperty.ValueType.Properties;  			if (properties.Any (p => p.Name == "velocityReference")) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  						double expectedX = 1.0;  						double expectedY = 2.0;  						double expectedZ = 3.0;  						bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  						if (isNormalized) {  							NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  						}  						WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	// write other materials as individual packets  	foreach (var property in schemaProperties) {  		writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  	}  	// special case - velocity reference  	writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  	using (writer.OpenScope ()) {  		writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  		WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  		var property = schemaProperties.First (p => p.Name == "position");  		writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			// construct a position with specific velocity  			double dx = 1.0;  			double dy = 2.0;  			double dz = 3.0;  			double deltaTime = 60.0;  			double x1 = 1.0;  			double x2 = x1 + dx * deltaTime;  			double y1 = 2.0;  			double y2 = y1 + dy * deltaTime;  			double z1 = 3.0;  			double z2 = z1 + dz * deltaTime;  			string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  			string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  			string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  			string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  			writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  			WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  			WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  		}  	}  	foreach (var property in schemaProperties) {  		string propertyName = property.Name;  		bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  		if (isExtension)  			propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  		var properties = property.ValueType.Properties;  		foreach (var subProperty in properties.Where (p => !p.IsValue)) {  			properties = subProperty.ValueType.Properties;  			if (properties.Any (p => p.Name == "velocityReference")) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  						double expectedX = 1.0;  						double expectedY = 2.0;  						double expectedZ = 3.0;  						bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  						if (isNormalized) {  							NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  						}  						WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	// write other materials as individual packets  	foreach (var property in schemaProperties) {  		writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  	}  	// special case - velocity reference  	writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  	using (writer.OpenScope ()) {  		writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  		WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  		var property = schemaProperties.First (p => p.Name == "position");  		writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			// construct a position with specific velocity  			double dx = 1.0;  			double dy = 2.0;  			double dz = 3.0;  			double deltaTime = 60.0;  			double x1 = 1.0;  			double x2 = x1 + dx * deltaTime;  			double y1 = 2.0;  			double y2 = y1 + dy * deltaTime;  			double z1 = 3.0;  			double z2 = z1 + dz * deltaTime;  			string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  			string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  			string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  			string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  			writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  			WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  			WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  		}  	}  	foreach (var property in schemaProperties) {  		string propertyName = property.Name;  		bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  		if (isExtension)  			propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  		var properties = property.ValueType.Properties;  		foreach (var subProperty in properties.Where (p => !p.IsValue)) {  			properties = subProperty.ValueType.Properties;  			if (properties.Any (p => p.Name == "velocityReference")) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  						double expectedX = 1.0;  						double expectedY = 2.0;  						double expectedZ = 3.0;  						bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  						if (isNormalized) {  							NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  						}  						WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	// write other materials as individual packets  	foreach (var property in schemaProperties) {  		writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  	}  	// special case - velocity reference  	writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  	using (writer.OpenScope ()) {  		writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  		WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  		var property = schemaProperties.First (p => p.Name == "position");  		writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			// construct a position with specific velocity  			double dx = 1.0;  			double dy = 2.0;  			double dz = 3.0;  			double deltaTime = 60.0;  			double x1 = 1.0;  			double x2 = x1 + dx * deltaTime;  			double y1 = 2.0;  			double y2 = y1 + dy * deltaTime;  			double z1 = 3.0;  			double z2 = z1 + dz * deltaTime;  			string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  			string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  			string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  			string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  			writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  			WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  			WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  		}  	}  	foreach (var property in schemaProperties) {  		string propertyName = property.Name;  		bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  		if (isExtension)  			propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  		var properties = property.ValueType.Properties;  		foreach (var subProperty in properties.Where (p => !p.IsValue)) {  			properties = subProperty.ValueType.Properties;  			if (properties.Any (p => p.Name == "velocityReference")) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  						double expectedX = 1.0;  						double expectedY = 2.0;  						double expectedZ = 3.0;  						bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  						if (isNormalized) {  							NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  						}  						WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	// write other materials as individual packets  	foreach (var property in schemaProperties) {  		writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  	}  	// special case - velocity reference  	writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  	using (writer.OpenScope ()) {  		writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  		WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  		var property = schemaProperties.First (p => p.Name == "position");  		writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			// construct a position with specific velocity  			double dx = 1.0;  			double dy = 2.0;  			double dz = 3.0;  			double deltaTime = 60.0;  			double x1 = 1.0;  			double x2 = x1 + dx * deltaTime;  			double y1 = 2.0;  			double y2 = y1 + dy * deltaTime;  			double z1 = 3.0;  			double z2 = z1 + dz * deltaTime;  			string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  			string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  			string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  			string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  			writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  			WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  			WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  		}  	}  	foreach (var property in schemaProperties) {  		string propertyName = property.Name;  		bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  		if (isExtension)  			propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  		var properties = property.ValueType.Properties;  		foreach (var subProperty in properties.Where (p => !p.IsValue)) {  			properties = subProperty.ValueType.Properties;  			if (properties.Any (p => p.Name == "velocityReference")) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  						double expectedX = 1.0;  						double expectedY = 2.0;  						double expectedZ = 3.0;  						bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  						if (isNormalized) {  							NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  						}  						WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	// write other materials as individual packets  	foreach (var property in schemaProperties) {  		writer.WriteLine ("WriteReferenceValuesIndividual{0}();"' property.NameWithPascalCase);  	}  	// special case - velocity reference  	writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  	using (writer.OpenScope ()) {  		writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  		WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  		var property = schemaProperties.First (p => p.Name == "position");  		writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  		using (writer.OpenScope ()) {  			// construct a position with specific velocity  			double dx = 1.0;  			double dy = 2.0;  			double dz = 3.0;  			double deltaTime = 60.0;  			double x1 = 1.0;  			double x2 = x1 + dx * deltaTime;  			double y1 = 2.0;  			double y2 = y1 + dy * deltaTime;  			double z1 = 3.0;  			double z2 = z1 + dz * deltaTime;  			string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  			string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  			string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  			string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  			writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  			WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  			WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  		}  	}  	foreach (var property in schemaProperties) {  		string propertyName = property.Name;  		bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  		if (isExtension)  			propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  		var properties = property.ValueType.Properties;  		foreach (var subProperty in properties.Where (p => !p.IsValue)) {  			properties = subProperty.ValueType.Properties;  			if (properties.Any (p => p.Name == "velocityReference")) {  				writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  				using (writer.OpenScope ()) {  					string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  					writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  					WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  					writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  					writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  					using (writer.OpenScope ()) {  						writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  						double expectedX = 1.0;  						double expectedY = 2.0;  						double expectedZ = 3.0;  						bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  						if (isNormalized) {  							NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  						}  						WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  					}  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  	WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  	var property = schemaProperties.First (p => p.Name == "position");  	writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  	using (writer.OpenScope ()) {  		// construct a position with specific velocity  		double dx = 1.0;  		double dy = 2.0;  		double dz = 3.0;  		double deltaTime = 60.0;  		double x1 = 1.0;  		double x2 = x1 + dx * deltaTime;  		double y1 = 2.0;  		double y2 = y1 + dy * deltaTime;  		double z1 = 3.0;  		double z2 = z1 + dz * deltaTime;  		string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  		string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  		string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  		string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  		writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  		WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  		WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  	WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  	var property = schemaProperties.First (p => p.Name == "position");  	writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  	using (writer.OpenScope ()) {  		// construct a position with specific velocity  		double dx = 1.0;  		double dy = 2.0;  		double dz = 3.0;  		double deltaTime = 60.0;  		double x1 = 1.0;  		double x2 = x1 + dx * deltaTime;  		double y1 = 2.0;  		double y2 = y1 + dy * deltaTime;  		double z1 = 3.0;  		double z2 = z1 + dz * deltaTime;  		string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  		string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  		string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  		string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  		writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  		WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  		WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  	WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  	var property = schemaProperties.First (p => p.Name == "position");  	writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  	using (writer.OpenScope ()) {  		// construct a position with specific velocity  		double dx = 1.0;  		double dy = 2.0;  		double dz = 3.0;  		double deltaTime = 60.0;  		double x1 = 1.0;  		double x2 = x1 + dx * deltaTime;  		double y1 = 2.0;  		double y2 = y1 + dy * deltaTime;  		double z1 = 3.0;  		double z2 = z1 + dz * deltaTime;  		string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  		string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  		string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  		string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  		writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  		WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  		WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  	WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  	var property = schemaProperties.First (p => p.Name == "position");  	writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  	using (writer.OpenScope ()) {  		// construct a position with specific velocity  		double dx = 1.0;  		double dy = 2.0;  		double dz = 3.0;  		double deltaTime = 60.0;  		double x1 = 1.0;  		double x2 = x1 + dx * deltaTime;  		double y1 = 2.0;  		double y2 = y1 + dy * deltaTime;  		double z1 = 3.0;  		double z2 = z1 + dz * deltaTime;  		string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  		string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  		string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  		string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  		writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  		WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  		WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	writer.WriteLine ("packet.WriteId(\"VelocityPosition\");");  	WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('VelocityPosition')).toBeDefined();");  	var property = schemaProperties.First (p => p.Name == "position");  	writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  	using (writer.OpenScope ()) {  		// construct a position with specific velocity  		double dx = 1.0;  		double dy = 2.0;  		double dz = 3.0;  		double deltaTime = 60.0;  		double x1 = 1.0;  		double x2 = x1 + dx * deltaTime;  		double y1 = 2.0;  		double y2 = y1 + dy * deltaTime;  		double z1 = 3.0;  		double z2 = z1 + dz * deltaTime;  		string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  		string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  		string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  		string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  		writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  		WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  		WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	// construct a position with specific velocity  	double dx = 1.0;  	double dy = 2.0;  	double dz = 3.0;  	double deltaTime = 60.0;  	double x1 = 1.0;  	double x2 = x1 + dx * deltaTime;  	double y1 = 2.0;  	double y2 = y1 + dy * deltaTime;  	double z1 = 3.0;  	double z2 = z1 + dz * deltaTime;  	string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  	string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  	string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  	string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  	writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  	WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  	WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	// construct a position with specific velocity  	double dx = 1.0;  	double dy = 2.0;  	double dz = 3.0;  	double deltaTime = 60.0;  	double x1 = 1.0;  	double x2 = x1 + dx * deltaTime;  	double y1 = 2.0;  	double y2 = y1 + dy * deltaTime;  	double z1 = 3.0;  	double z2 = z1 + dz * deltaTime;  	string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  	string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  	string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  	string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  	writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  	WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  	WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	// construct a position with specific velocity  	double dx = 1.0;  	double dy = 2.0;  	double dz = 3.0;  	double deltaTime = 60.0;  	double x1 = 1.0;  	double x2 = x1 + dx * deltaTime;  	double y1 = 2.0;  	double y2 = y1 + dy * deltaTime;  	double z1 = 3.0;  	double z2 = z1 + dz * deltaTime;  	string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  	string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  	string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  	string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  	writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  	WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  	WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	// construct a position with specific velocity  	double dx = 1.0;  	double dy = 2.0;  	double dz = 3.0;  	double deltaTime = 60.0;  	double x1 = 1.0;  	double x2 = x1 + dx * deltaTime;  	double y1 = 2.0;  	double y2 = y1 + dy * deltaTime;  	double z1 = 3.0;  	double z2 = z1 + dz * deltaTime;  	string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  	string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  	string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  	string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  	writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  	WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  	WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	// construct a position with specific velocity  	double dx = 1.0;  	double dy = 2.0;  	double dz = 3.0;  	double deltaTime = 60.0;  	double x1 = 1.0;  	double x2 = x1 + dx * deltaTime;  	double y1 = 2.0;  	double y2 = y1 + dy * deltaTime;  	double z1 = 3.0;  	double z2 = z1 + dz * deltaTime;  	string value1 = string.Format ("new Cartesian({0}' {1}' {2})"' x1' y1' z1);  	string assertionValue1 = string.Format ("new Cartesian3({0}' {1}' {2})"' x1' y1' z1);  	string value2 = string.Format ("new Cartesian({0}' {1}' {2})"' x2' y2' z2);  	string assertionValue2 = string.Format ("new Cartesian3({0}' {1}' {2})"' x2' y2' z2);  	writer.WriteLine ("w.WriteCartesian(CreateList(m_documentStartDate' m_documentStartDate.AddSeconds({0}))' CreateList({1}' {2}));"' deltaTime' value1' value2);  	WriteAssertion (writer' false' "expect(e.position.getValue(documentStartDate)).toEqual({0});"' assertionValue1);  	WriteAssertion (writer' false' "expect(e.position.getValue(JulianDate.addSeconds(documentStartDate' {0}' new JulianDate()))).toEqual({1});"' deltaTime' assertionValue2);  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: foreach (var property in schemaProperties) {  	string propertyName = property.Name;  	bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  	if (isExtension)  		propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  	var properties = property.ValueType.Properties;  	foreach (var subProperty in properties.Where (p => !p.IsValue)) {  		properties = subProperty.ValueType.Properties;  		if (properties.Any (p => p.Name == "velocityReference")) {  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  				using (writer.OpenScope ()) {  					writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  					double expectedX = 1.0;  					double expectedY = 2.0;  					double expectedZ = 3.0;  					bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  					if (isNormalized) {  						NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  					}  					WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: foreach (var property in schemaProperties) {  	string propertyName = property.Name;  	bool isExtension = !string.IsNullOrEmpty (property.ValueType.ExtensionPrefix);  	if (isExtension)  		propertyName = propertyName.Substring (property.ValueType.ExtensionPrefix.Length + 1);  	var properties = property.ValueType.Properties;  	foreach (var subProperty in properties.Where (p => !p.IsValue)) {  		properties = subProperty.ValueType.Properties;  		if (properties.Any (p => p.Name == "velocityReference")) {  			writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  			using (writer.OpenScope ()) {  				string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  				writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  				WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  				writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  				writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  				using (writer.OpenScope ()) {  					writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  					double expectedX = 1.0;  					double expectedY = 2.0;  					double expectedZ = 3.0;  					bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  					if (isNormalized) {  						NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  					}  					WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  				}  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: foreach (var subProperty in properties.Where (p => !p.IsValue)) {  	properties = subProperty.ValueType.Properties;  	if (properties.Any (p => p.Name == "velocityReference")) {  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  			writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  			WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  			writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  			writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  			using (writer.OpenScope ()) {  				writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  				double expectedX = 1.0;  				double expectedY = 2.0;  				double expectedZ = 3.0;  				bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  				if (isNormalized) {  					NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  				}  				WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: foreach (var subProperty in properties.Where (p => !p.IsValue)) {  	properties = subProperty.ValueType.Properties;  	if (properties.Any (p => p.Name == "velocityReference")) {  		writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  		using (writer.OpenScope ()) {  			string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  			writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  			WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  			writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  			writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  			using (writer.OpenScope ()) {  				writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  				double expectedX = 1.0;  				double expectedY = 2.0;  				double expectedZ = 3.0;  				bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  				if (isNormalized) {  					NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  				}  				WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  			}  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: if (properties.Any (p => p.Name == "velocityReference")) {  	writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  	using (writer.OpenScope ()) {  		string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  		writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  		WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  		writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  		writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  		using (writer.OpenScope ()) {  			writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  			double expectedX = 1.0;  			double expectedY = 2.0;  			double expectedZ = 3.0;  			bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  			if (isNormalized) {  				NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  			}  			WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: if (properties.Any (p => p.Name == "velocityReference")) {  	writer.WriteLine ("using (var packet = m_writer.OpenPacket(m_output))");  	using (writer.OpenScope ()) {  		string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  		writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  		WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  		writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  		writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  		using (writer.OpenScope ()) {  			writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  			double expectedX = 1.0;  			double expectedY = 2.0;  			double expectedZ = 3.0;  			bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  			if (isNormalized) {  				NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  			}  			WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  		}  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  	writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  	WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  	writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  	writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  	using (writer.OpenScope ()) {  		writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  		double expectedX = 1.0;  		double expectedY = 2.0;  		double expectedZ = 3.0;  		bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  		if (isNormalized) {  			NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  		}  		WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	string id = string.Format ("velocityReference_{0}_{1}"' propertyName' subProperty.Name);  	writer.WriteLine ("packet.WriteId(\"{0}\");"' id);  	WriteAssertionBoth (writer' "expect(e = dataSource.entities.getById('{0}')).toBeDefined();"' id);  	writer.WriteLine ("using (var w = packet.Open{0}Property())"' property.NameWithPascalCase);  	writer.WriteLine ("using (var w2 = w.Open{0}Property())"' subProperty.NameWithPascalCase);  	using (writer.OpenScope ()) {  		writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  		double expectedX = 1.0;  		double expectedY = 2.0;  		double expectedZ = 3.0;  		bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  		if (isNormalized) {  			NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  		}  		WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  	}  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  	double expectedX = 1.0;  	double expectedY = 2.0;  	double expectedZ = 3.0;  	bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  	if (isNormalized) {  		NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  	}  	WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,Generate,The following statement contains a magic number: using (writer.OpenScope ()) {  	writer.WriteLine ("w2.WriteVelocityReference(new Reference(\"VelocityPosition\"' \"position\"));");  	double expectedX = 1.0;  	double expectedY = 2.0;  	double expectedZ = 3.0;  	bool isNormalized = subProperty.NameWithPascalCase == "AlignedAxis";  	if (isNormalized) {  		NormalizeCartesian (ref expectedX' ref expectedY' ref expectedZ);  	}  	WriteAssertion (writer' isExtension' "expect(e.{0}.{1}.getValue(JulianDate.addSeconds(documentStartDate' 50' new JulianDate()))).toEqualEpsilon(new Cartesian3({2}' {3}' {4})' 1e-13);"' propertyName' subProperty.Name' expectedX' expectedY' expectedZ);  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,WriteValues,The following statement contains a magic number: GetUniqueValue (valueName + 2' valueProperty' parentProperty' out value2' out assertionValue2' out assertionEpsilon2' out valueType2);  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  
Magic Number,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following statement contains a magic number: assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  
Magic Number,GenerateFromSchema,MarkdownGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\MarkdownGenerator.cs,JsonSchemaTypesToLabel,The following statement contains a magic number: switch (index) {  case 0:  	return "";  case 1:  	return types [0];  case 2:  	return types [0] + " or " + types [1];  default:  	return string.Join ("' "' types' 0' index - 1) + "' or " + types [index - 1];  }  
Missing Default,GenerateFromSchema,ValidationDocumentGenerator,F:\newReposMay17\AnalyticalGraphicsInc_czml-writer\DotNet\GenerateFromSchema\ValidationDocumentGenerator.cs,GetUniqueValue,The following switch statement is missing a default case: switch (valueProperty.ValueType.Name) {  case "Boolean": {  	value = assertionValue = "true";  	valueType = "bool";  	return;  }  case "Double": {  	value = assertionValue = getNumber (0).ToString ("#.0");  	valueType = "double";  	return;  }  case "Integer": {  	value = assertionValue = getNumber (0).ToString ();  	valueType = "int";  	return;  }  case "DoubleList": {  	int v1 = getNumber (0);  	int v2 = getNumber (1);  	value = string.Format ("CreateList<double>({0}' {1})"' v1' v2);  	assertionValue = string.Format ("[ {0}' {1} ]"' v1' v2);  	valueType = "List<double>";  	return;  }  case "String": {  	string v = string.Format ("string{0}"' getNumber (0));  	value = string.Format ("\"{0}\""' v);  	assertionValue = string.Format ("'{0}'"' v);  	valueType = "string";  	return;  }  case "Cartesian3": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	value = string.Format ("new Cartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Cartesian";  	return;  }  case "Cartesian3List": {  	int x1 = getNumber (0);  	int y1 = getNumber (1);  	int z1 = getNumber (2);  	int x2 = getNumber (3);  	int y2 = getNumber (4);  	int z2 = getNumber (5);  	value = string.Format ("CreateList(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	valueType = "List<Cartesian>";  	return;  }  case "UnitCartesian3": {  	double x = getNumber (0);  	double y = getNumber (1);  	double z = getNumber (2);  	NormalizeCartesian (ref x' ref y' ref z);  	value = string.Format ("new UnitCartesian({0}' {1}' {2})"' x' y' z);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "UnitCartesian";  	assertionEpsilon = "1e-14";  	return;  }  case "UnitCartesian3List": {  	double x1 = getNumber (0);  	double y1 = getNumber (1);  	double z1 = getNumber (2);  	NormalizeCartesian (ref x1' ref y1' ref z1);  	double x2 = getNumber (3);  	double y2 = getNumber (4);  	double z2 = getNumber (5);  	NormalizeCartesian (ref x2' ref y2' ref z2);  	value = string.Format ("CreateList(new UnitCartesian({0}' {1}' {2})' new UnitCartesian({3}' {4}' {5}))"' x1' y1' z1' x2' y2' z2);  	assertionValue = string.Format ("[ {6}new Cartesian3({0}' {1}' {2}){7}' {6}new Cartesian3({3}' {4}' {5}){7} ]"' x1' y1' z1' x2' y2' z2' parentProperty.ValueType.Name == "DirectionList" ? "Spherical.fromCartesian3(" : ""' parentProperty.ValueType.Name == "DirectionList" ? ")" : "");  	assertionEpsilon = "1e-14";  	valueType = "List<UnitCartesian>";  	return;  }  case "Cartesian3Velocity": {  	int x = getNumber (0);  	int y = getNumber (1);  	int z = getNumber (2);  	int dX = getNumber (3);  	int dY = getNumber (4);  	int dZ = getNumber (5);  	value = string.Format ("new Motion<Cartesian>(new Cartesian({0}' {1}' {2})' new Cartesian({3}' {4}' {5}))"' x' y' z' dX' dY' dZ);  	assertionValue = string.Format ("new Cartesian3({0}' {1}' {2})"' x' y' z);  	valueType = "Motion<Cartesian>";  	return;  }  case "Cartographic": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height = getNumber (2);  	value = string.Format ("new Cartographic({0}' {1}' {2})"' longitude' latitude' height);  	assertionValue = string.Format ("Cartesian3.from{3}({0}' {1}' {2})"' longitude' latitude' height' isDegrees ? "Degrees" : "Radians");  	valueType = "Cartographic";  	return;  }  case "CartographicList": {  	bool isDegrees = valueProperty.Name == "cartographicDegrees";  	double longitude1 = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double latitude1 = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double height1 = getNumber (2);  	double longitude2 = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	double latitude2 = getNumber (4) % (isDegrees ? 45 : Math.PI / 2);  	double height2 = getNumber (5);  	value = string.Format ("CreateList(new Cartographic({0}' {1}' {2})' new Cartographic({3}' {4}' {5}))"' longitude1' latitude1' height1' longitude2' latitude2' height2);  	assertionValue = string.Format ("[ Cartesian3.from{6}({0}' {1}' {2})' Cartesian3.from{6}({3}' {4}' {5}) ]"' longitude1' latitude1' height1' longitude2' latitude2' height2' isDegrees ? "Degrees" : "Radians");  	valueType = "List<Cartesian>";  	return;  }  case "Cartesian2": {  	int x = getNumber (0);  	int y = getNumber (1);  	value = string.Format ("new Rectangular({0}' {1})"' x' y);  	assertionValue = string.Format ("new Cartesian2({0}' {1})"' x' y);  	valueType = "Rectangular";  	return;  }  case "Spherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	int magnitude = getNumber (2);  	value = string.Format ("new Spherical({0}' {1}' {2})"' clock' cone' magnitude);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}' {2}))"' clock' cone' magnitude);  	valueType = "Spherical";  	return;  }  case "SphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int magnitude1 = getNumber (2);  	int clock2 = getNumber (3);  	int cone2 = getNumber (4);  	int magnitude2 = getNumber (5);  	value = string.Format ("CreateList(new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}))"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	assertionValue = string.Format ("[ new Spherical({0}' {1}' {2})' new Spherical({3}' {4}' {5}) ]"' clock1' cone1' magnitude1' clock2' cone2' magnitude2);  	valueType = "List<Spherical>";  	return;  }  case "UnitSpherical": {  	int clock = getNumber (0);  	int cone = getNumber (1);  	value = string.Format ("new UnitSpherical({0}' {1})"' clock' cone);  	assertionValue = string.Format ("Cartesian3.fromSpherical(new Spherical({0}' {1}))"' clock' cone);  	valueType = "UnitSpherical";  	return;  }  case "UnitSphericalList": {  	int clock1 = getNumber (0);  	int cone1 = getNumber (1);  	int clock2 = getNumber (2);  	int cone2 = getNumber (3);  	value = string.Format ("CreateList(new UnitSpherical({0}' {1})' new UnitSpherical({2}' {3}))"' clock1' cone1' clock2' cone2);  	assertionValue = string.Format ("[ new Spherical({0}' {1})' new Spherical({2}' {3}) ]"' clock1' cone1' clock2' cone2);  	valueType = "List<UnitSpherical>";  	return;  }  case "UnitQuaternion": {  	double w = getNumber (0);  	double x = getNumber (1);  	double y = getNumber (2);  	double z = getNumber (3);  	double magnitude = Math.Sqrt (w * w + x * x + y * y + z * z);  	w /= magnitude;  	x /= magnitude;  	y /= magnitude;  	z /= magnitude;  	value = string.Format ("new UnitQuaternion({0}' {1}' {2}' {3})"' w' x' y' z);  	assertionValue = string.Format ("new Quaternion({0}' {1}' {2}' {3})"' x' y' z' w);  	assertionEpsilon = "1e-14";  	valueType = "UnitQuaternion";  	return;  }  case "Rgba": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("Color.fromBytes({0}' {1}' {2}' {3})"' r' g' b' a);  	valueType = "Color";  	return;  }  case "Rgbaf": {  	int a = getNumber (0) % 255;  	int r = getNumber (1) % 255;  	int g = getNumber (2) % 255;  	int b = getNumber (3) % 255;  	value = string.Format ("Color.FromArgb({0}' {1}' {2}' {3})"' a' r' g' b);  	assertionValue = string.Format ("new Color({0}' {1}' {2}' {3})"' r / 255.0' g / 255.0' b / 255.0' a / 255.0);  	assertionEpsilon = "1e-14";  	valueType = "Color";  	return;  }  case "VerticalOrigin": {  	value = "CesiumVerticalOrigin.Bottom";  	assertionValue = "VerticalOrigin.BOTTOM";  	valueType = "CesiumVerticalOrigin";  	return;  }  case "HorizontalOrigin": {  	value = "CesiumHorizontalOrigin.Left";  	assertionValue = "HorizontalOrigin.LEFT";  	valueType = "CesiumHorizontalOrigin";  	return;  }  case "HeightReference": {  	value = "CesiumHeightReference.ClampToGround";  	assertionValue = "HeightReference.CLAMP_TO_GROUND";  	valueType = "CesiumHeightReference";  	return;  }  case "LabelStyle": {  	value = "CesiumLabelStyle.FillAndOutline";  	assertionValue = "LabelStyle.FILL_AND_OUTLINE";  	valueType = "CesiumLabelStyle";  	return;  }  case "CornerType": {  	value = "CesiumCornerType.Beveled";  	assertionValue = "CornerType.BEVELED";  	valueType = "CesiumCornerType";  	return;  }  case "ShadowMode": {  	value = "CesiumShadowMode.CastOnly";  	assertionValue = "ShadowMode.CAST_ONLY";  	valueType = "CesiumShadowMode";  	return;  }  case "ColorBlendMode": {  	value = "CesiumColorBlendMode.Replace";  	assertionValue = "ColorBlendMode.REPLACE";  	valueType = "CesiumColorBlendMode";  	return;  }  case "StripeOrientation": {  	value = "CesiumStripeOrientation.Vertical";  	assertionValue = "StripeOrientation.VERTICAL";  	valueType = "CesiumStripeOrientation";  	return;  }  case "SensorVolumePortionToDisplay": {  	value = "CesiumSensorVolumePortionToDisplay.BelowEllipsoidHorizon";  	assertionValue = "SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON";  	valueType = "CesiumSensorVolumePortionToDisplay";  	return;  }  case "Font": {  	string s = string.Format ("{0}px sans-serif"' (getNumber (0) + 5) % 25);  	value = string.Format ("\"{0}\""' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "Uri": {  	string s = string.Format ("http://example.com/{0}"' getNumber (0));  	value = string.Format ("\"{0}\"' CesiumResourceBehavior.LinkTo"' s);  	assertionValue = string.Format ("'{0}'"' s);  	valueType = "string";  	return;  }  case "NearFarScalar": {  	int nearDistance = getNumber (0);  	int nearValue = getNumber (1);  	int farDistance = getNumber (2);  	int farValue = getNumber (3);  	value = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	assertionValue = string.Format ("new NearFarScalar({0}' {1}' {2}' {3})"' nearDistance' nearValue' farDistance' farValue);  	valueType = "NearFarScalar";  	return;  }  case "BoundingRectangle": {  	int x = getNumber (0);  	int y = getNumber (1);  	int width = getNumber (2);  	int height = getNumber (3);  	value = string.Format ("BoundingRectangle.FromWidthHeight({0}' {1}' {2}' {3})"' x' y' width' height);  	assertionValue = string.Format ("new BoundingRectangle({0}' {1}' {2}' {3})"' x' y' width' height);  	valueType = "BoundingRectangle";  	return;  }  case "CartographicRectangle": {  	bool isDegrees = valueProperty.Name == "wsenDegrees";  	double w = getNumber (0) % (isDegrees ? 45 : Math.PI / 2);  	double s = getNumber (1) % (isDegrees ? 45 : Math.PI / 2);  	double e = getNumber (2) % (isDegrees ? 45 : Math.PI / 2);  	double n = getNumber (3) % (isDegrees ? 45 : Math.PI / 2);  	value = string.Format ("new CartographicExtent({0}' {1}' {2}' {3})"' w' s' e' n);  	assertionValue = string.Format ("{4}({0}' {1}' {2}' {3})"' w' s' e' n' isDegrees ? "Rectangle.fromDegrees" : "new Rectangle");  	valueType = "CartographicExtent";  	return;  }  }  
