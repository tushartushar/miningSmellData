Implementation smell,Namespace,Class,File,Method,Description
Long Method,Bind,FuncProcessor,C:\repos\thefiddler_opentk\Source\Bind\FuncProcessor.cs,TranslateType,The method has 104 lines of code.
Long Method,Bind,FuncProcessor,C:\repos\thefiddler_opentk\Source\Bind\FuncProcessor.cs,WrapParameters,The method has 175 lines of code.
Long Method,Bind,MainClass,C:\repos\thefiddler_opentk\Source\Bind\Main.cs,Main,The method has 211 lines of code.
Long Method,Bind,XmlSpecReader,C:\repos\thefiddler_opentk\Source\Bind\XmlSpecReader.cs,ReadEnums,The method has 114 lines of code.
Complex Method,Bind,CppSpecWriter,C:\repos\thefiddler_opentk\Source\Bind\CppSpecWriter.cs,GenerateParameterString,Cyclomatic complexity of the method is 10
Complex Method,Bind,CppSpecWriter,C:\repos\thefiddler_opentk\Source\Bind\CppSpecWriter.cs,WriteDefinitions,Cyclomatic complexity of the method is 10
Complex Method,Bind,CSharpSpecWriter,C:\repos\thefiddler_opentk\Source\Bind\CSharpSpecWriter.cs,WriteWrappers,Cyclomatic complexity of the method is 11
Complex Method,Bind,CSharpSpecWriter,C:\repos\thefiddler_opentk\Source\Bind\CSharpSpecWriter.cs,WriteDocumentation,Cyclomatic complexity of the method is 11
Complex Method,Bind,CSharpSpecWriter,C:\repos\thefiddler_opentk\Source\Bind\CSharpSpecWriter.cs,WriteEnums,Cyclomatic complexity of the method is 11
Complex Method,Bind,CSharpSpecWriter,C:\repos\thefiddler_opentk\Source\Bind\CSharpSpecWriter.cs,GetDeclarationString,Cyclomatic complexity of the method is 8
Complex Method,Bind,FuncProcessor,C:\repos\thefiddler_opentk\Source\Bind\FuncProcessor.cs,TranslateType,Cyclomatic complexity of the method is 8
Complex Method,Bind,FuncProcessor,C:\repos\thefiddler_opentk\Source\Bind\FuncProcessor.cs,TranslateParameter,Cyclomatic complexity of the method is 9
Complex Method,Bind,FuncProcessor,C:\repos\thefiddler_opentk\Source\Bind\FuncProcessor.cs,MarkCLSCompliance,Cyclomatic complexity of the method is 13
Complex Method,Bind,FuncProcessor,C:\repos\thefiddler_opentk\Source\Bind\FuncProcessor.cs,WrapParameters,Cyclomatic complexity of the method is 31
Complex Method,Bind,JavaSpecWriter,C:\repos\thefiddler_opentk\Source\Bind\JavaSpecWriter.cs,GenerateParameterString,Cyclomatic complexity of the method is 8
Complex Method,Bind,MainClass,C:\repos\thefiddler_opentk\Source\Bind\Main.cs,Main,Cyclomatic complexity of the method is 8
Complex Method,Bind,EnumProcessor,C:\repos\thefiddler_opentk\Source\Bind\EnumProcessor.cs,TranslateEnumName,Cyclomatic complexity of the method is 9
Complex Method,Bind,XmlSpecReader,C:\repos\thefiddler_opentk\Source\Bind\XmlSpecReader.cs,ReadEnums,Cyclomatic complexity of the method is 8
Long Parameter List,Bind,CSharpSpecWriter,C:\repos\thefiddler_opentk\Source\Bind\CSharpSpecWriter.cs,WriteWrappers,The method has 5 parameters. Parameters: sw' wrappers' delegates' enums' CSTypes
Long Parameter List,Bind,FuncProcessor,C:\repos\thefiddler_opentk\Source\Bind\FuncProcessor.cs,Process,The method has 6 parameters. Parameters: enum_processor' doc_processor' delegates' enums' apiname' apiversion
Long Parameter List,Bind,FuncProcessor,C:\repos\thefiddler_opentk\Source\Bind\FuncProcessor.cs,GetPath,The method has 5 parameters. Parameters: apipath' apiname' apiversion' function' extension
Long Parameter List,Bind,FuncProcessor,C:\repos\thefiddler_opentk\Source\Bind\FuncProcessor.cs,TranslateType,The method has 7 parameters. Parameters: type' function_override' overrides' enum_processor' enums' category' apiname
Long Parameter List,Bind,FuncProcessor,C:\repos\thefiddler_opentk\Source\Bind\FuncProcessor.cs,TranslateReturnType,The method has 7 parameters. Parameters: d' function_override' nav' enum_processor' enums' apiname' apiversion
Long Parameter List,Bind,FuncProcessor,C:\repos\thefiddler_opentk\Source\Bind\FuncProcessor.cs,TranslateParameters,The method has 7 parameters. Parameters: d' function_override' nav' enum_processor' enums' apiname' apiversion
Long Parameter List,Bind,FuncProcessor,C:\repos\thefiddler_opentk\Source\Bind\FuncProcessor.cs,TranslateParameter,The method has 7 parameters. Parameters: p' function_override' overrides' enum_processor' enums' category' apiname
Long Parameter List,Bind,FuncProcessor,C:\repos\thefiddler_opentk\Source\Bind\FuncProcessor.cs,TranslateAttributes,The method has 5 parameters. Parameters: d' function_override' nav' apiname' apiversion
Long Statement,Bind,CSharpSpecWriter,C:\repos\thefiddler_opentk\Source\Bind\CSharpSpecWriter.cs,WriteMethod,The length of the statement  "            sw.WriteLine("public static {0} {{ throw new NotImplementedException(); }}"' GetDeclarationString(f' Settings.Compatibility)); " is 126.
Long Statement,Bind,CSharpSpecWriter,C:\repos\thefiddler_opentk\Source\Bind\CSharpSpecWriter.cs,WriteEnums,The length of the statement  "                Trace.WriteLine(String.Format("Writing enums to:\t{0}.{1}.{2}"' Settings.OutputNamespace' Settings.OutputClass' Settings.NestedEnumsClass)); " is 140.
Long Statement,Bind,CSharpSpecWriter,C:\repos\thefiddler_opentk\Source\Bind\CSharpSpecWriter.cs,WriteEnums,The length of the statement  "                            Char.IsDigit(c.Value[0]) ? c.Value : c.Value.StartsWith(Settings.ConstantPrefix) ? c.Value : Settings.ConstantPrefix + c.Value' " is 127.
Long Statement,Bind,CSharpSpecWriter,C:\repos\thefiddler_opentk\Source\Bind\CSharpSpecWriter.cs,GetDeclarationString,The length of the statement  "            if (!override_unsafe_setting && ((Settings.Compatibility & Settings.Legacy.NoPublicUnsafeFunctions) != Settings.Legacy.None)) " is 125.
Long Statement,Bind,EnumProcessor,C:\repos\thefiddler_opentk\Source\Bind\EnumProcessor.cs,ReplaceConstant,The length of the statement  "                XPathNavigator constant_override = enum_override.SelectSingleNode(String.Format("token[@name='{0}']"' c.OriginalName)) ?? " is 121.
Complex Conditional,Bind,FuncProcessor,C:\repos\thefiddler_opentk\Source\Bind\FuncProcessor.cs,GetTrimmedName,The conditional expression  "m.Value[m.Length - 1] == 'v' && EndingsAddV.IsMatch(name) &&                          !name.StartsWith("Get") && !name.StartsWith("MatrixIndex")"  is complex.
Complex Conditional,Bind,FuncProcessor,C:\repos\thefiddler_opentk\Source\Bind\FuncProcessor.cs,WrapParameters,The conditional expression  "parameter.WrapperType == 0 ||                          (parameter.WrapperType & WrapperTypes.ConvenienceArrayType) != 0 ||                          (parameter.WrapperType & WrapperTypes.ConvenienceReturnType) != 0 ||                          (parameter.WrapperType & WrapperTypes.ConvenienceArrayReturnType) != 0"  is complex.
Complex Conditional,Bind,EnumProcessor,C:\repos\thefiddler_opentk\Source\Bind\EnumProcessor.cs,TranslateConstantName,The conditional expression  "is_after_digit && (c == 'D' || c == 'R' || c == 'G' || c == 'B' || c == 'A')"  is complex.
Magic Number,Bind,CppSpecWriter,C:\repos\thefiddler_opentk\Source\Bind\CppSpecWriter.cs,GenerateParameterString,The following statement contains a magic number: if (d.Parameters.Count > 0)              {                  foreach (var p in d.Parameters)                  {                      if (p.CurrentType.ToLower() == "string[]")                          p.CurrentType = "char**";                      if (p.CurrentType.ToLower() == "string")                          p.CurrentType = "char*";                        if (p.Reference)                      {                         if (/*check_validity &&*/ p.Generic)                          {                              // We don't need generic parameters in C++ and void& is illegal.                              valid = false;                              return String.Empty;                          }                            if (p.Flow != FlowDirection.Out)                              sb.Append("const ");                          sb.Append(p.QualifiedType);                          sb.Append('*'' p.Array);                          sb.Append("&");                      }                      else if (p.Array > 0)                      {                          // Hack: generic parameters with array types are                          // not real (i.e. they are created by the generator                          // specifically for managed languages). We don't                          // need them in C++.                          // Todo: move C#/Java-specific code to their respective                          // classes' instead of the main generator.                          // Note: the 1-dimensional array is handled through the pointer case below.                          // (C# differentiates between arrays and pointers' C++ doesn't).                          if (check_validity && (p.Generic || p.Array == 1))                          {                              valid = false;                              return String.Empty;                          }                            if (p.Flow != FlowDirection.Out)                              sb.Append("const ");                          sb.Append(p.Generic ? "void" : p.QualifiedType); // We don't need generic parameters in C++.                          sb.Append('*'' p.Array);                      }                      else if (p.Pointer > 0)                      {                          if (p.Flow != FlowDirection.Out)                              sb.Append("const ");                          sb.Append(p.Generic ? "void" : p.QualifiedType); // We don't need generic parameters in C++.                          sb.Append('*'' p.Pointer);                      }                      else if (p.CurrentType == "IntPtr")                      {                          if (p.Flow != FlowDirection.Out)                              sb.Append("const ");                          sb.Append("void*");                      }                      else                      {                          sb.Append(p.QualifiedType);                      }                        sb.Append(" ");                      sb.Append(p.Name);                      sb.Append("' ");                  }                    if (d.Parameters.Count > 0)                      sb.Remove(sb.Length - 2' 2);              }
Magic Number,Bind,CppSpecWriter,C:\repos\thefiddler_opentk\Source\Bind\CppSpecWriter.cs,GenerateParameterString,The following statement contains a magic number: if (d.Parameters.Count > 0)              {                  foreach (var p in d.Parameters)                  {                      if (p.CurrentType.ToLower() == "string[]")                          p.CurrentType = "char**";                      if (p.CurrentType.ToLower() == "string")                          p.CurrentType = "char*";                        if (p.Reference)                      {                         if (/*check_validity &&*/ p.Generic)                          {                              // We don't need generic parameters in C++ and void& is illegal.                              valid = false;                              return String.Empty;                          }                            if (p.Flow != FlowDirection.Out)                              sb.Append("const ");                          sb.Append(p.QualifiedType);                          sb.Append('*'' p.Array);                          sb.Append("&");                      }                      else if (p.Array > 0)                      {                          // Hack: generic parameters with array types are                          // not real (i.e. they are created by the generator                          // specifically for managed languages). We don't                          // need them in C++.                          // Todo: move C#/Java-specific code to their respective                          // classes' instead of the main generator.                          // Note: the 1-dimensional array is handled through the pointer case below.                          // (C# differentiates between arrays and pointers' C++ doesn't).                          if (check_validity && (p.Generic || p.Array == 1))                          {                              valid = false;                              return String.Empty;                          }                            if (p.Flow != FlowDirection.Out)                              sb.Append("const ");                          sb.Append(p.Generic ? "void" : p.QualifiedType); // We don't need generic parameters in C++.                          sb.Append('*'' p.Array);                      }                      else if (p.Pointer > 0)                      {                          if (p.Flow != FlowDirection.Out)                              sb.Append("const ");                          sb.Append(p.Generic ? "void" : p.QualifiedType); // We don't need generic parameters in C++.                          sb.Append('*'' p.Pointer);                      }                      else if (p.CurrentType == "IntPtr")                      {                          if (p.Flow != FlowDirection.Out)                              sb.Append("const ");                          sb.Append("void*");                      }                      else                      {                          sb.Append(p.QualifiedType);                      }                        sb.Append(" ");                      sb.Append(p.Name);                      sb.Append("' ");                  }                    if (d.Parameters.Count > 0)                      sb.Remove(sb.Length - 2' 2);              }
Magic Number,Bind,CppSpecWriter,C:\repos\thefiddler_opentk\Source\Bind\CppSpecWriter.cs,GenerateCallString,The following statement contains a magic number: if (f.Parameters.Count > 0)                  sb.Remove(sb.Length - 2' 2);
Magic Number,Bind,CppSpecWriter,C:\repos\thefiddler_opentk\Source\Bind\CppSpecWriter.cs,GenerateCallString,The following statement contains a magic number: if (f.Parameters.Count > 0)                  sb.Remove(sb.Length - 2' 2);
Magic Number,Bind,CSharpSpecWriter,C:\repos\thefiddler_opentk\Source\Bind\CSharpSpecWriter.cs,ConsoleRewrite,The following statement contains a magic number: for (int i = text.Length; i < 80; i++)                  Console.Write(" ");
Magic Number,Bind,CSharpSpecWriter,C:\repos\thefiddler_opentk\Source\Bind\CSharpSpecWriter.cs,WriteEnums,The following statement contains a magic number: if ((Settings.Compatibility & Settings.Legacy.ConstIntEnums) == Settings.Legacy.None)              {                  if ((Settings.Compatibility & Settings.Legacy.NestedEnums) != Settings.Legacy.None &&                      !String.IsNullOrEmpty(Settings.NestedEnumsClass))                  {                      sw.WriteLine("public class Enums");                      sw.WriteLine("{");                      sw.Indent();                  }                    // Build a dictionary of which functions use which enums                  var enum_counts = new Dictionary<Enum' List<Function>>();                  foreach (var e in enums.Values)                  {                      // Initialize the dictionary                      enum_counts.Add(e' new List<Function>());                  }                  foreach (var wrapper in wrappers.Values.SelectMany(w => w))                  {                      // Add every function to every enum parameter it references                      foreach (var parameter in wrapper.Parameters.Where(p => p.IsEnum))                      {                          var e = enums[parameter.CurrentType];                          var list = enum_counts[e];                          list.Add(wrapper);                      }                  }                    foreach (Enum @enum in enums.Values)                  {                      if (!Settings.IsEnabled(Settings.Legacy.NoDocumentation))                      {                          // Document which functions use this enum.                          var functions = enum_counts[@enum]                              .Select(w => Settings.GLClass + (w.Extension != "Core" ? ("." + w.Extension) : "") + "." + w.TrimmedName)                              .Distinct();                            sw.WriteLine("/// <summary>");                          sw.WriteLine(String.Format("/// {0}"'                              functions.Count() >= 3 ?                                  String.Format("Used in {0} and {1} other function{2}"'                                      String.Join("' "' functions.Take(2).ToArray())'                                      functions.Count() - 2'                                      functions.Count() - 2 > 1 ? "s" : "") :                              functions.Count() >= 1 ?                                  String.Format("Used in {0}"'                                      String.Join("' "' functions.ToArray())) :                                  "Not used directly."));                          sw.WriteLine("/// </summary>");                      }                        if (@enum.IsFlagCollection)                          sw.WriteLine("[Flags]");                      sw.WriteLine("public enum " + @enum.Name + " : " + @enum.Type);                      sw.WriteLine("{");                      sw.Indent();                      WriteConstants(sw' @enum.ConstantCollection.Values);                      sw.Unindent();                      sw.WriteLine("}");                      sw.WriteLine();                  }                    if ((Settings.Compatibility & Settings.Legacy.NestedEnums) != Settings.Legacy.None &&                      !String.IsNullOrEmpty(Settings.NestedEnumsClass))                  {                      sw.Unindent();                      sw.WriteLine("}");                  }              }              else              {                  // Tao legacy mode: dump all enums as constants in GLClass.                  foreach (Constant c in enums[Settings.CompleteEnumName].ConstantCollection.Values)                  {                      // Print constants avoiding circular definitions                      if (c.Name != c.Value)                      {                          sw.WriteLine(String.Format(                              "public const int {0} = {2}((int){1});"'                              c.Name.StartsWith(Settings.ConstantPrefix) ? c.Name : Settings.ConstantPrefix + c.Name'                              Char.IsDigit(c.Value[0]) ? c.Value : c.Value.StartsWith(Settings.ConstantPrefix) ? c.Value : Settings.ConstantPrefix + c.Value'                              c.Unchecked ? "unchecked" : ""));                      }                      else                      {                      }                  }              }
Magic Number,Bind,CSharpSpecWriter,C:\repos\thefiddler_opentk\Source\Bind\CSharpSpecWriter.cs,WriteEnums,The following statement contains a magic number: if ((Settings.Compatibility & Settings.Legacy.ConstIntEnums) == Settings.Legacy.None)              {                  if ((Settings.Compatibility & Settings.Legacy.NestedEnums) != Settings.Legacy.None &&                      !String.IsNullOrEmpty(Settings.NestedEnumsClass))                  {                      sw.WriteLine("public class Enums");                      sw.WriteLine("{");                      sw.Indent();                  }                    // Build a dictionary of which functions use which enums                  var enum_counts = new Dictionary<Enum' List<Function>>();                  foreach (var e in enums.Values)                  {                      // Initialize the dictionary                      enum_counts.Add(e' new List<Function>());                  }                  foreach (var wrapper in wrappers.Values.SelectMany(w => w))                  {                      // Add every function to every enum parameter it references                      foreach (var parameter in wrapper.Parameters.Where(p => p.IsEnum))                      {                          var e = enums[parameter.CurrentType];                          var list = enum_counts[e];                          list.Add(wrapper);                      }                  }                    foreach (Enum @enum in enums.Values)                  {                      if (!Settings.IsEnabled(Settings.Legacy.NoDocumentation))                      {                          // Document which functions use this enum.                          var functions = enum_counts[@enum]                              .Select(w => Settings.GLClass + (w.Extension != "Core" ? ("." + w.Extension) : "") + "." + w.TrimmedName)                              .Distinct();                            sw.WriteLine("/// <summary>");                          sw.WriteLine(String.Format("/// {0}"'                              functions.Count() >= 3 ?                                  String.Format("Used in {0} and {1} other function{2}"'                                      String.Join("' "' functions.Take(2).ToArray())'                                      functions.Count() - 2'                                      functions.Count() - 2 > 1 ? "s" : "") :                              functions.Count() >= 1 ?                                  String.Format("Used in {0}"'                                      String.Join("' "' functions.ToArray())) :                                  "Not used directly."));                          sw.WriteLine("/// </summary>");                      }                        if (@enum.IsFlagCollection)                          sw.WriteLine("[Flags]");                      sw.WriteLine("public enum " + @enum.Name + " : " + @enum.Type);                      sw.WriteLine("{");                      sw.Indent();                      WriteConstants(sw' @enum.ConstantCollection.Values);                      sw.Unindent();                      sw.WriteLine("}");                      sw.WriteLine();                  }                    if ((Settings.Compatibility & Settings.Legacy.NestedEnums) != Settings.Legacy.None &&                      !String.IsNullOrEmpty(Settings.NestedEnumsClass))                  {                      sw.Unindent();                      sw.WriteLine("}");                  }              }              else              {                  // Tao legacy mode: dump all enums as constants in GLClass.                  foreach (Constant c in enums[Settings.CompleteEnumName].ConstantCollection.Values)                  {                      // Print constants avoiding circular definitions                      if (c.Name != c.Value)                      {                          sw.WriteLine(String.Format(                              "public const int {0} = {2}((int){1});"'                              c.Name.StartsWith(Settings.ConstantPrefix) ? c.Name : Settings.ConstantPrefix + c.Name'                              Char.IsDigit(c.Value[0]) ? c.Value : c.Value.StartsWith(Settings.ConstantPrefix) ? c.Value : Settings.ConstantPrefix + c.Value'                              c.Unchecked ? "unchecked" : ""));                      }                      else                      {                      }                  }              }
Magic Number,Bind,CSharpSpecWriter,C:\repos\thefiddler_opentk\Source\Bind\CSharpSpecWriter.cs,WriteEnums,The following statement contains a magic number: if ((Settings.Compatibility & Settings.Legacy.ConstIntEnums) == Settings.Legacy.None)              {                  if ((Settings.Compatibility & Settings.Legacy.NestedEnums) != Settings.Legacy.None &&                      !String.IsNullOrEmpty(Settings.NestedEnumsClass))                  {                      sw.WriteLine("public class Enums");                      sw.WriteLine("{");                      sw.Indent();                  }                    // Build a dictionary of which functions use which enums                  var enum_counts = new Dictionary<Enum' List<Function>>();                  foreach (var e in enums.Values)                  {                      // Initialize the dictionary                      enum_counts.Add(e' new List<Function>());                  }                  foreach (var wrapper in wrappers.Values.SelectMany(w => w))                  {                      // Add every function to every enum parameter it references                      foreach (var parameter in wrapper.Parameters.Where(p => p.IsEnum))                      {                          var e = enums[parameter.CurrentType];                          var list = enum_counts[e];                          list.Add(wrapper);                      }                  }                    foreach (Enum @enum in enums.Values)                  {                      if (!Settings.IsEnabled(Settings.Legacy.NoDocumentation))                      {                          // Document which functions use this enum.                          var functions = enum_counts[@enum]                              .Select(w => Settings.GLClass + (w.Extension != "Core" ? ("." + w.Extension) : "") + "." + w.TrimmedName)                              .Distinct();                            sw.WriteLine("/// <summary>");                          sw.WriteLine(String.Format("/// {0}"'                              functions.Count() >= 3 ?                                  String.Format("Used in {0} and {1} other function{2}"'                                      String.Join("' "' functions.Take(2).ToArray())'                                      functions.Count() - 2'                                      functions.Count() - 2 > 1 ? "s" : "") :                              functions.Count() >= 1 ?                                  String.Format("Used in {0}"'                                      String.Join("' "' functions.ToArray())) :                                  "Not used directly."));                          sw.WriteLine("/// </summary>");                      }                        if (@enum.IsFlagCollection)                          sw.WriteLine("[Flags]");                      sw.WriteLine("public enum " + @enum.Name + " : " + @enum.Type);                      sw.WriteLine("{");                      sw.Indent();                      WriteConstants(sw' @enum.ConstantCollection.Values);                      sw.Unindent();                      sw.WriteLine("}");                      sw.WriteLine();                  }                    if ((Settings.Compatibility & Settings.Legacy.NestedEnums) != Settings.Legacy.None &&                      !String.IsNullOrEmpty(Settings.NestedEnumsClass))                  {                      sw.Unindent();                      sw.WriteLine("}");                  }              }              else              {                  // Tao legacy mode: dump all enums as constants in GLClass.                  foreach (Constant c in enums[Settings.CompleteEnumName].ConstantCollection.Values)                  {                      // Print constants avoiding circular definitions                      if (c.Name != c.Value)                      {                          sw.WriteLine(String.Format(                              "public const int {0} = {2}((int){1});"'                              c.Name.StartsWith(Settings.ConstantPrefix) ? c.Name : Settings.ConstantPrefix + c.Name'                              Char.IsDigit(c.Value[0]) ? c.Value : c.Value.StartsWith(Settings.ConstantPrefix) ? c.Value : Settings.ConstantPrefix + c.Value'                              c.Unchecked ? "unchecked" : ""));                      }                      else                      {                      }                  }              }
Magic Number,Bind,CSharpSpecWriter,C:\repos\thefiddler_opentk\Source\Bind\CSharpSpecWriter.cs,WriteEnums,The following statement contains a magic number: if ((Settings.Compatibility & Settings.Legacy.ConstIntEnums) == Settings.Legacy.None)              {                  if ((Settings.Compatibility & Settings.Legacy.NestedEnums) != Settings.Legacy.None &&                      !String.IsNullOrEmpty(Settings.NestedEnumsClass))                  {                      sw.WriteLine("public class Enums");                      sw.WriteLine("{");                      sw.Indent();                  }                    // Build a dictionary of which functions use which enums                  var enum_counts = new Dictionary<Enum' List<Function>>();                  foreach (var e in enums.Values)                  {                      // Initialize the dictionary                      enum_counts.Add(e' new List<Function>());                  }                  foreach (var wrapper in wrappers.Values.SelectMany(w => w))                  {                      // Add every function to every enum parameter it references                      foreach (var parameter in wrapper.Parameters.Where(p => p.IsEnum))                      {                          var e = enums[parameter.CurrentType];                          var list = enum_counts[e];                          list.Add(wrapper);                      }                  }                    foreach (Enum @enum in enums.Values)                  {                      if (!Settings.IsEnabled(Settings.Legacy.NoDocumentation))                      {                          // Document which functions use this enum.                          var functions = enum_counts[@enum]                              .Select(w => Settings.GLClass + (w.Extension != "Core" ? ("." + w.Extension) : "") + "." + w.TrimmedName)                              .Distinct();                            sw.WriteLine("/// <summary>");                          sw.WriteLine(String.Format("/// {0}"'                              functions.Count() >= 3 ?                                  String.Format("Used in {0} and {1} other function{2}"'                                      String.Join("' "' functions.Take(2).ToArray())'                                      functions.Count() - 2'                                      functions.Count() - 2 > 1 ? "s" : "") :                              functions.Count() >= 1 ?                                  String.Format("Used in {0}"'                                      String.Join("' "' functions.ToArray())) :                                  "Not used directly."));                          sw.WriteLine("/// </summary>");                      }                        if (@enum.IsFlagCollection)                          sw.WriteLine("[Flags]");                      sw.WriteLine("public enum " + @enum.Name + " : " + @enum.Type);                      sw.WriteLine("{");                      sw.Indent();                      WriteConstants(sw' @enum.ConstantCollection.Values);                      sw.Unindent();                      sw.WriteLine("}");                      sw.WriteLine();                  }                    if ((Settings.Compatibility & Settings.Legacy.NestedEnums) != Settings.Legacy.None &&                      !String.IsNullOrEmpty(Settings.NestedEnumsClass))                  {                      sw.Unindent();                      sw.WriteLine("}");                  }              }              else              {                  // Tao legacy mode: dump all enums as constants in GLClass.                  foreach (Constant c in enums[Settings.CompleteEnumName].ConstantCollection.Values)                  {                      // Print constants avoiding circular definitions                      if (c.Name != c.Value)                      {                          sw.WriteLine(String.Format(                              "public const int {0} = {2}((int){1});"'                              c.Name.StartsWith(Settings.ConstantPrefix) ? c.Name : Settings.ConstantPrefix + c.Name'                              Char.IsDigit(c.Value[0]) ? c.Value : c.Value.StartsWith(Settings.ConstantPrefix) ? c.Value : Settings.ConstantPrefix + c.Value'                              c.Unchecked ? "unchecked" : ""));                      }                      else                      {                      }                  }              }
Magic Number,Bind,CSharpSpecWriter,C:\repos\thefiddler_opentk\Source\Bind\CSharpSpecWriter.cs,GetDeclarationString,The following statement contains a magic number: if (parameters.Count > 0)              {                  foreach (Parameter p in parameters)                  {                      sb.Append(GetDeclarationString(p' false' settings));                      sb.Append("' ");                  }                  sb.Replace("' "' ")"' sb.Length - 2' 2);              }              else              {                  sb.Append(")");              }
Magic Number,Bind,CSharpSpecWriter,C:\repos\thefiddler_opentk\Source\Bind\CSharpSpecWriter.cs,GetDeclarationString,The following statement contains a magic number: if (parameters.Count > 0)              {                  foreach (Parameter p in parameters)                  {                      sb.Append(GetDeclarationString(p' false' settings));                      sb.Append("' ");                  }                  sb.Replace("' "' ")"' sb.Length - 2' 2);              }              else              {                  sb.Append(")");              }
Magic Number,Bind,FuncProcessor,C:\repos\thefiddler_opentk\Source\Bind\FuncProcessor.cs,TranslateType,The following statement contains a magic number: if (type.Pointer >= 3)              {                  System.Diagnostics.Trace.WriteLine(String.Format(                      "[Error] Type '{0}' has a high pointer level. Bindings will be incorrect."'                      type));              }
Magic Number,Bind,FuncProcessor,C:\repos\thefiddler_opentk\Source\Bind\FuncProcessor.cs,TranslateExtension,The following statement contains a magic number: if (extension.Length > 2)              {                  extension = extension[0] + extension.Substring(1).ToLower();              }
Magic Number,Bind,FuncProcessor,C:\repos\thefiddler_opentk\Source\Bind\FuncProcessor.cs,TranslateParameter,The following statement contains a magic number: if (p.CurrentType.ToLower() == "string" && p.Pointer >= 1)              {                  // string* -> [In] String[]                  // [Out] StringBuilder[] parameter is not currently supported                  // Higher indirection levels are also not supported                  if (p.Flow == FlowDirection.Out)                  {                      throw new NotSupportedException("[Out] String* parameters are not currently supported.");                  }                  if (p.Pointer >= 2)                  {                      throw new NotSupportedException("String arrays with arity >= 2 are not currently supported.");                  }                    p.QualifiedType = "IntPtr";                  p.Pointer = 0;                  p.Array = 0;                  p.WrapperType |= WrapperTypes.StringArrayParameter;              }
Magic Number,Bind,FuncProcessor,C:\repos\thefiddler_opentk\Source\Bind\FuncProcessor.cs,CreateConvenienceOverloads,The following statement contains a magic number: foreach (var d in wrappers.Values.SelectMany(w => w))              {                  if (d.Parameters.Count > 0 && d.Parameters.Count <= 2)                  {                      var p = d.Parameters.Last();                      var r = d.ReturnType;                        var name = d.Name;                        bool is_candidate = true;                      is_candidate &=                          name.StartsWith("Get") || name.StartsWith("Gen") ||                          name.StartsWith("Delete") || name.StartsWith("New");                      is_candidate &= p.Pointer > 0;                      // if there is a specific count set' such as "4"' then this function                      // returns a vector of specific dimensions and it would be wrong                      // to generate an overload that returns a value of different size.                      is_candidate &= p.ElementCount == 0 || p.ElementCount == 1;                      is_candidate &= r.CurrentType == "void" && r.Pointer == 0;                        Function f = null;                      if (is_candidate && p.Flow == FlowDirection.Out)                      {                          // Match Gen*|Get*|New*([Out] int[] names) methods                          f = CreateReturnTypeConvenienceWrapper(d);                      }                      else if (is_candidate && p.Flow != FlowDirection.Out)                      {                          // Match *Delete(int count' int[] names) methods                          if (d.Parameters.Count == 2)                          {                              f = CreateArrayReturnTypeConvenienceWrapper(d);                          }                      }                        if (f != null)                      {                          // If we have a convenience overload' we should turn its name from plural into singular                          f.TrimmedName = f.TrimmedName.Replace("Queries"' "Query").TrimEnd('s');                            convenience_wrappers.Add(f);                      }                  }              }
Magic Number,Bind,FuncProcessor,C:\repos\thefiddler_opentk\Source\Bind\FuncProcessor.cs,CreateConvenienceOverloads,The following statement contains a magic number: foreach (var d in wrappers.Values.SelectMany(w => w))              {                  if (d.Parameters.Count > 0 && d.Parameters.Count <= 2)                  {                      var p = d.Parameters.Last();                      var r = d.ReturnType;                        var name = d.Name;                        bool is_candidate = true;                      is_candidate &=                          name.StartsWith("Get") || name.StartsWith("Gen") ||                          name.StartsWith("Delete") || name.StartsWith("New");                      is_candidate &= p.Pointer > 0;                      // if there is a specific count set' such as "4"' then this function                      // returns a vector of specific dimensions and it would be wrong                      // to generate an overload that returns a value of different size.                      is_candidate &= p.ElementCount == 0 || p.ElementCount == 1;                      is_candidate &= r.CurrentType == "void" && r.Pointer == 0;                        Function f = null;                      if (is_candidate && p.Flow == FlowDirection.Out)                      {                          // Match Gen*|Get*|New*([Out] int[] names) methods                          f = CreateReturnTypeConvenienceWrapper(d);                      }                      else if (is_candidate && p.Flow != FlowDirection.Out)                      {                          // Match *Delete(int count' int[] names) methods                          if (d.Parameters.Count == 2)                          {                              f = CreateArrayReturnTypeConvenienceWrapper(d);                          }                      }                        if (f != null)                      {                          // If we have a convenience overload' we should turn its name from plural into singular                          f.TrimmedName = f.TrimmedName.Replace("Queries"' "Query").TrimEnd('s');                            convenience_wrappers.Add(f);                      }                  }              }
Magic Number,Bind,FuncProcessor,C:\repos\thefiddler_opentk\Source\Bind\FuncProcessor.cs,CreateArrayReturnTypeConvenienceWrapper,The following statement contains a magic number: var p_size = f.Parameters[f.Parameters.Count - 2];
Magic Number,Bind,FuncProcessor,C:\repos\thefiddler_opentk\Source\Bind\FuncProcessor.cs,CreateArrayReturnTypeConvenienceWrapper,The following statement contains a magic number: f.Parameters.RemoveAt(f.Parameters.Count - 2);
Magic Number,Bind,FuncProcessor,C:\repos\thefiddler_opentk\Source\Bind\FuncProcessor.cs,WrapParameters,The following statement contains a magic number: foreach (var wrapper in wrappers.Values.SelectMany(v => v))              {                  // Add generic 'ref T' wrapper                  Function generic_wrapper = null;                  for (int i = 0; i < wrapper.Parameters.Count; i++)                  {                      var parameter = wrapper.Parameters[i];                      if ((parameter.WrapperType & WrapperTypes.GenericParameter) != 0)                      {                          generic_wrapper = generic_wrapper ?? new Function(wrapper);                          var p = generic_wrapper.Parameters[i];                            p.Reference = true;                          p.Pointer = 0;                          p.Array = 0;                          p.Generic = true;                          p.QualifiedType = "T" + i.ToString();                          p.Flow = FlowDirection.Undefined;                      }                  }                  if (generic_wrapper != null)                  {                      list.Add(generic_wrapper);                  }                    // Add the following wrappers:                  // 'IntPtr'' 'T[]'' 'T[']' and 'T['']'                  for (int arity = 0; arity < 4; arity++)                  {                      generic_wrapper = null;                      for (int i = 0; i < wrapper.Parameters.Count; i++)                      {                          var parameter = wrapper.Parameters[i];                          if ((parameter.WrapperType & WrapperTypes.GenericParameter) != 0)                          {                              generic_wrapper = generic_wrapper ?? new Function(wrapper);                              if (arity > 0)                              {                                  // Overloading on array arity is not CLS-compliant                                  generic_wrapper.CLSCompliant = false;                              }                              var p = generic_wrapper.Parameters[i];                                p.Reference = false;                              p.Pointer = 0;                              p.Array = arity;                              if (arity == 0)                              {                                  p.QualifiedType = "IntPtr";                              }                              else                              {                                  p.Generic = true;                                  p.QualifiedType = "T" + i.ToString();                                  p.Flow = FlowDirection.Undefined;                              }                          }                      }                      if (generic_wrapper != null)                      {                          list.Add(generic_wrapper);                      }                  }              }
Magic Number,Bind,JavaSpecWriter,C:\repos\thefiddler_opentk\Source\Bind\JavaSpecWriter.cs,GenerateParameterString,The following statement contains a magic number: if (f.Parameters.Count > 0)              {                  foreach (var p in f.Parameters)                  {                      if (p.Reference)                      {                          // Use a boxed type instead of primitives (i.e. "Byte" rather than "byte")' since                          // the former are reference types. We don't need to do anything for regular reference                          // types.                          // Hack: we do this by upper-casing the first letter of the type. This should work for                          // all primitive types' but won't work for enums and other reference types. In these                          // cases' we'll just ignore the reference overload.                          if (Char.IsLower(p.CurrentType[0]))                          {                              // Hack: Int -> Integer and Bool -> Boolean                              if (p.CurrentType == "int")                                  sb.Append("Integer");                              else if (p.CurrentType == "bool")                                  sb.Append("Boolean");                              else                                  sb.Append(Char.ToUpper(p.CurrentType[0]) + p.CurrentType.Substring(1));                          }                          else                          {                              valid = false;                              return String.Empty;                          }                      }                      else if (p.Array > 0)                      {                          // Generic arrays are handled in the IntPtr case below.                          if (p.Generic)                          {                              valid = false;                              return String.Empty;                          }                            sb.Append(p.CurrentType);                          for (int i = 0; i < p.Array; i++)                              sb.Append("[]");                      }                      else if (p.Pointer > 0)                      {                          // Java does not support pointers                          // Todo: maybe use one of the java.nio.* pointer classes?                          valid = false;                          return String.Empty;                      }                      else if (p.CurrentType == "IntPtr")                      {                          sb.Append("Buffer");                      }                      else                      {                          sb.Append(p.CurrentType);                      }                        sb.Append(" ");                      sb.Append(p.Name);                      sb.Append("' ");                  }                    if (f.Parameters.Count > 0)                      sb.Remove(sb.Length - 2' 2);              }
Magic Number,Bind,JavaSpecWriter,C:\repos\thefiddler_opentk\Source\Bind\JavaSpecWriter.cs,GenerateParameterString,The following statement contains a magic number: if (f.Parameters.Count > 0)              {                  foreach (var p in f.Parameters)                  {                      if (p.Reference)                      {                          // Use a boxed type instead of primitives (i.e. "Byte" rather than "byte")' since                          // the former are reference types. We don't need to do anything for regular reference                          // types.                          // Hack: we do this by upper-casing the first letter of the type. This should work for                          // all primitive types' but won't work for enums and other reference types. In these                          // cases' we'll just ignore the reference overload.                          if (Char.IsLower(p.CurrentType[0]))                          {                              // Hack: Int -> Integer and Bool -> Boolean                              if (p.CurrentType == "int")                                  sb.Append("Integer");                              else if (p.CurrentType == "bool")                                  sb.Append("Boolean");                              else                                  sb.Append(Char.ToUpper(p.CurrentType[0]) + p.CurrentType.Substring(1));                          }                          else                          {                              valid = false;                              return String.Empty;                          }                      }                      else if (p.Array > 0)                      {                          // Generic arrays are handled in the IntPtr case below.                          if (p.Generic)                          {                              valid = false;                              return String.Empty;                          }                            sb.Append(p.CurrentType);                          for (int i = 0; i < p.Array; i++)                              sb.Append("[]");                      }                      else if (p.Pointer > 0)                      {                          // Java does not support pointers                          // Todo: maybe use one of the java.nio.* pointer classes?                          valid = false;                          return String.Empty;                      }                      else if (p.CurrentType == "IntPtr")                      {                          sb.Append("Buffer");                      }                      else                      {                          sb.Append(p.CurrentType);                      }                        sb.Append(" ");                      sb.Append(p.Name);                      sb.Append("' ");                  }                    if (f.Parameters.Count > 0)                      sb.Remove(sb.Length - 2' 2);              }
Magic Number,Bind,JavaSpecWriter,C:\repos\thefiddler_opentk\Source\Bind\JavaSpecWriter.cs,GenerateGenericTypeString,The following statement contains a magic number: if (parameters.Count() > 0)              {                  var sb = new StringBuilder();                  foreach (var p in f.Parameters.Where(p => p.Generic))                  {                      sb.Append(p.CurrentType);                      sb.Append("' ");                  }                  if (parameters.Count() > 0)                      sb.Remove(sb.Length - 2' 2);                    return sb.ToString();              }
Magic Number,Bind,JavaSpecWriter,C:\repos\thefiddler_opentk\Source\Bind\JavaSpecWriter.cs,GenerateGenericTypeString,The following statement contains a magic number: if (parameters.Count() > 0)              {                  var sb = new StringBuilder();                  foreach (var p in f.Parameters.Where(p => p.Generic))                  {                      sb.Append(p.CurrentType);                      sb.Append("' ");                  }                  if (parameters.Count() > 0)                      sb.Remove(sb.Length - 2' 2);                    return sb.ToString();              }
Magic Number,Bind,MainClass,C:\repos\thefiddler_opentk\Source\Bind\Main.cs,Main,The following statement contains a magic number: try              {                  switch (mode)                  {                      case GeneratorMode.All:                          Console.WriteLine("Using 'all' generator mode.");                          Console.WriteLine("Use '-mode:all/gl2/gl4/es10/es11/es20/es30' to select a specific mode.");                          Generators.Add(new GL2Generator(Settings' dirName));                          Generators.Add(new GL4Generator(Settings' dirName));                          Generators.Add(new ESGenerator(Settings' dirName));                          Generators.Add(new ES2Generator(Settings' dirName));                          Generators.Add(new ES3Generator(Settings' dirName));                          break;                        case GeneratorMode.GL2:                          Generators.Add(new GL2Generator(Settings' dirName));                          break;                        case GeneratorMode.GL3:                      case GeneratorMode.GL4:                          Generators.Add(new GL4Generator(Settings' dirName));                          break;                        case GeneratorMode.ES10:                          Generators.Add(new ESGenerator(Settings' dirName));                          break;                                            case GeneratorMode.ES11:                          Generators.Add(new ESGenerator(Settings' dirName));                          break;                                            case GeneratorMode.ES20:                          Generators.Add(new ES2Generator(Settings' dirName));                          break;                        case GeneratorMode.ES30:                          Generators.Add(new ES3Generator(Settings' dirName));                          break;                        case GeneratorMode.CL10:                          Generators.Add(new CLGenerator(Settings' dirName));                          break;                                            default:                          Console.WriteLine("Please specify a generator mode (use '-mode:gl2/gl4/es10/es11/es20/es30')");                          return;                  }                    foreach (var generator in Generators)                  {                      long ticks = DateTime.Now.Ticks;                        generator.Process();                        ISpecWriter writer = null;                      switch (generator.Settings.Language)                      {                          case GeneratorLanguage.Cpp:                              writer = new CppSpecWriter();                              break;                            case GeneratorLanguage.Java:                              writer = new JavaSpecWriter();                              break;                            case GeneratorLanguage.CSharp:                          default:                              writer = new CSharpSpecWriter();                              break;                      }                      writer.WriteBindings(generator);                        ticks = DateTime.Now.Ticks - ticks;                        Console.WriteLine();                      Console.WriteLine("Bindings generated in {0} seconds."' ticks / (double)10000000.0);                  }                                    Console.WriteLine();                  if (Debugger.IsAttached)                  {                      Console.WriteLine("Press any key to continue...");                      Console.ReadKey(true);                  }              }              catch (SecurityException e)              {                  Console.WriteLine("Security violation \"{0}\" in method \"{1}\"."' e.Message' e.Method);                  Console.WriteLine("This application does not have permission to take the requested actions.");              }              catch (NotImplementedException e)              {                  Console.WriteLine(e.Message);                  Console.WriteLine("The requested functionality is not implemented yet.");              }
Magic Number,Bind,DocProcessor,C:\repos\thefiddler_opentk\Source\Bind\DocProcessor.cs,ProcessFile,The following statement contains a magic number: while (m.Length > 0)              {                  string removed = text.Substring(m.Index' m.Length);                  text = text.Remove(m.Index' m.Length);                  int equation = removed.IndexOf("eqn");                  if (equation > 0)                  {                      // Find the start and end of the equation string                      int eqn_start = equation + 4;                      int eqn_end = removed.IndexOf(":-->") - equation - 4;                      if (eqn_end < 0)                      {                          // Note: a few docs from man4 delimit eqn end with ": -->"                          eqn_end = removed.IndexOf(": -->") - equation - 4;                      }                      if (eqn_end < 0)                      {                          Console.WriteLine("[Warning] Failed to find equation for mml.");                          goto next;                      }                        string eqn_substring = removed.Substring(eqn_start' eqn_end);                      text = text.Insert(m.Index' "<![CDATA[" + eqn_substring + "]]>");                  }                next:                  m = remove_mathml.Match(text);              }
Magic Number,Bind,DocProcessor,C:\repos\thefiddler_opentk\Source\Bind\DocProcessor.cs,ProcessFile,The following statement contains a magic number: while (m.Length > 0)              {                  string removed = text.Substring(m.Index' m.Length);                  text = text.Remove(m.Index' m.Length);                  int equation = removed.IndexOf("eqn");                  if (equation > 0)                  {                      // Find the start and end of the equation string                      int eqn_start = equation + 4;                      int eqn_end = removed.IndexOf(":-->") - equation - 4;                      if (eqn_end < 0)                      {                          // Note: a few docs from man4 delimit eqn end with ": -->"                          eqn_end = removed.IndexOf(": -->") - equation - 4;                      }                      if (eqn_end < 0)                      {                          Console.WriteLine("[Warning] Failed to find equation for mml.");                          goto next;                      }                        string eqn_substring = removed.Substring(eqn_start' eqn_end);                      text = text.Insert(m.Index' "<![CDATA[" + eqn_substring + "]]>");                  }                next:                  m = remove_mathml.Match(text);              }
Magic Number,Bind,DocProcessor,C:\repos\thefiddler_opentk\Source\Bind\DocProcessor.cs,ProcessFile,The following statement contains a magic number: while (m.Length > 0)              {                  string removed = text.Substring(m.Index' m.Length);                  text = text.Remove(m.Index' m.Length);                  int equation = removed.IndexOf("eqn");                  if (equation > 0)                  {                      // Find the start and end of the equation string                      int eqn_start = equation + 4;                      int eqn_end = removed.IndexOf(":-->") - equation - 4;                      if (eqn_end < 0)                      {                          // Note: a few docs from man4 delimit eqn end with ": -->"                          eqn_end = removed.IndexOf(": -->") - equation - 4;                      }                      if (eqn_end < 0)                      {                          Console.WriteLine("[Warning] Failed to find equation for mml.");                          goto next;                      }                        string eqn_substring = removed.Substring(eqn_start' eqn_end);                      text = text.Insert(m.Index' "<![CDATA[" + eqn_substring + "]]>");                  }                next:                  m = remove_mathml.Match(text);              }
Magic Number,Bind,EnumProcessor,C:\repos\thefiddler_opentk\Source\Bind\EnumProcessor.cs,TranslateConstantValue,The following statement contains a magic number: if (value.ToLower().StartsWith("0x"))              {                  // Trim the unsigned or long specifiers used in C constants ('u' or 'ull').                  if (value.ToLower().EndsWith("ull"))                      value = value.Substring(0' value.Length - 3);                  if (value.ToLower().EndsWith("u"))                      value = value.Substring(0' value.Length - 1);              }
Magic Number,Bind,Utilities,C:\repos\thefiddler_opentk\Source\Bind\Utilities.cs,GetGL2Extension,The following statement contains a magic number: if (match.Success)              {                  string ext = match.Value;                  if (ext.Length > 2)                  {                      ext = ext[0] + ext.Substring(1).ToLower();                  }                  return ext;              }              else              {                  return String.Empty;              }
Magic Number,Bind,Utilities,C:\repos\thefiddler_opentk\Source\Bind\Utilities.cs,RequiresSlot,The following statement contains a magic number: return                  !settings.IsEnabled(Settings.Legacy.UseDllImports) ||                  (settings.IsEnabled(Settings.Legacy.UseWindowsCompatibleGL) && version > 1.1) ||                  d.Extension != "Core";
Magic Number,Bind,XmlSpecReader,C:\repos\thefiddler_opentk\Source\Bind\XmlSpecReader.cs,ReadTypeMap,The following statement contains a magic number: using (var sr = new StreamReader(file))              {                  Console.WriteLine("Reading opengl types.");                  Dictionary<string' string> GLTypes = new Dictionary<string' string>();                    if (sr == null)                      return GLTypes;                    do                  {                      string line = sr.ReadLine();                        if (String.IsNullOrEmpty(line) || line.StartsWith("#"))                          continue;                        string[] words = line.Split(" '*\t".ToCharArray()' StringSplitOptions.RemoveEmptyEntries);                        if (words[0].ToLower() == "void")                      {                          // Special case for "void" -> "". We make it "void" -> "void"                          GLTypes.Add(words[0]' "void");                      }                      else if (words[0] == "VoidPointer" || words[0] == "ConstVoidPointer")                      {                          // "(Const)VoidPointer" -> "void*"                          GLTypes.Add(words[0]' "void*");                      }                      else if (words[0] == "CharPointer" || words[0] == "charPointerARB" ||                               words[0] == "ConstCharPointer")                      {                          // The typematching logic cannot handle pointers to pointers' e.g. CharPointer* -> char** -> string* -> string[].                          // Hence we give it a push.                          // Note: When both CurrentType == "String" and Pointer == true' the typematching is hardcoded to use                          // String[] or StringBuilder[].                          GLTypes.Add(words[0]' "String");                      }                      /*else if (words[0].Contains("Pointer"))                      {                          GLTypes.Add(words[0]' words[1].Replace("Pointer"' "*"));                      }*/                      else if (words[1].Contains("GLvoid"))                      {                          GLTypes.Add(words[0]' "void");                      }                      else if (words[1] == "const" && words[2] == "GLubyte")                      {                          GLTypes.Add(words[0]' "String");                      }                      else if (words[1] == "struct")                      {                          GLTypes.Add(words[0]' words[2]);                      }                      else                      {                          GLTypes.Add(words[0]' words[1]);                      }                  }                  while (!sr.EndOfStream);                    return GLTypes;              }
Magic Number,Bind,XmlSpecReader,C:\repos\thefiddler_opentk\Source\Bind\XmlSpecReader.cs,ReadTypeMap,The following statement contains a magic number: using (var sr = new StreamReader(file))              {                  Console.WriteLine("Reading opengl types.");                  Dictionary<string' string> GLTypes = new Dictionary<string' string>();                    if (sr == null)                      return GLTypes;                    do                  {                      string line = sr.ReadLine();                        if (String.IsNullOrEmpty(line) || line.StartsWith("#"))                          continue;                        string[] words = line.Split(" '*\t".ToCharArray()' StringSplitOptions.RemoveEmptyEntries);                        if (words[0].ToLower() == "void")                      {                          // Special case for "void" -> "". We make it "void" -> "void"                          GLTypes.Add(words[0]' "void");                      }                      else if (words[0] == "VoidPointer" || words[0] == "ConstVoidPointer")                      {                          // "(Const)VoidPointer" -> "void*"                          GLTypes.Add(words[0]' "void*");                      }                      else if (words[0] == "CharPointer" || words[0] == "charPointerARB" ||                               words[0] == "ConstCharPointer")                      {                          // The typematching logic cannot handle pointers to pointers' e.g. CharPointer* -> char** -> string* -> string[].                          // Hence we give it a push.                          // Note: When both CurrentType == "String" and Pointer == true' the typematching is hardcoded to use                          // String[] or StringBuilder[].                          GLTypes.Add(words[0]' "String");                      }                      /*else if (words[0].Contains("Pointer"))                      {                          GLTypes.Add(words[0]' words[1].Replace("Pointer"' "*"));                      }*/                      else if (words[1].Contains("GLvoid"))                      {                          GLTypes.Add(words[0]' "void");                      }                      else if (words[1] == "const" && words[2] == "GLubyte")                      {                          GLTypes.Add(words[0]' "String");                      }                      else if (words[1] == "struct")                      {                          GLTypes.Add(words[0]' words[2]);                      }                      else                      {                          GLTypes.Add(words[0]' words[1]);                      }                  }                  while (!sr.EndOfStream);                    return GLTypes;              }
Magic Number,Bind,XmlSpecReader,C:\repos\thefiddler_opentk\Source\Bind\XmlSpecReader.cs,ReadCSTypeMap,The following statement contains a magic number: using (var sr = new StreamReader(file))              {                  Dictionary<string' string> CSTypes = new Dictionary<string' string>();                  Console.WriteLine("Reading C# types.");                    while (!sr.EndOfStream)                  {                      string line = sr.ReadLine();                      if (String.IsNullOrEmpty(line) || line.StartsWith("#"))                          continue;                        string[] words = line.Split(" '\t".ToCharArray()' StringSplitOptions.RemoveEmptyEntries);                      if (words.Length < 2)                          continue;                        if (((Settings.Compatibility & Settings.Legacy.NoBoolParameters) != Settings.Legacy.None) && words[1] == "bool")                          words[1] = "Int32";                        CSTypes.Add(words[0]' words[1]);                  }                    return CSTypes;              }
Magic Number,Bind.Structures,FunctionBody,C:\repos\thefiddler_opentk\Source\Bind\Structures\Function.cs,Unindent,The following statement contains a magic number: if (indent.Length > 4)                  indent = indent.Substring(4);              else                  indent = String.Empty;
Magic Number,Bind.Structures,FunctionBody,C:\repos\thefiddler_opentk\Source\Bind\Structures\Function.cs,Unindent,The following statement contains a magic number: if (indent.Length > 4)                  indent = indent.Substring(4);              else                  indent = String.Empty;
Magic Number,Bind.Structures,ParameterCollection,C:\repos\thefiddler_opentk\Source\Bind\Structures\Parameter.cs,ToString,The following statement contains a magic number: if (Count > 0)              {                  foreach (Parameter p in this)                  {                      sb.Append(p.ToString());                      sb.Append("' ");                  }                  sb.Replace("' "' ")"' sb.Length - 2' 2);              }              else                  sb.Append(")");
Magic Number,Bind.Structures,ParameterCollection,C:\repos\thefiddler_opentk\Source\Bind\Structures\Parameter.cs,ToString,The following statement contains a magic number: if (Count > 0)              {                  foreach (Parameter p in this)                  {                      sb.Append(p.ToString());                      sb.Append("' ");                  }                  sb.Replace("' "' ")"' sb.Length - 2' 2);              }              else                  sb.Append(")");
Missing Default,Bind,FuncProcessor,C:\repos\thefiddler_opentk\Source\Bind\FuncProcessor.cs,TranslateType,The following switch statement is missing a default case: switch (type.CurrentType.ToLower())                      {                          case "string":                              type.QualifiedType = "String";                              break;                      }
Missing Default,Bind,FuncProcessor,C:\repos\thefiddler_opentk\Source\Bind\FuncProcessor.cs,ApplyParameterReplacement,The following switch statement is missing a default case: switch (node.Name)                              {                                  case "type":                                      d.Parameters[i].CurrentType = (string)node.TypedValue;                                      break;                                  case "name":                                      d.Parameters[i].Name = (string)node.TypedValue;                                      break;                                  case "flow":                                      d.Parameters[i].Flow = Parameter.GetFlowDirection((string)node.TypedValue);                                      break;                                  case "count":                                      int count;                                      if (Int32.TryParse(node.Value' out count))                                          d.Parameters[i].ElementCount = count;                                      break;                              }
Missing Default,Bind,FuncProcessor,C:\repos\thefiddler_opentk\Source\Bind\FuncProcessor.cs,GetCLSCompliantType,The following switch statement is missing a default case: switch (type.CurrentType)                  {                      case "UInt16":                      case "ushort":                          return "Int16";                      case "UInt32":                      case "uint":                          return "Int32";                      case "UInt64":                      case "ulong":                          return "Int64";                      case "SByte":                      case "sbyte":                          return "Byte";                      case "UIntPtr":                          return "IntPtr";                  }
Missing Default,Bind,MainClass,C:\repos\thefiddler_opentk\Source\Bind\Main.cs,Main,The following switch statement is missing a default case: switch (val)                                  {                                      case "tao": settings |= Settings.Legacy.Tao; break;                                      case "simple_enums": settings |= Settings.Legacy.NoAdvancedEnumProcessing; break;                                      case "safe": settings |= Settings.Legacy.NoPublicUnsafeFunctions; break;                                      case "permutations": settings |= Settings.Legacy.GenerateAllPermutations; break;                                      case "enums_in_class": settings |= Settings.Legacy.NestedEnums; break;                                      case "nodocs": settings |= Settings.Legacy.NoDocumentation; break;                                      case "keep_untyped_enums": settings |= Settings.Legacy.KeepUntypedEnums; break;                                  }
Missing Default,Bind,EnumProcessor,C:\repos\thefiddler_opentk\Source\Bind\EnumProcessor.cs,ReplaceConstant,The following switch statement is missing a default case: switch (node.Name)                          {                              case "name": c.Name = (string)node.TypedValue; break;                              case "value": c.Value = (string)node.TypedValue; break;                              case "reference": c.Reference = (string)node.TypedValue; break;                          }
Missing Default,Bind,XmlSpecReader,C:\repos\thefiddler_opentk\Source\Bind\XmlSpecReader.cs,ReadDelegates,The following switch statement is missing a default case: switch (param.Name)                      {                          case "returns":                              d.ReturnType.CurrentType = param.GetAttribute("type"' String.Empty).Trim();                              break;                            case "param":                              Parameter p = new Parameter();                              p.CurrentType = param.GetAttribute("type"' String.Empty).Trim();                              p.Name = param.GetAttribute("name"' String.Empty).Trim();                                string element_count = param.GetAttribute("elementcount"' String.Empty).Trim();                              if (String.IsNullOrEmpty(element_count))                              {                                  element_count = param.GetAttribute("count"' String.Empty).Trim();                                  if (!String.IsNullOrEmpty(element_count))                                  {                                      int count;                                      if (Int32.TryParse(element_count' out count))                                      {                                          p.ElementCount = count;                                      }                                  }                              }                                                            p.ComputeSize = param.GetAttribute("count"' String.Empty).Trim();                              if (p.ComputeSize.StartsWith("COMPSIZE"))                              {                                  //remove the compsize hint' just keep comma delimited param names                                  var len = "COMPSIZE(".Length;                                  p.ComputeSize = p.ComputeSize.Substring(len' (p.ComputeSize.Length - len) - 1);                              }                                p.Flow = Parameter.GetFlowDirection(param.GetAttribute("flow"' String.Empty).Trim());                                d.Parameters.Add(p);                              break;                      }
