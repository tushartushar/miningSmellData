Implementation smell,Namespace,Class,File,Method,Description
Long Method,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The method has 124 lines of code.
Complex Method,PdfSharp.Charting.Renderers,AxisTitleRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AxisTitleRenderer.cs,Draw,Cyclomatic complexity of the method is 39
Complex Method,PdfSharp.Charting.Renderers,BarClusteredPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\BarClusteredPlotAreaRenderer.cs,CalcBars,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Charting.Renderers,BarDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\BarDataLabelRenderer.cs,Format,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Charting.Renderers,BarDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\BarDataLabelRenderer.cs,CalcPositions,Cyclomatic complexity of the method is 21
Complex Method,PdfSharp.Charting.Renderers,BarGridlinesRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\BarGridlinesRenderer.cs,Draw,Cyclomatic complexity of the method is 9
Complex Method,PdfSharp.Charting.Renderers,BarPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\BarPlotAreaRenderer.cs,Draw,Cyclomatic complexity of the method is 10
Complex Method,PdfSharp.Charting.Renderers,BarStackedPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\BarStackedPlotAreaRenderer.cs,CalcBars,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Charting.Renderers,ChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ChartRenderer.cs,LayoutLegend,Cyclomatic complexity of the method is 25
Complex Method,PdfSharp.Charting.Renderers,ColumnClusteredPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ColumnClusteredPlotAreaRenderer.cs,CalcColumns,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Charting.Renderers,ColumnDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ColumnDataLabelRenderer.cs,Format,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Charting.Renderers,ColumnDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ColumnDataLabelRenderer.cs,CalcPositions,Cyclomatic complexity of the method is 21
Complex Method,PdfSharp.Charting.Renderers,ColumnLikeGridlinesRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ColumnLikeGridlinesRenderer.cs,Draw,Cyclomatic complexity of the method is 9
Complex Method,PdfSharp.Charting.Renderers,ColumnPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ColumnPlotAreaRenderer.cs,Draw,Cyclomatic complexity of the method is 10
Complex Method,PdfSharp.Charting.Renderers,ColumnStackedPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ColumnStackedPlotAreaRenderer.cs,CalcColumns,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Charting.Renderers,CombinationChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\CombinationChartRenderer.cs,DistributeSeries,Cyclomatic complexity of the method is 15
Complex Method,PdfSharp.Charting.Renderers,DataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\DataLabelRenderer.cs,Init,Cyclomatic complexity of the method is 9
Complex Method,PdfSharp.Charting.Renderers,HorizontalStackedYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalStackedYAxisRenderer.cs,CalcYAxis,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Charting.Renderers,HorizontalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalXAxisRenderer.cs,Draw,Cyclomatic complexity of the method is 14
Complex Method,PdfSharp.Charting.Renderers,HorizontalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalXAxisRenderer.cs,GetTickMarkPos,Cyclomatic complexity of the method is 31
Complex Method,PdfSharp.Charting.Renderers,HorizontalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalYAxisRenderer.cs,Draw,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Charting.Renderers,HorizontalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalYAxisRenderer.cs,GetTickMarkPos,Cyclomatic complexity of the method is 31
Complex Method,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,Cyclomatic complexity of the method is 74
Complex Method,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,CalcPositions,Cyclomatic complexity of the method is 33
Complex Method,PdfSharp.Charting.Renderers,VerticalStackedYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalStackedYAxisRenderer.cs,CalcYAxis,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Charting.Renderers,VerticalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalXAxisRenderer.cs,Draw,Cyclomatic complexity of the method is 10
Complex Method,PdfSharp.Charting.Renderers,VerticalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalXAxisRenderer.cs,GetTickMarkPos,Cyclomatic complexity of the method is 31
Complex Method,PdfSharp.Charting.Renderers,VerticalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalYAxisRenderer.cs,Draw,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Charting.Renderers,VerticalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalYAxisRenderer.cs,GetTickMarkPos,Cyclomatic complexity of the method is 31
Complex Method,PdfSharp.Charting.Renderers,YAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\YAxisRenderer.cs,FineTuneYAxis,Cyclomatic complexity of the method is 16
Complex Method,PdfSharp.Charting,Chart,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting\Chart.cs,DeepCopy,Cyclomatic complexity of the method is 8
Complex Method,PdfSharp.Charting,ChartFrame,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting\ChartFrame.cs,GetChartRenderer,Cyclomatic complexity of the method is 10
Long Parameter List,PdfSharp.Charting.Renderers,HorizontalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalXAxisRenderer.cs,GetTickMarkPos,The method has 5 parameters.
Long Parameter List,PdfSharp.Charting.Renderers,HorizontalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalYAxisRenderer.cs,GetTickMarkPos,The method has 5 parameters.
Long Parameter List,PdfSharp.Charting.Renderers,RendererParameters,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\RendererParameters.cs,RendererParameters,The method has 5 parameters.
Long Parameter List,PdfSharp.Charting.Renderers,VerticalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalXAxisRenderer.cs,GetTickMarkPos,The method has 5 parameters.
Long Parameter List,PdfSharp.Charting.Renderers,VerticalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalYAxisRenderer.cs,GetTickMarkPos,The method has 5 parameters.
Long Statement,PdfSharp.Charting.Renderers,AxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AxisRenderer.cs,InitAxisLineFormat,The length of the statement  "		rendererInfo.MinorTickMarkLineFormat = Converter.ToXPen (rendererInfo.axis.lineFormat' XColors.Black' DefaultMinorTickMarkLineWidth); " is 133.
Long Statement,PdfSharp.Charting.Renderers,AxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AxisRenderer.cs,InitAxisLineFormat,The length of the statement  "		rendererInfo.MajorTickMarkLineFormat = Converter.ToXPen (rendererInfo.axis.lineFormat' XColors.Black' DefaultMajorTickMarkLineWidth); " is 133.
Long Statement,PdfSharp.Charting.Renderers,AxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AxisRenderer.cs,InitGridlines,The length of the statement  "		rendererInfo.MinorGridlinesLineFormat = Converter.ToXPen (rendererInfo.axis.minorGridlines.lineFormat' XColors.Black' DefaultGridLineWidth); " is 140.
Long Statement,PdfSharp.Charting.Renderers,AxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AxisRenderer.cs,InitGridlines,The length of the statement  "		rendererInfo.MajorGridlinesLineFormat = Converter.ToXPen (rendererInfo.axis.majorGridlines.lineFormat' XColors.Black' DefaultGridLineWidth); " is 140.
Long Statement,PdfSharp.Charting.Renderers,BarPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\BarPlotAreaRenderer.cs,Format,The length of the statement  "	cri.plotAreaRendererInfo.matrix.Scale (plotAreaBox.Width / (yMax - yMin)' plotAreaBox.Height / (xMax - xMin)' XMatrixOrder.Append); " is 131.
Long Statement,PdfSharp.Charting.Renderers,ColumnLikePlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ColumnLikePlotAreaRenderer.cs,Format,The length of the statement  "	cri.plotAreaRendererInfo.matrix.Scale (plotAreaBox.Width / xMax' plotAreaBox.Height / (yMax - yMin)' XMatrixOrder.Append); " is 122.
Long Statement,PdfSharp.Charting.Renderers,HorizontalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalXAxisRenderer.cs,Draw,The length of the statement  "	//XPoint startPos = new XPoint(xari.X + tickLabelStep / 2' xari.Y + /*xari.TickLabelsHeight +*/ xari.MajorTickMarkWidth); " is 121.
Long Statement,PdfSharp.Charting.Renderers,HorizontalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalXAxisRenderer.cs,Draw,The length of the statement  "		XRect rect = new XRect (xari.Rect.Right / 2 - atri.AxisTitleSize.Width / 2' xari.Rect.Bottom' atri.AxisTitleSize.Width' 0); " is 123.
Long Statement,PdfSharp.Charting.Renderers,LineChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\LineChartRenderer.cs,InitSeries,The length of the statement  "			sri.LineFormat = Converter.ToXPen (sri.series.lineFormat' LineColors.Item (seriesIndex)' ChartRenderer.DefaultSeriesLineWidth); " is 127.
Long Statement,PdfSharp.Charting.Renderers,LineChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\LineChartRenderer.cs,InitSeries,The length of the statement  "			sri.LineFormat = Converter.ToXPen (sri.series.lineFormat' sri.series.markerBackgroundColor' ChartRenderer.DefaultSeriesLineWidth); " is 130.
Long Statement,PdfSharp.Charting.Renderers,PieExplodedPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieExplodedPlotAreaRenderer.cs,CalcSectors,The length of the statement  "	double midAngle = 0' sectorStartAngle = 0' sectorSweepAngle = 0' deltaAngle = 2' startAngle = 270' sweepAngle = 0' rInnerCircle = pieRect.Width / 15' rOuterCircle = pieRect.Width / 2; " is 183.
Long Statement,PdfSharp.Charting.Renderers,VerticalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalXAxisRenderer.cs,Draw,The length of the statement  "			gfx.DrawString (tickLabel' xari.TickLabelsFont' xari.TickLabelsBrush' startPos.X - size.Width' startPos.Y + size.Height / 2); " is 125.
Long Statement,PdfSharp.Charting,ChartFrame,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting\ChartFrame.cs,Draw,The length of the statement  "	gfx.DrawRoundedRectangle (XBrushes.Gainsboro' this.location.X + dx' this.location.Y + dy' this.size.Width' this.size.Height' 20' 20); " is 133.
Long Statement,PdfSharp.Charting,ChartFrame,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting\ChartFrame.cs,Draw,The length of the statement  "	XLinearGradientBrush brush = new XLinearGradientBrush (chartRect' XColor.FromArgb (0xFFD0DEEF)' XColors.White' XLinearGradientMode.Vertical); " is 141.
Long Statement,PdfSharp.Charting,ChartFrame,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting\ChartFrame.cs,Draw,The length of the statement  "	gfx.DrawRoundedRectangle (penBorder' brush' this.location.X' this.location.Y' this.size.Width' this.size.Height' 15' 15); " is 121.
Long Statement,PdfSharp.Charting,ChartFrame,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting\ChartFrame.cs,Draw,The length of the statement  "	XRect rect = new XRect (dxChart' dyChart' this.size.Width - 2 * dxChart' (this.size.Height - (charts - 1) * dyBetweenCharts - 2 * dyChart) / charts); " is 149.
Complex Conditional,PdfSharp.Charting.Renderers,DataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\DataLabelRenderer.cs,Init,The conditional expression  "cri.chart.hasDataLabel || cri.chart.dataLabel != null || sri.series.hasDataLabel || sri.series.dataLabel != null"  is complex.
Magic Number,PdfSharp.Charting.Renderers,AreaPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AreaPlotAreaRenderer.cs,Draw,The following statement contains a magic number: foreach (SeriesRendererInfo sri in cri.seriesRendererInfos) {  	int count = sri.series.Elements.Count;  	XPoint[] points = new XPoint[count + 2];  	points [0] = new XPoint (xMajorTick / 2' 0);  	for (int idx = 0; idx < count; idx++) {  		double pointValue = sri.series.Elements [idx].Value;  		if (double.IsNaN (pointValue))  			pointValue = 0;  		points [idx + 1] = new XPoint (idx + xMajorTick / 2' pointValue);  	}  	points [count + 1] = new XPoint (count - 1 + xMajorTick / 2' 0);  	matrix.TransformPoints (points);  	gfx.DrawPolygon (sri.LineFormat' sri.FillFormat' points' XFillMode.Winding);  }  
Magic Number,PdfSharp.Charting.Renderers,AreaPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AreaPlotAreaRenderer.cs,Draw,The following statement contains a magic number: foreach (SeriesRendererInfo sri in cri.seriesRendererInfos) {  	int count = sri.series.Elements.Count;  	XPoint[] points = new XPoint[count + 2];  	points [0] = new XPoint (xMajorTick / 2' 0);  	for (int idx = 0; idx < count; idx++) {  		double pointValue = sri.series.Elements [idx].Value;  		if (double.IsNaN (pointValue))  			pointValue = 0;  		points [idx + 1] = new XPoint (idx + xMajorTick / 2' pointValue);  	}  	points [count + 1] = new XPoint (count - 1 + xMajorTick / 2' 0);  	matrix.TransformPoints (points);  	gfx.DrawPolygon (sri.LineFormat' sri.FillFormat' points' XFillMode.Winding);  }  
Magic Number,PdfSharp.Charting.Renderers,AreaPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AreaPlotAreaRenderer.cs,Draw,The following statement contains a magic number: foreach (SeriesRendererInfo sri in cri.seriesRendererInfos) {  	int count = sri.series.Elements.Count;  	XPoint[] points = new XPoint[count + 2];  	points [0] = new XPoint (xMajorTick / 2' 0);  	for (int idx = 0; idx < count; idx++) {  		double pointValue = sri.series.Elements [idx].Value;  		if (double.IsNaN (pointValue))  			pointValue = 0;  		points [idx + 1] = new XPoint (idx + xMajorTick / 2' pointValue);  	}  	points [count + 1] = new XPoint (count - 1 + xMajorTick / 2' 0);  	matrix.TransformPoints (points);  	gfx.DrawPolygon (sri.LineFormat' sri.FillFormat' points' XFillMode.Winding);  }  
Magic Number,PdfSharp.Charting.Renderers,AreaPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AreaPlotAreaRenderer.cs,Draw,The following statement contains a magic number: foreach (SeriesRendererInfo sri in cri.seriesRendererInfos) {  	int count = sri.series.Elements.Count;  	XPoint[] points = new XPoint[count + 2];  	points [0] = new XPoint (xMajorTick / 2' 0);  	for (int idx = 0; idx < count; idx++) {  		double pointValue = sri.series.Elements [idx].Value;  		if (double.IsNaN (pointValue))  			pointValue = 0;  		points [idx + 1] = new XPoint (idx + xMajorTick / 2' pointValue);  	}  	points [count + 1] = new XPoint (count - 1 + xMajorTick / 2' 0);  	matrix.TransformPoints (points);  	gfx.DrawPolygon (sri.LineFormat' sri.FillFormat' points' XFillMode.Winding);  }  
Magic Number,PdfSharp.Charting.Renderers,AreaPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AreaPlotAreaRenderer.cs,Draw,The following statement contains a magic number: points [0] = new XPoint (xMajorTick / 2' 0);  
Magic Number,PdfSharp.Charting.Renderers,AreaPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AreaPlotAreaRenderer.cs,Draw,The following statement contains a magic number: for (int idx = 0; idx < count; idx++) {  	double pointValue = sri.series.Elements [idx].Value;  	if (double.IsNaN (pointValue))  		pointValue = 0;  	points [idx + 1] = new XPoint (idx + xMajorTick / 2' pointValue);  }  
Magic Number,PdfSharp.Charting.Renderers,AreaPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AreaPlotAreaRenderer.cs,Draw,The following statement contains a magic number: points [idx + 1] = new XPoint (idx + xMajorTick / 2' pointValue);  
Magic Number,PdfSharp.Charting.Renderers,AreaPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AreaPlotAreaRenderer.cs,Draw,The following statement contains a magic number: points [count + 1] = new XPoint (count - 1 + xMajorTick / 2' 0);  
Magic Number,PdfSharp.Charting.Renderers,AxisTitleRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AxisTitleRenderer.cs,Format,The following statement contains a magic number: if (atri.AxisTitleText != "") {  	XSize size = gfx.MeasureString (atri.AxisTitleText' atri.AxisTitleFont);  	if (atri.AxisTitleOrientation != 0) {  		XPoint[] points = new XPoint[2];  		points [0].X = 0;  		points [0].Y = 0;  		points [1].X = size.Width;  		points [1].Y = size.Height;  		XMatrix matrix = new XMatrix ();  		//XMatrix.Identity;  		matrix.RotatePrepend (-atri.AxisTitleOrientation);  		matrix.TransformPoints (points);  		size.Width = Math.Abs (points [1].X - points [0].X);  		size.Height = Math.Abs (points [1].Y - points [0].Y);  	}  	atri.X = 0;  	atri.Y = 0;  	atri.Height = size.Height;  	atri.Width = size.Width;  }  
Magic Number,PdfSharp.Charting.Renderers,AxisTitleRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AxisTitleRenderer.cs,Format,The following statement contains a magic number: if (atri.AxisTitleOrientation != 0) {  	XPoint[] points = new XPoint[2];  	points [0].X = 0;  	points [0].Y = 0;  	points [1].X = size.Width;  	points [1].Y = size.Height;  	XMatrix matrix = new XMatrix ();  	//XMatrix.Identity;  	matrix.RotatePrepend (-atri.AxisTitleOrientation);  	matrix.TransformPoints (points);  	size.Width = Math.Abs (points [1].X - points [0].X);  	size.Height = Math.Abs (points [1].Y - points [0].Y);  }  
Magic Number,PdfSharp.Charting.Renderers,AxisTitleRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AxisTitleRenderer.cs,Draw,The following statement contains a magic number: if (atri.AxisTitleText != "") {  	XGraphics gfx = this.rendererParms.Graphics;  	if (atri.AxisTitleOrientation != 0) {  		XRect layout = atri.Rect;  		layout.X = -(layout.Width / 2);  		layout.Y = -(layout.Height / 2);  		double x = 0;  		switch (atri.AxisTitleAlignment) {  		case HorizontalAlignment.Center:  			x = atri.X + atri.Width / 2;  			break;  		case HorizontalAlignment.Right:  			x = atri.X + atri.Width - layout.Width / 2;  			break;  		case HorizontalAlignment.Left:  		default:  			x = atri.X;  			break;  		}  		double y = 0;  		switch (atri.AxisTitleVerticalAlignment) {  		case VerticalAlignment.Center:  			y = atri.Y + atri.Height / 2;  			break;  		case VerticalAlignment.Bottom:  			y = atri.Y + atri.Height - layout.Height / 2;  			break;  		case VerticalAlignment.Top:  		default:  			y = atri.Y;  			break;  		}  		XStringFormat xsf = new XStringFormat ();  		xsf.Alignment = XStringAlignment.Center;  		xsf.LineAlignment = XLineAlignment.Center;  		XGraphicsState state = gfx.Save ();  		gfx.TranslateTransform (x' y);  		gfx.RotateTransform (-atri.AxisTitleOrientation);  		gfx.DrawString (atri.AxisTitleText' atri.AxisTitleFont' atri.AxisTitleBrush' layout' xsf);  		gfx.Restore (state);  	}  	else {  		XStringFormat format = new XStringFormat ();  		switch (atri.AxisTitleAlignment) {  		case HorizontalAlignment.Center:  			format.Alignment = XStringAlignment.Center;  			break;  		case HorizontalAlignment.Right:  			format.Alignment = XStringAlignment.Far;  			break;  		case HorizontalAlignment.Left:  		default:  			format.Alignment = XStringAlignment.Near;  			break;  		}  		switch (atri.AxisTitleVerticalAlignment) {  		case VerticalAlignment.Center:  			format.LineAlignment = XLineAlignment.Center;  			break;  		case VerticalAlignment.Bottom:  			format.LineAlignment = XLineAlignment.Far;  			break;  		case VerticalAlignment.Top:  		default:  			format.LineAlignment = XLineAlignment.Near;  			break;  		}  		gfx.DrawString (atri.AxisTitleText' atri.AxisTitleFont' atri.AxisTitleBrush' atri.Rect' format);  	}  }  
Magic Number,PdfSharp.Charting.Renderers,AxisTitleRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AxisTitleRenderer.cs,Draw,The following statement contains a magic number: if (atri.AxisTitleText != "") {  	XGraphics gfx = this.rendererParms.Graphics;  	if (atri.AxisTitleOrientation != 0) {  		XRect layout = atri.Rect;  		layout.X = -(layout.Width / 2);  		layout.Y = -(layout.Height / 2);  		double x = 0;  		switch (atri.AxisTitleAlignment) {  		case HorizontalAlignment.Center:  			x = atri.X + atri.Width / 2;  			break;  		case HorizontalAlignment.Right:  			x = atri.X + atri.Width - layout.Width / 2;  			break;  		case HorizontalAlignment.Left:  		default:  			x = atri.X;  			break;  		}  		double y = 0;  		switch (atri.AxisTitleVerticalAlignment) {  		case VerticalAlignment.Center:  			y = atri.Y + atri.Height / 2;  			break;  		case VerticalAlignment.Bottom:  			y = atri.Y + atri.Height - layout.Height / 2;  			break;  		case VerticalAlignment.Top:  		default:  			y = atri.Y;  			break;  		}  		XStringFormat xsf = new XStringFormat ();  		xsf.Alignment = XStringAlignment.Center;  		xsf.LineAlignment = XLineAlignment.Center;  		XGraphicsState state = gfx.Save ();  		gfx.TranslateTransform (x' y);  		gfx.RotateTransform (-atri.AxisTitleOrientation);  		gfx.DrawString (atri.AxisTitleText' atri.AxisTitleFont' atri.AxisTitleBrush' layout' xsf);  		gfx.Restore (state);  	}  	else {  		XStringFormat format = new XStringFormat ();  		switch (atri.AxisTitleAlignment) {  		case HorizontalAlignment.Center:  			format.Alignment = XStringAlignment.Center;  			break;  		case HorizontalAlignment.Right:  			format.Alignment = XStringAlignment.Far;  			break;  		case HorizontalAlignment.Left:  		default:  			format.Alignment = XStringAlignment.Near;  			break;  		}  		switch (atri.AxisTitleVerticalAlignment) {  		case VerticalAlignment.Center:  			format.LineAlignment = XLineAlignment.Center;  			break;  		case VerticalAlignment.Bottom:  			format.LineAlignment = XLineAlignment.Far;  			break;  		case VerticalAlignment.Top:  		default:  			format.LineAlignment = XLineAlignment.Near;  			break;  		}  		gfx.DrawString (atri.AxisTitleText' atri.AxisTitleFont' atri.AxisTitleBrush' atri.Rect' format);  	}  }  
Magic Number,PdfSharp.Charting.Renderers,AxisTitleRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AxisTitleRenderer.cs,Draw,The following statement contains a magic number: if (atri.AxisTitleText != "") {  	XGraphics gfx = this.rendererParms.Graphics;  	if (atri.AxisTitleOrientation != 0) {  		XRect layout = atri.Rect;  		layout.X = -(layout.Width / 2);  		layout.Y = -(layout.Height / 2);  		double x = 0;  		switch (atri.AxisTitleAlignment) {  		case HorizontalAlignment.Center:  			x = atri.X + atri.Width / 2;  			break;  		case HorizontalAlignment.Right:  			x = atri.X + atri.Width - layout.Width / 2;  			break;  		case HorizontalAlignment.Left:  		default:  			x = atri.X;  			break;  		}  		double y = 0;  		switch (atri.AxisTitleVerticalAlignment) {  		case VerticalAlignment.Center:  			y = atri.Y + atri.Height / 2;  			break;  		case VerticalAlignment.Bottom:  			y = atri.Y + atri.Height - layout.Height / 2;  			break;  		case VerticalAlignment.Top:  		default:  			y = atri.Y;  			break;  		}  		XStringFormat xsf = new XStringFormat ();  		xsf.Alignment = XStringAlignment.Center;  		xsf.LineAlignment = XLineAlignment.Center;  		XGraphicsState state = gfx.Save ();  		gfx.TranslateTransform (x' y);  		gfx.RotateTransform (-atri.AxisTitleOrientation);  		gfx.DrawString (atri.AxisTitleText' atri.AxisTitleFont' atri.AxisTitleBrush' layout' xsf);  		gfx.Restore (state);  	}  	else {  		XStringFormat format = new XStringFormat ();  		switch (atri.AxisTitleAlignment) {  		case HorizontalAlignment.Center:  			format.Alignment = XStringAlignment.Center;  			break;  		case HorizontalAlignment.Right:  			format.Alignment = XStringAlignment.Far;  			break;  		case HorizontalAlignment.Left:  		default:  			format.Alignment = XStringAlignment.Near;  			break;  		}  		switch (atri.AxisTitleVerticalAlignment) {  		case VerticalAlignment.Center:  			format.LineAlignment = XLineAlignment.Center;  			break;  		case VerticalAlignment.Bottom:  			format.LineAlignment = XLineAlignment.Far;  			break;  		case VerticalAlignment.Top:  		default:  			format.LineAlignment = XLineAlignment.Near;  			break;  		}  		gfx.DrawString (atri.AxisTitleText' atri.AxisTitleFont' atri.AxisTitleBrush' atri.Rect' format);  	}  }  
Magic Number,PdfSharp.Charting.Renderers,AxisTitleRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AxisTitleRenderer.cs,Draw,The following statement contains a magic number: if (atri.AxisTitleText != "") {  	XGraphics gfx = this.rendererParms.Graphics;  	if (atri.AxisTitleOrientation != 0) {  		XRect layout = atri.Rect;  		layout.X = -(layout.Width / 2);  		layout.Y = -(layout.Height / 2);  		double x = 0;  		switch (atri.AxisTitleAlignment) {  		case HorizontalAlignment.Center:  			x = atri.X + atri.Width / 2;  			break;  		case HorizontalAlignment.Right:  			x = atri.X + atri.Width - layout.Width / 2;  			break;  		case HorizontalAlignment.Left:  		default:  			x = atri.X;  			break;  		}  		double y = 0;  		switch (atri.AxisTitleVerticalAlignment) {  		case VerticalAlignment.Center:  			y = atri.Y + atri.Height / 2;  			break;  		case VerticalAlignment.Bottom:  			y = atri.Y + atri.Height - layout.Height / 2;  			break;  		case VerticalAlignment.Top:  		default:  			y = atri.Y;  			break;  		}  		XStringFormat xsf = new XStringFormat ();  		xsf.Alignment = XStringAlignment.Center;  		xsf.LineAlignment = XLineAlignment.Center;  		XGraphicsState state = gfx.Save ();  		gfx.TranslateTransform (x' y);  		gfx.RotateTransform (-atri.AxisTitleOrientation);  		gfx.DrawString (atri.AxisTitleText' atri.AxisTitleFont' atri.AxisTitleBrush' layout' xsf);  		gfx.Restore (state);  	}  	else {  		XStringFormat format = new XStringFormat ();  		switch (atri.AxisTitleAlignment) {  		case HorizontalAlignment.Center:  			format.Alignment = XStringAlignment.Center;  			break;  		case HorizontalAlignment.Right:  			format.Alignment = XStringAlignment.Far;  			break;  		case HorizontalAlignment.Left:  		default:  			format.Alignment = XStringAlignment.Near;  			break;  		}  		switch (atri.AxisTitleVerticalAlignment) {  		case VerticalAlignment.Center:  			format.LineAlignment = XLineAlignment.Center;  			break;  		case VerticalAlignment.Bottom:  			format.LineAlignment = XLineAlignment.Far;  			break;  		case VerticalAlignment.Top:  		default:  			format.LineAlignment = XLineAlignment.Near;  			break;  		}  		gfx.DrawString (atri.AxisTitleText' atri.AxisTitleFont' atri.AxisTitleBrush' atri.Rect' format);  	}  }  
Magic Number,PdfSharp.Charting.Renderers,AxisTitleRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AxisTitleRenderer.cs,Draw,The following statement contains a magic number: if (atri.AxisTitleText != "") {  	XGraphics gfx = this.rendererParms.Graphics;  	if (atri.AxisTitleOrientation != 0) {  		XRect layout = atri.Rect;  		layout.X = -(layout.Width / 2);  		layout.Y = -(layout.Height / 2);  		double x = 0;  		switch (atri.AxisTitleAlignment) {  		case HorizontalAlignment.Center:  			x = atri.X + atri.Width / 2;  			break;  		case HorizontalAlignment.Right:  			x = atri.X + atri.Width - layout.Width / 2;  			break;  		case HorizontalAlignment.Left:  		default:  			x = atri.X;  			break;  		}  		double y = 0;  		switch (atri.AxisTitleVerticalAlignment) {  		case VerticalAlignment.Center:  			y = atri.Y + atri.Height / 2;  			break;  		case VerticalAlignment.Bottom:  			y = atri.Y + atri.Height - layout.Height / 2;  			break;  		case VerticalAlignment.Top:  		default:  			y = atri.Y;  			break;  		}  		XStringFormat xsf = new XStringFormat ();  		xsf.Alignment = XStringAlignment.Center;  		xsf.LineAlignment = XLineAlignment.Center;  		XGraphicsState state = gfx.Save ();  		gfx.TranslateTransform (x' y);  		gfx.RotateTransform (-atri.AxisTitleOrientation);  		gfx.DrawString (atri.AxisTitleText' atri.AxisTitleFont' atri.AxisTitleBrush' layout' xsf);  		gfx.Restore (state);  	}  	else {  		XStringFormat format = new XStringFormat ();  		switch (atri.AxisTitleAlignment) {  		case HorizontalAlignment.Center:  			format.Alignment = XStringAlignment.Center;  			break;  		case HorizontalAlignment.Right:  			format.Alignment = XStringAlignment.Far;  			break;  		case HorizontalAlignment.Left:  		default:  			format.Alignment = XStringAlignment.Near;  			break;  		}  		switch (atri.AxisTitleVerticalAlignment) {  		case VerticalAlignment.Center:  			format.LineAlignment = XLineAlignment.Center;  			break;  		case VerticalAlignment.Bottom:  			format.LineAlignment = XLineAlignment.Far;  			break;  		case VerticalAlignment.Top:  		default:  			format.LineAlignment = XLineAlignment.Near;  			break;  		}  		gfx.DrawString (atri.AxisTitleText' atri.AxisTitleFont' atri.AxisTitleBrush' atri.Rect' format);  	}  }  
Magic Number,PdfSharp.Charting.Renderers,AxisTitleRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AxisTitleRenderer.cs,Draw,The following statement contains a magic number: if (atri.AxisTitleText != "") {  	XGraphics gfx = this.rendererParms.Graphics;  	if (atri.AxisTitleOrientation != 0) {  		XRect layout = atri.Rect;  		layout.X = -(layout.Width / 2);  		layout.Y = -(layout.Height / 2);  		double x = 0;  		switch (atri.AxisTitleAlignment) {  		case HorizontalAlignment.Center:  			x = atri.X + atri.Width / 2;  			break;  		case HorizontalAlignment.Right:  			x = atri.X + atri.Width - layout.Width / 2;  			break;  		case HorizontalAlignment.Left:  		default:  			x = atri.X;  			break;  		}  		double y = 0;  		switch (atri.AxisTitleVerticalAlignment) {  		case VerticalAlignment.Center:  			y = atri.Y + atri.Height / 2;  			break;  		case VerticalAlignment.Bottom:  			y = atri.Y + atri.Height - layout.Height / 2;  			break;  		case VerticalAlignment.Top:  		default:  			y = atri.Y;  			break;  		}  		XStringFormat xsf = new XStringFormat ();  		xsf.Alignment = XStringAlignment.Center;  		xsf.LineAlignment = XLineAlignment.Center;  		XGraphicsState state = gfx.Save ();  		gfx.TranslateTransform (x' y);  		gfx.RotateTransform (-atri.AxisTitleOrientation);  		gfx.DrawString (atri.AxisTitleText' atri.AxisTitleFont' atri.AxisTitleBrush' layout' xsf);  		gfx.Restore (state);  	}  	else {  		XStringFormat format = new XStringFormat ();  		switch (atri.AxisTitleAlignment) {  		case HorizontalAlignment.Center:  			format.Alignment = XStringAlignment.Center;  			break;  		case HorizontalAlignment.Right:  			format.Alignment = XStringAlignment.Far;  			break;  		case HorizontalAlignment.Left:  		default:  			format.Alignment = XStringAlignment.Near;  			break;  		}  		switch (atri.AxisTitleVerticalAlignment) {  		case VerticalAlignment.Center:  			format.LineAlignment = XLineAlignment.Center;  			break;  		case VerticalAlignment.Bottom:  			format.LineAlignment = XLineAlignment.Far;  			break;  		case VerticalAlignment.Top:  		default:  			format.LineAlignment = XLineAlignment.Near;  			break;  		}  		gfx.DrawString (atri.AxisTitleText' atri.AxisTitleFont' atri.AxisTitleBrush' atri.Rect' format);  	}  }  
Magic Number,PdfSharp.Charting.Renderers,AxisTitleRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AxisTitleRenderer.cs,Draw,The following statement contains a magic number: if (atri.AxisTitleOrientation != 0) {  	XRect layout = atri.Rect;  	layout.X = -(layout.Width / 2);  	layout.Y = -(layout.Height / 2);  	double x = 0;  	switch (atri.AxisTitleAlignment) {  	case HorizontalAlignment.Center:  		x = atri.X + atri.Width / 2;  		break;  	case HorizontalAlignment.Right:  		x = atri.X + atri.Width - layout.Width / 2;  		break;  	case HorizontalAlignment.Left:  	default:  		x = atri.X;  		break;  	}  	double y = 0;  	switch (atri.AxisTitleVerticalAlignment) {  	case VerticalAlignment.Center:  		y = atri.Y + atri.Height / 2;  		break;  	case VerticalAlignment.Bottom:  		y = atri.Y + atri.Height - layout.Height / 2;  		break;  	case VerticalAlignment.Top:  	default:  		y = atri.Y;  		break;  	}  	XStringFormat xsf = new XStringFormat ();  	xsf.Alignment = XStringAlignment.Center;  	xsf.LineAlignment = XLineAlignment.Center;  	XGraphicsState state = gfx.Save ();  	gfx.TranslateTransform (x' y);  	gfx.RotateTransform (-atri.AxisTitleOrientation);  	gfx.DrawString (atri.AxisTitleText' atri.AxisTitleFont' atri.AxisTitleBrush' layout' xsf);  	gfx.Restore (state);  }  else {  	XStringFormat format = new XStringFormat ();  	switch (atri.AxisTitleAlignment) {  	case HorizontalAlignment.Center:  		format.Alignment = XStringAlignment.Center;  		break;  	case HorizontalAlignment.Right:  		format.Alignment = XStringAlignment.Far;  		break;  	case HorizontalAlignment.Left:  	default:  		format.Alignment = XStringAlignment.Near;  		break;  	}  	switch (atri.AxisTitleVerticalAlignment) {  	case VerticalAlignment.Center:  		format.LineAlignment = XLineAlignment.Center;  		break;  	case VerticalAlignment.Bottom:  		format.LineAlignment = XLineAlignment.Far;  		break;  	case VerticalAlignment.Top:  	default:  		format.LineAlignment = XLineAlignment.Near;  		break;  	}  	gfx.DrawString (atri.AxisTitleText' atri.AxisTitleFont' atri.AxisTitleBrush' atri.Rect' format);  }  
Magic Number,PdfSharp.Charting.Renderers,AxisTitleRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AxisTitleRenderer.cs,Draw,The following statement contains a magic number: if (atri.AxisTitleOrientation != 0) {  	XRect layout = atri.Rect;  	layout.X = -(layout.Width / 2);  	layout.Y = -(layout.Height / 2);  	double x = 0;  	switch (atri.AxisTitleAlignment) {  	case HorizontalAlignment.Center:  		x = atri.X + atri.Width / 2;  		break;  	case HorizontalAlignment.Right:  		x = atri.X + atri.Width - layout.Width / 2;  		break;  	case HorizontalAlignment.Left:  	default:  		x = atri.X;  		break;  	}  	double y = 0;  	switch (atri.AxisTitleVerticalAlignment) {  	case VerticalAlignment.Center:  		y = atri.Y + atri.Height / 2;  		break;  	case VerticalAlignment.Bottom:  		y = atri.Y + atri.Height - layout.Height / 2;  		break;  	case VerticalAlignment.Top:  	default:  		y = atri.Y;  		break;  	}  	XStringFormat xsf = new XStringFormat ();  	xsf.Alignment = XStringAlignment.Center;  	xsf.LineAlignment = XLineAlignment.Center;  	XGraphicsState state = gfx.Save ();  	gfx.TranslateTransform (x' y);  	gfx.RotateTransform (-atri.AxisTitleOrientation);  	gfx.DrawString (atri.AxisTitleText' atri.AxisTitleFont' atri.AxisTitleBrush' layout' xsf);  	gfx.Restore (state);  }  else {  	XStringFormat format = new XStringFormat ();  	switch (atri.AxisTitleAlignment) {  	case HorizontalAlignment.Center:  		format.Alignment = XStringAlignment.Center;  		break;  	case HorizontalAlignment.Right:  		format.Alignment = XStringAlignment.Far;  		break;  	case HorizontalAlignment.Left:  	default:  		format.Alignment = XStringAlignment.Near;  		break;  	}  	switch (atri.AxisTitleVerticalAlignment) {  	case VerticalAlignment.Center:  		format.LineAlignment = XLineAlignment.Center;  		break;  	case VerticalAlignment.Bottom:  		format.LineAlignment = XLineAlignment.Far;  		break;  	case VerticalAlignment.Top:  	default:  		format.LineAlignment = XLineAlignment.Near;  		break;  	}  	gfx.DrawString (atri.AxisTitleText' atri.AxisTitleFont' atri.AxisTitleBrush' atri.Rect' format);  }  
Magic Number,PdfSharp.Charting.Renderers,AxisTitleRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AxisTitleRenderer.cs,Draw,The following statement contains a magic number: if (atri.AxisTitleOrientation != 0) {  	XRect layout = atri.Rect;  	layout.X = -(layout.Width / 2);  	layout.Y = -(layout.Height / 2);  	double x = 0;  	switch (atri.AxisTitleAlignment) {  	case HorizontalAlignment.Center:  		x = atri.X + atri.Width / 2;  		break;  	case HorizontalAlignment.Right:  		x = atri.X + atri.Width - layout.Width / 2;  		break;  	case HorizontalAlignment.Left:  	default:  		x = atri.X;  		break;  	}  	double y = 0;  	switch (atri.AxisTitleVerticalAlignment) {  	case VerticalAlignment.Center:  		y = atri.Y + atri.Height / 2;  		break;  	case VerticalAlignment.Bottom:  		y = atri.Y + atri.Height - layout.Height / 2;  		break;  	case VerticalAlignment.Top:  	default:  		y = atri.Y;  		break;  	}  	XStringFormat xsf = new XStringFormat ();  	xsf.Alignment = XStringAlignment.Center;  	xsf.LineAlignment = XLineAlignment.Center;  	XGraphicsState state = gfx.Save ();  	gfx.TranslateTransform (x' y);  	gfx.RotateTransform (-atri.AxisTitleOrientation);  	gfx.DrawString (atri.AxisTitleText' atri.AxisTitleFont' atri.AxisTitleBrush' layout' xsf);  	gfx.Restore (state);  }  else {  	XStringFormat format = new XStringFormat ();  	switch (atri.AxisTitleAlignment) {  	case HorizontalAlignment.Center:  		format.Alignment = XStringAlignment.Center;  		break;  	case HorizontalAlignment.Right:  		format.Alignment = XStringAlignment.Far;  		break;  	case HorizontalAlignment.Left:  	default:  		format.Alignment = XStringAlignment.Near;  		break;  	}  	switch (atri.AxisTitleVerticalAlignment) {  	case VerticalAlignment.Center:  		format.LineAlignment = XLineAlignment.Center;  		break;  	case VerticalAlignment.Bottom:  		format.LineAlignment = XLineAlignment.Far;  		break;  	case VerticalAlignment.Top:  	default:  		format.LineAlignment = XLineAlignment.Near;  		break;  	}  	gfx.DrawString (atri.AxisTitleText' atri.AxisTitleFont' atri.AxisTitleBrush' atri.Rect' format);  }  
Magic Number,PdfSharp.Charting.Renderers,AxisTitleRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AxisTitleRenderer.cs,Draw,The following statement contains a magic number: if (atri.AxisTitleOrientation != 0) {  	XRect layout = atri.Rect;  	layout.X = -(layout.Width / 2);  	layout.Y = -(layout.Height / 2);  	double x = 0;  	switch (atri.AxisTitleAlignment) {  	case HorizontalAlignment.Center:  		x = atri.X + atri.Width / 2;  		break;  	case HorizontalAlignment.Right:  		x = atri.X + atri.Width - layout.Width / 2;  		break;  	case HorizontalAlignment.Left:  	default:  		x = atri.X;  		break;  	}  	double y = 0;  	switch (atri.AxisTitleVerticalAlignment) {  	case VerticalAlignment.Center:  		y = atri.Y + atri.Height / 2;  		break;  	case VerticalAlignment.Bottom:  		y = atri.Y + atri.Height - layout.Height / 2;  		break;  	case VerticalAlignment.Top:  	default:  		y = atri.Y;  		break;  	}  	XStringFormat xsf = new XStringFormat ();  	xsf.Alignment = XStringAlignment.Center;  	xsf.LineAlignment = XLineAlignment.Center;  	XGraphicsState state = gfx.Save ();  	gfx.TranslateTransform (x' y);  	gfx.RotateTransform (-atri.AxisTitleOrientation);  	gfx.DrawString (atri.AxisTitleText' atri.AxisTitleFont' atri.AxisTitleBrush' layout' xsf);  	gfx.Restore (state);  }  else {  	XStringFormat format = new XStringFormat ();  	switch (atri.AxisTitleAlignment) {  	case HorizontalAlignment.Center:  		format.Alignment = XStringAlignment.Center;  		break;  	case HorizontalAlignment.Right:  		format.Alignment = XStringAlignment.Far;  		break;  	case HorizontalAlignment.Left:  	default:  		format.Alignment = XStringAlignment.Near;  		break;  	}  	switch (atri.AxisTitleVerticalAlignment) {  	case VerticalAlignment.Center:  		format.LineAlignment = XLineAlignment.Center;  		break;  	case VerticalAlignment.Bottom:  		format.LineAlignment = XLineAlignment.Far;  		break;  	case VerticalAlignment.Top:  	default:  		format.LineAlignment = XLineAlignment.Near;  		break;  	}  	gfx.DrawString (atri.AxisTitleText' atri.AxisTitleFont' atri.AxisTitleBrush' atri.Rect' format);  }  
Magic Number,PdfSharp.Charting.Renderers,AxisTitleRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AxisTitleRenderer.cs,Draw,The following statement contains a magic number: if (atri.AxisTitleOrientation != 0) {  	XRect layout = atri.Rect;  	layout.X = -(layout.Width / 2);  	layout.Y = -(layout.Height / 2);  	double x = 0;  	switch (atri.AxisTitleAlignment) {  	case HorizontalAlignment.Center:  		x = atri.X + atri.Width / 2;  		break;  	case HorizontalAlignment.Right:  		x = atri.X + atri.Width - layout.Width / 2;  		break;  	case HorizontalAlignment.Left:  	default:  		x = atri.X;  		break;  	}  	double y = 0;  	switch (atri.AxisTitleVerticalAlignment) {  	case VerticalAlignment.Center:  		y = atri.Y + atri.Height / 2;  		break;  	case VerticalAlignment.Bottom:  		y = atri.Y + atri.Height - layout.Height / 2;  		break;  	case VerticalAlignment.Top:  	default:  		y = atri.Y;  		break;  	}  	XStringFormat xsf = new XStringFormat ();  	xsf.Alignment = XStringAlignment.Center;  	xsf.LineAlignment = XLineAlignment.Center;  	XGraphicsState state = gfx.Save ();  	gfx.TranslateTransform (x' y);  	gfx.RotateTransform (-atri.AxisTitleOrientation);  	gfx.DrawString (atri.AxisTitleText' atri.AxisTitleFont' atri.AxisTitleBrush' layout' xsf);  	gfx.Restore (state);  }  else {  	XStringFormat format = new XStringFormat ();  	switch (atri.AxisTitleAlignment) {  	case HorizontalAlignment.Center:  		format.Alignment = XStringAlignment.Center;  		break;  	case HorizontalAlignment.Right:  		format.Alignment = XStringAlignment.Far;  		break;  	case HorizontalAlignment.Left:  	default:  		format.Alignment = XStringAlignment.Near;  		break;  	}  	switch (atri.AxisTitleVerticalAlignment) {  	case VerticalAlignment.Center:  		format.LineAlignment = XLineAlignment.Center;  		break;  	case VerticalAlignment.Bottom:  		format.LineAlignment = XLineAlignment.Far;  		break;  	case VerticalAlignment.Top:  	default:  		format.LineAlignment = XLineAlignment.Near;  		break;  	}  	gfx.DrawString (atri.AxisTitleText' atri.AxisTitleFont' atri.AxisTitleBrush' atri.Rect' format);  }  
Magic Number,PdfSharp.Charting.Renderers,AxisTitleRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AxisTitleRenderer.cs,Draw,The following statement contains a magic number: if (atri.AxisTitleOrientation != 0) {  	XRect layout = atri.Rect;  	layout.X = -(layout.Width / 2);  	layout.Y = -(layout.Height / 2);  	double x = 0;  	switch (atri.AxisTitleAlignment) {  	case HorizontalAlignment.Center:  		x = atri.X + atri.Width / 2;  		break;  	case HorizontalAlignment.Right:  		x = atri.X + atri.Width - layout.Width / 2;  		break;  	case HorizontalAlignment.Left:  	default:  		x = atri.X;  		break;  	}  	double y = 0;  	switch (atri.AxisTitleVerticalAlignment) {  	case VerticalAlignment.Center:  		y = atri.Y + atri.Height / 2;  		break;  	case VerticalAlignment.Bottom:  		y = atri.Y + atri.Height - layout.Height / 2;  		break;  	case VerticalAlignment.Top:  	default:  		y = atri.Y;  		break;  	}  	XStringFormat xsf = new XStringFormat ();  	xsf.Alignment = XStringAlignment.Center;  	xsf.LineAlignment = XLineAlignment.Center;  	XGraphicsState state = gfx.Save ();  	gfx.TranslateTransform (x' y);  	gfx.RotateTransform (-atri.AxisTitleOrientation);  	gfx.DrawString (atri.AxisTitleText' atri.AxisTitleFont' atri.AxisTitleBrush' layout' xsf);  	gfx.Restore (state);  }  else {  	XStringFormat format = new XStringFormat ();  	switch (atri.AxisTitleAlignment) {  	case HorizontalAlignment.Center:  		format.Alignment = XStringAlignment.Center;  		break;  	case HorizontalAlignment.Right:  		format.Alignment = XStringAlignment.Far;  		break;  	case HorizontalAlignment.Left:  	default:  		format.Alignment = XStringAlignment.Near;  		break;  	}  	switch (atri.AxisTitleVerticalAlignment) {  	case VerticalAlignment.Center:  		format.LineAlignment = XLineAlignment.Center;  		break;  	case VerticalAlignment.Bottom:  		format.LineAlignment = XLineAlignment.Far;  		break;  	case VerticalAlignment.Top:  	default:  		format.LineAlignment = XLineAlignment.Near;  		break;  	}  	gfx.DrawString (atri.AxisTitleText' atri.AxisTitleFont' atri.AxisTitleBrush' atri.Rect' format);  }  
Magic Number,PdfSharp.Charting.Renderers,AxisTitleRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AxisTitleRenderer.cs,Draw,The following statement contains a magic number: layout.X = -(layout.Width / 2);  
Magic Number,PdfSharp.Charting.Renderers,AxisTitleRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AxisTitleRenderer.cs,Draw,The following statement contains a magic number: layout.Y = -(layout.Height / 2);  
Magic Number,PdfSharp.Charting.Renderers,AxisTitleRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AxisTitleRenderer.cs,Draw,The following statement contains a magic number: switch (atri.AxisTitleAlignment) {  case HorizontalAlignment.Center:  	x = atri.X + atri.Width / 2;  	break;  case HorizontalAlignment.Right:  	x = atri.X + atri.Width - layout.Width / 2;  	break;  case HorizontalAlignment.Left:  default:  	x = atri.X;  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,AxisTitleRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AxisTitleRenderer.cs,Draw,The following statement contains a magic number: switch (atri.AxisTitleAlignment) {  case HorizontalAlignment.Center:  	x = atri.X + atri.Width / 2;  	break;  case HorizontalAlignment.Right:  	x = atri.X + atri.Width - layout.Width / 2;  	break;  case HorizontalAlignment.Left:  default:  	x = atri.X;  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,AxisTitleRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AxisTitleRenderer.cs,Draw,The following statement contains a magic number: x = atri.X + atri.Width / 2;  
Magic Number,PdfSharp.Charting.Renderers,AxisTitleRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AxisTitleRenderer.cs,Draw,The following statement contains a magic number: x = atri.X + atri.Width - layout.Width / 2;  
Magic Number,PdfSharp.Charting.Renderers,AxisTitleRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AxisTitleRenderer.cs,Draw,The following statement contains a magic number: switch (atri.AxisTitleVerticalAlignment) {  case VerticalAlignment.Center:  	y = atri.Y + atri.Height / 2;  	break;  case VerticalAlignment.Bottom:  	y = atri.Y + atri.Height - layout.Height / 2;  	break;  case VerticalAlignment.Top:  default:  	y = atri.Y;  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,AxisTitleRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AxisTitleRenderer.cs,Draw,The following statement contains a magic number: switch (atri.AxisTitleVerticalAlignment) {  case VerticalAlignment.Center:  	y = atri.Y + atri.Height / 2;  	break;  case VerticalAlignment.Bottom:  	y = atri.Y + atri.Height - layout.Height / 2;  	break;  case VerticalAlignment.Top:  default:  	y = atri.Y;  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,AxisTitleRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AxisTitleRenderer.cs,Draw,The following statement contains a magic number: y = atri.Y + atri.Height / 2;  
Magic Number,PdfSharp.Charting.Renderers,AxisTitleRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\AxisTitleRenderer.cs,Draw,The following statement contains a magic number: y = atri.Y + atri.Height - layout.Height / 2;  
Magic Number,PdfSharp.Charting.Renderers,BarClusteredLegendRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\BarClusteredLegendRenderer.cs,Draw,The following statement contains a magic number: if (lri.BorderPen != null)  	paddingFactor = 2;  
Magic Number,PdfSharp.Charting.Renderers,BarClusteredLegendRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\BarClusteredLegendRenderer.cs,Draw,The following statement contains a magic number: paddingFactor = 2;  
Magic Number,PdfSharp.Charting.Renderers,BarClusteredPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\BarClusteredPlotAreaRenderer.cs,CalcBars,The following statement contains a magic number: foreach (SeriesRendererInfo sri in cri.seriesRendererInfos) {  	// Set x to first clustered bar for each series.  	double x = xMax - groupWidth / 2;  	// Offset for bars of a particular series from the start of a clustered bar.  	double dx = (columnWidth * seriesIdx) - (columnWidth / 2 * cri.seriesRendererInfos.Length);  	double y0 = yMin;  	foreach (ColumnRendererInfo column in sri.pointRendererInfos) {  		if (column.point != null) {  			double x0 = x - dx;  			double x1 = x - dx - columnWidth;  			double y1 = column.point.Value;  			// Draw from zero base line' if it exists.  			if (y0 < 0 && yMax >= 0)  				y0 = 0;  			// y0 should always be lower than y1' i. e. draw bar from bottom to top.  			if (y1 < 0 && y1 < y0) {  				double y = y0;  				y0 = y1;  				y1 = y;  			}  			points [0].X = y0;  			// upper left  			points [0].Y = x0;  			points [1].X = y1;  			// lower right  			points [1].Y = x1;  			cri.plotAreaRendererInfo.matrix.TransformPoints (points);  			column.Rect = new XRect (points [0].X' points [1].Y' points [1].X - points [0].X' points [0].Y - points [1].Y);  		}  		x--;  		// Next clustered bar.  	}  	seriesIdx++;  }  
Magic Number,PdfSharp.Charting.Renderers,BarClusteredPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\BarClusteredPlotAreaRenderer.cs,CalcBars,The following statement contains a magic number: foreach (SeriesRendererInfo sri in cri.seriesRendererInfos) {  	// Set x to first clustered bar for each series.  	double x = xMax - groupWidth / 2;  	// Offset for bars of a particular series from the start of a clustered bar.  	double dx = (columnWidth * seriesIdx) - (columnWidth / 2 * cri.seriesRendererInfos.Length);  	double y0 = yMin;  	foreach (ColumnRendererInfo column in sri.pointRendererInfos) {  		if (column.point != null) {  			double x0 = x - dx;  			double x1 = x - dx - columnWidth;  			double y1 = column.point.Value;  			// Draw from zero base line' if it exists.  			if (y0 < 0 && yMax >= 0)  				y0 = 0;  			// y0 should always be lower than y1' i. e. draw bar from bottom to top.  			if (y1 < 0 && y1 < y0) {  				double y = y0;  				y0 = y1;  				y1 = y;  			}  			points [0].X = y0;  			// upper left  			points [0].Y = x0;  			points [1].X = y1;  			// lower right  			points [1].Y = x1;  			cri.plotAreaRendererInfo.matrix.TransformPoints (points);  			column.Rect = new XRect (points [0].X' points [1].Y' points [1].X - points [0].X' points [0].Y - points [1].Y);  		}  		x--;  		// Next clustered bar.  	}  	seriesIdx++;  }  
Magic Number,PdfSharp.Charting.Renderers,BarDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\BarDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: foreach (SeriesRendererInfo sri in cri.seriesRendererInfos) {  	if (sri.dataLabelRendererInfo == null)  		continue;  	int columnIndex = 0;  	foreach (ColumnRendererInfo bar in sri.pointRendererInfos) {  		DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [columnIndex++];  		dleri.Y = bar.Rect.Y + (bar.Rect.Height - dleri.Height) / 2;  		// Always the same...  		switch (sri.dataLabelRendererInfo.Position) {  		case DataLabelPosition.InsideEnd:  			// Inner border of the column.  			dleri.X = bar.Rect.X;  			if (bar.point.value > 0)  				dleri.X += bar.Rect.Width - dleri.Width;  			break;  		case DataLabelPosition.Center:  			// Centered inside the column.  			dleri.X = bar.Rect.X + (bar.Rect.Width - dleri.Width) / 2;  			break;  		case DataLabelPosition.InsideBase:  			// Aligned at the base of the column.  			dleri.X = bar.Rect.X;  			if (bar.point.value < 0)  				dleri.X += bar.Rect.Width - dleri.Width;  			break;  		case DataLabelPosition.OutsideEnd:  			// Outer border of the column.  			dleri.X = bar.Rect.X;  			if (bar.point.value > 0)  				dleri.X += bar.Rect.Width;  			else  				dleri.X -= dleri.Width;  			break;  		}  	}  }  
Magic Number,PdfSharp.Charting.Renderers,BarDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\BarDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: foreach (SeriesRendererInfo sri in cri.seriesRendererInfos) {  	if (sri.dataLabelRendererInfo == null)  		continue;  	int columnIndex = 0;  	foreach (ColumnRendererInfo bar in sri.pointRendererInfos) {  		DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [columnIndex++];  		dleri.Y = bar.Rect.Y + (bar.Rect.Height - dleri.Height) / 2;  		// Always the same...  		switch (sri.dataLabelRendererInfo.Position) {  		case DataLabelPosition.InsideEnd:  			// Inner border of the column.  			dleri.X = bar.Rect.X;  			if (bar.point.value > 0)  				dleri.X += bar.Rect.Width - dleri.Width;  			break;  		case DataLabelPosition.Center:  			// Centered inside the column.  			dleri.X = bar.Rect.X + (bar.Rect.Width - dleri.Width) / 2;  			break;  		case DataLabelPosition.InsideBase:  			// Aligned at the base of the column.  			dleri.X = bar.Rect.X;  			if (bar.point.value < 0)  				dleri.X += bar.Rect.Width - dleri.Width;  			break;  		case DataLabelPosition.OutsideEnd:  			// Outer border of the column.  			dleri.X = bar.Rect.X;  			if (bar.point.value > 0)  				dleri.X += bar.Rect.Width;  			else  				dleri.X -= dleri.Width;  			break;  		}  	}  }  
Magic Number,PdfSharp.Charting.Renderers,BarDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\BarDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: foreach (ColumnRendererInfo bar in sri.pointRendererInfos) {  	DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [columnIndex++];  	dleri.Y = bar.Rect.Y + (bar.Rect.Height - dleri.Height) / 2;  	// Always the same...  	switch (sri.dataLabelRendererInfo.Position) {  	case DataLabelPosition.InsideEnd:  		// Inner border of the column.  		dleri.X = bar.Rect.X;  		if (bar.point.value > 0)  			dleri.X += bar.Rect.Width - dleri.Width;  		break;  	case DataLabelPosition.Center:  		// Centered inside the column.  		dleri.X = bar.Rect.X + (bar.Rect.Width - dleri.Width) / 2;  		break;  	case DataLabelPosition.InsideBase:  		// Aligned at the base of the column.  		dleri.X = bar.Rect.X;  		if (bar.point.value < 0)  			dleri.X += bar.Rect.Width - dleri.Width;  		break;  	case DataLabelPosition.OutsideEnd:  		// Outer border of the column.  		dleri.X = bar.Rect.X;  		if (bar.point.value > 0)  			dleri.X += bar.Rect.Width;  		else  			dleri.X -= dleri.Width;  		break;  	}  }  
Magic Number,PdfSharp.Charting.Renderers,BarDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\BarDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: foreach (ColumnRendererInfo bar in sri.pointRendererInfos) {  	DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [columnIndex++];  	dleri.Y = bar.Rect.Y + (bar.Rect.Height - dleri.Height) / 2;  	// Always the same...  	switch (sri.dataLabelRendererInfo.Position) {  	case DataLabelPosition.InsideEnd:  		// Inner border of the column.  		dleri.X = bar.Rect.X;  		if (bar.point.value > 0)  			dleri.X += bar.Rect.Width - dleri.Width;  		break;  	case DataLabelPosition.Center:  		// Centered inside the column.  		dleri.X = bar.Rect.X + (bar.Rect.Width - dleri.Width) / 2;  		break;  	case DataLabelPosition.InsideBase:  		// Aligned at the base of the column.  		dleri.X = bar.Rect.X;  		if (bar.point.value < 0)  			dleri.X += bar.Rect.Width - dleri.Width;  		break;  	case DataLabelPosition.OutsideEnd:  		// Outer border of the column.  		dleri.X = bar.Rect.X;  		if (bar.point.value > 0)  			dleri.X += bar.Rect.Width;  		else  			dleri.X -= dleri.Width;  		break;  	}  }  
Magic Number,PdfSharp.Charting.Renderers,BarDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\BarDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: dleri.Y = bar.Rect.Y + (bar.Rect.Height - dleri.Height) / 2;  
Magic Number,PdfSharp.Charting.Renderers,BarDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\BarDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: switch (sri.dataLabelRendererInfo.Position) {  case DataLabelPosition.InsideEnd:  	// Inner border of the column.  	dleri.X = bar.Rect.X;  	if (bar.point.value > 0)  		dleri.X += bar.Rect.Width - dleri.Width;  	break;  case DataLabelPosition.Center:  	// Centered inside the column.  	dleri.X = bar.Rect.X + (bar.Rect.Width - dleri.Width) / 2;  	break;  case DataLabelPosition.InsideBase:  	// Aligned at the base of the column.  	dleri.X = bar.Rect.X;  	if (bar.point.value < 0)  		dleri.X += bar.Rect.Width - dleri.Width;  	break;  case DataLabelPosition.OutsideEnd:  	// Outer border of the column.  	dleri.X = bar.Rect.X;  	if (bar.point.value > 0)  		dleri.X += bar.Rect.Width;  	else  		dleri.X -= dleri.Width;  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,BarDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\BarDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: dleri.X = bar.Rect.X + (bar.Rect.Width - dleri.Width) / 2;  
Magic Number,PdfSharp.Charting.Renderers,BarPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\BarPlotAreaRenderer.cs,Draw,The following statement contains a magic number: if (cri.yAxisRendererInfo.MajorGridlinesLineFormat != null || cri.yAxisRendererInfo.MinorGridlinesLineFormat != null) {  	if (yMin < 0 && yMax > 0) {  		XPoint[] points = new XPoint[2];  		points [0].X = 0;  		points [0].Y = xMin;  		points [1].X = 0;  		points [1].Y = xMax;  		cri.plotAreaRendererInfo.matrix.TransformPoints (points);  		if (cri.yAxisRendererInfo.MinorGridlinesLineFormat != null)  			lineFormatRenderer = new LineFormatRenderer (gfx' cri.yAxisRendererInfo.MinorGridlinesLineFormat);  		else  			lineFormatRenderer = new LineFormatRenderer (gfx' cri.yAxisRendererInfo.MajorGridlinesLineFormat);  		lineFormatRenderer.DrawLine (points [0]' points [1]);  	}  }  
Magic Number,PdfSharp.Charting.Renderers,BarPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\BarPlotAreaRenderer.cs,Draw,The following statement contains a magic number: if (yMin < 0 && yMax > 0) {  	XPoint[] points = new XPoint[2];  	points [0].X = 0;  	points [0].Y = xMin;  	points [1].X = 0;  	points [1].Y = xMax;  	cri.plotAreaRendererInfo.matrix.TransformPoints (points);  	if (cri.yAxisRendererInfo.MinorGridlinesLineFormat != null)  		lineFormatRenderer = new LineFormatRenderer (gfx' cri.yAxisRendererInfo.MinorGridlinesLineFormat);  	else  		lineFormatRenderer = new LineFormatRenderer (gfx' cri.yAxisRendererInfo.MajorGridlinesLineFormat);  	lineFormatRenderer.DrawLine (points [0]' points [1]);  }  
Magic Number,PdfSharp.Charting.Renderers,ChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ChartRenderer.cs,LayoutLegend,The following statement contains a magic number: if (cri.legendRendererInfo != null) {  	switch (cri.legendRendererInfo.legend.Docking) {  	case DockingType.Left:  		cri.legendRendererInfo.X = remainingRect.Left;  		cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  		double width = cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  		remainingRect.X += width;  		remainingRect.Width -= width;  		break;  	case DockingType.Right:  		cri.legendRendererInfo.X = remainingRect.Right - cri.legendRendererInfo.Width;  		cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  		remainingRect.Width -= cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  		break;  	case DockingType.Top:  		cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  		cri.legendRendererInfo.Y = remainingRect.Top;  		double height = cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  		remainingRect.Y += height;  		remainingRect.Height -= height;  		break;  	case DockingType.Bottom:  		cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  		cri.legendRendererInfo.Y = remainingRect.Bottom - cri.legendRendererInfo.Height;  		remainingRect.Height -= cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  		break;  	}  }  
Magic Number,PdfSharp.Charting.Renderers,ChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ChartRenderer.cs,LayoutLegend,The following statement contains a magic number: if (cri.legendRendererInfo != null) {  	switch (cri.legendRendererInfo.legend.Docking) {  	case DockingType.Left:  		cri.legendRendererInfo.X = remainingRect.Left;  		cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  		double width = cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  		remainingRect.X += width;  		remainingRect.Width -= width;  		break;  	case DockingType.Right:  		cri.legendRendererInfo.X = remainingRect.Right - cri.legendRendererInfo.Width;  		cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  		remainingRect.Width -= cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  		break;  	case DockingType.Top:  		cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  		cri.legendRendererInfo.Y = remainingRect.Top;  		double height = cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  		remainingRect.Y += height;  		remainingRect.Height -= height;  		break;  	case DockingType.Bottom:  		cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  		cri.legendRendererInfo.Y = remainingRect.Bottom - cri.legendRendererInfo.Height;  		remainingRect.Height -= cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  		break;  	}  }  
Magic Number,PdfSharp.Charting.Renderers,ChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ChartRenderer.cs,LayoutLegend,The following statement contains a magic number: if (cri.legendRendererInfo != null) {  	switch (cri.legendRendererInfo.legend.Docking) {  	case DockingType.Left:  		cri.legendRendererInfo.X = remainingRect.Left;  		cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  		double width = cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  		remainingRect.X += width;  		remainingRect.Width -= width;  		break;  	case DockingType.Right:  		cri.legendRendererInfo.X = remainingRect.Right - cri.legendRendererInfo.Width;  		cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  		remainingRect.Width -= cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  		break;  	case DockingType.Top:  		cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  		cri.legendRendererInfo.Y = remainingRect.Top;  		double height = cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  		remainingRect.Y += height;  		remainingRect.Height -= height;  		break;  	case DockingType.Bottom:  		cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  		cri.legendRendererInfo.Y = remainingRect.Bottom - cri.legendRendererInfo.Height;  		remainingRect.Height -= cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  		break;  	}  }  
Magic Number,PdfSharp.Charting.Renderers,ChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ChartRenderer.cs,LayoutLegend,The following statement contains a magic number: if (cri.legendRendererInfo != null) {  	switch (cri.legendRendererInfo.legend.Docking) {  	case DockingType.Left:  		cri.legendRendererInfo.X = remainingRect.Left;  		cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  		double width = cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  		remainingRect.X += width;  		remainingRect.Width -= width;  		break;  	case DockingType.Right:  		cri.legendRendererInfo.X = remainingRect.Right - cri.legendRendererInfo.Width;  		cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  		remainingRect.Width -= cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  		break;  	case DockingType.Top:  		cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  		cri.legendRendererInfo.Y = remainingRect.Top;  		double height = cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  		remainingRect.Y += height;  		remainingRect.Height -= height;  		break;  	case DockingType.Bottom:  		cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  		cri.legendRendererInfo.Y = remainingRect.Bottom - cri.legendRendererInfo.Height;  		remainingRect.Height -= cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  		break;  	}  }  
Magic Number,PdfSharp.Charting.Renderers,ChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ChartRenderer.cs,LayoutLegend,The following statement contains a magic number: if (cri.legendRendererInfo != null) {  	switch (cri.legendRendererInfo.legend.Docking) {  	case DockingType.Left:  		cri.legendRendererInfo.X = remainingRect.Left;  		cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  		double width = cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  		remainingRect.X += width;  		remainingRect.Width -= width;  		break;  	case DockingType.Right:  		cri.legendRendererInfo.X = remainingRect.Right - cri.legendRendererInfo.Width;  		cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  		remainingRect.Width -= cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  		break;  	case DockingType.Top:  		cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  		cri.legendRendererInfo.Y = remainingRect.Top;  		double height = cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  		remainingRect.Y += height;  		remainingRect.Height -= height;  		break;  	case DockingType.Bottom:  		cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  		cri.legendRendererInfo.Y = remainingRect.Bottom - cri.legendRendererInfo.Height;  		remainingRect.Height -= cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  		break;  	}  }  
Magic Number,PdfSharp.Charting.Renderers,ChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ChartRenderer.cs,LayoutLegend,The following statement contains a magic number: if (cri.legendRendererInfo != null) {  	switch (cri.legendRendererInfo.legend.Docking) {  	case DockingType.Left:  		cri.legendRendererInfo.X = remainingRect.Left;  		cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  		double width = cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  		remainingRect.X += width;  		remainingRect.Width -= width;  		break;  	case DockingType.Right:  		cri.legendRendererInfo.X = remainingRect.Right - cri.legendRendererInfo.Width;  		cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  		remainingRect.Width -= cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  		break;  	case DockingType.Top:  		cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  		cri.legendRendererInfo.Y = remainingRect.Top;  		double height = cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  		remainingRect.Y += height;  		remainingRect.Height -= height;  		break;  	case DockingType.Bottom:  		cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  		cri.legendRendererInfo.Y = remainingRect.Bottom - cri.legendRendererInfo.Height;  		remainingRect.Height -= cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  		break;  	}  }  
Magic Number,PdfSharp.Charting.Renderers,ChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ChartRenderer.cs,LayoutLegend,The following statement contains a magic number: if (cri.legendRendererInfo != null) {  	switch (cri.legendRendererInfo.legend.Docking) {  	case DockingType.Left:  		cri.legendRendererInfo.X = remainingRect.Left;  		cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  		double width = cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  		remainingRect.X += width;  		remainingRect.Width -= width;  		break;  	case DockingType.Right:  		cri.legendRendererInfo.X = remainingRect.Right - cri.legendRendererInfo.Width;  		cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  		remainingRect.Width -= cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  		break;  	case DockingType.Top:  		cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  		cri.legendRendererInfo.Y = remainingRect.Top;  		double height = cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  		remainingRect.Y += height;  		remainingRect.Height -= height;  		break;  	case DockingType.Bottom:  		cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  		cri.legendRendererInfo.Y = remainingRect.Bottom - cri.legendRendererInfo.Height;  		remainingRect.Height -= cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  		break;  	}  }  
Magic Number,PdfSharp.Charting.Renderers,ChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ChartRenderer.cs,LayoutLegend,The following statement contains a magic number: if (cri.legendRendererInfo != null) {  	switch (cri.legendRendererInfo.legend.Docking) {  	case DockingType.Left:  		cri.legendRendererInfo.X = remainingRect.Left;  		cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  		double width = cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  		remainingRect.X += width;  		remainingRect.Width -= width;  		break;  	case DockingType.Right:  		cri.legendRendererInfo.X = remainingRect.Right - cri.legendRendererInfo.Width;  		cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  		remainingRect.Width -= cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  		break;  	case DockingType.Top:  		cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  		cri.legendRendererInfo.Y = remainingRect.Top;  		double height = cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  		remainingRect.Y += height;  		remainingRect.Height -= height;  		break;  	case DockingType.Bottom:  		cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  		cri.legendRendererInfo.Y = remainingRect.Bottom - cri.legendRendererInfo.Height;  		remainingRect.Height -= cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  		break;  	}  }  
Magic Number,PdfSharp.Charting.Renderers,ChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ChartRenderer.cs,LayoutLegend,The following statement contains a magic number: switch (cri.legendRendererInfo.legend.Docking) {  case DockingType.Left:  	cri.legendRendererInfo.X = remainingRect.Left;  	cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  	double width = cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  	remainingRect.X += width;  	remainingRect.Width -= width;  	break;  case DockingType.Right:  	cri.legendRendererInfo.X = remainingRect.Right - cri.legendRendererInfo.Width;  	cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  	remainingRect.Width -= cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  	break;  case DockingType.Top:  	cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  	cri.legendRendererInfo.Y = remainingRect.Top;  	double height = cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  	remainingRect.Y += height;  	remainingRect.Height -= height;  	break;  case DockingType.Bottom:  	cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  	cri.legendRendererInfo.Y = remainingRect.Bottom - cri.legendRendererInfo.Height;  	remainingRect.Height -= cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,ChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ChartRenderer.cs,LayoutLegend,The following statement contains a magic number: switch (cri.legendRendererInfo.legend.Docking) {  case DockingType.Left:  	cri.legendRendererInfo.X = remainingRect.Left;  	cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  	double width = cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  	remainingRect.X += width;  	remainingRect.Width -= width;  	break;  case DockingType.Right:  	cri.legendRendererInfo.X = remainingRect.Right - cri.legendRendererInfo.Width;  	cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  	remainingRect.Width -= cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  	break;  case DockingType.Top:  	cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  	cri.legendRendererInfo.Y = remainingRect.Top;  	double height = cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  	remainingRect.Y += height;  	remainingRect.Height -= height;  	break;  case DockingType.Bottom:  	cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  	cri.legendRendererInfo.Y = remainingRect.Bottom - cri.legendRendererInfo.Height;  	remainingRect.Height -= cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,ChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ChartRenderer.cs,LayoutLegend,The following statement contains a magic number: switch (cri.legendRendererInfo.legend.Docking) {  case DockingType.Left:  	cri.legendRendererInfo.X = remainingRect.Left;  	cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  	double width = cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  	remainingRect.X += width;  	remainingRect.Width -= width;  	break;  case DockingType.Right:  	cri.legendRendererInfo.X = remainingRect.Right - cri.legendRendererInfo.Width;  	cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  	remainingRect.Width -= cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  	break;  case DockingType.Top:  	cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  	cri.legendRendererInfo.Y = remainingRect.Top;  	double height = cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  	remainingRect.Y += height;  	remainingRect.Height -= height;  	break;  case DockingType.Bottom:  	cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  	cri.legendRendererInfo.Y = remainingRect.Bottom - cri.legendRendererInfo.Height;  	remainingRect.Height -= cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,ChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ChartRenderer.cs,LayoutLegend,The following statement contains a magic number: switch (cri.legendRendererInfo.legend.Docking) {  case DockingType.Left:  	cri.legendRendererInfo.X = remainingRect.Left;  	cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  	double width = cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  	remainingRect.X += width;  	remainingRect.Width -= width;  	break;  case DockingType.Right:  	cri.legendRendererInfo.X = remainingRect.Right - cri.legendRendererInfo.Width;  	cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  	remainingRect.Width -= cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  	break;  case DockingType.Top:  	cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  	cri.legendRendererInfo.Y = remainingRect.Top;  	double height = cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  	remainingRect.Y += height;  	remainingRect.Height -= height;  	break;  case DockingType.Bottom:  	cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  	cri.legendRendererInfo.Y = remainingRect.Bottom - cri.legendRendererInfo.Height;  	remainingRect.Height -= cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,ChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ChartRenderer.cs,LayoutLegend,The following statement contains a magic number: switch (cri.legendRendererInfo.legend.Docking) {  case DockingType.Left:  	cri.legendRendererInfo.X = remainingRect.Left;  	cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  	double width = cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  	remainingRect.X += width;  	remainingRect.Width -= width;  	break;  case DockingType.Right:  	cri.legendRendererInfo.X = remainingRect.Right - cri.legendRendererInfo.Width;  	cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  	remainingRect.Width -= cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  	break;  case DockingType.Top:  	cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  	cri.legendRendererInfo.Y = remainingRect.Top;  	double height = cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  	remainingRect.Y += height;  	remainingRect.Height -= height;  	break;  case DockingType.Bottom:  	cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  	cri.legendRendererInfo.Y = remainingRect.Bottom - cri.legendRendererInfo.Height;  	remainingRect.Height -= cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,ChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ChartRenderer.cs,LayoutLegend,The following statement contains a magic number: switch (cri.legendRendererInfo.legend.Docking) {  case DockingType.Left:  	cri.legendRendererInfo.X = remainingRect.Left;  	cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  	double width = cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  	remainingRect.X += width;  	remainingRect.Width -= width;  	break;  case DockingType.Right:  	cri.legendRendererInfo.X = remainingRect.Right - cri.legendRendererInfo.Width;  	cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  	remainingRect.Width -= cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  	break;  case DockingType.Top:  	cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  	cri.legendRendererInfo.Y = remainingRect.Top;  	double height = cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  	remainingRect.Y += height;  	remainingRect.Height -= height;  	break;  case DockingType.Bottom:  	cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  	cri.legendRendererInfo.Y = remainingRect.Bottom - cri.legendRendererInfo.Height;  	remainingRect.Height -= cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,ChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ChartRenderer.cs,LayoutLegend,The following statement contains a magic number: switch (cri.legendRendererInfo.legend.Docking) {  case DockingType.Left:  	cri.legendRendererInfo.X = remainingRect.Left;  	cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  	double width = cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  	remainingRect.X += width;  	remainingRect.Width -= width;  	break;  case DockingType.Right:  	cri.legendRendererInfo.X = remainingRect.Right - cri.legendRendererInfo.Width;  	cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  	remainingRect.Width -= cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  	break;  case DockingType.Top:  	cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  	cri.legendRendererInfo.Y = remainingRect.Top;  	double height = cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  	remainingRect.Y += height;  	remainingRect.Height -= height;  	break;  case DockingType.Bottom:  	cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  	cri.legendRendererInfo.Y = remainingRect.Bottom - cri.legendRendererInfo.Height;  	remainingRect.Height -= cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,ChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ChartRenderer.cs,LayoutLegend,The following statement contains a magic number: switch (cri.legendRendererInfo.legend.Docking) {  case DockingType.Left:  	cri.legendRendererInfo.X = remainingRect.Left;  	cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  	double width = cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  	remainingRect.X += width;  	remainingRect.Width -= width;  	break;  case DockingType.Right:  	cri.legendRendererInfo.X = remainingRect.Right - cri.legendRendererInfo.Width;  	cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  	remainingRect.Width -= cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  	break;  case DockingType.Top:  	cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  	cri.legendRendererInfo.Y = remainingRect.Top;  	double height = cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  	remainingRect.Y += height;  	remainingRect.Height -= height;  	break;  case DockingType.Bottom:  	cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  	cri.legendRendererInfo.Y = remainingRect.Bottom - cri.legendRendererInfo.Height;  	remainingRect.Height -= cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,ChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ChartRenderer.cs,LayoutLegend,The following statement contains a magic number: cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  
Magic Number,PdfSharp.Charting.Renderers,ChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ChartRenderer.cs,LayoutLegend,The following statement contains a magic number: cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  
Magic Number,PdfSharp.Charting.Renderers,ChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ChartRenderer.cs,LayoutLegend,The following statement contains a magic number: cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  
Magic Number,PdfSharp.Charting.Renderers,ChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ChartRenderer.cs,LayoutLegend,The following statement contains a magic number: cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  
Magic Number,PdfSharp.Charting.Renderers,ChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ChartRenderer.cs,LayoutLegend,The following statement contains a magic number: cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  
Magic Number,PdfSharp.Charting.Renderers,ChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ChartRenderer.cs,LayoutLegend,The following statement contains a magic number: cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  
Magic Number,PdfSharp.Charting.Renderers,ChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ChartRenderer.cs,LayoutLegend,The following statement contains a magic number: cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  
Magic Number,PdfSharp.Charting.Renderers,ChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ChartRenderer.cs,LayoutLegend,The following statement contains a magic number: cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  
Magic Number,PdfSharp.Charting.Renderers,ColumnClusteredPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ColumnClusteredPlotAreaRenderer.cs,CalcColumns,The following statement contains a magic number: foreach (SeriesRendererInfo sri in cri.seriesRendererInfos) {  	// Set x to first clustered column for each series.  	double x = xMin + groupWidth / 2;  	// Offset for columns of a particular series from the start of a clustered cloumn.  	double dx = (columnWidth * seriesIdx) - (columnWidth / 2 * cri.seriesRendererInfos.Length);  	foreach (ColumnRendererInfo column in sri.pointRendererInfos) {  		if (column.point != null) {  			double x0 = x + dx;  			double x1 = x + dx + columnWidth;  			double y0 = yMin;  			double y1 = column.point.Value;  			// Draw from zero base line' if it exists.  			if (y0 < 0 && yMax >= 0)  				y0 = 0;  			// y0 should always be lower than y1' i. e. draw column from bottom to top.  			if (y1 < 0 && y1 < y0) {  				double y = y0;  				y0 = y1;  				y1 = y;  			}  			points [0].X = x0;  			// upper left  			points [0].Y = y1;  			points [1].X = x1;  			// lower right  			points [1].Y = y0;  			cri.plotAreaRendererInfo.matrix.TransformPoints (points);  			column.Rect = new XRect (points [0].X' points [0].Y' points [1].X - points [0].X' points [1].Y - points [0].Y);  		}  		x++;  		// Next clustered column.  	}  	seriesIdx++;  }  
Magic Number,PdfSharp.Charting.Renderers,ColumnClusteredPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ColumnClusteredPlotAreaRenderer.cs,CalcColumns,The following statement contains a magic number: foreach (SeriesRendererInfo sri in cri.seriesRendererInfos) {  	// Set x to first clustered column for each series.  	double x = xMin + groupWidth / 2;  	// Offset for columns of a particular series from the start of a clustered cloumn.  	double dx = (columnWidth * seriesIdx) - (columnWidth / 2 * cri.seriesRendererInfos.Length);  	foreach (ColumnRendererInfo column in sri.pointRendererInfos) {  		if (column.point != null) {  			double x0 = x + dx;  			double x1 = x + dx + columnWidth;  			double y0 = yMin;  			double y1 = column.point.Value;  			// Draw from zero base line' if it exists.  			if (y0 < 0 && yMax >= 0)  				y0 = 0;  			// y0 should always be lower than y1' i. e. draw column from bottom to top.  			if (y1 < 0 && y1 < y0) {  				double y = y0;  				y0 = y1;  				y1 = y;  			}  			points [0].X = x0;  			// upper left  			points [0].Y = y1;  			points [1].X = x1;  			// lower right  			points [1].Y = y0;  			cri.plotAreaRendererInfo.matrix.TransformPoints (points);  			column.Rect = new XRect (points [0].X' points [0].Y' points [1].X - points [0].X' points [1].Y - points [0].Y);  		}  		x++;  		// Next clustered column.  	}  	seriesIdx++;  }  
Magic Number,PdfSharp.Charting.Renderers,ColumnDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ColumnDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: foreach (SeriesRendererInfo sri in cri.seriesRendererInfos) {  	if (sri.dataLabelRendererInfo == null)  		continue;  	int columnIndex = 0;  	foreach (ColumnRendererInfo column in sri.pointRendererInfos) {  		DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [columnIndex++];  		dleri.X = column.Rect.X + column.Rect.Width / 2 - dleri.Width / 2;  		// Always the same...  		switch (sri.dataLabelRendererInfo.Position) {  		case DataLabelPosition.InsideEnd:  			// Inner border of the column.  			dleri.Y = column.Rect.Y;  			if (column.point.value < 0)  				dleri.Y = column.Rect.Y + column.Rect.Height - dleri.Height;  			break;  		case DataLabelPosition.Center:  			// Centered inside the column.  			dleri.Y = column.Rect.Y + column.Rect.Height / 2 - dleri.Height / 2;  			break;  		case DataLabelPosition.InsideBase:  			// Aligned at the base of the column.  			dleri.Y = column.Rect.Y + column.Rect.Height - dleri.Height;  			if (column.point.value < 0)  				dleri.Y = column.Rect.Y;  			break;  		case DataLabelPosition.OutsideEnd:  			// Outer border of the column.  			dleri.Y = column.Rect.Y - dleri.Height;  			if (column.point.value < 0)  				dleri.Y = column.Rect.Y + column.Rect.Height;  			break;  		}  	}  }  
Magic Number,PdfSharp.Charting.Renderers,ColumnDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ColumnDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: foreach (SeriesRendererInfo sri in cri.seriesRendererInfos) {  	if (sri.dataLabelRendererInfo == null)  		continue;  	int columnIndex = 0;  	foreach (ColumnRendererInfo column in sri.pointRendererInfos) {  		DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [columnIndex++];  		dleri.X = column.Rect.X + column.Rect.Width / 2 - dleri.Width / 2;  		// Always the same...  		switch (sri.dataLabelRendererInfo.Position) {  		case DataLabelPosition.InsideEnd:  			// Inner border of the column.  			dleri.Y = column.Rect.Y;  			if (column.point.value < 0)  				dleri.Y = column.Rect.Y + column.Rect.Height - dleri.Height;  			break;  		case DataLabelPosition.Center:  			// Centered inside the column.  			dleri.Y = column.Rect.Y + column.Rect.Height / 2 - dleri.Height / 2;  			break;  		case DataLabelPosition.InsideBase:  			// Aligned at the base of the column.  			dleri.Y = column.Rect.Y + column.Rect.Height - dleri.Height;  			if (column.point.value < 0)  				dleri.Y = column.Rect.Y;  			break;  		case DataLabelPosition.OutsideEnd:  			// Outer border of the column.  			dleri.Y = column.Rect.Y - dleri.Height;  			if (column.point.value < 0)  				dleri.Y = column.Rect.Y + column.Rect.Height;  			break;  		}  	}  }  
Magic Number,PdfSharp.Charting.Renderers,ColumnDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ColumnDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: foreach (SeriesRendererInfo sri in cri.seriesRendererInfos) {  	if (sri.dataLabelRendererInfo == null)  		continue;  	int columnIndex = 0;  	foreach (ColumnRendererInfo column in sri.pointRendererInfos) {  		DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [columnIndex++];  		dleri.X = column.Rect.X + column.Rect.Width / 2 - dleri.Width / 2;  		// Always the same...  		switch (sri.dataLabelRendererInfo.Position) {  		case DataLabelPosition.InsideEnd:  			// Inner border of the column.  			dleri.Y = column.Rect.Y;  			if (column.point.value < 0)  				dleri.Y = column.Rect.Y + column.Rect.Height - dleri.Height;  			break;  		case DataLabelPosition.Center:  			// Centered inside the column.  			dleri.Y = column.Rect.Y + column.Rect.Height / 2 - dleri.Height / 2;  			break;  		case DataLabelPosition.InsideBase:  			// Aligned at the base of the column.  			dleri.Y = column.Rect.Y + column.Rect.Height - dleri.Height;  			if (column.point.value < 0)  				dleri.Y = column.Rect.Y;  			break;  		case DataLabelPosition.OutsideEnd:  			// Outer border of the column.  			dleri.Y = column.Rect.Y - dleri.Height;  			if (column.point.value < 0)  				dleri.Y = column.Rect.Y + column.Rect.Height;  			break;  		}  	}  }  
Magic Number,PdfSharp.Charting.Renderers,ColumnDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ColumnDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: foreach (SeriesRendererInfo sri in cri.seriesRendererInfos) {  	if (sri.dataLabelRendererInfo == null)  		continue;  	int columnIndex = 0;  	foreach (ColumnRendererInfo column in sri.pointRendererInfos) {  		DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [columnIndex++];  		dleri.X = column.Rect.X + column.Rect.Width / 2 - dleri.Width / 2;  		// Always the same...  		switch (sri.dataLabelRendererInfo.Position) {  		case DataLabelPosition.InsideEnd:  			// Inner border of the column.  			dleri.Y = column.Rect.Y;  			if (column.point.value < 0)  				dleri.Y = column.Rect.Y + column.Rect.Height - dleri.Height;  			break;  		case DataLabelPosition.Center:  			// Centered inside the column.  			dleri.Y = column.Rect.Y + column.Rect.Height / 2 - dleri.Height / 2;  			break;  		case DataLabelPosition.InsideBase:  			// Aligned at the base of the column.  			dleri.Y = column.Rect.Y + column.Rect.Height - dleri.Height;  			if (column.point.value < 0)  				dleri.Y = column.Rect.Y;  			break;  		case DataLabelPosition.OutsideEnd:  			// Outer border of the column.  			dleri.Y = column.Rect.Y - dleri.Height;  			if (column.point.value < 0)  				dleri.Y = column.Rect.Y + column.Rect.Height;  			break;  		}  	}  }  
Magic Number,PdfSharp.Charting.Renderers,ColumnDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ColumnDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: foreach (ColumnRendererInfo column in sri.pointRendererInfos) {  	DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [columnIndex++];  	dleri.X = column.Rect.X + column.Rect.Width / 2 - dleri.Width / 2;  	// Always the same...  	switch (sri.dataLabelRendererInfo.Position) {  	case DataLabelPosition.InsideEnd:  		// Inner border of the column.  		dleri.Y = column.Rect.Y;  		if (column.point.value < 0)  			dleri.Y = column.Rect.Y + column.Rect.Height - dleri.Height;  		break;  	case DataLabelPosition.Center:  		// Centered inside the column.  		dleri.Y = column.Rect.Y + column.Rect.Height / 2 - dleri.Height / 2;  		break;  	case DataLabelPosition.InsideBase:  		// Aligned at the base of the column.  		dleri.Y = column.Rect.Y + column.Rect.Height - dleri.Height;  		if (column.point.value < 0)  			dleri.Y = column.Rect.Y;  		break;  	case DataLabelPosition.OutsideEnd:  		// Outer border of the column.  		dleri.Y = column.Rect.Y - dleri.Height;  		if (column.point.value < 0)  			dleri.Y = column.Rect.Y + column.Rect.Height;  		break;  	}  }  
Magic Number,PdfSharp.Charting.Renderers,ColumnDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ColumnDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: foreach (ColumnRendererInfo column in sri.pointRendererInfos) {  	DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [columnIndex++];  	dleri.X = column.Rect.X + column.Rect.Width / 2 - dleri.Width / 2;  	// Always the same...  	switch (sri.dataLabelRendererInfo.Position) {  	case DataLabelPosition.InsideEnd:  		// Inner border of the column.  		dleri.Y = column.Rect.Y;  		if (column.point.value < 0)  			dleri.Y = column.Rect.Y + column.Rect.Height - dleri.Height;  		break;  	case DataLabelPosition.Center:  		// Centered inside the column.  		dleri.Y = column.Rect.Y + column.Rect.Height / 2 - dleri.Height / 2;  		break;  	case DataLabelPosition.InsideBase:  		// Aligned at the base of the column.  		dleri.Y = column.Rect.Y + column.Rect.Height - dleri.Height;  		if (column.point.value < 0)  			dleri.Y = column.Rect.Y;  		break;  	case DataLabelPosition.OutsideEnd:  		// Outer border of the column.  		dleri.Y = column.Rect.Y - dleri.Height;  		if (column.point.value < 0)  			dleri.Y = column.Rect.Y + column.Rect.Height;  		break;  	}  }  
Magic Number,PdfSharp.Charting.Renderers,ColumnDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ColumnDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: foreach (ColumnRendererInfo column in sri.pointRendererInfos) {  	DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [columnIndex++];  	dleri.X = column.Rect.X + column.Rect.Width / 2 - dleri.Width / 2;  	// Always the same...  	switch (sri.dataLabelRendererInfo.Position) {  	case DataLabelPosition.InsideEnd:  		// Inner border of the column.  		dleri.Y = column.Rect.Y;  		if (column.point.value < 0)  			dleri.Y = column.Rect.Y + column.Rect.Height - dleri.Height;  		break;  	case DataLabelPosition.Center:  		// Centered inside the column.  		dleri.Y = column.Rect.Y + column.Rect.Height / 2 - dleri.Height / 2;  		break;  	case DataLabelPosition.InsideBase:  		// Aligned at the base of the column.  		dleri.Y = column.Rect.Y + column.Rect.Height - dleri.Height;  		if (column.point.value < 0)  			dleri.Y = column.Rect.Y;  		break;  	case DataLabelPosition.OutsideEnd:  		// Outer border of the column.  		dleri.Y = column.Rect.Y - dleri.Height;  		if (column.point.value < 0)  			dleri.Y = column.Rect.Y + column.Rect.Height;  		break;  	}  }  
Magic Number,PdfSharp.Charting.Renderers,ColumnDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ColumnDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: foreach (ColumnRendererInfo column in sri.pointRendererInfos) {  	DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [columnIndex++];  	dleri.X = column.Rect.X + column.Rect.Width / 2 - dleri.Width / 2;  	// Always the same...  	switch (sri.dataLabelRendererInfo.Position) {  	case DataLabelPosition.InsideEnd:  		// Inner border of the column.  		dleri.Y = column.Rect.Y;  		if (column.point.value < 0)  			dleri.Y = column.Rect.Y + column.Rect.Height - dleri.Height;  		break;  	case DataLabelPosition.Center:  		// Centered inside the column.  		dleri.Y = column.Rect.Y + column.Rect.Height / 2 - dleri.Height / 2;  		break;  	case DataLabelPosition.InsideBase:  		// Aligned at the base of the column.  		dleri.Y = column.Rect.Y + column.Rect.Height - dleri.Height;  		if (column.point.value < 0)  			dleri.Y = column.Rect.Y;  		break;  	case DataLabelPosition.OutsideEnd:  		// Outer border of the column.  		dleri.Y = column.Rect.Y - dleri.Height;  		if (column.point.value < 0)  			dleri.Y = column.Rect.Y + column.Rect.Height;  		break;  	}  }  
Magic Number,PdfSharp.Charting.Renderers,ColumnDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ColumnDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: dleri.X = column.Rect.X + column.Rect.Width / 2 - dleri.Width / 2;  
Magic Number,PdfSharp.Charting.Renderers,ColumnDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ColumnDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: dleri.X = column.Rect.X + column.Rect.Width / 2 - dleri.Width / 2;  
Magic Number,PdfSharp.Charting.Renderers,ColumnDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ColumnDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: switch (sri.dataLabelRendererInfo.Position) {  case DataLabelPosition.InsideEnd:  	// Inner border of the column.  	dleri.Y = column.Rect.Y;  	if (column.point.value < 0)  		dleri.Y = column.Rect.Y + column.Rect.Height - dleri.Height;  	break;  case DataLabelPosition.Center:  	// Centered inside the column.  	dleri.Y = column.Rect.Y + column.Rect.Height / 2 - dleri.Height / 2;  	break;  case DataLabelPosition.InsideBase:  	// Aligned at the base of the column.  	dleri.Y = column.Rect.Y + column.Rect.Height - dleri.Height;  	if (column.point.value < 0)  		dleri.Y = column.Rect.Y;  	break;  case DataLabelPosition.OutsideEnd:  	// Outer border of the column.  	dleri.Y = column.Rect.Y - dleri.Height;  	if (column.point.value < 0)  		dleri.Y = column.Rect.Y + column.Rect.Height;  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,ColumnDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ColumnDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: switch (sri.dataLabelRendererInfo.Position) {  case DataLabelPosition.InsideEnd:  	// Inner border of the column.  	dleri.Y = column.Rect.Y;  	if (column.point.value < 0)  		dleri.Y = column.Rect.Y + column.Rect.Height - dleri.Height;  	break;  case DataLabelPosition.Center:  	// Centered inside the column.  	dleri.Y = column.Rect.Y + column.Rect.Height / 2 - dleri.Height / 2;  	break;  case DataLabelPosition.InsideBase:  	// Aligned at the base of the column.  	dleri.Y = column.Rect.Y + column.Rect.Height - dleri.Height;  	if (column.point.value < 0)  		dleri.Y = column.Rect.Y;  	break;  case DataLabelPosition.OutsideEnd:  	// Outer border of the column.  	dleri.Y = column.Rect.Y - dleri.Height;  	if (column.point.value < 0)  		dleri.Y = column.Rect.Y + column.Rect.Height;  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,ColumnDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ColumnDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: dleri.Y = column.Rect.Y + column.Rect.Height / 2 - dleri.Height / 2;  
Magic Number,PdfSharp.Charting.Renderers,ColumnDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ColumnDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: dleri.Y = column.Rect.Y + column.Rect.Height / 2 - dleri.Height / 2;  
Magic Number,PdfSharp.Charting.Renderers,ColumnPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ColumnPlotAreaRenderer.cs,Draw,The following statement contains a magic number: if (cri.yAxisRendererInfo.MajorGridlinesLineFormat != null || cri.yAxisRendererInfo.MinorGridlinesLineFormat != null) {  	if (yMin < 0 && yMax > 0) {  		XPoint[] points = new XPoint[2];  		points [0].X = xMin;  		points [0].Y = 0;  		points [1].X = xMax;  		points [1].Y = 0;  		cri.plotAreaRendererInfo.matrix.TransformPoints (points);  		if (cri.yAxisRendererInfo.MinorGridlinesLineFormat != null)  			lineFormatRenderer = new LineFormatRenderer (gfx' cri.yAxisRendererInfo.MinorGridlinesLineFormat);  		else  			lineFormatRenderer = new LineFormatRenderer (gfx' cri.yAxisRendererInfo.MajorGridlinesLineFormat);  		lineFormatRenderer.DrawLine (points [0]' points [1]);  	}  }  
Magic Number,PdfSharp.Charting.Renderers,ColumnPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ColumnPlotAreaRenderer.cs,Draw,The following statement contains a magic number: if (yMin < 0 && yMax > 0) {  	XPoint[] points = new XPoint[2];  	points [0].X = xMin;  	points [0].Y = 0;  	points [1].X = xMax;  	points [1].Y = 0;  	cri.plotAreaRendererInfo.matrix.TransformPoints (points);  	if (cri.yAxisRendererInfo.MinorGridlinesLineFormat != null)  		lineFormatRenderer = new LineFormatRenderer (gfx' cri.yAxisRendererInfo.MinorGridlinesLineFormat);  	else  		lineFormatRenderer = new LineFormatRenderer (gfx' cri.yAxisRendererInfo.MajorGridlinesLineFormat);  	lineFormatRenderer.DrawLine (points [0]' points [1]);  }  
Magic Number,PdfSharp.Charting.Renderers,Converter,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\Converter.cs,ToXPen,The following statement contains a magic number: if (lineFormat == null) {  	pen = new XPen (defaultColor' defaultWidth);  	pen.DashStyle = defaultDashStyle;  }  else {  	XColor color = defaultColor;  	if (!lineFormat.Color.IsEmpty)  		color = lineFormat.Color;  	double width = lineFormat.Width.Point;  	if (!lineFormat.Visible)  		width = 0;  	if (lineFormat.Visible && width == 0)  		width = defaultWidth;  	pen = new XPen (color' width);  	pen.DashStyle = lineFormat.dashStyle;  	pen.DashOffset = 10 * width;  }  
Magic Number,PdfSharp.Charting.Renderers,Converter,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\Converter.cs,ToXPen,The following statement contains a magic number: pen.DashOffset = 10 * width;  
Magic Number,PdfSharp.Charting.Renderers,HorizontalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalXAxisRenderer.cs,Draw,The following statement contains a magic number: foreach (XSeries xs in xari.XValues) {  	for (int idx = 0; idx < countTickLabels && idx < xs.Count; ++idx) {  		XValue xv = xs [idx];  		if (xv != null) {  			string tickLabel = xv.Value;  			XSize size = gfx.MeasureString (tickLabel' xari.TickLabelsFont);  			gfx.DrawString (tickLabel' xari.TickLabelsFont' xari.TickLabelsBrush' startPos.X - size.Width / 2' startPos.Y);  		}  		startPos.X += tickLabelStep;  	}  }  
Magic Number,PdfSharp.Charting.Renderers,HorizontalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalXAxisRenderer.cs,Draw,The following statement contains a magic number: for (int idx = 0; idx < countTickLabels && idx < xs.Count; ++idx) {  	XValue xv = xs [idx];  	if (xv != null) {  		string tickLabel = xv.Value;  		XSize size = gfx.MeasureString (tickLabel' xari.TickLabelsFont);  		gfx.DrawString (tickLabel' xari.TickLabelsFont' xari.TickLabelsBrush' startPos.X - size.Width / 2' startPos.Y);  	}  	startPos.X += tickLabelStep;  }  
Magic Number,PdfSharp.Charting.Renderers,HorizontalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalXAxisRenderer.cs,Draw,The following statement contains a magic number: if (xv != null) {  	string tickLabel = xv.Value;  	XSize size = gfx.MeasureString (tickLabel' xari.TickLabelsFont);  	gfx.DrawString (tickLabel' xari.TickLabelsFont' xari.TickLabelsBrush' startPos.X - size.Width / 2' startPos.Y);  }  
Magic Number,PdfSharp.Charting.Renderers,HorizontalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalXAxisRenderer.cs,Draw,The following statement contains a magic number: gfx.DrawString (tickLabel' xari.TickLabelsFont' xari.TickLabelsBrush' startPos.X - size.Width / 2' startPos.Y);  
Magic Number,PdfSharp.Charting.Renderers,HorizontalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalXAxisRenderer.cs,Draw,The following statement contains a magic number: if (xari.LineFormat != null) {  	points [0].X = xari.X;  	points [0].Y = xari.Y;  	points [1].X = xari.X + xari.Width;  	points [1].Y = xari.Y;  	if (xari.MajorTickMark != TickMarkType.None) {  		points [0].X -= xari.LineFormat.Width / 2;  		points [1].X += xari.LineFormat.Width / 2;  	}  	lineFormatRenderer.DrawLine (points [0]' points [1]);  }  
Magic Number,PdfSharp.Charting.Renderers,HorizontalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalXAxisRenderer.cs,Draw,The following statement contains a magic number: if (xari.LineFormat != null) {  	points [0].X = xari.X;  	points [0].Y = xari.Y;  	points [1].X = xari.X + xari.Width;  	points [1].Y = xari.Y;  	if (xari.MajorTickMark != TickMarkType.None) {  		points [0].X -= xari.LineFormat.Width / 2;  		points [1].X += xari.LineFormat.Width / 2;  	}  	lineFormatRenderer.DrawLine (points [0]' points [1]);  }  
Magic Number,PdfSharp.Charting.Renderers,HorizontalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalXAxisRenderer.cs,Draw,The following statement contains a magic number: if (xari.MajorTickMark != TickMarkType.None) {  	points [0].X -= xari.LineFormat.Width / 2;  	points [1].X += xari.LineFormat.Width / 2;  }  
Magic Number,PdfSharp.Charting.Renderers,HorizontalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalXAxisRenderer.cs,Draw,The following statement contains a magic number: if (xari.MajorTickMark != TickMarkType.None) {  	points [0].X -= xari.LineFormat.Width / 2;  	points [1].X += xari.LineFormat.Width / 2;  }  
Magic Number,PdfSharp.Charting.Renderers,HorizontalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalXAxisRenderer.cs,Draw,The following statement contains a magic number: points [0].X -= xari.LineFormat.Width / 2;  
Magic Number,PdfSharp.Charting.Renderers,HorizontalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalXAxisRenderer.cs,Draw,The following statement contains a magic number: points [1].X += xari.LineFormat.Width / 2;  
Magic Number,PdfSharp.Charting.Renderers,HorizontalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalXAxisRenderer.cs,Draw,The following statement contains a magic number: if (atri != null && atri.AxisTitleText != null && atri.AxisTitleText.Length > 0) {  	XRect rect = new XRect (xari.Rect.Right / 2 - atri.AxisTitleSize.Width / 2' xari.Rect.Bottom' atri.AxisTitleSize.Width' 0);  	gfx.DrawString (atri.AxisTitleText' atri.AxisTitleFont' atri.AxisTitleBrush' rect);  }  
Magic Number,PdfSharp.Charting.Renderers,HorizontalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalXAxisRenderer.cs,Draw,The following statement contains a magic number: if (atri != null && atri.AxisTitleText != null && atri.AxisTitleText.Length > 0) {  	XRect rect = new XRect (xari.Rect.Right / 2 - atri.AxisTitleSize.Width / 2' xari.Rect.Bottom' atri.AxisTitleSize.Width' 0);  	gfx.DrawString (atri.AxisTitleText' atri.AxisTitleFont' atri.AxisTitleBrush' rect);  }  
Magic Number,PdfSharp.Charting.Renderers,HorizontalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalXAxisRenderer.cs,CalculateXAxisValues,The following statement contains a magic number: rendererInfo.MinorTick = 0.5;  
Magic Number,PdfSharp.Charting.Renderers,HorizontalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalYAxisRenderer.cs,Format,The following statement contains a magic number: if (yari.axis != null) {  	XGraphics gfx = this.rendererParms.Graphics;  	XSize size = new XSize (0' 0);  	// height of all ticklabels  	double yMin = yari.MinimumScale;  	double yMax = yari.MaximumScale;  	double yMajorTick = yari.MajorTick;  	double lineHeight = Double.MinValue;  	XSize labelSize = new XSize (0' 0);  	for (double y = yMin; y <= yMax; y += yMajorTick) {  		string str = y.ToString (yari.TickLabelsFormat);  		labelSize = gfx.MeasureString (str' yari.TickLabelsFont);  		size.Width += labelSize.Width;  		size.Height = Math.Max (labelSize.Height' size.Height);  		lineHeight = Math.Max (lineHeight' labelSize.Width);  	}  	// add space for tickmarks  	size.Height += yari.MajorTickMarkWidth * 1.5;  	// Measure axis title  	XSize titleSize = new XSize (0' 0);  	if (yari.axisTitleRendererInfo != null) {  		RendererParameters parms = new RendererParameters ();  		parms.Graphics = gfx;  		parms.RendererInfo = yari;  		AxisTitleRenderer atr = new AxisTitleRenderer (parms);  		atr.Format ();  		titleSize.Height = yari.axisTitleRendererInfo.Height;  		titleSize.Width = yari.axisTitleRendererInfo.Width;  	}  	yari.Height = size.Height + titleSize.Height;  	yari.Width = Math.Max (size.Width' titleSize.Width);  	yari.InnerRect = yari.Rect;  	yari.LabelSize = labelSize;  }  
Magic Number,PdfSharp.Charting.Renderers,HorizontalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalYAxisRenderer.cs,Format,The following statement contains a magic number: size.Height += yari.MajorTickMarkWidth * 1.5;  
Magic Number,PdfSharp.Charting.Renderers,HorizontalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalYAxisRenderer.cs,Draw,The following statement contains a magic number: for (int i = 0; i < countTickLabels; ++i) {  	double y = yMin + yMajorTick * i;  	string str = y.ToString (yari.TickLabelsFormat);  	XSize labelSize = gfx.MeasureString (str' yari.TickLabelsFont);  	if (yari.MajorTickMark != TickMarkType.None) {  		labelSize.Height += 1.5f * yari.MajorTickMarkWidth;  		points [0].X = y;  		points [0].Y = majorTickMarkStart;  		points [1].X = y;  		points [1].Y = majorTickMarkEnd;  		matrix.TransformPoints (points);  		lineFormatRenderer.DrawLine (points [0]' points [1]);  	}  	XPoint[] layoutText = new XPoint[1];  	layoutText [0].X = y;  	layoutText [0].Y = yari.Y + 1.5 * yari.MajorTickMarkWidth;  	matrix.TransformPoints (layoutText);  	layoutText [0].X -= labelSize.Width / 2;  	// Center text vertically.  	gfx.DrawString (str' yari.TickLabelsFont' yari.TickLabelsBrush' layoutText [0]' xsf);  }  
Magic Number,PdfSharp.Charting.Renderers,HorizontalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalYAxisRenderer.cs,Draw,The following statement contains a magic number: for (int i = 0; i < countTickLabels; ++i) {  	double y = yMin + yMajorTick * i;  	string str = y.ToString (yari.TickLabelsFormat);  	XSize labelSize = gfx.MeasureString (str' yari.TickLabelsFont);  	if (yari.MajorTickMark != TickMarkType.None) {  		labelSize.Height += 1.5f * yari.MajorTickMarkWidth;  		points [0].X = y;  		points [0].Y = majorTickMarkStart;  		points [1].X = y;  		points [1].Y = majorTickMarkEnd;  		matrix.TransformPoints (points);  		lineFormatRenderer.DrawLine (points [0]' points [1]);  	}  	XPoint[] layoutText = new XPoint[1];  	layoutText [0].X = y;  	layoutText [0].Y = yari.Y + 1.5 * yari.MajorTickMarkWidth;  	matrix.TransformPoints (layoutText);  	layoutText [0].X -= labelSize.Width / 2;  	// Center text vertically.  	gfx.DrawString (str' yari.TickLabelsFont' yari.TickLabelsBrush' layoutText [0]' xsf);  }  
Magic Number,PdfSharp.Charting.Renderers,HorizontalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalYAxisRenderer.cs,Draw,The following statement contains a magic number: layoutText [0].Y = yari.Y + 1.5 * yari.MajorTickMarkWidth;  
Magic Number,PdfSharp.Charting.Renderers,HorizontalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalYAxisRenderer.cs,Draw,The following statement contains a magic number: layoutText [0].X -= labelSize.Width / 2;  
Magic Number,PdfSharp.Charting.Renderers,HorizontalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalYAxisRenderer.cs,Draw,The following statement contains a magic number: if (yari.LineFormat != null) {  	points [0].X = yMin;  	points [0].Y = yari.Y;  	points [1].X = yMax;  	points [1].Y = yari.Y;  	matrix.TransformPoints (points);  	if (yari.MajorTickMark != TickMarkType.None) {  		// yMax is at the upper side of the axis  		points [0].X -= yari.LineFormat.Width / 2;  		points [1].X += yari.LineFormat.Width / 2;  	}  	lineFormatRenderer.DrawLine (points [0]' points [1]);  }  
Magic Number,PdfSharp.Charting.Renderers,HorizontalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalYAxisRenderer.cs,Draw,The following statement contains a magic number: if (yari.LineFormat != null) {  	points [0].X = yMin;  	points [0].Y = yari.Y;  	points [1].X = yMax;  	points [1].Y = yari.Y;  	matrix.TransformPoints (points);  	if (yari.MajorTickMark != TickMarkType.None) {  		// yMax is at the upper side of the axis  		points [0].X -= yari.LineFormat.Width / 2;  		points [1].X += yari.LineFormat.Width / 2;  	}  	lineFormatRenderer.DrawLine (points [0]' points [1]);  }  
Magic Number,PdfSharp.Charting.Renderers,HorizontalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalYAxisRenderer.cs,Draw,The following statement contains a magic number: if (yari.MajorTickMark != TickMarkType.None) {  	// yMax is at the upper side of the axis  	points [0].X -= yari.LineFormat.Width / 2;  	points [1].X += yari.LineFormat.Width / 2;  }  
Magic Number,PdfSharp.Charting.Renderers,HorizontalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalYAxisRenderer.cs,Draw,The following statement contains a magic number: if (yari.MajorTickMark != TickMarkType.None) {  	// yMax is at the upper side of the axis  	points [0].X -= yari.LineFormat.Width / 2;  	points [1].X += yari.LineFormat.Width / 2;  }  
Magic Number,PdfSharp.Charting.Renderers,HorizontalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalYAxisRenderer.cs,Draw,The following statement contains a magic number: points [0].X -= yari.LineFormat.Width / 2;  
Magic Number,PdfSharp.Charting.Renderers,HorizontalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalYAxisRenderer.cs,Draw,The following statement contains a magic number: points [1].X += yari.LineFormat.Width / 2;  
Magic Number,PdfSharp.Charting.Renderers,LegendEntryRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\LegendEntryRenderer.cs,Format,The following statement contains a magic number: if (leri.seriesRendererInfo.series.chartType == ChartType.Line)  	leri.MarkerArea.Width *= 3;  
Magic Number,PdfSharp.Charting.Renderers,LegendEntryRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\LegendEntryRenderer.cs,Format,The following statement contains a magic number: leri.MarkerArea.Width *= 3;  
Magic Number,PdfSharp.Charting.Renderers,LegendEntryRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\LegendEntryRenderer.cs,Format,The following statement contains a magic number: if (leri.EntryText != "") {  	leri.TextSize = gfx.MeasureString (leri.EntryText' leri.legendRendererInfo.Font);  	if (leri.seriesRendererInfo.series.chartType == ChartType.Line) {  		leri.MarkerSize.Width = leri.seriesRendererInfo.markerRendererInfo.MarkerSize.Value;  		leri.MarkerArea.Width = Math.Max (3 * leri.MarkerSize.Width' leri.MarkerArea.Width);  	}  	leri.MarkerArea.Height = Math.Min (leri.MarkerArea.Height' leri.TextSize.Height);  	leri.MarkerSize.Height = Math.Min (leri.MarkerSize.Height' leri.TextSize.Height);  	leri.Width = leri.TextSize.Width + leri.MarkerArea.Width + SpacingBetweenMarkerAndText;  	leri.Height = leri.TextSize.Height;  }  
Magic Number,PdfSharp.Charting.Renderers,LegendEntryRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\LegendEntryRenderer.cs,Format,The following statement contains a magic number: if (leri.seriesRendererInfo.series.chartType == ChartType.Line) {  	leri.MarkerSize.Width = leri.seriesRendererInfo.markerRendererInfo.MarkerSize.Value;  	leri.MarkerArea.Width = Math.Max (3 * leri.MarkerSize.Width' leri.MarkerArea.Width);  }  
Magic Number,PdfSharp.Charting.Renderers,LegendEntryRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\LegendEntryRenderer.cs,Format,The following statement contains a magic number: leri.MarkerArea.Width = Math.Max (3 * leri.MarkerSize.Width' leri.MarkerArea.Width);  
Magic Number,PdfSharp.Charting.Renderers,LegendEntryRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\LegendEntryRenderer.cs,Draw,The following statement contains a magic number: if (leri.seriesRendererInfo.series.chartType == ChartType.Line) {  	// Draw line.  	XPoint posLineStart = new XPoint (leri.X' leri.Y + leri.Height / 2);  	XPoint posLineEnd = new XPoint (leri.X + leri.MarkerArea.Width' leri.Y + leri.Height / 2);  	gfx.DrawLine (new XPen (((XSolidBrush)leri.MarkerBrush).Color)' posLineStart' posLineEnd);  	// Draw marker.  	double x = leri.X + leri.MarkerArea.Width / 2;  	XPoint posMarker = new XPoint (x' leri.Y + leri.Height / 2);  	MarkerRenderer.Draw (gfx' posMarker' leri.seriesRendererInfo.markerRendererInfo);  }  else {  	// Draw series rectangle for column' bar or pie charts.  	rect = new XRect (leri.X' leri.Y' leri.MarkerArea.Width' leri.MarkerArea.Height);  	rect.Y += (leri.Height - leri.MarkerArea.Height) / 2;  	gfx.DrawRectangle (leri.MarkerPen' leri.MarkerBrush' rect);  }  
Magic Number,PdfSharp.Charting.Renderers,LegendEntryRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\LegendEntryRenderer.cs,Draw,The following statement contains a magic number: if (leri.seriesRendererInfo.series.chartType == ChartType.Line) {  	// Draw line.  	XPoint posLineStart = new XPoint (leri.X' leri.Y + leri.Height / 2);  	XPoint posLineEnd = new XPoint (leri.X + leri.MarkerArea.Width' leri.Y + leri.Height / 2);  	gfx.DrawLine (new XPen (((XSolidBrush)leri.MarkerBrush).Color)' posLineStart' posLineEnd);  	// Draw marker.  	double x = leri.X + leri.MarkerArea.Width / 2;  	XPoint posMarker = new XPoint (x' leri.Y + leri.Height / 2);  	MarkerRenderer.Draw (gfx' posMarker' leri.seriesRendererInfo.markerRendererInfo);  }  else {  	// Draw series rectangle for column' bar or pie charts.  	rect = new XRect (leri.X' leri.Y' leri.MarkerArea.Width' leri.MarkerArea.Height);  	rect.Y += (leri.Height - leri.MarkerArea.Height) / 2;  	gfx.DrawRectangle (leri.MarkerPen' leri.MarkerBrush' rect);  }  
Magic Number,PdfSharp.Charting.Renderers,LegendEntryRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\LegendEntryRenderer.cs,Draw,The following statement contains a magic number: if (leri.seriesRendererInfo.series.chartType == ChartType.Line) {  	// Draw line.  	XPoint posLineStart = new XPoint (leri.X' leri.Y + leri.Height / 2);  	XPoint posLineEnd = new XPoint (leri.X + leri.MarkerArea.Width' leri.Y + leri.Height / 2);  	gfx.DrawLine (new XPen (((XSolidBrush)leri.MarkerBrush).Color)' posLineStart' posLineEnd);  	// Draw marker.  	double x = leri.X + leri.MarkerArea.Width / 2;  	XPoint posMarker = new XPoint (x' leri.Y + leri.Height / 2);  	MarkerRenderer.Draw (gfx' posMarker' leri.seriesRendererInfo.markerRendererInfo);  }  else {  	// Draw series rectangle for column' bar or pie charts.  	rect = new XRect (leri.X' leri.Y' leri.MarkerArea.Width' leri.MarkerArea.Height);  	rect.Y += (leri.Height - leri.MarkerArea.Height) / 2;  	gfx.DrawRectangle (leri.MarkerPen' leri.MarkerBrush' rect);  }  
Magic Number,PdfSharp.Charting.Renderers,LegendEntryRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\LegendEntryRenderer.cs,Draw,The following statement contains a magic number: if (leri.seriesRendererInfo.series.chartType == ChartType.Line) {  	// Draw line.  	XPoint posLineStart = new XPoint (leri.X' leri.Y + leri.Height / 2);  	XPoint posLineEnd = new XPoint (leri.X + leri.MarkerArea.Width' leri.Y + leri.Height / 2);  	gfx.DrawLine (new XPen (((XSolidBrush)leri.MarkerBrush).Color)' posLineStart' posLineEnd);  	// Draw marker.  	double x = leri.X + leri.MarkerArea.Width / 2;  	XPoint posMarker = new XPoint (x' leri.Y + leri.Height / 2);  	MarkerRenderer.Draw (gfx' posMarker' leri.seriesRendererInfo.markerRendererInfo);  }  else {  	// Draw series rectangle for column' bar or pie charts.  	rect = new XRect (leri.X' leri.Y' leri.MarkerArea.Width' leri.MarkerArea.Height);  	rect.Y += (leri.Height - leri.MarkerArea.Height) / 2;  	gfx.DrawRectangle (leri.MarkerPen' leri.MarkerBrush' rect);  }  
Magic Number,PdfSharp.Charting.Renderers,LegendEntryRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\LegendEntryRenderer.cs,Draw,The following statement contains a magic number: if (leri.seriesRendererInfo.series.chartType == ChartType.Line) {  	// Draw line.  	XPoint posLineStart = new XPoint (leri.X' leri.Y + leri.Height / 2);  	XPoint posLineEnd = new XPoint (leri.X + leri.MarkerArea.Width' leri.Y + leri.Height / 2);  	gfx.DrawLine (new XPen (((XSolidBrush)leri.MarkerBrush).Color)' posLineStart' posLineEnd);  	// Draw marker.  	double x = leri.X + leri.MarkerArea.Width / 2;  	XPoint posMarker = new XPoint (x' leri.Y + leri.Height / 2);  	MarkerRenderer.Draw (gfx' posMarker' leri.seriesRendererInfo.markerRendererInfo);  }  else {  	// Draw series rectangle for column' bar or pie charts.  	rect = new XRect (leri.X' leri.Y' leri.MarkerArea.Width' leri.MarkerArea.Height);  	rect.Y += (leri.Height - leri.MarkerArea.Height) / 2;  	gfx.DrawRectangle (leri.MarkerPen' leri.MarkerBrush' rect);  }  
Magic Number,PdfSharp.Charting.Renderers,LegendEntryRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\LegendEntryRenderer.cs,Draw,The following statement contains a magic number: rect.Y += (leri.Height - leri.MarkerArea.Height) / 2;  
Magic Number,PdfSharp.Charting.Renderers,LegendRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\LegendRenderer.cs,Format,The following statement contains a magic number: if (lri.BorderPen != null)  	paddingFactor = 2;  
Magic Number,PdfSharp.Charting.Renderers,LegendRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\LegendRenderer.cs,Format,The following statement contains a magic number: paddingFactor = 2;  
Magic Number,PdfSharp.Charting.Renderers,LegendRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\LegendRenderer.cs,Draw,The following statement contains a magic number: if (lri.BorderPen != null)  	paddingFactor = 2;  
Magic Number,PdfSharp.Charting.Renderers,LegendRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\LegendRenderer.cs,Draw,The following statement contains a magic number: paddingFactor = 2;  
Magic Number,PdfSharp.Charting.Renderers,LineChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\LineChartRenderer.cs,InitSeries,The following statement contains a magic number: foreach (SeriesRendererInfo sri in cri.seriesRendererInfos) {  	if (sri.series.markerBackgroundColor.IsEmpty)  		sri.LineFormat = Converter.ToXPen (sri.series.lineFormat' LineColors.Item (seriesIndex)' ChartRenderer.DefaultSeriesLineWidth);  	else  		sri.LineFormat = Converter.ToXPen (sri.series.lineFormat' sri.series.markerBackgroundColor' ChartRenderer.DefaultSeriesLineWidth);  	sri.LineFormat.LineJoin = XLineJoin.Bevel;  	MarkerRendererInfo mri = new MarkerRendererInfo ();  	sri.markerRendererInfo = mri;  	mri.MarkerForegroundColor = sri.series.markerForegroundColor;  	if (mri.MarkerForegroundColor.IsEmpty)  		mri.MarkerForegroundColor = XColors.Black;  	mri.MarkerBackgroundColor = sri.series.markerBackgroundColor;  	if (mri.MarkerBackgroundColor.IsEmpty)  		mri.MarkerBackgroundColor = sri.LineFormat.Color;  	mri.MarkerSize = sri.series.markerSize;  	if (mri.MarkerSize == 0)  		mri.MarkerSize = 7;  	if (!sri.series.markerStyleInitialized)  		mri.MarkerStyle = (MarkerStyle)(seriesIndex % (Enum.GetNames (typeof(MarkerStyle)).Length - 1) + 1);  	else  		mri.MarkerStyle = sri.series.markerStyle;  	++seriesIndex;  }  
Magic Number,PdfSharp.Charting.Renderers,LineChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\LineChartRenderer.cs,InitSeries,The following statement contains a magic number: if (mri.MarkerSize == 0)  	mri.MarkerSize = 7;  
Magic Number,PdfSharp.Charting.Renderers,LineChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\LineChartRenderer.cs,InitSeries,The following statement contains a magic number: mri.MarkerSize = 7;  
Magic Number,PdfSharp.Charting.Renderers,LinePlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\LinePlotAreaRenderer.cs,Draw,The following statement contains a magic number: foreach (SeriesRendererInfo sri in cri.seriesRendererInfos) {  	int count = sri.series.Elements.Count;  	XPoint[] points = new XPoint[count];  	for (int idx = 0; idx < count; idx++) {  		double v = sri.series.Elements [idx].Value;  		if (double.IsNaN (v))  			v = 0;  		points [idx] = new XPoint (idx + xMajorTick / 2' v);  	}  	matrix.TransformPoints (points);  	gfx.DrawLines (sri.LineFormat' points);  	DrawMarker (gfx' points' sri);  }  
Magic Number,PdfSharp.Charting.Renderers,LinePlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\LinePlotAreaRenderer.cs,Draw,The following statement contains a magic number: for (int idx = 0; idx < count; idx++) {  	double v = sri.series.Elements [idx].Value;  	if (double.IsNaN (v))  		v = 0;  	points [idx] = new XPoint (idx + xMajorTick / 2' v);  }  
Magic Number,PdfSharp.Charting.Renderers,LinePlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\LinePlotAreaRenderer.cs,Draw,The following statement contains a magic number: points [idx] = new XPoint (idx + xMajorTick / 2' v);  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: switch (rendererInfo.MarkerStyle) {  case MarkerStyle.Square:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	x1 = pos.X + size2;  	y1 = pos.Y + size2;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.Diamond:  	gp.AddLine (x1 = pos.X + size2' pos.Y' pos.X' y0 = pos.Y - size2);  	gp.AddLine (pos.X' y0' x0 = pos.X - size2' pos.Y);  	gp.AddLine (x0' pos.Y' pos.X' y1 = pos.Y + size2);  	gp.AddLine (pos.X' y1' x1' pos.Y);  	break;  case MarkerStyle.Triangle:  	y0 = pos.Y + size / 2;  	y1 = pos.Y - size / 2;  	g = Math.Sqrt (size * size * 4 / 3) / 2;  	gp.AddLine (pos.X' y1' pos.X + g' y0);  	gp.AddLine (pos.X + g' y0' pos.X - g' y0);  	gp.AddLine (pos.X - g' y0' pos.X' y1);  	break;  case MarkerStyle.Plus:  	g = size2 / 4;  	gp.AddLine (pos.X - size2' pos.Y + g' pos.X - g' pos.Y + g);  	gp.AddLine (pos.X - g' pos.Y + g' pos.X - g' pos.Y + size2);  	gp.AddLine (pos.X - g' pos.Y + size2' pos.X + g' pos.Y + size2);  	gp.AddLine (pos.X + g' pos.Y + size2' pos.X + g' pos.Y + g);  	gp.AddLine (pos.X + g' pos.Y + g' pos.X + size2' pos.Y + g);  	gp.AddLine (pos.X + size2' pos.Y + g' pos.X + size2' pos.Y - g);  	gp.AddLine (pos.X + size2' pos.Y - g' pos.X + g' pos.Y - g);  	gp.AddLine (pos.X + g' pos.Y - g' pos.X + g' pos.Y - size2);  	gp.AddLine (pos.X + g' pos.Y - size2' pos.X - g' pos.Y - size2);  	gp.AddLine (pos.X - g' pos.Y - size2' pos.X - g' pos.Y - g);  	gp.AddLine (pos.X - g' pos.Y - g' pos.X - size2' pos.Y - g);  	gp.AddLine (pos.X - size2' pos.Y - g' pos.X - size2' pos.Y + g);  	break;  case MarkerStyle.Circle:  case MarkerStyle.Dot:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	gp.AddEllipse (x0' y0' size' size);  	break;  case MarkerStyle.Dash:  	x0 = pos.X - size2;  	y0 = pos.Y - size2 / 3;  	x1 = pos.X + size2;  	y1 = pos.Y + size2 / 3;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.X:  	g = size / 4;  	gp.AddLine (pos.X - size2 + g' pos.Y - size2' pos.X' pos.Y - g);  	gp.AddLine (pos.X' pos.Y - g' pos.X + size2 - g' pos.Y - size2);  	gp.AddLine (pos.X + size2 - g' pos.Y - size2' pos.X + size2' pos.Y - size2 + g);  	gp.AddLine (pos.X + size2' pos.Y - size2 + g' pos.X + g' pos.Y);  	gp.AddLine (pos.X + g' pos.Y' pos.X + size2' pos.Y + size2 - g);  	gp.AddLine (pos.X + size2' pos.Y + size2 - g' pos.X + size2 - g' pos.Y + size2);  	gp.AddLine (pos.X + size2 - g' pos.Y + size2' pos.X' pos.Y + g);  	gp.AddLine (pos.X' pos.Y + g' pos.X - size2 + g' pos.Y + size2);  	gp.AddLine (pos.X - size2 + g' pos.Y + size2' pos.X - size2' pos.Y + size2 - g);  	gp.AddLine (pos.X - size2' pos.Y + size2 - g' pos.X - g' pos.Y);  	gp.AddLine (pos.X - g' pos.Y' pos.X - size2' pos.Y - size2 + g);  	break;  case MarkerStyle.Star:  	{  		XPoint[] points = new XPoint[10];  		double radStep = 2 * Math.PI / 5;  		double outerCircle = size / 2;  		double innerCircle = size / 5;  		// outer circle  		double rad = -(Math.PI / 2);  		// 90�  		for (int idx = 0; idx < 10; idx += 2) {  			points [idx].X = pos.X + outerCircle * Math.Cos (rad);  			points [idx].Y = pos.Y + outerCircle * Math.Sin (rad);  			rad += radStep;  		}  		// inner circle  		rad = -(Math.PI / 4);  		// 45�  		double x = innerCircle * Math.Cos (rad);  		double y = innerCircle * Math.Sin (rad);  		points [1].X = pos.X + x;  		points [1].Y = pos.Y + y;  		points [9].X = pos.X - x;  		points [9].Y = pos.Y + y;  		rad += radStep;  		x = innerCircle * Math.Cos (rad);  		y = innerCircle * Math.Sin (rad);  		points [3].X = pos.X + x;  		points [3].Y = pos.Y + y;  		points [7].X = pos.X - x;  		points [7].Y = pos.Y + y;  		rad += radStep;  		y = innerCircle * Math.Sin (rad);  		points [5].X = pos.X;  		points [5].Y = pos.Y + y;  		gp.AddLines (points);  	}  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: switch (rendererInfo.MarkerStyle) {  case MarkerStyle.Square:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	x1 = pos.X + size2;  	y1 = pos.Y + size2;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.Diamond:  	gp.AddLine (x1 = pos.X + size2' pos.Y' pos.X' y0 = pos.Y - size2);  	gp.AddLine (pos.X' y0' x0 = pos.X - size2' pos.Y);  	gp.AddLine (x0' pos.Y' pos.X' y1 = pos.Y + size2);  	gp.AddLine (pos.X' y1' x1' pos.Y);  	break;  case MarkerStyle.Triangle:  	y0 = pos.Y + size / 2;  	y1 = pos.Y - size / 2;  	g = Math.Sqrt (size * size * 4 / 3) / 2;  	gp.AddLine (pos.X' y1' pos.X + g' y0);  	gp.AddLine (pos.X + g' y0' pos.X - g' y0);  	gp.AddLine (pos.X - g' y0' pos.X' y1);  	break;  case MarkerStyle.Plus:  	g = size2 / 4;  	gp.AddLine (pos.X - size2' pos.Y + g' pos.X - g' pos.Y + g);  	gp.AddLine (pos.X - g' pos.Y + g' pos.X - g' pos.Y + size2);  	gp.AddLine (pos.X - g' pos.Y + size2' pos.X + g' pos.Y + size2);  	gp.AddLine (pos.X + g' pos.Y + size2' pos.X + g' pos.Y + g);  	gp.AddLine (pos.X + g' pos.Y + g' pos.X + size2' pos.Y + g);  	gp.AddLine (pos.X + size2' pos.Y + g' pos.X + size2' pos.Y - g);  	gp.AddLine (pos.X + size2' pos.Y - g' pos.X + g' pos.Y - g);  	gp.AddLine (pos.X + g' pos.Y - g' pos.X + g' pos.Y - size2);  	gp.AddLine (pos.X + g' pos.Y - size2' pos.X - g' pos.Y - size2);  	gp.AddLine (pos.X - g' pos.Y - size2' pos.X - g' pos.Y - g);  	gp.AddLine (pos.X - g' pos.Y - g' pos.X - size2' pos.Y - g);  	gp.AddLine (pos.X - size2' pos.Y - g' pos.X - size2' pos.Y + g);  	break;  case MarkerStyle.Circle:  case MarkerStyle.Dot:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	gp.AddEllipse (x0' y0' size' size);  	break;  case MarkerStyle.Dash:  	x0 = pos.X - size2;  	y0 = pos.Y - size2 / 3;  	x1 = pos.X + size2;  	y1 = pos.Y + size2 / 3;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.X:  	g = size / 4;  	gp.AddLine (pos.X - size2 + g' pos.Y - size2' pos.X' pos.Y - g);  	gp.AddLine (pos.X' pos.Y - g' pos.X + size2 - g' pos.Y - size2);  	gp.AddLine (pos.X + size2 - g' pos.Y - size2' pos.X + size2' pos.Y - size2 + g);  	gp.AddLine (pos.X + size2' pos.Y - size2 + g' pos.X + g' pos.Y);  	gp.AddLine (pos.X + g' pos.Y' pos.X + size2' pos.Y + size2 - g);  	gp.AddLine (pos.X + size2' pos.Y + size2 - g' pos.X + size2 - g' pos.Y + size2);  	gp.AddLine (pos.X + size2 - g' pos.Y + size2' pos.X' pos.Y + g);  	gp.AddLine (pos.X' pos.Y + g' pos.X - size2 + g' pos.Y + size2);  	gp.AddLine (pos.X - size2 + g' pos.Y + size2' pos.X - size2' pos.Y + size2 - g);  	gp.AddLine (pos.X - size2' pos.Y + size2 - g' pos.X - g' pos.Y);  	gp.AddLine (pos.X - g' pos.Y' pos.X - size2' pos.Y - size2 + g);  	break;  case MarkerStyle.Star:  	{  		XPoint[] points = new XPoint[10];  		double radStep = 2 * Math.PI / 5;  		double outerCircle = size / 2;  		double innerCircle = size / 5;  		// outer circle  		double rad = -(Math.PI / 2);  		// 90�  		for (int idx = 0; idx < 10; idx += 2) {  			points [idx].X = pos.X + outerCircle * Math.Cos (rad);  			points [idx].Y = pos.Y + outerCircle * Math.Sin (rad);  			rad += radStep;  		}  		// inner circle  		rad = -(Math.PI / 4);  		// 45�  		double x = innerCircle * Math.Cos (rad);  		double y = innerCircle * Math.Sin (rad);  		points [1].X = pos.X + x;  		points [1].Y = pos.Y + y;  		points [9].X = pos.X - x;  		points [9].Y = pos.Y + y;  		rad += radStep;  		x = innerCircle * Math.Cos (rad);  		y = innerCircle * Math.Sin (rad);  		points [3].X = pos.X + x;  		points [3].Y = pos.Y + y;  		points [7].X = pos.X - x;  		points [7].Y = pos.Y + y;  		rad += radStep;  		y = innerCircle * Math.Sin (rad);  		points [5].X = pos.X;  		points [5].Y = pos.Y + y;  		gp.AddLines (points);  	}  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: switch (rendererInfo.MarkerStyle) {  case MarkerStyle.Square:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	x1 = pos.X + size2;  	y1 = pos.Y + size2;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.Diamond:  	gp.AddLine (x1 = pos.X + size2' pos.Y' pos.X' y0 = pos.Y - size2);  	gp.AddLine (pos.X' y0' x0 = pos.X - size2' pos.Y);  	gp.AddLine (x0' pos.Y' pos.X' y1 = pos.Y + size2);  	gp.AddLine (pos.X' y1' x1' pos.Y);  	break;  case MarkerStyle.Triangle:  	y0 = pos.Y + size / 2;  	y1 = pos.Y - size / 2;  	g = Math.Sqrt (size * size * 4 / 3) / 2;  	gp.AddLine (pos.X' y1' pos.X + g' y0);  	gp.AddLine (pos.X + g' y0' pos.X - g' y0);  	gp.AddLine (pos.X - g' y0' pos.X' y1);  	break;  case MarkerStyle.Plus:  	g = size2 / 4;  	gp.AddLine (pos.X - size2' pos.Y + g' pos.X - g' pos.Y + g);  	gp.AddLine (pos.X - g' pos.Y + g' pos.X - g' pos.Y + size2);  	gp.AddLine (pos.X - g' pos.Y + size2' pos.X + g' pos.Y + size2);  	gp.AddLine (pos.X + g' pos.Y + size2' pos.X + g' pos.Y + g);  	gp.AddLine (pos.X + g' pos.Y + g' pos.X + size2' pos.Y + g);  	gp.AddLine (pos.X + size2' pos.Y + g' pos.X + size2' pos.Y - g);  	gp.AddLine (pos.X + size2' pos.Y - g' pos.X + g' pos.Y - g);  	gp.AddLine (pos.X + g' pos.Y - g' pos.X + g' pos.Y - size2);  	gp.AddLine (pos.X + g' pos.Y - size2' pos.X - g' pos.Y - size2);  	gp.AddLine (pos.X - g' pos.Y - size2' pos.X - g' pos.Y - g);  	gp.AddLine (pos.X - g' pos.Y - g' pos.X - size2' pos.Y - g);  	gp.AddLine (pos.X - size2' pos.Y - g' pos.X - size2' pos.Y + g);  	break;  case MarkerStyle.Circle:  case MarkerStyle.Dot:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	gp.AddEllipse (x0' y0' size' size);  	break;  case MarkerStyle.Dash:  	x0 = pos.X - size2;  	y0 = pos.Y - size2 / 3;  	x1 = pos.X + size2;  	y1 = pos.Y + size2 / 3;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.X:  	g = size / 4;  	gp.AddLine (pos.X - size2 + g' pos.Y - size2' pos.X' pos.Y - g);  	gp.AddLine (pos.X' pos.Y - g' pos.X + size2 - g' pos.Y - size2);  	gp.AddLine (pos.X + size2 - g' pos.Y - size2' pos.X + size2' pos.Y - size2 + g);  	gp.AddLine (pos.X + size2' pos.Y - size2 + g' pos.X + g' pos.Y);  	gp.AddLine (pos.X + g' pos.Y' pos.X + size2' pos.Y + size2 - g);  	gp.AddLine (pos.X + size2' pos.Y + size2 - g' pos.X + size2 - g' pos.Y + size2);  	gp.AddLine (pos.X + size2 - g' pos.Y + size2' pos.X' pos.Y + g);  	gp.AddLine (pos.X' pos.Y + g' pos.X - size2 + g' pos.Y + size2);  	gp.AddLine (pos.X - size2 + g' pos.Y + size2' pos.X - size2' pos.Y + size2 - g);  	gp.AddLine (pos.X - size2' pos.Y + size2 - g' pos.X - g' pos.Y);  	gp.AddLine (pos.X - g' pos.Y' pos.X - size2' pos.Y - size2 + g);  	break;  case MarkerStyle.Star:  	{  		XPoint[] points = new XPoint[10];  		double radStep = 2 * Math.PI / 5;  		double outerCircle = size / 2;  		double innerCircle = size / 5;  		// outer circle  		double rad = -(Math.PI / 2);  		// 90�  		for (int idx = 0; idx < 10; idx += 2) {  			points [idx].X = pos.X + outerCircle * Math.Cos (rad);  			points [idx].Y = pos.Y + outerCircle * Math.Sin (rad);  			rad += radStep;  		}  		// inner circle  		rad = -(Math.PI / 4);  		// 45�  		double x = innerCircle * Math.Cos (rad);  		double y = innerCircle * Math.Sin (rad);  		points [1].X = pos.X + x;  		points [1].Y = pos.Y + y;  		points [9].X = pos.X - x;  		points [9].Y = pos.Y + y;  		rad += radStep;  		x = innerCircle * Math.Cos (rad);  		y = innerCircle * Math.Sin (rad);  		points [3].X = pos.X + x;  		points [3].Y = pos.Y + y;  		points [7].X = pos.X - x;  		points [7].Y = pos.Y + y;  		rad += radStep;  		y = innerCircle * Math.Sin (rad);  		points [5].X = pos.X;  		points [5].Y = pos.Y + y;  		gp.AddLines (points);  	}  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: switch (rendererInfo.MarkerStyle) {  case MarkerStyle.Square:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	x1 = pos.X + size2;  	y1 = pos.Y + size2;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.Diamond:  	gp.AddLine (x1 = pos.X + size2' pos.Y' pos.X' y0 = pos.Y - size2);  	gp.AddLine (pos.X' y0' x0 = pos.X - size2' pos.Y);  	gp.AddLine (x0' pos.Y' pos.X' y1 = pos.Y + size2);  	gp.AddLine (pos.X' y1' x1' pos.Y);  	break;  case MarkerStyle.Triangle:  	y0 = pos.Y + size / 2;  	y1 = pos.Y - size / 2;  	g = Math.Sqrt (size * size * 4 / 3) / 2;  	gp.AddLine (pos.X' y1' pos.X + g' y0);  	gp.AddLine (pos.X + g' y0' pos.X - g' y0);  	gp.AddLine (pos.X - g' y0' pos.X' y1);  	break;  case MarkerStyle.Plus:  	g = size2 / 4;  	gp.AddLine (pos.X - size2' pos.Y + g' pos.X - g' pos.Y + g);  	gp.AddLine (pos.X - g' pos.Y + g' pos.X - g' pos.Y + size2);  	gp.AddLine (pos.X - g' pos.Y + size2' pos.X + g' pos.Y + size2);  	gp.AddLine (pos.X + g' pos.Y + size2' pos.X + g' pos.Y + g);  	gp.AddLine (pos.X + g' pos.Y + g' pos.X + size2' pos.Y + g);  	gp.AddLine (pos.X + size2' pos.Y + g' pos.X + size2' pos.Y - g);  	gp.AddLine (pos.X + size2' pos.Y - g' pos.X + g' pos.Y - g);  	gp.AddLine (pos.X + g' pos.Y - g' pos.X + g' pos.Y - size2);  	gp.AddLine (pos.X + g' pos.Y - size2' pos.X - g' pos.Y - size2);  	gp.AddLine (pos.X - g' pos.Y - size2' pos.X - g' pos.Y - g);  	gp.AddLine (pos.X - g' pos.Y - g' pos.X - size2' pos.Y - g);  	gp.AddLine (pos.X - size2' pos.Y - g' pos.X - size2' pos.Y + g);  	break;  case MarkerStyle.Circle:  case MarkerStyle.Dot:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	gp.AddEllipse (x0' y0' size' size);  	break;  case MarkerStyle.Dash:  	x0 = pos.X - size2;  	y0 = pos.Y - size2 / 3;  	x1 = pos.X + size2;  	y1 = pos.Y + size2 / 3;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.X:  	g = size / 4;  	gp.AddLine (pos.X - size2 + g' pos.Y - size2' pos.X' pos.Y - g);  	gp.AddLine (pos.X' pos.Y - g' pos.X + size2 - g' pos.Y - size2);  	gp.AddLine (pos.X + size2 - g' pos.Y - size2' pos.X + size2' pos.Y - size2 + g);  	gp.AddLine (pos.X + size2' pos.Y - size2 + g' pos.X + g' pos.Y);  	gp.AddLine (pos.X + g' pos.Y' pos.X + size2' pos.Y + size2 - g);  	gp.AddLine (pos.X + size2' pos.Y + size2 - g' pos.X + size2 - g' pos.Y + size2);  	gp.AddLine (pos.X + size2 - g' pos.Y + size2' pos.X' pos.Y + g);  	gp.AddLine (pos.X' pos.Y + g' pos.X - size2 + g' pos.Y + size2);  	gp.AddLine (pos.X - size2 + g' pos.Y + size2' pos.X - size2' pos.Y + size2 - g);  	gp.AddLine (pos.X - size2' pos.Y + size2 - g' pos.X - g' pos.Y);  	gp.AddLine (pos.X - g' pos.Y' pos.X - size2' pos.Y - size2 + g);  	break;  case MarkerStyle.Star:  	{  		XPoint[] points = new XPoint[10];  		double radStep = 2 * Math.PI / 5;  		double outerCircle = size / 2;  		double innerCircle = size / 5;  		// outer circle  		double rad = -(Math.PI / 2);  		// 90�  		for (int idx = 0; idx < 10; idx += 2) {  			points [idx].X = pos.X + outerCircle * Math.Cos (rad);  			points [idx].Y = pos.Y + outerCircle * Math.Sin (rad);  			rad += radStep;  		}  		// inner circle  		rad = -(Math.PI / 4);  		// 45�  		double x = innerCircle * Math.Cos (rad);  		double y = innerCircle * Math.Sin (rad);  		points [1].X = pos.X + x;  		points [1].Y = pos.Y + y;  		points [9].X = pos.X - x;  		points [9].Y = pos.Y + y;  		rad += radStep;  		x = innerCircle * Math.Cos (rad);  		y = innerCircle * Math.Sin (rad);  		points [3].X = pos.X + x;  		points [3].Y = pos.Y + y;  		points [7].X = pos.X - x;  		points [7].Y = pos.Y + y;  		rad += radStep;  		y = innerCircle * Math.Sin (rad);  		points [5].X = pos.X;  		points [5].Y = pos.Y + y;  		gp.AddLines (points);  	}  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: switch (rendererInfo.MarkerStyle) {  case MarkerStyle.Square:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	x1 = pos.X + size2;  	y1 = pos.Y + size2;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.Diamond:  	gp.AddLine (x1 = pos.X + size2' pos.Y' pos.X' y0 = pos.Y - size2);  	gp.AddLine (pos.X' y0' x0 = pos.X - size2' pos.Y);  	gp.AddLine (x0' pos.Y' pos.X' y1 = pos.Y + size2);  	gp.AddLine (pos.X' y1' x1' pos.Y);  	break;  case MarkerStyle.Triangle:  	y0 = pos.Y + size / 2;  	y1 = pos.Y - size / 2;  	g = Math.Sqrt (size * size * 4 / 3) / 2;  	gp.AddLine (pos.X' y1' pos.X + g' y0);  	gp.AddLine (pos.X + g' y0' pos.X - g' y0);  	gp.AddLine (pos.X - g' y0' pos.X' y1);  	break;  case MarkerStyle.Plus:  	g = size2 / 4;  	gp.AddLine (pos.X - size2' pos.Y + g' pos.X - g' pos.Y + g);  	gp.AddLine (pos.X - g' pos.Y + g' pos.X - g' pos.Y + size2);  	gp.AddLine (pos.X - g' pos.Y + size2' pos.X + g' pos.Y + size2);  	gp.AddLine (pos.X + g' pos.Y + size2' pos.X + g' pos.Y + g);  	gp.AddLine (pos.X + g' pos.Y + g' pos.X + size2' pos.Y + g);  	gp.AddLine (pos.X + size2' pos.Y + g' pos.X + size2' pos.Y - g);  	gp.AddLine (pos.X + size2' pos.Y - g' pos.X + g' pos.Y - g);  	gp.AddLine (pos.X + g' pos.Y - g' pos.X + g' pos.Y - size2);  	gp.AddLine (pos.X + g' pos.Y - size2' pos.X - g' pos.Y - size2);  	gp.AddLine (pos.X - g' pos.Y - size2' pos.X - g' pos.Y - g);  	gp.AddLine (pos.X - g' pos.Y - g' pos.X - size2' pos.Y - g);  	gp.AddLine (pos.X - size2' pos.Y - g' pos.X - size2' pos.Y + g);  	break;  case MarkerStyle.Circle:  case MarkerStyle.Dot:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	gp.AddEllipse (x0' y0' size' size);  	break;  case MarkerStyle.Dash:  	x0 = pos.X - size2;  	y0 = pos.Y - size2 / 3;  	x1 = pos.X + size2;  	y1 = pos.Y + size2 / 3;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.X:  	g = size / 4;  	gp.AddLine (pos.X - size2 + g' pos.Y - size2' pos.X' pos.Y - g);  	gp.AddLine (pos.X' pos.Y - g' pos.X + size2 - g' pos.Y - size2);  	gp.AddLine (pos.X + size2 - g' pos.Y - size2' pos.X + size2' pos.Y - size2 + g);  	gp.AddLine (pos.X + size2' pos.Y - size2 + g' pos.X + g' pos.Y);  	gp.AddLine (pos.X + g' pos.Y' pos.X + size2' pos.Y + size2 - g);  	gp.AddLine (pos.X + size2' pos.Y + size2 - g' pos.X + size2 - g' pos.Y + size2);  	gp.AddLine (pos.X + size2 - g' pos.Y + size2' pos.X' pos.Y + g);  	gp.AddLine (pos.X' pos.Y + g' pos.X - size2 + g' pos.Y + size2);  	gp.AddLine (pos.X - size2 + g' pos.Y + size2' pos.X - size2' pos.Y + size2 - g);  	gp.AddLine (pos.X - size2' pos.Y + size2 - g' pos.X - g' pos.Y);  	gp.AddLine (pos.X - g' pos.Y' pos.X - size2' pos.Y - size2 + g);  	break;  case MarkerStyle.Star:  	{  		XPoint[] points = new XPoint[10];  		double radStep = 2 * Math.PI / 5;  		double outerCircle = size / 2;  		double innerCircle = size / 5;  		// outer circle  		double rad = -(Math.PI / 2);  		// 90�  		for (int idx = 0; idx < 10; idx += 2) {  			points [idx].X = pos.X + outerCircle * Math.Cos (rad);  			points [idx].Y = pos.Y + outerCircle * Math.Sin (rad);  			rad += radStep;  		}  		// inner circle  		rad = -(Math.PI / 4);  		// 45�  		double x = innerCircle * Math.Cos (rad);  		double y = innerCircle * Math.Sin (rad);  		points [1].X = pos.X + x;  		points [1].Y = pos.Y + y;  		points [9].X = pos.X - x;  		points [9].Y = pos.Y + y;  		rad += radStep;  		x = innerCircle * Math.Cos (rad);  		y = innerCircle * Math.Sin (rad);  		points [3].X = pos.X + x;  		points [3].Y = pos.Y + y;  		points [7].X = pos.X - x;  		points [7].Y = pos.Y + y;  		rad += radStep;  		y = innerCircle * Math.Sin (rad);  		points [5].X = pos.X;  		points [5].Y = pos.Y + y;  		gp.AddLines (points);  	}  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: switch (rendererInfo.MarkerStyle) {  case MarkerStyle.Square:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	x1 = pos.X + size2;  	y1 = pos.Y + size2;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.Diamond:  	gp.AddLine (x1 = pos.X + size2' pos.Y' pos.X' y0 = pos.Y - size2);  	gp.AddLine (pos.X' y0' x0 = pos.X - size2' pos.Y);  	gp.AddLine (x0' pos.Y' pos.X' y1 = pos.Y + size2);  	gp.AddLine (pos.X' y1' x1' pos.Y);  	break;  case MarkerStyle.Triangle:  	y0 = pos.Y + size / 2;  	y1 = pos.Y - size / 2;  	g = Math.Sqrt (size * size * 4 / 3) / 2;  	gp.AddLine (pos.X' y1' pos.X + g' y0);  	gp.AddLine (pos.X + g' y0' pos.X - g' y0);  	gp.AddLine (pos.X - g' y0' pos.X' y1);  	break;  case MarkerStyle.Plus:  	g = size2 / 4;  	gp.AddLine (pos.X - size2' pos.Y + g' pos.X - g' pos.Y + g);  	gp.AddLine (pos.X - g' pos.Y + g' pos.X - g' pos.Y + size2);  	gp.AddLine (pos.X - g' pos.Y + size2' pos.X + g' pos.Y + size2);  	gp.AddLine (pos.X + g' pos.Y + size2' pos.X + g' pos.Y + g);  	gp.AddLine (pos.X + g' pos.Y + g' pos.X + size2' pos.Y + g);  	gp.AddLine (pos.X + size2' pos.Y + g' pos.X + size2' pos.Y - g);  	gp.AddLine (pos.X + size2' pos.Y - g' pos.X + g' pos.Y - g);  	gp.AddLine (pos.X + g' pos.Y - g' pos.X + g' pos.Y - size2);  	gp.AddLine (pos.X + g' pos.Y - size2' pos.X - g' pos.Y - size2);  	gp.AddLine (pos.X - g' pos.Y - size2' pos.X - g' pos.Y - g);  	gp.AddLine (pos.X - g' pos.Y - g' pos.X - size2' pos.Y - g);  	gp.AddLine (pos.X - size2' pos.Y - g' pos.X - size2' pos.Y + g);  	break;  case MarkerStyle.Circle:  case MarkerStyle.Dot:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	gp.AddEllipse (x0' y0' size' size);  	break;  case MarkerStyle.Dash:  	x0 = pos.X - size2;  	y0 = pos.Y - size2 / 3;  	x1 = pos.X + size2;  	y1 = pos.Y + size2 / 3;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.X:  	g = size / 4;  	gp.AddLine (pos.X - size2 + g' pos.Y - size2' pos.X' pos.Y - g);  	gp.AddLine (pos.X' pos.Y - g' pos.X + size2 - g' pos.Y - size2);  	gp.AddLine (pos.X + size2 - g' pos.Y - size2' pos.X + size2' pos.Y - size2 + g);  	gp.AddLine (pos.X + size2' pos.Y - size2 + g' pos.X + g' pos.Y);  	gp.AddLine (pos.X + g' pos.Y' pos.X + size2' pos.Y + size2 - g);  	gp.AddLine (pos.X + size2' pos.Y + size2 - g' pos.X + size2 - g' pos.Y + size2);  	gp.AddLine (pos.X + size2 - g' pos.Y + size2' pos.X' pos.Y + g);  	gp.AddLine (pos.X' pos.Y + g' pos.X - size2 + g' pos.Y + size2);  	gp.AddLine (pos.X - size2 + g' pos.Y + size2' pos.X - size2' pos.Y + size2 - g);  	gp.AddLine (pos.X - size2' pos.Y + size2 - g' pos.X - g' pos.Y);  	gp.AddLine (pos.X - g' pos.Y' pos.X - size2' pos.Y - size2 + g);  	break;  case MarkerStyle.Star:  	{  		XPoint[] points = new XPoint[10];  		double radStep = 2 * Math.PI / 5;  		double outerCircle = size / 2;  		double innerCircle = size / 5;  		// outer circle  		double rad = -(Math.PI / 2);  		// 90�  		for (int idx = 0; idx < 10; idx += 2) {  			points [idx].X = pos.X + outerCircle * Math.Cos (rad);  			points [idx].Y = pos.Y + outerCircle * Math.Sin (rad);  			rad += radStep;  		}  		// inner circle  		rad = -(Math.PI / 4);  		// 45�  		double x = innerCircle * Math.Cos (rad);  		double y = innerCircle * Math.Sin (rad);  		points [1].X = pos.X + x;  		points [1].Y = pos.Y + y;  		points [9].X = pos.X - x;  		points [9].Y = pos.Y + y;  		rad += radStep;  		x = innerCircle * Math.Cos (rad);  		y = innerCircle * Math.Sin (rad);  		points [3].X = pos.X + x;  		points [3].Y = pos.Y + y;  		points [7].X = pos.X - x;  		points [7].Y = pos.Y + y;  		rad += radStep;  		y = innerCircle * Math.Sin (rad);  		points [5].X = pos.X;  		points [5].Y = pos.Y + y;  		gp.AddLines (points);  	}  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: switch (rendererInfo.MarkerStyle) {  case MarkerStyle.Square:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	x1 = pos.X + size2;  	y1 = pos.Y + size2;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.Diamond:  	gp.AddLine (x1 = pos.X + size2' pos.Y' pos.X' y0 = pos.Y - size2);  	gp.AddLine (pos.X' y0' x0 = pos.X - size2' pos.Y);  	gp.AddLine (x0' pos.Y' pos.X' y1 = pos.Y + size2);  	gp.AddLine (pos.X' y1' x1' pos.Y);  	break;  case MarkerStyle.Triangle:  	y0 = pos.Y + size / 2;  	y1 = pos.Y - size / 2;  	g = Math.Sqrt (size * size * 4 / 3) / 2;  	gp.AddLine (pos.X' y1' pos.X + g' y0);  	gp.AddLine (pos.X + g' y0' pos.X - g' y0);  	gp.AddLine (pos.X - g' y0' pos.X' y1);  	break;  case MarkerStyle.Plus:  	g = size2 / 4;  	gp.AddLine (pos.X - size2' pos.Y + g' pos.X - g' pos.Y + g);  	gp.AddLine (pos.X - g' pos.Y + g' pos.X - g' pos.Y + size2);  	gp.AddLine (pos.X - g' pos.Y + size2' pos.X + g' pos.Y + size2);  	gp.AddLine (pos.X + g' pos.Y + size2' pos.X + g' pos.Y + g);  	gp.AddLine (pos.X + g' pos.Y + g' pos.X + size2' pos.Y + g);  	gp.AddLine (pos.X + size2' pos.Y + g' pos.X + size2' pos.Y - g);  	gp.AddLine (pos.X + size2' pos.Y - g' pos.X + g' pos.Y - g);  	gp.AddLine (pos.X + g' pos.Y - g' pos.X + g' pos.Y - size2);  	gp.AddLine (pos.X + g' pos.Y - size2' pos.X - g' pos.Y - size2);  	gp.AddLine (pos.X - g' pos.Y - size2' pos.X - g' pos.Y - g);  	gp.AddLine (pos.X - g' pos.Y - g' pos.X - size2' pos.Y - g);  	gp.AddLine (pos.X - size2' pos.Y - g' pos.X - size2' pos.Y + g);  	break;  case MarkerStyle.Circle:  case MarkerStyle.Dot:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	gp.AddEllipse (x0' y0' size' size);  	break;  case MarkerStyle.Dash:  	x0 = pos.X - size2;  	y0 = pos.Y - size2 / 3;  	x1 = pos.X + size2;  	y1 = pos.Y + size2 / 3;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.X:  	g = size / 4;  	gp.AddLine (pos.X - size2 + g' pos.Y - size2' pos.X' pos.Y - g);  	gp.AddLine (pos.X' pos.Y - g' pos.X + size2 - g' pos.Y - size2);  	gp.AddLine (pos.X + size2 - g' pos.Y - size2' pos.X + size2' pos.Y - size2 + g);  	gp.AddLine (pos.X + size2' pos.Y - size2 + g' pos.X + g' pos.Y);  	gp.AddLine (pos.X + g' pos.Y' pos.X + size2' pos.Y + size2 - g);  	gp.AddLine (pos.X + size2' pos.Y + size2 - g' pos.X + size2 - g' pos.Y + size2);  	gp.AddLine (pos.X + size2 - g' pos.Y + size2' pos.X' pos.Y + g);  	gp.AddLine (pos.X' pos.Y + g' pos.X - size2 + g' pos.Y + size2);  	gp.AddLine (pos.X - size2 + g' pos.Y + size2' pos.X - size2' pos.Y + size2 - g);  	gp.AddLine (pos.X - size2' pos.Y + size2 - g' pos.X - g' pos.Y);  	gp.AddLine (pos.X - g' pos.Y' pos.X - size2' pos.Y - size2 + g);  	break;  case MarkerStyle.Star:  	{  		XPoint[] points = new XPoint[10];  		double radStep = 2 * Math.PI / 5;  		double outerCircle = size / 2;  		double innerCircle = size / 5;  		// outer circle  		double rad = -(Math.PI / 2);  		// 90�  		for (int idx = 0; idx < 10; idx += 2) {  			points [idx].X = pos.X + outerCircle * Math.Cos (rad);  			points [idx].Y = pos.Y + outerCircle * Math.Sin (rad);  			rad += radStep;  		}  		// inner circle  		rad = -(Math.PI / 4);  		// 45�  		double x = innerCircle * Math.Cos (rad);  		double y = innerCircle * Math.Sin (rad);  		points [1].X = pos.X + x;  		points [1].Y = pos.Y + y;  		points [9].X = pos.X - x;  		points [9].Y = pos.Y + y;  		rad += radStep;  		x = innerCircle * Math.Cos (rad);  		y = innerCircle * Math.Sin (rad);  		points [3].X = pos.X + x;  		points [3].Y = pos.Y + y;  		points [7].X = pos.X - x;  		points [7].Y = pos.Y + y;  		rad += radStep;  		y = innerCircle * Math.Sin (rad);  		points [5].X = pos.X;  		points [5].Y = pos.Y + y;  		gp.AddLines (points);  	}  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: switch (rendererInfo.MarkerStyle) {  case MarkerStyle.Square:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	x1 = pos.X + size2;  	y1 = pos.Y + size2;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.Diamond:  	gp.AddLine (x1 = pos.X + size2' pos.Y' pos.X' y0 = pos.Y - size2);  	gp.AddLine (pos.X' y0' x0 = pos.X - size2' pos.Y);  	gp.AddLine (x0' pos.Y' pos.X' y1 = pos.Y + size2);  	gp.AddLine (pos.X' y1' x1' pos.Y);  	break;  case MarkerStyle.Triangle:  	y0 = pos.Y + size / 2;  	y1 = pos.Y - size / 2;  	g = Math.Sqrt (size * size * 4 / 3) / 2;  	gp.AddLine (pos.X' y1' pos.X + g' y0);  	gp.AddLine (pos.X + g' y0' pos.X - g' y0);  	gp.AddLine (pos.X - g' y0' pos.X' y1);  	break;  case MarkerStyle.Plus:  	g = size2 / 4;  	gp.AddLine (pos.X - size2' pos.Y + g' pos.X - g' pos.Y + g);  	gp.AddLine (pos.X - g' pos.Y + g' pos.X - g' pos.Y + size2);  	gp.AddLine (pos.X - g' pos.Y + size2' pos.X + g' pos.Y + size2);  	gp.AddLine (pos.X + g' pos.Y + size2' pos.X + g' pos.Y + g);  	gp.AddLine (pos.X + g' pos.Y + g' pos.X + size2' pos.Y + g);  	gp.AddLine (pos.X + size2' pos.Y + g' pos.X + size2' pos.Y - g);  	gp.AddLine (pos.X + size2' pos.Y - g' pos.X + g' pos.Y - g);  	gp.AddLine (pos.X + g' pos.Y - g' pos.X + g' pos.Y - size2);  	gp.AddLine (pos.X + g' pos.Y - size2' pos.X - g' pos.Y - size2);  	gp.AddLine (pos.X - g' pos.Y - size2' pos.X - g' pos.Y - g);  	gp.AddLine (pos.X - g' pos.Y - g' pos.X - size2' pos.Y - g);  	gp.AddLine (pos.X - size2' pos.Y - g' pos.X - size2' pos.Y + g);  	break;  case MarkerStyle.Circle:  case MarkerStyle.Dot:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	gp.AddEllipse (x0' y0' size' size);  	break;  case MarkerStyle.Dash:  	x0 = pos.X - size2;  	y0 = pos.Y - size2 / 3;  	x1 = pos.X + size2;  	y1 = pos.Y + size2 / 3;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.X:  	g = size / 4;  	gp.AddLine (pos.X - size2 + g' pos.Y - size2' pos.X' pos.Y - g);  	gp.AddLine (pos.X' pos.Y - g' pos.X + size2 - g' pos.Y - size2);  	gp.AddLine (pos.X + size2 - g' pos.Y - size2' pos.X + size2' pos.Y - size2 + g);  	gp.AddLine (pos.X + size2' pos.Y - size2 + g' pos.X + g' pos.Y);  	gp.AddLine (pos.X + g' pos.Y' pos.X + size2' pos.Y + size2 - g);  	gp.AddLine (pos.X + size2' pos.Y + size2 - g' pos.X + size2 - g' pos.Y + size2);  	gp.AddLine (pos.X + size2 - g' pos.Y + size2' pos.X' pos.Y + g);  	gp.AddLine (pos.X' pos.Y + g' pos.X - size2 + g' pos.Y + size2);  	gp.AddLine (pos.X - size2 + g' pos.Y + size2' pos.X - size2' pos.Y + size2 - g);  	gp.AddLine (pos.X - size2' pos.Y + size2 - g' pos.X - g' pos.Y);  	gp.AddLine (pos.X - g' pos.Y' pos.X - size2' pos.Y - size2 + g);  	break;  case MarkerStyle.Star:  	{  		XPoint[] points = new XPoint[10];  		double radStep = 2 * Math.PI / 5;  		double outerCircle = size / 2;  		double innerCircle = size / 5;  		// outer circle  		double rad = -(Math.PI / 2);  		// 90�  		for (int idx = 0; idx < 10; idx += 2) {  			points [idx].X = pos.X + outerCircle * Math.Cos (rad);  			points [idx].Y = pos.Y + outerCircle * Math.Sin (rad);  			rad += radStep;  		}  		// inner circle  		rad = -(Math.PI / 4);  		// 45�  		double x = innerCircle * Math.Cos (rad);  		double y = innerCircle * Math.Sin (rad);  		points [1].X = pos.X + x;  		points [1].Y = pos.Y + y;  		points [9].X = pos.X - x;  		points [9].Y = pos.Y + y;  		rad += radStep;  		x = innerCircle * Math.Cos (rad);  		y = innerCircle * Math.Sin (rad);  		points [3].X = pos.X + x;  		points [3].Y = pos.Y + y;  		points [7].X = pos.X - x;  		points [7].Y = pos.Y + y;  		rad += radStep;  		y = innerCircle * Math.Sin (rad);  		points [5].X = pos.X;  		points [5].Y = pos.Y + y;  		gp.AddLines (points);  	}  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: switch (rendererInfo.MarkerStyle) {  case MarkerStyle.Square:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	x1 = pos.X + size2;  	y1 = pos.Y + size2;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.Diamond:  	gp.AddLine (x1 = pos.X + size2' pos.Y' pos.X' y0 = pos.Y - size2);  	gp.AddLine (pos.X' y0' x0 = pos.X - size2' pos.Y);  	gp.AddLine (x0' pos.Y' pos.X' y1 = pos.Y + size2);  	gp.AddLine (pos.X' y1' x1' pos.Y);  	break;  case MarkerStyle.Triangle:  	y0 = pos.Y + size / 2;  	y1 = pos.Y - size / 2;  	g = Math.Sqrt (size * size * 4 / 3) / 2;  	gp.AddLine (pos.X' y1' pos.X + g' y0);  	gp.AddLine (pos.X + g' y0' pos.X - g' y0);  	gp.AddLine (pos.X - g' y0' pos.X' y1);  	break;  case MarkerStyle.Plus:  	g = size2 / 4;  	gp.AddLine (pos.X - size2' pos.Y + g' pos.X - g' pos.Y + g);  	gp.AddLine (pos.X - g' pos.Y + g' pos.X - g' pos.Y + size2);  	gp.AddLine (pos.X - g' pos.Y + size2' pos.X + g' pos.Y + size2);  	gp.AddLine (pos.X + g' pos.Y + size2' pos.X + g' pos.Y + g);  	gp.AddLine (pos.X + g' pos.Y + g' pos.X + size2' pos.Y + g);  	gp.AddLine (pos.X + size2' pos.Y + g' pos.X + size2' pos.Y - g);  	gp.AddLine (pos.X + size2' pos.Y - g' pos.X + g' pos.Y - g);  	gp.AddLine (pos.X + g' pos.Y - g' pos.X + g' pos.Y - size2);  	gp.AddLine (pos.X + g' pos.Y - size2' pos.X - g' pos.Y - size2);  	gp.AddLine (pos.X - g' pos.Y - size2' pos.X - g' pos.Y - g);  	gp.AddLine (pos.X - g' pos.Y - g' pos.X - size2' pos.Y - g);  	gp.AddLine (pos.X - size2' pos.Y - g' pos.X - size2' pos.Y + g);  	break;  case MarkerStyle.Circle:  case MarkerStyle.Dot:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	gp.AddEllipse (x0' y0' size' size);  	break;  case MarkerStyle.Dash:  	x0 = pos.X - size2;  	y0 = pos.Y - size2 / 3;  	x1 = pos.X + size2;  	y1 = pos.Y + size2 / 3;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.X:  	g = size / 4;  	gp.AddLine (pos.X - size2 + g' pos.Y - size2' pos.X' pos.Y - g);  	gp.AddLine (pos.X' pos.Y - g' pos.X + size2 - g' pos.Y - size2);  	gp.AddLine (pos.X + size2 - g' pos.Y - size2' pos.X + size2' pos.Y - size2 + g);  	gp.AddLine (pos.X + size2' pos.Y - size2 + g' pos.X + g' pos.Y);  	gp.AddLine (pos.X + g' pos.Y' pos.X + size2' pos.Y + size2 - g);  	gp.AddLine (pos.X + size2' pos.Y + size2 - g' pos.X + size2 - g' pos.Y + size2);  	gp.AddLine (pos.X + size2 - g' pos.Y + size2' pos.X' pos.Y + g);  	gp.AddLine (pos.X' pos.Y + g' pos.X - size2 + g' pos.Y + size2);  	gp.AddLine (pos.X - size2 + g' pos.Y + size2' pos.X - size2' pos.Y + size2 - g);  	gp.AddLine (pos.X - size2' pos.Y + size2 - g' pos.X - g' pos.Y);  	gp.AddLine (pos.X - g' pos.Y' pos.X - size2' pos.Y - size2 + g);  	break;  case MarkerStyle.Star:  	{  		XPoint[] points = new XPoint[10];  		double radStep = 2 * Math.PI / 5;  		double outerCircle = size / 2;  		double innerCircle = size / 5;  		// outer circle  		double rad = -(Math.PI / 2);  		// 90�  		for (int idx = 0; idx < 10; idx += 2) {  			points [idx].X = pos.X + outerCircle * Math.Cos (rad);  			points [idx].Y = pos.Y + outerCircle * Math.Sin (rad);  			rad += radStep;  		}  		// inner circle  		rad = -(Math.PI / 4);  		// 45�  		double x = innerCircle * Math.Cos (rad);  		double y = innerCircle * Math.Sin (rad);  		points [1].X = pos.X + x;  		points [1].Y = pos.Y + y;  		points [9].X = pos.X - x;  		points [9].Y = pos.Y + y;  		rad += radStep;  		x = innerCircle * Math.Cos (rad);  		y = innerCircle * Math.Sin (rad);  		points [3].X = pos.X + x;  		points [3].Y = pos.Y + y;  		points [7].X = pos.X - x;  		points [7].Y = pos.Y + y;  		rad += radStep;  		y = innerCircle * Math.Sin (rad);  		points [5].X = pos.X;  		points [5].Y = pos.Y + y;  		gp.AddLines (points);  	}  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: switch (rendererInfo.MarkerStyle) {  case MarkerStyle.Square:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	x1 = pos.X + size2;  	y1 = pos.Y + size2;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.Diamond:  	gp.AddLine (x1 = pos.X + size2' pos.Y' pos.X' y0 = pos.Y - size2);  	gp.AddLine (pos.X' y0' x0 = pos.X - size2' pos.Y);  	gp.AddLine (x0' pos.Y' pos.X' y1 = pos.Y + size2);  	gp.AddLine (pos.X' y1' x1' pos.Y);  	break;  case MarkerStyle.Triangle:  	y0 = pos.Y + size / 2;  	y1 = pos.Y - size / 2;  	g = Math.Sqrt (size * size * 4 / 3) / 2;  	gp.AddLine (pos.X' y1' pos.X + g' y0);  	gp.AddLine (pos.X + g' y0' pos.X - g' y0);  	gp.AddLine (pos.X - g' y0' pos.X' y1);  	break;  case MarkerStyle.Plus:  	g = size2 / 4;  	gp.AddLine (pos.X - size2' pos.Y + g' pos.X - g' pos.Y + g);  	gp.AddLine (pos.X - g' pos.Y + g' pos.X - g' pos.Y + size2);  	gp.AddLine (pos.X - g' pos.Y + size2' pos.X + g' pos.Y + size2);  	gp.AddLine (pos.X + g' pos.Y + size2' pos.X + g' pos.Y + g);  	gp.AddLine (pos.X + g' pos.Y + g' pos.X + size2' pos.Y + g);  	gp.AddLine (pos.X + size2' pos.Y + g' pos.X + size2' pos.Y - g);  	gp.AddLine (pos.X + size2' pos.Y - g' pos.X + g' pos.Y - g);  	gp.AddLine (pos.X + g' pos.Y - g' pos.X + g' pos.Y - size2);  	gp.AddLine (pos.X + g' pos.Y - size2' pos.X - g' pos.Y - size2);  	gp.AddLine (pos.X - g' pos.Y - size2' pos.X - g' pos.Y - g);  	gp.AddLine (pos.X - g' pos.Y - g' pos.X - size2' pos.Y - g);  	gp.AddLine (pos.X - size2' pos.Y - g' pos.X - size2' pos.Y + g);  	break;  case MarkerStyle.Circle:  case MarkerStyle.Dot:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	gp.AddEllipse (x0' y0' size' size);  	break;  case MarkerStyle.Dash:  	x0 = pos.X - size2;  	y0 = pos.Y - size2 / 3;  	x1 = pos.X + size2;  	y1 = pos.Y + size2 / 3;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.X:  	g = size / 4;  	gp.AddLine (pos.X - size2 + g' pos.Y - size2' pos.X' pos.Y - g);  	gp.AddLine (pos.X' pos.Y - g' pos.X + size2 - g' pos.Y - size2);  	gp.AddLine (pos.X + size2 - g' pos.Y - size2' pos.X + size2' pos.Y - size2 + g);  	gp.AddLine (pos.X + size2' pos.Y - size2 + g' pos.X + g' pos.Y);  	gp.AddLine (pos.X + g' pos.Y' pos.X + size2' pos.Y + size2 - g);  	gp.AddLine (pos.X + size2' pos.Y + size2 - g' pos.X + size2 - g' pos.Y + size2);  	gp.AddLine (pos.X + size2 - g' pos.Y + size2' pos.X' pos.Y + g);  	gp.AddLine (pos.X' pos.Y + g' pos.X - size2 + g' pos.Y + size2);  	gp.AddLine (pos.X - size2 + g' pos.Y + size2' pos.X - size2' pos.Y + size2 - g);  	gp.AddLine (pos.X - size2' pos.Y + size2 - g' pos.X - g' pos.Y);  	gp.AddLine (pos.X - g' pos.Y' pos.X - size2' pos.Y - size2 + g);  	break;  case MarkerStyle.Star:  	{  		XPoint[] points = new XPoint[10];  		double radStep = 2 * Math.PI / 5;  		double outerCircle = size / 2;  		double innerCircle = size / 5;  		// outer circle  		double rad = -(Math.PI / 2);  		// 90�  		for (int idx = 0; idx < 10; idx += 2) {  			points [idx].X = pos.X + outerCircle * Math.Cos (rad);  			points [idx].Y = pos.Y + outerCircle * Math.Sin (rad);  			rad += radStep;  		}  		// inner circle  		rad = -(Math.PI / 4);  		// 45�  		double x = innerCircle * Math.Cos (rad);  		double y = innerCircle * Math.Sin (rad);  		points [1].X = pos.X + x;  		points [1].Y = pos.Y + y;  		points [9].X = pos.X - x;  		points [9].Y = pos.Y + y;  		rad += radStep;  		x = innerCircle * Math.Cos (rad);  		y = innerCircle * Math.Sin (rad);  		points [3].X = pos.X + x;  		points [3].Y = pos.Y + y;  		points [7].X = pos.X - x;  		points [7].Y = pos.Y + y;  		rad += radStep;  		y = innerCircle * Math.Sin (rad);  		points [5].X = pos.X;  		points [5].Y = pos.Y + y;  		gp.AddLines (points);  	}  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: switch (rendererInfo.MarkerStyle) {  case MarkerStyle.Square:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	x1 = pos.X + size2;  	y1 = pos.Y + size2;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.Diamond:  	gp.AddLine (x1 = pos.X + size2' pos.Y' pos.X' y0 = pos.Y - size2);  	gp.AddLine (pos.X' y0' x0 = pos.X - size2' pos.Y);  	gp.AddLine (x0' pos.Y' pos.X' y1 = pos.Y + size2);  	gp.AddLine (pos.X' y1' x1' pos.Y);  	break;  case MarkerStyle.Triangle:  	y0 = pos.Y + size / 2;  	y1 = pos.Y - size / 2;  	g = Math.Sqrt (size * size * 4 / 3) / 2;  	gp.AddLine (pos.X' y1' pos.X + g' y0);  	gp.AddLine (pos.X + g' y0' pos.X - g' y0);  	gp.AddLine (pos.X - g' y0' pos.X' y1);  	break;  case MarkerStyle.Plus:  	g = size2 / 4;  	gp.AddLine (pos.X - size2' pos.Y + g' pos.X - g' pos.Y + g);  	gp.AddLine (pos.X - g' pos.Y + g' pos.X - g' pos.Y + size2);  	gp.AddLine (pos.X - g' pos.Y + size2' pos.X + g' pos.Y + size2);  	gp.AddLine (pos.X + g' pos.Y + size2' pos.X + g' pos.Y + g);  	gp.AddLine (pos.X + g' pos.Y + g' pos.X + size2' pos.Y + g);  	gp.AddLine (pos.X + size2' pos.Y + g' pos.X + size2' pos.Y - g);  	gp.AddLine (pos.X + size2' pos.Y - g' pos.X + g' pos.Y - g);  	gp.AddLine (pos.X + g' pos.Y - g' pos.X + g' pos.Y - size2);  	gp.AddLine (pos.X + g' pos.Y - size2' pos.X - g' pos.Y - size2);  	gp.AddLine (pos.X - g' pos.Y - size2' pos.X - g' pos.Y - g);  	gp.AddLine (pos.X - g' pos.Y - g' pos.X - size2' pos.Y - g);  	gp.AddLine (pos.X - size2' pos.Y - g' pos.X - size2' pos.Y + g);  	break;  case MarkerStyle.Circle:  case MarkerStyle.Dot:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	gp.AddEllipse (x0' y0' size' size);  	break;  case MarkerStyle.Dash:  	x0 = pos.X - size2;  	y0 = pos.Y - size2 / 3;  	x1 = pos.X + size2;  	y1 = pos.Y + size2 / 3;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.X:  	g = size / 4;  	gp.AddLine (pos.X - size2 + g' pos.Y - size2' pos.X' pos.Y - g);  	gp.AddLine (pos.X' pos.Y - g' pos.X + size2 - g' pos.Y - size2);  	gp.AddLine (pos.X + size2 - g' pos.Y - size2' pos.X + size2' pos.Y - size2 + g);  	gp.AddLine (pos.X + size2' pos.Y - size2 + g' pos.X + g' pos.Y);  	gp.AddLine (pos.X + g' pos.Y' pos.X + size2' pos.Y + size2 - g);  	gp.AddLine (pos.X + size2' pos.Y + size2 - g' pos.X + size2 - g' pos.Y + size2);  	gp.AddLine (pos.X + size2 - g' pos.Y + size2' pos.X' pos.Y + g);  	gp.AddLine (pos.X' pos.Y + g' pos.X - size2 + g' pos.Y + size2);  	gp.AddLine (pos.X - size2 + g' pos.Y + size2' pos.X - size2' pos.Y + size2 - g);  	gp.AddLine (pos.X - size2' pos.Y + size2 - g' pos.X - g' pos.Y);  	gp.AddLine (pos.X - g' pos.Y' pos.X - size2' pos.Y - size2 + g);  	break;  case MarkerStyle.Star:  	{  		XPoint[] points = new XPoint[10];  		double radStep = 2 * Math.PI / 5;  		double outerCircle = size / 2;  		double innerCircle = size / 5;  		// outer circle  		double rad = -(Math.PI / 2);  		// 90�  		for (int idx = 0; idx < 10; idx += 2) {  			points [idx].X = pos.X + outerCircle * Math.Cos (rad);  			points [idx].Y = pos.Y + outerCircle * Math.Sin (rad);  			rad += radStep;  		}  		// inner circle  		rad = -(Math.PI / 4);  		// 45�  		double x = innerCircle * Math.Cos (rad);  		double y = innerCircle * Math.Sin (rad);  		points [1].X = pos.X + x;  		points [1].Y = pos.Y + y;  		points [9].X = pos.X - x;  		points [9].Y = pos.Y + y;  		rad += radStep;  		x = innerCircle * Math.Cos (rad);  		y = innerCircle * Math.Sin (rad);  		points [3].X = pos.X + x;  		points [3].Y = pos.Y + y;  		points [7].X = pos.X - x;  		points [7].Y = pos.Y + y;  		rad += radStep;  		y = innerCircle * Math.Sin (rad);  		points [5].X = pos.X;  		points [5].Y = pos.Y + y;  		gp.AddLines (points);  	}  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: switch (rendererInfo.MarkerStyle) {  case MarkerStyle.Square:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	x1 = pos.X + size2;  	y1 = pos.Y + size2;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.Diamond:  	gp.AddLine (x1 = pos.X + size2' pos.Y' pos.X' y0 = pos.Y - size2);  	gp.AddLine (pos.X' y0' x0 = pos.X - size2' pos.Y);  	gp.AddLine (x0' pos.Y' pos.X' y1 = pos.Y + size2);  	gp.AddLine (pos.X' y1' x1' pos.Y);  	break;  case MarkerStyle.Triangle:  	y0 = pos.Y + size / 2;  	y1 = pos.Y - size / 2;  	g = Math.Sqrt (size * size * 4 / 3) / 2;  	gp.AddLine (pos.X' y1' pos.X + g' y0);  	gp.AddLine (pos.X + g' y0' pos.X - g' y0);  	gp.AddLine (pos.X - g' y0' pos.X' y1);  	break;  case MarkerStyle.Plus:  	g = size2 / 4;  	gp.AddLine (pos.X - size2' pos.Y + g' pos.X - g' pos.Y + g);  	gp.AddLine (pos.X - g' pos.Y + g' pos.X - g' pos.Y + size2);  	gp.AddLine (pos.X - g' pos.Y + size2' pos.X + g' pos.Y + size2);  	gp.AddLine (pos.X + g' pos.Y + size2' pos.X + g' pos.Y + g);  	gp.AddLine (pos.X + g' pos.Y + g' pos.X + size2' pos.Y + g);  	gp.AddLine (pos.X + size2' pos.Y + g' pos.X + size2' pos.Y - g);  	gp.AddLine (pos.X + size2' pos.Y - g' pos.X + g' pos.Y - g);  	gp.AddLine (pos.X + g' pos.Y - g' pos.X + g' pos.Y - size2);  	gp.AddLine (pos.X + g' pos.Y - size2' pos.X - g' pos.Y - size2);  	gp.AddLine (pos.X - g' pos.Y - size2' pos.X - g' pos.Y - g);  	gp.AddLine (pos.X - g' pos.Y - g' pos.X - size2' pos.Y - g);  	gp.AddLine (pos.X - size2' pos.Y - g' pos.X - size2' pos.Y + g);  	break;  case MarkerStyle.Circle:  case MarkerStyle.Dot:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	gp.AddEllipse (x0' y0' size' size);  	break;  case MarkerStyle.Dash:  	x0 = pos.X - size2;  	y0 = pos.Y - size2 / 3;  	x1 = pos.X + size2;  	y1 = pos.Y + size2 / 3;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.X:  	g = size / 4;  	gp.AddLine (pos.X - size2 + g' pos.Y - size2' pos.X' pos.Y - g);  	gp.AddLine (pos.X' pos.Y - g' pos.X + size2 - g' pos.Y - size2);  	gp.AddLine (pos.X + size2 - g' pos.Y - size2' pos.X + size2' pos.Y - size2 + g);  	gp.AddLine (pos.X + size2' pos.Y - size2 + g' pos.X + g' pos.Y);  	gp.AddLine (pos.X + g' pos.Y' pos.X + size2' pos.Y + size2 - g);  	gp.AddLine (pos.X + size2' pos.Y + size2 - g' pos.X + size2 - g' pos.Y + size2);  	gp.AddLine (pos.X + size2 - g' pos.Y + size2' pos.X' pos.Y + g);  	gp.AddLine (pos.X' pos.Y + g' pos.X - size2 + g' pos.Y + size2);  	gp.AddLine (pos.X - size2 + g' pos.Y + size2' pos.X - size2' pos.Y + size2 - g);  	gp.AddLine (pos.X - size2' pos.Y + size2 - g' pos.X - g' pos.Y);  	gp.AddLine (pos.X - g' pos.Y' pos.X - size2' pos.Y - size2 + g);  	break;  case MarkerStyle.Star:  	{  		XPoint[] points = new XPoint[10];  		double radStep = 2 * Math.PI / 5;  		double outerCircle = size / 2;  		double innerCircle = size / 5;  		// outer circle  		double rad = -(Math.PI / 2);  		// 90�  		for (int idx = 0; idx < 10; idx += 2) {  			points [idx].X = pos.X + outerCircle * Math.Cos (rad);  			points [idx].Y = pos.Y + outerCircle * Math.Sin (rad);  			rad += radStep;  		}  		// inner circle  		rad = -(Math.PI / 4);  		// 45�  		double x = innerCircle * Math.Cos (rad);  		double y = innerCircle * Math.Sin (rad);  		points [1].X = pos.X + x;  		points [1].Y = pos.Y + y;  		points [9].X = pos.X - x;  		points [9].Y = pos.Y + y;  		rad += radStep;  		x = innerCircle * Math.Cos (rad);  		y = innerCircle * Math.Sin (rad);  		points [3].X = pos.X + x;  		points [3].Y = pos.Y + y;  		points [7].X = pos.X - x;  		points [7].Y = pos.Y + y;  		rad += radStep;  		y = innerCircle * Math.Sin (rad);  		points [5].X = pos.X;  		points [5].Y = pos.Y + y;  		gp.AddLines (points);  	}  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: switch (rendererInfo.MarkerStyle) {  case MarkerStyle.Square:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	x1 = pos.X + size2;  	y1 = pos.Y + size2;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.Diamond:  	gp.AddLine (x1 = pos.X + size2' pos.Y' pos.X' y0 = pos.Y - size2);  	gp.AddLine (pos.X' y0' x0 = pos.X - size2' pos.Y);  	gp.AddLine (x0' pos.Y' pos.X' y1 = pos.Y + size2);  	gp.AddLine (pos.X' y1' x1' pos.Y);  	break;  case MarkerStyle.Triangle:  	y0 = pos.Y + size / 2;  	y1 = pos.Y - size / 2;  	g = Math.Sqrt (size * size * 4 / 3) / 2;  	gp.AddLine (pos.X' y1' pos.X + g' y0);  	gp.AddLine (pos.X + g' y0' pos.X - g' y0);  	gp.AddLine (pos.X - g' y0' pos.X' y1);  	break;  case MarkerStyle.Plus:  	g = size2 / 4;  	gp.AddLine (pos.X - size2' pos.Y + g' pos.X - g' pos.Y + g);  	gp.AddLine (pos.X - g' pos.Y + g' pos.X - g' pos.Y + size2);  	gp.AddLine (pos.X - g' pos.Y + size2' pos.X + g' pos.Y + size2);  	gp.AddLine (pos.X + g' pos.Y + size2' pos.X + g' pos.Y + g);  	gp.AddLine (pos.X + g' pos.Y + g' pos.X + size2' pos.Y + g);  	gp.AddLine (pos.X + size2' pos.Y + g' pos.X + size2' pos.Y - g);  	gp.AddLine (pos.X + size2' pos.Y - g' pos.X + g' pos.Y - g);  	gp.AddLine (pos.X + g' pos.Y - g' pos.X + g' pos.Y - size2);  	gp.AddLine (pos.X + g' pos.Y - size2' pos.X - g' pos.Y - size2);  	gp.AddLine (pos.X - g' pos.Y - size2' pos.X - g' pos.Y - g);  	gp.AddLine (pos.X - g' pos.Y - g' pos.X - size2' pos.Y - g);  	gp.AddLine (pos.X - size2' pos.Y - g' pos.X - size2' pos.Y + g);  	break;  case MarkerStyle.Circle:  case MarkerStyle.Dot:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	gp.AddEllipse (x0' y0' size' size);  	break;  case MarkerStyle.Dash:  	x0 = pos.X - size2;  	y0 = pos.Y - size2 / 3;  	x1 = pos.X + size2;  	y1 = pos.Y + size2 / 3;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.X:  	g = size / 4;  	gp.AddLine (pos.X - size2 + g' pos.Y - size2' pos.X' pos.Y - g);  	gp.AddLine (pos.X' pos.Y - g' pos.X + size2 - g' pos.Y - size2);  	gp.AddLine (pos.X + size2 - g' pos.Y - size2' pos.X + size2' pos.Y - size2 + g);  	gp.AddLine (pos.X + size2' pos.Y - size2 + g' pos.X + g' pos.Y);  	gp.AddLine (pos.X + g' pos.Y' pos.X + size2' pos.Y + size2 - g);  	gp.AddLine (pos.X + size2' pos.Y + size2 - g' pos.X + size2 - g' pos.Y + size2);  	gp.AddLine (pos.X + size2 - g' pos.Y + size2' pos.X' pos.Y + g);  	gp.AddLine (pos.X' pos.Y + g' pos.X - size2 + g' pos.Y + size2);  	gp.AddLine (pos.X - size2 + g' pos.Y + size2' pos.X - size2' pos.Y + size2 - g);  	gp.AddLine (pos.X - size2' pos.Y + size2 - g' pos.X - g' pos.Y);  	gp.AddLine (pos.X - g' pos.Y' pos.X - size2' pos.Y - size2 + g);  	break;  case MarkerStyle.Star:  	{  		XPoint[] points = new XPoint[10];  		double radStep = 2 * Math.PI / 5;  		double outerCircle = size / 2;  		double innerCircle = size / 5;  		// outer circle  		double rad = -(Math.PI / 2);  		// 90�  		for (int idx = 0; idx < 10; idx += 2) {  			points [idx].X = pos.X + outerCircle * Math.Cos (rad);  			points [idx].Y = pos.Y + outerCircle * Math.Sin (rad);  			rad += radStep;  		}  		// inner circle  		rad = -(Math.PI / 4);  		// 45�  		double x = innerCircle * Math.Cos (rad);  		double y = innerCircle * Math.Sin (rad);  		points [1].X = pos.X + x;  		points [1].Y = pos.Y + y;  		points [9].X = pos.X - x;  		points [9].Y = pos.Y + y;  		rad += radStep;  		x = innerCircle * Math.Cos (rad);  		y = innerCircle * Math.Sin (rad);  		points [3].X = pos.X + x;  		points [3].Y = pos.Y + y;  		points [7].X = pos.X - x;  		points [7].Y = pos.Y + y;  		rad += radStep;  		y = innerCircle * Math.Sin (rad);  		points [5].X = pos.X;  		points [5].Y = pos.Y + y;  		gp.AddLines (points);  	}  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: switch (rendererInfo.MarkerStyle) {  case MarkerStyle.Square:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	x1 = pos.X + size2;  	y1 = pos.Y + size2;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.Diamond:  	gp.AddLine (x1 = pos.X + size2' pos.Y' pos.X' y0 = pos.Y - size2);  	gp.AddLine (pos.X' y0' x0 = pos.X - size2' pos.Y);  	gp.AddLine (x0' pos.Y' pos.X' y1 = pos.Y + size2);  	gp.AddLine (pos.X' y1' x1' pos.Y);  	break;  case MarkerStyle.Triangle:  	y0 = pos.Y + size / 2;  	y1 = pos.Y - size / 2;  	g = Math.Sqrt (size * size * 4 / 3) / 2;  	gp.AddLine (pos.X' y1' pos.X + g' y0);  	gp.AddLine (pos.X + g' y0' pos.X - g' y0);  	gp.AddLine (pos.X - g' y0' pos.X' y1);  	break;  case MarkerStyle.Plus:  	g = size2 / 4;  	gp.AddLine (pos.X - size2' pos.Y + g' pos.X - g' pos.Y + g);  	gp.AddLine (pos.X - g' pos.Y + g' pos.X - g' pos.Y + size2);  	gp.AddLine (pos.X - g' pos.Y + size2' pos.X + g' pos.Y + size2);  	gp.AddLine (pos.X + g' pos.Y + size2' pos.X + g' pos.Y + g);  	gp.AddLine (pos.X + g' pos.Y + g' pos.X + size2' pos.Y + g);  	gp.AddLine (pos.X + size2' pos.Y + g' pos.X + size2' pos.Y - g);  	gp.AddLine (pos.X + size2' pos.Y - g' pos.X + g' pos.Y - g);  	gp.AddLine (pos.X + g' pos.Y - g' pos.X + g' pos.Y - size2);  	gp.AddLine (pos.X + g' pos.Y - size2' pos.X - g' pos.Y - size2);  	gp.AddLine (pos.X - g' pos.Y - size2' pos.X - g' pos.Y - g);  	gp.AddLine (pos.X - g' pos.Y - g' pos.X - size2' pos.Y - g);  	gp.AddLine (pos.X - size2' pos.Y - g' pos.X - size2' pos.Y + g);  	break;  case MarkerStyle.Circle:  case MarkerStyle.Dot:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	gp.AddEllipse (x0' y0' size' size);  	break;  case MarkerStyle.Dash:  	x0 = pos.X - size2;  	y0 = pos.Y - size2 / 3;  	x1 = pos.X + size2;  	y1 = pos.Y + size2 / 3;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.X:  	g = size / 4;  	gp.AddLine (pos.X - size2 + g' pos.Y - size2' pos.X' pos.Y - g);  	gp.AddLine (pos.X' pos.Y - g' pos.X + size2 - g' pos.Y - size2);  	gp.AddLine (pos.X + size2 - g' pos.Y - size2' pos.X + size2' pos.Y - size2 + g);  	gp.AddLine (pos.X + size2' pos.Y - size2 + g' pos.X + g' pos.Y);  	gp.AddLine (pos.X + g' pos.Y' pos.X + size2' pos.Y + size2 - g);  	gp.AddLine (pos.X + size2' pos.Y + size2 - g' pos.X + size2 - g' pos.Y + size2);  	gp.AddLine (pos.X + size2 - g' pos.Y + size2' pos.X' pos.Y + g);  	gp.AddLine (pos.X' pos.Y + g' pos.X - size2 + g' pos.Y + size2);  	gp.AddLine (pos.X - size2 + g' pos.Y + size2' pos.X - size2' pos.Y + size2 - g);  	gp.AddLine (pos.X - size2' pos.Y + size2 - g' pos.X - g' pos.Y);  	gp.AddLine (pos.X - g' pos.Y' pos.X - size2' pos.Y - size2 + g);  	break;  case MarkerStyle.Star:  	{  		XPoint[] points = new XPoint[10];  		double radStep = 2 * Math.PI / 5;  		double outerCircle = size / 2;  		double innerCircle = size / 5;  		// outer circle  		double rad = -(Math.PI / 2);  		// 90�  		for (int idx = 0; idx < 10; idx += 2) {  			points [idx].X = pos.X + outerCircle * Math.Cos (rad);  			points [idx].Y = pos.Y + outerCircle * Math.Sin (rad);  			rad += radStep;  		}  		// inner circle  		rad = -(Math.PI / 4);  		// 45�  		double x = innerCircle * Math.Cos (rad);  		double y = innerCircle * Math.Sin (rad);  		points [1].X = pos.X + x;  		points [1].Y = pos.Y + y;  		points [9].X = pos.X - x;  		points [9].Y = pos.Y + y;  		rad += radStep;  		x = innerCircle * Math.Cos (rad);  		y = innerCircle * Math.Sin (rad);  		points [3].X = pos.X + x;  		points [3].Y = pos.Y + y;  		points [7].X = pos.X - x;  		points [7].Y = pos.Y + y;  		rad += radStep;  		y = innerCircle * Math.Sin (rad);  		points [5].X = pos.X;  		points [5].Y = pos.Y + y;  		gp.AddLines (points);  	}  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: switch (rendererInfo.MarkerStyle) {  case MarkerStyle.Square:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	x1 = pos.X + size2;  	y1 = pos.Y + size2;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.Diamond:  	gp.AddLine (x1 = pos.X + size2' pos.Y' pos.X' y0 = pos.Y - size2);  	gp.AddLine (pos.X' y0' x0 = pos.X - size2' pos.Y);  	gp.AddLine (x0' pos.Y' pos.X' y1 = pos.Y + size2);  	gp.AddLine (pos.X' y1' x1' pos.Y);  	break;  case MarkerStyle.Triangle:  	y0 = pos.Y + size / 2;  	y1 = pos.Y - size / 2;  	g = Math.Sqrt (size * size * 4 / 3) / 2;  	gp.AddLine (pos.X' y1' pos.X + g' y0);  	gp.AddLine (pos.X + g' y0' pos.X - g' y0);  	gp.AddLine (pos.X - g' y0' pos.X' y1);  	break;  case MarkerStyle.Plus:  	g = size2 / 4;  	gp.AddLine (pos.X - size2' pos.Y + g' pos.X - g' pos.Y + g);  	gp.AddLine (pos.X - g' pos.Y + g' pos.X - g' pos.Y + size2);  	gp.AddLine (pos.X - g' pos.Y + size2' pos.X + g' pos.Y + size2);  	gp.AddLine (pos.X + g' pos.Y + size2' pos.X + g' pos.Y + g);  	gp.AddLine (pos.X + g' pos.Y + g' pos.X + size2' pos.Y + g);  	gp.AddLine (pos.X + size2' pos.Y + g' pos.X + size2' pos.Y - g);  	gp.AddLine (pos.X + size2' pos.Y - g' pos.X + g' pos.Y - g);  	gp.AddLine (pos.X + g' pos.Y - g' pos.X + g' pos.Y - size2);  	gp.AddLine (pos.X + g' pos.Y - size2' pos.X - g' pos.Y - size2);  	gp.AddLine (pos.X - g' pos.Y - size2' pos.X - g' pos.Y - g);  	gp.AddLine (pos.X - g' pos.Y - g' pos.X - size2' pos.Y - g);  	gp.AddLine (pos.X - size2' pos.Y - g' pos.X - size2' pos.Y + g);  	break;  case MarkerStyle.Circle:  case MarkerStyle.Dot:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	gp.AddEllipse (x0' y0' size' size);  	break;  case MarkerStyle.Dash:  	x0 = pos.X - size2;  	y0 = pos.Y - size2 / 3;  	x1 = pos.X + size2;  	y1 = pos.Y + size2 / 3;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.X:  	g = size / 4;  	gp.AddLine (pos.X - size2 + g' pos.Y - size2' pos.X' pos.Y - g);  	gp.AddLine (pos.X' pos.Y - g' pos.X + size2 - g' pos.Y - size2);  	gp.AddLine (pos.X + size2 - g' pos.Y - size2' pos.X + size2' pos.Y - size2 + g);  	gp.AddLine (pos.X + size2' pos.Y - size2 + g' pos.X + g' pos.Y);  	gp.AddLine (pos.X + g' pos.Y' pos.X + size2' pos.Y + size2 - g);  	gp.AddLine (pos.X + size2' pos.Y + size2 - g' pos.X + size2 - g' pos.Y + size2);  	gp.AddLine (pos.X + size2 - g' pos.Y + size2' pos.X' pos.Y + g);  	gp.AddLine (pos.X' pos.Y + g' pos.X - size2 + g' pos.Y + size2);  	gp.AddLine (pos.X - size2 + g' pos.Y + size2' pos.X - size2' pos.Y + size2 - g);  	gp.AddLine (pos.X - size2' pos.Y + size2 - g' pos.X - g' pos.Y);  	gp.AddLine (pos.X - g' pos.Y' pos.X - size2' pos.Y - size2 + g);  	break;  case MarkerStyle.Star:  	{  		XPoint[] points = new XPoint[10];  		double radStep = 2 * Math.PI / 5;  		double outerCircle = size / 2;  		double innerCircle = size / 5;  		// outer circle  		double rad = -(Math.PI / 2);  		// 90�  		for (int idx = 0; idx < 10; idx += 2) {  			points [idx].X = pos.X + outerCircle * Math.Cos (rad);  			points [idx].Y = pos.Y + outerCircle * Math.Sin (rad);  			rad += radStep;  		}  		// inner circle  		rad = -(Math.PI / 4);  		// 45�  		double x = innerCircle * Math.Cos (rad);  		double y = innerCircle * Math.Sin (rad);  		points [1].X = pos.X + x;  		points [1].Y = pos.Y + y;  		points [9].X = pos.X - x;  		points [9].Y = pos.Y + y;  		rad += radStep;  		x = innerCircle * Math.Cos (rad);  		y = innerCircle * Math.Sin (rad);  		points [3].X = pos.X + x;  		points [3].Y = pos.Y + y;  		points [7].X = pos.X - x;  		points [7].Y = pos.Y + y;  		rad += radStep;  		y = innerCircle * Math.Sin (rad);  		points [5].X = pos.X;  		points [5].Y = pos.Y + y;  		gp.AddLines (points);  	}  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: switch (rendererInfo.MarkerStyle) {  case MarkerStyle.Square:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	x1 = pos.X + size2;  	y1 = pos.Y + size2;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.Diamond:  	gp.AddLine (x1 = pos.X + size2' pos.Y' pos.X' y0 = pos.Y - size2);  	gp.AddLine (pos.X' y0' x0 = pos.X - size2' pos.Y);  	gp.AddLine (x0' pos.Y' pos.X' y1 = pos.Y + size2);  	gp.AddLine (pos.X' y1' x1' pos.Y);  	break;  case MarkerStyle.Triangle:  	y0 = pos.Y + size / 2;  	y1 = pos.Y - size / 2;  	g = Math.Sqrt (size * size * 4 / 3) / 2;  	gp.AddLine (pos.X' y1' pos.X + g' y0);  	gp.AddLine (pos.X + g' y0' pos.X - g' y0);  	gp.AddLine (pos.X - g' y0' pos.X' y1);  	break;  case MarkerStyle.Plus:  	g = size2 / 4;  	gp.AddLine (pos.X - size2' pos.Y + g' pos.X - g' pos.Y + g);  	gp.AddLine (pos.X - g' pos.Y + g' pos.X - g' pos.Y + size2);  	gp.AddLine (pos.X - g' pos.Y + size2' pos.X + g' pos.Y + size2);  	gp.AddLine (pos.X + g' pos.Y + size2' pos.X + g' pos.Y + g);  	gp.AddLine (pos.X + g' pos.Y + g' pos.X + size2' pos.Y + g);  	gp.AddLine (pos.X + size2' pos.Y + g' pos.X + size2' pos.Y - g);  	gp.AddLine (pos.X + size2' pos.Y - g' pos.X + g' pos.Y - g);  	gp.AddLine (pos.X + g' pos.Y - g' pos.X + g' pos.Y - size2);  	gp.AddLine (pos.X + g' pos.Y - size2' pos.X - g' pos.Y - size2);  	gp.AddLine (pos.X - g' pos.Y - size2' pos.X - g' pos.Y - g);  	gp.AddLine (pos.X - g' pos.Y - g' pos.X - size2' pos.Y - g);  	gp.AddLine (pos.X - size2' pos.Y - g' pos.X - size2' pos.Y + g);  	break;  case MarkerStyle.Circle:  case MarkerStyle.Dot:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	gp.AddEllipse (x0' y0' size' size);  	break;  case MarkerStyle.Dash:  	x0 = pos.X - size2;  	y0 = pos.Y - size2 / 3;  	x1 = pos.X + size2;  	y1 = pos.Y + size2 / 3;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.X:  	g = size / 4;  	gp.AddLine (pos.X - size2 + g' pos.Y - size2' pos.X' pos.Y - g);  	gp.AddLine (pos.X' pos.Y - g' pos.X + size2 - g' pos.Y - size2);  	gp.AddLine (pos.X + size2 - g' pos.Y - size2' pos.X + size2' pos.Y - size2 + g);  	gp.AddLine (pos.X + size2' pos.Y - size2 + g' pos.X + g' pos.Y);  	gp.AddLine (pos.X + g' pos.Y' pos.X + size2' pos.Y + size2 - g);  	gp.AddLine (pos.X + size2' pos.Y + size2 - g' pos.X + size2 - g' pos.Y + size2);  	gp.AddLine (pos.X + size2 - g' pos.Y + size2' pos.X' pos.Y + g);  	gp.AddLine (pos.X' pos.Y + g' pos.X - size2 + g' pos.Y + size2);  	gp.AddLine (pos.X - size2 + g' pos.Y + size2' pos.X - size2' pos.Y + size2 - g);  	gp.AddLine (pos.X - size2' pos.Y + size2 - g' pos.X - g' pos.Y);  	gp.AddLine (pos.X - g' pos.Y' pos.X - size2' pos.Y - size2 + g);  	break;  case MarkerStyle.Star:  	{  		XPoint[] points = new XPoint[10];  		double radStep = 2 * Math.PI / 5;  		double outerCircle = size / 2;  		double innerCircle = size / 5;  		// outer circle  		double rad = -(Math.PI / 2);  		// 90�  		for (int idx = 0; idx < 10; idx += 2) {  			points [idx].X = pos.X + outerCircle * Math.Cos (rad);  			points [idx].Y = pos.Y + outerCircle * Math.Sin (rad);  			rad += radStep;  		}  		// inner circle  		rad = -(Math.PI / 4);  		// 45�  		double x = innerCircle * Math.Cos (rad);  		double y = innerCircle * Math.Sin (rad);  		points [1].X = pos.X + x;  		points [1].Y = pos.Y + y;  		points [9].X = pos.X - x;  		points [9].Y = pos.Y + y;  		rad += radStep;  		x = innerCircle * Math.Cos (rad);  		y = innerCircle * Math.Sin (rad);  		points [3].X = pos.X + x;  		points [3].Y = pos.Y + y;  		points [7].X = pos.X - x;  		points [7].Y = pos.Y + y;  		rad += radStep;  		y = innerCircle * Math.Sin (rad);  		points [5].X = pos.X;  		points [5].Y = pos.Y + y;  		gp.AddLines (points);  	}  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: switch (rendererInfo.MarkerStyle) {  case MarkerStyle.Square:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	x1 = pos.X + size2;  	y1 = pos.Y + size2;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.Diamond:  	gp.AddLine (x1 = pos.X + size2' pos.Y' pos.X' y0 = pos.Y - size2);  	gp.AddLine (pos.X' y0' x0 = pos.X - size2' pos.Y);  	gp.AddLine (x0' pos.Y' pos.X' y1 = pos.Y + size2);  	gp.AddLine (pos.X' y1' x1' pos.Y);  	break;  case MarkerStyle.Triangle:  	y0 = pos.Y + size / 2;  	y1 = pos.Y - size / 2;  	g = Math.Sqrt (size * size * 4 / 3) / 2;  	gp.AddLine (pos.X' y1' pos.X + g' y0);  	gp.AddLine (pos.X + g' y0' pos.X - g' y0);  	gp.AddLine (pos.X - g' y0' pos.X' y1);  	break;  case MarkerStyle.Plus:  	g = size2 / 4;  	gp.AddLine (pos.X - size2' pos.Y + g' pos.X - g' pos.Y + g);  	gp.AddLine (pos.X - g' pos.Y + g' pos.X - g' pos.Y + size2);  	gp.AddLine (pos.X - g' pos.Y + size2' pos.X + g' pos.Y + size2);  	gp.AddLine (pos.X + g' pos.Y + size2' pos.X + g' pos.Y + g);  	gp.AddLine (pos.X + g' pos.Y + g' pos.X + size2' pos.Y + g);  	gp.AddLine (pos.X + size2' pos.Y + g' pos.X + size2' pos.Y - g);  	gp.AddLine (pos.X + size2' pos.Y - g' pos.X + g' pos.Y - g);  	gp.AddLine (pos.X + g' pos.Y - g' pos.X + g' pos.Y - size2);  	gp.AddLine (pos.X + g' pos.Y - size2' pos.X - g' pos.Y - size2);  	gp.AddLine (pos.X - g' pos.Y - size2' pos.X - g' pos.Y - g);  	gp.AddLine (pos.X - g' pos.Y - g' pos.X - size2' pos.Y - g);  	gp.AddLine (pos.X - size2' pos.Y - g' pos.X - size2' pos.Y + g);  	break;  case MarkerStyle.Circle:  case MarkerStyle.Dot:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	gp.AddEllipse (x0' y0' size' size);  	break;  case MarkerStyle.Dash:  	x0 = pos.X - size2;  	y0 = pos.Y - size2 / 3;  	x1 = pos.X + size2;  	y1 = pos.Y + size2 / 3;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.X:  	g = size / 4;  	gp.AddLine (pos.X - size2 + g' pos.Y - size2' pos.X' pos.Y - g);  	gp.AddLine (pos.X' pos.Y - g' pos.X + size2 - g' pos.Y - size2);  	gp.AddLine (pos.X + size2 - g' pos.Y - size2' pos.X + size2' pos.Y - size2 + g);  	gp.AddLine (pos.X + size2' pos.Y - size2 + g' pos.X + g' pos.Y);  	gp.AddLine (pos.X + g' pos.Y' pos.X + size2' pos.Y + size2 - g);  	gp.AddLine (pos.X + size2' pos.Y + size2 - g' pos.X + size2 - g' pos.Y + size2);  	gp.AddLine (pos.X + size2 - g' pos.Y + size2' pos.X' pos.Y + g);  	gp.AddLine (pos.X' pos.Y + g' pos.X - size2 + g' pos.Y + size2);  	gp.AddLine (pos.X - size2 + g' pos.Y + size2' pos.X - size2' pos.Y + size2 - g);  	gp.AddLine (pos.X - size2' pos.Y + size2 - g' pos.X - g' pos.Y);  	gp.AddLine (pos.X - g' pos.Y' pos.X - size2' pos.Y - size2 + g);  	break;  case MarkerStyle.Star:  	{  		XPoint[] points = new XPoint[10];  		double radStep = 2 * Math.PI / 5;  		double outerCircle = size / 2;  		double innerCircle = size / 5;  		// outer circle  		double rad = -(Math.PI / 2);  		// 90�  		for (int idx = 0; idx < 10; idx += 2) {  			points [idx].X = pos.X + outerCircle * Math.Cos (rad);  			points [idx].Y = pos.Y + outerCircle * Math.Sin (rad);  			rad += radStep;  		}  		// inner circle  		rad = -(Math.PI / 4);  		// 45�  		double x = innerCircle * Math.Cos (rad);  		double y = innerCircle * Math.Sin (rad);  		points [1].X = pos.X + x;  		points [1].Y = pos.Y + y;  		points [9].X = pos.X - x;  		points [9].Y = pos.Y + y;  		rad += radStep;  		x = innerCircle * Math.Cos (rad);  		y = innerCircle * Math.Sin (rad);  		points [3].X = pos.X + x;  		points [3].Y = pos.Y + y;  		points [7].X = pos.X - x;  		points [7].Y = pos.Y + y;  		rad += radStep;  		y = innerCircle * Math.Sin (rad);  		points [5].X = pos.X;  		points [5].Y = pos.Y + y;  		gp.AddLines (points);  	}  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: switch (rendererInfo.MarkerStyle) {  case MarkerStyle.Square:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	x1 = pos.X + size2;  	y1 = pos.Y + size2;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.Diamond:  	gp.AddLine (x1 = pos.X + size2' pos.Y' pos.X' y0 = pos.Y - size2);  	gp.AddLine (pos.X' y0' x0 = pos.X - size2' pos.Y);  	gp.AddLine (x0' pos.Y' pos.X' y1 = pos.Y + size2);  	gp.AddLine (pos.X' y1' x1' pos.Y);  	break;  case MarkerStyle.Triangle:  	y0 = pos.Y + size / 2;  	y1 = pos.Y - size / 2;  	g = Math.Sqrt (size * size * 4 / 3) / 2;  	gp.AddLine (pos.X' y1' pos.X + g' y0);  	gp.AddLine (pos.X + g' y0' pos.X - g' y0);  	gp.AddLine (pos.X - g' y0' pos.X' y1);  	break;  case MarkerStyle.Plus:  	g = size2 / 4;  	gp.AddLine (pos.X - size2' pos.Y + g' pos.X - g' pos.Y + g);  	gp.AddLine (pos.X - g' pos.Y + g' pos.X - g' pos.Y + size2);  	gp.AddLine (pos.X - g' pos.Y + size2' pos.X + g' pos.Y + size2);  	gp.AddLine (pos.X + g' pos.Y + size2' pos.X + g' pos.Y + g);  	gp.AddLine (pos.X + g' pos.Y + g' pos.X + size2' pos.Y + g);  	gp.AddLine (pos.X + size2' pos.Y + g' pos.X + size2' pos.Y - g);  	gp.AddLine (pos.X + size2' pos.Y - g' pos.X + g' pos.Y - g);  	gp.AddLine (pos.X + g' pos.Y - g' pos.X + g' pos.Y - size2);  	gp.AddLine (pos.X + g' pos.Y - size2' pos.X - g' pos.Y - size2);  	gp.AddLine (pos.X - g' pos.Y - size2' pos.X - g' pos.Y - g);  	gp.AddLine (pos.X - g' pos.Y - g' pos.X - size2' pos.Y - g);  	gp.AddLine (pos.X - size2' pos.Y - g' pos.X - size2' pos.Y + g);  	break;  case MarkerStyle.Circle:  case MarkerStyle.Dot:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	gp.AddEllipse (x0' y0' size' size);  	break;  case MarkerStyle.Dash:  	x0 = pos.X - size2;  	y0 = pos.Y - size2 / 3;  	x1 = pos.X + size2;  	y1 = pos.Y + size2 / 3;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.X:  	g = size / 4;  	gp.AddLine (pos.X - size2 + g' pos.Y - size2' pos.X' pos.Y - g);  	gp.AddLine (pos.X' pos.Y - g' pos.X + size2 - g' pos.Y - size2);  	gp.AddLine (pos.X + size2 - g' pos.Y - size2' pos.X + size2' pos.Y - size2 + g);  	gp.AddLine (pos.X + size2' pos.Y - size2 + g' pos.X + g' pos.Y);  	gp.AddLine (pos.X + g' pos.Y' pos.X + size2' pos.Y + size2 - g);  	gp.AddLine (pos.X + size2' pos.Y + size2 - g' pos.X + size2 - g' pos.Y + size2);  	gp.AddLine (pos.X + size2 - g' pos.Y + size2' pos.X' pos.Y + g);  	gp.AddLine (pos.X' pos.Y + g' pos.X - size2 + g' pos.Y + size2);  	gp.AddLine (pos.X - size2 + g' pos.Y + size2' pos.X - size2' pos.Y + size2 - g);  	gp.AddLine (pos.X - size2' pos.Y + size2 - g' pos.X - g' pos.Y);  	gp.AddLine (pos.X - g' pos.Y' pos.X - size2' pos.Y - size2 + g);  	break;  case MarkerStyle.Star:  	{  		XPoint[] points = new XPoint[10];  		double radStep = 2 * Math.PI / 5;  		double outerCircle = size / 2;  		double innerCircle = size / 5;  		// outer circle  		double rad = -(Math.PI / 2);  		// 90�  		for (int idx = 0; idx < 10; idx += 2) {  			points [idx].X = pos.X + outerCircle * Math.Cos (rad);  			points [idx].Y = pos.Y + outerCircle * Math.Sin (rad);  			rad += radStep;  		}  		// inner circle  		rad = -(Math.PI / 4);  		// 45�  		double x = innerCircle * Math.Cos (rad);  		double y = innerCircle * Math.Sin (rad);  		points [1].X = pos.X + x;  		points [1].Y = pos.Y + y;  		points [9].X = pos.X - x;  		points [9].Y = pos.Y + y;  		rad += radStep;  		x = innerCircle * Math.Cos (rad);  		y = innerCircle * Math.Sin (rad);  		points [3].X = pos.X + x;  		points [3].Y = pos.Y + y;  		points [7].X = pos.X - x;  		points [7].Y = pos.Y + y;  		rad += radStep;  		y = innerCircle * Math.Sin (rad);  		points [5].X = pos.X;  		points [5].Y = pos.Y + y;  		gp.AddLines (points);  	}  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: switch (rendererInfo.MarkerStyle) {  case MarkerStyle.Square:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	x1 = pos.X + size2;  	y1 = pos.Y + size2;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.Diamond:  	gp.AddLine (x1 = pos.X + size2' pos.Y' pos.X' y0 = pos.Y - size2);  	gp.AddLine (pos.X' y0' x0 = pos.X - size2' pos.Y);  	gp.AddLine (x0' pos.Y' pos.X' y1 = pos.Y + size2);  	gp.AddLine (pos.X' y1' x1' pos.Y);  	break;  case MarkerStyle.Triangle:  	y0 = pos.Y + size / 2;  	y1 = pos.Y - size / 2;  	g = Math.Sqrt (size * size * 4 / 3) / 2;  	gp.AddLine (pos.X' y1' pos.X + g' y0);  	gp.AddLine (pos.X + g' y0' pos.X - g' y0);  	gp.AddLine (pos.X - g' y0' pos.X' y1);  	break;  case MarkerStyle.Plus:  	g = size2 / 4;  	gp.AddLine (pos.X - size2' pos.Y + g' pos.X - g' pos.Y + g);  	gp.AddLine (pos.X - g' pos.Y + g' pos.X - g' pos.Y + size2);  	gp.AddLine (pos.X - g' pos.Y + size2' pos.X + g' pos.Y + size2);  	gp.AddLine (pos.X + g' pos.Y + size2' pos.X + g' pos.Y + g);  	gp.AddLine (pos.X + g' pos.Y + g' pos.X + size2' pos.Y + g);  	gp.AddLine (pos.X + size2' pos.Y + g' pos.X + size2' pos.Y - g);  	gp.AddLine (pos.X + size2' pos.Y - g' pos.X + g' pos.Y - g);  	gp.AddLine (pos.X + g' pos.Y - g' pos.X + g' pos.Y - size2);  	gp.AddLine (pos.X + g' pos.Y - size2' pos.X - g' pos.Y - size2);  	gp.AddLine (pos.X - g' pos.Y - size2' pos.X - g' pos.Y - g);  	gp.AddLine (pos.X - g' pos.Y - g' pos.X - size2' pos.Y - g);  	gp.AddLine (pos.X - size2' pos.Y - g' pos.X - size2' pos.Y + g);  	break;  case MarkerStyle.Circle:  case MarkerStyle.Dot:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	gp.AddEllipse (x0' y0' size' size);  	break;  case MarkerStyle.Dash:  	x0 = pos.X - size2;  	y0 = pos.Y - size2 / 3;  	x1 = pos.X + size2;  	y1 = pos.Y + size2 / 3;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.X:  	g = size / 4;  	gp.AddLine (pos.X - size2 + g' pos.Y - size2' pos.X' pos.Y - g);  	gp.AddLine (pos.X' pos.Y - g' pos.X + size2 - g' pos.Y - size2);  	gp.AddLine (pos.X + size2 - g' pos.Y - size2' pos.X + size2' pos.Y - size2 + g);  	gp.AddLine (pos.X + size2' pos.Y - size2 + g' pos.X + g' pos.Y);  	gp.AddLine (pos.X + g' pos.Y' pos.X + size2' pos.Y + size2 - g);  	gp.AddLine (pos.X + size2' pos.Y + size2 - g' pos.X + size2 - g' pos.Y + size2);  	gp.AddLine (pos.X + size2 - g' pos.Y + size2' pos.X' pos.Y + g);  	gp.AddLine (pos.X' pos.Y + g' pos.X - size2 + g' pos.Y + size2);  	gp.AddLine (pos.X - size2 + g' pos.Y + size2' pos.X - size2' pos.Y + size2 - g);  	gp.AddLine (pos.X - size2' pos.Y + size2 - g' pos.X - g' pos.Y);  	gp.AddLine (pos.X - g' pos.Y' pos.X - size2' pos.Y - size2 + g);  	break;  case MarkerStyle.Star:  	{  		XPoint[] points = new XPoint[10];  		double radStep = 2 * Math.PI / 5;  		double outerCircle = size / 2;  		double innerCircle = size / 5;  		// outer circle  		double rad = -(Math.PI / 2);  		// 90�  		for (int idx = 0; idx < 10; idx += 2) {  			points [idx].X = pos.X + outerCircle * Math.Cos (rad);  			points [idx].Y = pos.Y + outerCircle * Math.Sin (rad);  			rad += radStep;  		}  		// inner circle  		rad = -(Math.PI / 4);  		// 45�  		double x = innerCircle * Math.Cos (rad);  		double y = innerCircle * Math.Sin (rad);  		points [1].X = pos.X + x;  		points [1].Y = pos.Y + y;  		points [9].X = pos.X - x;  		points [9].Y = pos.Y + y;  		rad += radStep;  		x = innerCircle * Math.Cos (rad);  		y = innerCircle * Math.Sin (rad);  		points [3].X = pos.X + x;  		points [3].Y = pos.Y + y;  		points [7].X = pos.X - x;  		points [7].Y = pos.Y + y;  		rad += radStep;  		y = innerCircle * Math.Sin (rad);  		points [5].X = pos.X;  		points [5].Y = pos.Y + y;  		gp.AddLines (points);  	}  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: switch (rendererInfo.MarkerStyle) {  case MarkerStyle.Square:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	x1 = pos.X + size2;  	y1 = pos.Y + size2;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.Diamond:  	gp.AddLine (x1 = pos.X + size2' pos.Y' pos.X' y0 = pos.Y - size2);  	gp.AddLine (pos.X' y0' x0 = pos.X - size2' pos.Y);  	gp.AddLine (x0' pos.Y' pos.X' y1 = pos.Y + size2);  	gp.AddLine (pos.X' y1' x1' pos.Y);  	break;  case MarkerStyle.Triangle:  	y0 = pos.Y + size / 2;  	y1 = pos.Y - size / 2;  	g = Math.Sqrt (size * size * 4 / 3) / 2;  	gp.AddLine (pos.X' y1' pos.X + g' y0);  	gp.AddLine (pos.X + g' y0' pos.X - g' y0);  	gp.AddLine (pos.X - g' y0' pos.X' y1);  	break;  case MarkerStyle.Plus:  	g = size2 / 4;  	gp.AddLine (pos.X - size2' pos.Y + g' pos.X - g' pos.Y + g);  	gp.AddLine (pos.X - g' pos.Y + g' pos.X - g' pos.Y + size2);  	gp.AddLine (pos.X - g' pos.Y + size2' pos.X + g' pos.Y + size2);  	gp.AddLine (pos.X + g' pos.Y + size2' pos.X + g' pos.Y + g);  	gp.AddLine (pos.X + g' pos.Y + g' pos.X + size2' pos.Y + g);  	gp.AddLine (pos.X + size2' pos.Y + g' pos.X + size2' pos.Y - g);  	gp.AddLine (pos.X + size2' pos.Y - g' pos.X + g' pos.Y - g);  	gp.AddLine (pos.X + g' pos.Y - g' pos.X + g' pos.Y - size2);  	gp.AddLine (pos.X + g' pos.Y - size2' pos.X - g' pos.Y - size2);  	gp.AddLine (pos.X - g' pos.Y - size2' pos.X - g' pos.Y - g);  	gp.AddLine (pos.X - g' pos.Y - g' pos.X - size2' pos.Y - g);  	gp.AddLine (pos.X - size2' pos.Y - g' pos.X - size2' pos.Y + g);  	break;  case MarkerStyle.Circle:  case MarkerStyle.Dot:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	gp.AddEllipse (x0' y0' size' size);  	break;  case MarkerStyle.Dash:  	x0 = pos.X - size2;  	y0 = pos.Y - size2 / 3;  	x1 = pos.X + size2;  	y1 = pos.Y + size2 / 3;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.X:  	g = size / 4;  	gp.AddLine (pos.X - size2 + g' pos.Y - size2' pos.X' pos.Y - g);  	gp.AddLine (pos.X' pos.Y - g' pos.X + size2 - g' pos.Y - size2);  	gp.AddLine (pos.X + size2 - g' pos.Y - size2' pos.X + size2' pos.Y - size2 + g);  	gp.AddLine (pos.X + size2' pos.Y - size2 + g' pos.X + g' pos.Y);  	gp.AddLine (pos.X + g' pos.Y' pos.X + size2' pos.Y + size2 - g);  	gp.AddLine (pos.X + size2' pos.Y + size2 - g' pos.X + size2 - g' pos.Y + size2);  	gp.AddLine (pos.X + size2 - g' pos.Y + size2' pos.X' pos.Y + g);  	gp.AddLine (pos.X' pos.Y + g' pos.X - size2 + g' pos.Y + size2);  	gp.AddLine (pos.X - size2 + g' pos.Y + size2' pos.X - size2' pos.Y + size2 - g);  	gp.AddLine (pos.X - size2' pos.Y + size2 - g' pos.X - g' pos.Y);  	gp.AddLine (pos.X - g' pos.Y' pos.X - size2' pos.Y - size2 + g);  	break;  case MarkerStyle.Star:  	{  		XPoint[] points = new XPoint[10];  		double radStep = 2 * Math.PI / 5;  		double outerCircle = size / 2;  		double innerCircle = size / 5;  		// outer circle  		double rad = -(Math.PI / 2);  		// 90�  		for (int idx = 0; idx < 10; idx += 2) {  			points [idx].X = pos.X + outerCircle * Math.Cos (rad);  			points [idx].Y = pos.Y + outerCircle * Math.Sin (rad);  			rad += radStep;  		}  		// inner circle  		rad = -(Math.PI / 4);  		// 45�  		double x = innerCircle * Math.Cos (rad);  		double y = innerCircle * Math.Sin (rad);  		points [1].X = pos.X + x;  		points [1].Y = pos.Y + y;  		points [9].X = pos.X - x;  		points [9].Y = pos.Y + y;  		rad += radStep;  		x = innerCircle * Math.Cos (rad);  		y = innerCircle * Math.Sin (rad);  		points [3].X = pos.X + x;  		points [3].Y = pos.Y + y;  		points [7].X = pos.X - x;  		points [7].Y = pos.Y + y;  		rad += radStep;  		y = innerCircle * Math.Sin (rad);  		points [5].X = pos.X;  		points [5].Y = pos.Y + y;  		gp.AddLines (points);  	}  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: switch (rendererInfo.MarkerStyle) {  case MarkerStyle.Square:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	x1 = pos.X + size2;  	y1 = pos.Y + size2;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.Diamond:  	gp.AddLine (x1 = pos.X + size2' pos.Y' pos.X' y0 = pos.Y - size2);  	gp.AddLine (pos.X' y0' x0 = pos.X - size2' pos.Y);  	gp.AddLine (x0' pos.Y' pos.X' y1 = pos.Y + size2);  	gp.AddLine (pos.X' y1' x1' pos.Y);  	break;  case MarkerStyle.Triangle:  	y0 = pos.Y + size / 2;  	y1 = pos.Y - size / 2;  	g = Math.Sqrt (size * size * 4 / 3) / 2;  	gp.AddLine (pos.X' y1' pos.X + g' y0);  	gp.AddLine (pos.X + g' y0' pos.X - g' y0);  	gp.AddLine (pos.X - g' y0' pos.X' y1);  	break;  case MarkerStyle.Plus:  	g = size2 / 4;  	gp.AddLine (pos.X - size2' pos.Y + g' pos.X - g' pos.Y + g);  	gp.AddLine (pos.X - g' pos.Y + g' pos.X - g' pos.Y + size2);  	gp.AddLine (pos.X - g' pos.Y + size2' pos.X + g' pos.Y + size2);  	gp.AddLine (pos.X + g' pos.Y + size2' pos.X + g' pos.Y + g);  	gp.AddLine (pos.X + g' pos.Y + g' pos.X + size2' pos.Y + g);  	gp.AddLine (pos.X + size2' pos.Y + g' pos.X + size2' pos.Y - g);  	gp.AddLine (pos.X + size2' pos.Y - g' pos.X + g' pos.Y - g);  	gp.AddLine (pos.X + g' pos.Y - g' pos.X + g' pos.Y - size2);  	gp.AddLine (pos.X + g' pos.Y - size2' pos.X - g' pos.Y - size2);  	gp.AddLine (pos.X - g' pos.Y - size2' pos.X - g' pos.Y - g);  	gp.AddLine (pos.X - g' pos.Y - g' pos.X - size2' pos.Y - g);  	gp.AddLine (pos.X - size2' pos.Y - g' pos.X - size2' pos.Y + g);  	break;  case MarkerStyle.Circle:  case MarkerStyle.Dot:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	gp.AddEllipse (x0' y0' size' size);  	break;  case MarkerStyle.Dash:  	x0 = pos.X - size2;  	y0 = pos.Y - size2 / 3;  	x1 = pos.X + size2;  	y1 = pos.Y + size2 / 3;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.X:  	g = size / 4;  	gp.AddLine (pos.X - size2 + g' pos.Y - size2' pos.X' pos.Y - g);  	gp.AddLine (pos.X' pos.Y - g' pos.X + size2 - g' pos.Y - size2);  	gp.AddLine (pos.X + size2 - g' pos.Y - size2' pos.X + size2' pos.Y - size2 + g);  	gp.AddLine (pos.X + size2' pos.Y - size2 + g' pos.X + g' pos.Y);  	gp.AddLine (pos.X + g' pos.Y' pos.X + size2' pos.Y + size2 - g);  	gp.AddLine (pos.X + size2' pos.Y + size2 - g' pos.X + size2 - g' pos.Y + size2);  	gp.AddLine (pos.X + size2 - g' pos.Y + size2' pos.X' pos.Y + g);  	gp.AddLine (pos.X' pos.Y + g' pos.X - size2 + g' pos.Y + size2);  	gp.AddLine (pos.X - size2 + g' pos.Y + size2' pos.X - size2' pos.Y + size2 - g);  	gp.AddLine (pos.X - size2' pos.Y + size2 - g' pos.X - g' pos.Y);  	gp.AddLine (pos.X - g' pos.Y' pos.X - size2' pos.Y - size2 + g);  	break;  case MarkerStyle.Star:  	{  		XPoint[] points = new XPoint[10];  		double radStep = 2 * Math.PI / 5;  		double outerCircle = size / 2;  		double innerCircle = size / 5;  		// outer circle  		double rad = -(Math.PI / 2);  		// 90�  		for (int idx = 0; idx < 10; idx += 2) {  			points [idx].X = pos.X + outerCircle * Math.Cos (rad);  			points [idx].Y = pos.Y + outerCircle * Math.Sin (rad);  			rad += radStep;  		}  		// inner circle  		rad = -(Math.PI / 4);  		// 45�  		double x = innerCircle * Math.Cos (rad);  		double y = innerCircle * Math.Sin (rad);  		points [1].X = pos.X + x;  		points [1].Y = pos.Y + y;  		points [9].X = pos.X - x;  		points [9].Y = pos.Y + y;  		rad += radStep;  		x = innerCircle * Math.Cos (rad);  		y = innerCircle * Math.Sin (rad);  		points [3].X = pos.X + x;  		points [3].Y = pos.Y + y;  		points [7].X = pos.X - x;  		points [7].Y = pos.Y + y;  		rad += radStep;  		y = innerCircle * Math.Sin (rad);  		points [5].X = pos.X;  		points [5].Y = pos.Y + y;  		gp.AddLines (points);  	}  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: switch (rendererInfo.MarkerStyle) {  case MarkerStyle.Square:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	x1 = pos.X + size2;  	y1 = pos.Y + size2;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.Diamond:  	gp.AddLine (x1 = pos.X + size2' pos.Y' pos.X' y0 = pos.Y - size2);  	gp.AddLine (pos.X' y0' x0 = pos.X - size2' pos.Y);  	gp.AddLine (x0' pos.Y' pos.X' y1 = pos.Y + size2);  	gp.AddLine (pos.X' y1' x1' pos.Y);  	break;  case MarkerStyle.Triangle:  	y0 = pos.Y + size / 2;  	y1 = pos.Y - size / 2;  	g = Math.Sqrt (size * size * 4 / 3) / 2;  	gp.AddLine (pos.X' y1' pos.X + g' y0);  	gp.AddLine (pos.X + g' y0' pos.X - g' y0);  	gp.AddLine (pos.X - g' y0' pos.X' y1);  	break;  case MarkerStyle.Plus:  	g = size2 / 4;  	gp.AddLine (pos.X - size2' pos.Y + g' pos.X - g' pos.Y + g);  	gp.AddLine (pos.X - g' pos.Y + g' pos.X - g' pos.Y + size2);  	gp.AddLine (pos.X - g' pos.Y + size2' pos.X + g' pos.Y + size2);  	gp.AddLine (pos.X + g' pos.Y + size2' pos.X + g' pos.Y + g);  	gp.AddLine (pos.X + g' pos.Y + g' pos.X + size2' pos.Y + g);  	gp.AddLine (pos.X + size2' pos.Y + g' pos.X + size2' pos.Y - g);  	gp.AddLine (pos.X + size2' pos.Y - g' pos.X + g' pos.Y - g);  	gp.AddLine (pos.X + g' pos.Y - g' pos.X + g' pos.Y - size2);  	gp.AddLine (pos.X + g' pos.Y - size2' pos.X - g' pos.Y - size2);  	gp.AddLine (pos.X - g' pos.Y - size2' pos.X - g' pos.Y - g);  	gp.AddLine (pos.X - g' pos.Y - g' pos.X - size2' pos.Y - g);  	gp.AddLine (pos.X - size2' pos.Y - g' pos.X - size2' pos.Y + g);  	break;  case MarkerStyle.Circle:  case MarkerStyle.Dot:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	gp.AddEllipse (x0' y0' size' size);  	break;  case MarkerStyle.Dash:  	x0 = pos.X - size2;  	y0 = pos.Y - size2 / 3;  	x1 = pos.X + size2;  	y1 = pos.Y + size2 / 3;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.X:  	g = size / 4;  	gp.AddLine (pos.X - size2 + g' pos.Y - size2' pos.X' pos.Y - g);  	gp.AddLine (pos.X' pos.Y - g' pos.X + size2 - g' pos.Y - size2);  	gp.AddLine (pos.X + size2 - g' pos.Y - size2' pos.X + size2' pos.Y - size2 + g);  	gp.AddLine (pos.X + size2' pos.Y - size2 + g' pos.X + g' pos.Y);  	gp.AddLine (pos.X + g' pos.Y' pos.X + size2' pos.Y + size2 - g);  	gp.AddLine (pos.X + size2' pos.Y + size2 - g' pos.X + size2 - g' pos.Y + size2);  	gp.AddLine (pos.X + size2 - g' pos.Y + size2' pos.X' pos.Y + g);  	gp.AddLine (pos.X' pos.Y + g' pos.X - size2 + g' pos.Y + size2);  	gp.AddLine (pos.X - size2 + g' pos.Y + size2' pos.X - size2' pos.Y + size2 - g);  	gp.AddLine (pos.X - size2' pos.Y + size2 - g' pos.X - g' pos.Y);  	gp.AddLine (pos.X - g' pos.Y' pos.X - size2' pos.Y - size2 + g);  	break;  case MarkerStyle.Star:  	{  		XPoint[] points = new XPoint[10];  		double radStep = 2 * Math.PI / 5;  		double outerCircle = size / 2;  		double innerCircle = size / 5;  		// outer circle  		double rad = -(Math.PI / 2);  		// 90�  		for (int idx = 0; idx < 10; idx += 2) {  			points [idx].X = pos.X + outerCircle * Math.Cos (rad);  			points [idx].Y = pos.Y + outerCircle * Math.Sin (rad);  			rad += radStep;  		}  		// inner circle  		rad = -(Math.PI / 4);  		// 45�  		double x = innerCircle * Math.Cos (rad);  		double y = innerCircle * Math.Sin (rad);  		points [1].X = pos.X + x;  		points [1].Y = pos.Y + y;  		points [9].X = pos.X - x;  		points [9].Y = pos.Y + y;  		rad += radStep;  		x = innerCircle * Math.Cos (rad);  		y = innerCircle * Math.Sin (rad);  		points [3].X = pos.X + x;  		points [3].Y = pos.Y + y;  		points [7].X = pos.X - x;  		points [7].Y = pos.Y + y;  		rad += radStep;  		y = innerCircle * Math.Sin (rad);  		points [5].X = pos.X;  		points [5].Y = pos.Y + y;  		gp.AddLines (points);  	}  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: switch (rendererInfo.MarkerStyle) {  case MarkerStyle.Square:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	x1 = pos.X + size2;  	y1 = pos.Y + size2;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.Diamond:  	gp.AddLine (x1 = pos.X + size2' pos.Y' pos.X' y0 = pos.Y - size2);  	gp.AddLine (pos.X' y0' x0 = pos.X - size2' pos.Y);  	gp.AddLine (x0' pos.Y' pos.X' y1 = pos.Y + size2);  	gp.AddLine (pos.X' y1' x1' pos.Y);  	break;  case MarkerStyle.Triangle:  	y0 = pos.Y + size / 2;  	y1 = pos.Y - size / 2;  	g = Math.Sqrt (size * size * 4 / 3) / 2;  	gp.AddLine (pos.X' y1' pos.X + g' y0);  	gp.AddLine (pos.X + g' y0' pos.X - g' y0);  	gp.AddLine (pos.X - g' y0' pos.X' y1);  	break;  case MarkerStyle.Plus:  	g = size2 / 4;  	gp.AddLine (pos.X - size2' pos.Y + g' pos.X - g' pos.Y + g);  	gp.AddLine (pos.X - g' pos.Y + g' pos.X - g' pos.Y + size2);  	gp.AddLine (pos.X - g' pos.Y + size2' pos.X + g' pos.Y + size2);  	gp.AddLine (pos.X + g' pos.Y + size2' pos.X + g' pos.Y + g);  	gp.AddLine (pos.X + g' pos.Y + g' pos.X + size2' pos.Y + g);  	gp.AddLine (pos.X + size2' pos.Y + g' pos.X + size2' pos.Y - g);  	gp.AddLine (pos.X + size2' pos.Y - g' pos.X + g' pos.Y - g);  	gp.AddLine (pos.X + g' pos.Y - g' pos.X + g' pos.Y - size2);  	gp.AddLine (pos.X + g' pos.Y - size2' pos.X - g' pos.Y - size2);  	gp.AddLine (pos.X - g' pos.Y - size2' pos.X - g' pos.Y - g);  	gp.AddLine (pos.X - g' pos.Y - g' pos.X - size2' pos.Y - g);  	gp.AddLine (pos.X - size2' pos.Y - g' pos.X - size2' pos.Y + g);  	break;  case MarkerStyle.Circle:  case MarkerStyle.Dot:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	gp.AddEllipse (x0' y0' size' size);  	break;  case MarkerStyle.Dash:  	x0 = pos.X - size2;  	y0 = pos.Y - size2 / 3;  	x1 = pos.X + size2;  	y1 = pos.Y + size2 / 3;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.X:  	g = size / 4;  	gp.AddLine (pos.X - size2 + g' pos.Y - size2' pos.X' pos.Y - g);  	gp.AddLine (pos.X' pos.Y - g' pos.X + size2 - g' pos.Y - size2);  	gp.AddLine (pos.X + size2 - g' pos.Y - size2' pos.X + size2' pos.Y - size2 + g);  	gp.AddLine (pos.X + size2' pos.Y - size2 + g' pos.X + g' pos.Y);  	gp.AddLine (pos.X + g' pos.Y' pos.X + size2' pos.Y + size2 - g);  	gp.AddLine (pos.X + size2' pos.Y + size2 - g' pos.X + size2 - g' pos.Y + size2);  	gp.AddLine (pos.X + size2 - g' pos.Y + size2' pos.X' pos.Y + g);  	gp.AddLine (pos.X' pos.Y + g' pos.X - size2 + g' pos.Y + size2);  	gp.AddLine (pos.X - size2 + g' pos.Y + size2' pos.X - size2' pos.Y + size2 - g);  	gp.AddLine (pos.X - size2' pos.Y + size2 - g' pos.X - g' pos.Y);  	gp.AddLine (pos.X - g' pos.Y' pos.X - size2' pos.Y - size2 + g);  	break;  case MarkerStyle.Star:  	{  		XPoint[] points = new XPoint[10];  		double radStep = 2 * Math.PI / 5;  		double outerCircle = size / 2;  		double innerCircle = size / 5;  		// outer circle  		double rad = -(Math.PI / 2);  		// 90�  		for (int idx = 0; idx < 10; idx += 2) {  			points [idx].X = pos.X + outerCircle * Math.Cos (rad);  			points [idx].Y = pos.Y + outerCircle * Math.Sin (rad);  			rad += radStep;  		}  		// inner circle  		rad = -(Math.PI / 4);  		// 45�  		double x = innerCircle * Math.Cos (rad);  		double y = innerCircle * Math.Sin (rad);  		points [1].X = pos.X + x;  		points [1].Y = pos.Y + y;  		points [9].X = pos.X - x;  		points [9].Y = pos.Y + y;  		rad += radStep;  		x = innerCircle * Math.Cos (rad);  		y = innerCircle * Math.Sin (rad);  		points [3].X = pos.X + x;  		points [3].Y = pos.Y + y;  		points [7].X = pos.X - x;  		points [7].Y = pos.Y + y;  		rad += radStep;  		y = innerCircle * Math.Sin (rad);  		points [5].X = pos.X;  		points [5].Y = pos.Y + y;  		gp.AddLines (points);  	}  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: switch (rendererInfo.MarkerStyle) {  case MarkerStyle.Square:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	x1 = pos.X + size2;  	y1 = pos.Y + size2;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.Diamond:  	gp.AddLine (x1 = pos.X + size2' pos.Y' pos.X' y0 = pos.Y - size2);  	gp.AddLine (pos.X' y0' x0 = pos.X - size2' pos.Y);  	gp.AddLine (x0' pos.Y' pos.X' y1 = pos.Y + size2);  	gp.AddLine (pos.X' y1' x1' pos.Y);  	break;  case MarkerStyle.Triangle:  	y0 = pos.Y + size / 2;  	y1 = pos.Y - size / 2;  	g = Math.Sqrt (size * size * 4 / 3) / 2;  	gp.AddLine (pos.X' y1' pos.X + g' y0);  	gp.AddLine (pos.X + g' y0' pos.X - g' y0);  	gp.AddLine (pos.X - g' y0' pos.X' y1);  	break;  case MarkerStyle.Plus:  	g = size2 / 4;  	gp.AddLine (pos.X - size2' pos.Y + g' pos.X - g' pos.Y + g);  	gp.AddLine (pos.X - g' pos.Y + g' pos.X - g' pos.Y + size2);  	gp.AddLine (pos.X - g' pos.Y + size2' pos.X + g' pos.Y + size2);  	gp.AddLine (pos.X + g' pos.Y + size2' pos.X + g' pos.Y + g);  	gp.AddLine (pos.X + g' pos.Y + g' pos.X + size2' pos.Y + g);  	gp.AddLine (pos.X + size2' pos.Y + g' pos.X + size2' pos.Y - g);  	gp.AddLine (pos.X + size2' pos.Y - g' pos.X + g' pos.Y - g);  	gp.AddLine (pos.X + g' pos.Y - g' pos.X + g' pos.Y - size2);  	gp.AddLine (pos.X + g' pos.Y - size2' pos.X - g' pos.Y - size2);  	gp.AddLine (pos.X - g' pos.Y - size2' pos.X - g' pos.Y - g);  	gp.AddLine (pos.X - g' pos.Y - g' pos.X - size2' pos.Y - g);  	gp.AddLine (pos.X - size2' pos.Y - g' pos.X - size2' pos.Y + g);  	break;  case MarkerStyle.Circle:  case MarkerStyle.Dot:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	gp.AddEllipse (x0' y0' size' size);  	break;  case MarkerStyle.Dash:  	x0 = pos.X - size2;  	y0 = pos.Y - size2 / 3;  	x1 = pos.X + size2;  	y1 = pos.Y + size2 / 3;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.X:  	g = size / 4;  	gp.AddLine (pos.X - size2 + g' pos.Y - size2' pos.X' pos.Y - g);  	gp.AddLine (pos.X' pos.Y - g' pos.X + size2 - g' pos.Y - size2);  	gp.AddLine (pos.X + size2 - g' pos.Y - size2' pos.X + size2' pos.Y - size2 + g);  	gp.AddLine (pos.X + size2' pos.Y - size2 + g' pos.X + g' pos.Y);  	gp.AddLine (pos.X + g' pos.Y' pos.X + size2' pos.Y + size2 - g);  	gp.AddLine (pos.X + size2' pos.Y + size2 - g' pos.X + size2 - g' pos.Y + size2);  	gp.AddLine (pos.X + size2 - g' pos.Y + size2' pos.X' pos.Y + g);  	gp.AddLine (pos.X' pos.Y + g' pos.X - size2 + g' pos.Y + size2);  	gp.AddLine (pos.X - size2 + g' pos.Y + size2' pos.X - size2' pos.Y + size2 - g);  	gp.AddLine (pos.X - size2' pos.Y + size2 - g' pos.X - g' pos.Y);  	gp.AddLine (pos.X - g' pos.Y' pos.X - size2' pos.Y - size2 + g);  	break;  case MarkerStyle.Star:  	{  		XPoint[] points = new XPoint[10];  		double radStep = 2 * Math.PI / 5;  		double outerCircle = size / 2;  		double innerCircle = size / 5;  		// outer circle  		double rad = -(Math.PI / 2);  		// 90�  		for (int idx = 0; idx < 10; idx += 2) {  			points [idx].X = pos.X + outerCircle * Math.Cos (rad);  			points [idx].Y = pos.Y + outerCircle * Math.Sin (rad);  			rad += radStep;  		}  		// inner circle  		rad = -(Math.PI / 4);  		// 45�  		double x = innerCircle * Math.Cos (rad);  		double y = innerCircle * Math.Sin (rad);  		points [1].X = pos.X + x;  		points [1].Y = pos.Y + y;  		points [9].X = pos.X - x;  		points [9].Y = pos.Y + y;  		rad += radStep;  		x = innerCircle * Math.Cos (rad);  		y = innerCircle * Math.Sin (rad);  		points [3].X = pos.X + x;  		points [3].Y = pos.Y + y;  		points [7].X = pos.X - x;  		points [7].Y = pos.Y + y;  		rad += radStep;  		y = innerCircle * Math.Sin (rad);  		points [5].X = pos.X;  		points [5].Y = pos.Y + y;  		gp.AddLines (points);  	}  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: switch (rendererInfo.MarkerStyle) {  case MarkerStyle.Square:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	x1 = pos.X + size2;  	y1 = pos.Y + size2;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.Diamond:  	gp.AddLine (x1 = pos.X + size2' pos.Y' pos.X' y0 = pos.Y - size2);  	gp.AddLine (pos.X' y0' x0 = pos.X - size2' pos.Y);  	gp.AddLine (x0' pos.Y' pos.X' y1 = pos.Y + size2);  	gp.AddLine (pos.X' y1' x1' pos.Y);  	break;  case MarkerStyle.Triangle:  	y0 = pos.Y + size / 2;  	y1 = pos.Y - size / 2;  	g = Math.Sqrt (size * size * 4 / 3) / 2;  	gp.AddLine (pos.X' y1' pos.X + g' y0);  	gp.AddLine (pos.X + g' y0' pos.X - g' y0);  	gp.AddLine (pos.X - g' y0' pos.X' y1);  	break;  case MarkerStyle.Plus:  	g = size2 / 4;  	gp.AddLine (pos.X - size2' pos.Y + g' pos.X - g' pos.Y + g);  	gp.AddLine (pos.X - g' pos.Y + g' pos.X - g' pos.Y + size2);  	gp.AddLine (pos.X - g' pos.Y + size2' pos.X + g' pos.Y + size2);  	gp.AddLine (pos.X + g' pos.Y + size2' pos.X + g' pos.Y + g);  	gp.AddLine (pos.X + g' pos.Y + g' pos.X + size2' pos.Y + g);  	gp.AddLine (pos.X + size2' pos.Y + g' pos.X + size2' pos.Y - g);  	gp.AddLine (pos.X + size2' pos.Y - g' pos.X + g' pos.Y - g);  	gp.AddLine (pos.X + g' pos.Y - g' pos.X + g' pos.Y - size2);  	gp.AddLine (pos.X + g' pos.Y - size2' pos.X - g' pos.Y - size2);  	gp.AddLine (pos.X - g' pos.Y - size2' pos.X - g' pos.Y - g);  	gp.AddLine (pos.X - g' pos.Y - g' pos.X - size2' pos.Y - g);  	gp.AddLine (pos.X - size2' pos.Y - g' pos.X - size2' pos.Y + g);  	break;  case MarkerStyle.Circle:  case MarkerStyle.Dot:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	gp.AddEllipse (x0' y0' size' size);  	break;  case MarkerStyle.Dash:  	x0 = pos.X - size2;  	y0 = pos.Y - size2 / 3;  	x1 = pos.X + size2;  	y1 = pos.Y + size2 / 3;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.X:  	g = size / 4;  	gp.AddLine (pos.X - size2 + g' pos.Y - size2' pos.X' pos.Y - g);  	gp.AddLine (pos.X' pos.Y - g' pos.X + size2 - g' pos.Y - size2);  	gp.AddLine (pos.X + size2 - g' pos.Y - size2' pos.X + size2' pos.Y - size2 + g);  	gp.AddLine (pos.X + size2' pos.Y - size2 + g' pos.X + g' pos.Y);  	gp.AddLine (pos.X + g' pos.Y' pos.X + size2' pos.Y + size2 - g);  	gp.AddLine (pos.X + size2' pos.Y + size2 - g' pos.X + size2 - g' pos.Y + size2);  	gp.AddLine (pos.X + size2 - g' pos.Y + size2' pos.X' pos.Y + g);  	gp.AddLine (pos.X' pos.Y + g' pos.X - size2 + g' pos.Y + size2);  	gp.AddLine (pos.X - size2 + g' pos.Y + size2' pos.X - size2' pos.Y + size2 - g);  	gp.AddLine (pos.X - size2' pos.Y + size2 - g' pos.X - g' pos.Y);  	gp.AddLine (pos.X - g' pos.Y' pos.X - size2' pos.Y - size2 + g);  	break;  case MarkerStyle.Star:  	{  		XPoint[] points = new XPoint[10];  		double radStep = 2 * Math.PI / 5;  		double outerCircle = size / 2;  		double innerCircle = size / 5;  		// outer circle  		double rad = -(Math.PI / 2);  		// 90�  		for (int idx = 0; idx < 10; idx += 2) {  			points [idx].X = pos.X + outerCircle * Math.Cos (rad);  			points [idx].Y = pos.Y + outerCircle * Math.Sin (rad);  			rad += radStep;  		}  		// inner circle  		rad = -(Math.PI / 4);  		// 45�  		double x = innerCircle * Math.Cos (rad);  		double y = innerCircle * Math.Sin (rad);  		points [1].X = pos.X + x;  		points [1].Y = pos.Y + y;  		points [9].X = pos.X - x;  		points [9].Y = pos.Y + y;  		rad += radStep;  		x = innerCircle * Math.Cos (rad);  		y = innerCircle * Math.Sin (rad);  		points [3].X = pos.X + x;  		points [3].Y = pos.Y + y;  		points [7].X = pos.X - x;  		points [7].Y = pos.Y + y;  		rad += radStep;  		y = innerCircle * Math.Sin (rad);  		points [5].X = pos.X;  		points [5].Y = pos.Y + y;  		gp.AddLines (points);  	}  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: switch (rendererInfo.MarkerStyle) {  case MarkerStyle.Square:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	x1 = pos.X + size2;  	y1 = pos.Y + size2;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.Diamond:  	gp.AddLine (x1 = pos.X + size2' pos.Y' pos.X' y0 = pos.Y - size2);  	gp.AddLine (pos.X' y0' x0 = pos.X - size2' pos.Y);  	gp.AddLine (x0' pos.Y' pos.X' y1 = pos.Y + size2);  	gp.AddLine (pos.X' y1' x1' pos.Y);  	break;  case MarkerStyle.Triangle:  	y0 = pos.Y + size / 2;  	y1 = pos.Y - size / 2;  	g = Math.Sqrt (size * size * 4 / 3) / 2;  	gp.AddLine (pos.X' y1' pos.X + g' y0);  	gp.AddLine (pos.X + g' y0' pos.X - g' y0);  	gp.AddLine (pos.X - g' y0' pos.X' y1);  	break;  case MarkerStyle.Plus:  	g = size2 / 4;  	gp.AddLine (pos.X - size2' pos.Y + g' pos.X - g' pos.Y + g);  	gp.AddLine (pos.X - g' pos.Y + g' pos.X - g' pos.Y + size2);  	gp.AddLine (pos.X - g' pos.Y + size2' pos.X + g' pos.Y + size2);  	gp.AddLine (pos.X + g' pos.Y + size2' pos.X + g' pos.Y + g);  	gp.AddLine (pos.X + g' pos.Y + g' pos.X + size2' pos.Y + g);  	gp.AddLine (pos.X + size2' pos.Y + g' pos.X + size2' pos.Y - g);  	gp.AddLine (pos.X + size2' pos.Y - g' pos.X + g' pos.Y - g);  	gp.AddLine (pos.X + g' pos.Y - g' pos.X + g' pos.Y - size2);  	gp.AddLine (pos.X + g' pos.Y - size2' pos.X - g' pos.Y - size2);  	gp.AddLine (pos.X - g' pos.Y - size2' pos.X - g' pos.Y - g);  	gp.AddLine (pos.X - g' pos.Y - g' pos.X - size2' pos.Y - g);  	gp.AddLine (pos.X - size2' pos.Y - g' pos.X - size2' pos.Y + g);  	break;  case MarkerStyle.Circle:  case MarkerStyle.Dot:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	gp.AddEllipse (x0' y0' size' size);  	break;  case MarkerStyle.Dash:  	x0 = pos.X - size2;  	y0 = pos.Y - size2 / 3;  	x1 = pos.X + size2;  	y1 = pos.Y + size2 / 3;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.X:  	g = size / 4;  	gp.AddLine (pos.X - size2 + g' pos.Y - size2' pos.X' pos.Y - g);  	gp.AddLine (pos.X' pos.Y - g' pos.X + size2 - g' pos.Y - size2);  	gp.AddLine (pos.X + size2 - g' pos.Y - size2' pos.X + size2' pos.Y - size2 + g);  	gp.AddLine (pos.X + size2' pos.Y - size2 + g' pos.X + g' pos.Y);  	gp.AddLine (pos.X + g' pos.Y' pos.X + size2' pos.Y + size2 - g);  	gp.AddLine (pos.X + size2' pos.Y + size2 - g' pos.X + size2 - g' pos.Y + size2);  	gp.AddLine (pos.X + size2 - g' pos.Y + size2' pos.X' pos.Y + g);  	gp.AddLine (pos.X' pos.Y + g' pos.X - size2 + g' pos.Y + size2);  	gp.AddLine (pos.X - size2 + g' pos.Y + size2' pos.X - size2' pos.Y + size2 - g);  	gp.AddLine (pos.X - size2' pos.Y + size2 - g' pos.X - g' pos.Y);  	gp.AddLine (pos.X - g' pos.Y' pos.X - size2' pos.Y - size2 + g);  	break;  case MarkerStyle.Star:  	{  		XPoint[] points = new XPoint[10];  		double radStep = 2 * Math.PI / 5;  		double outerCircle = size / 2;  		double innerCircle = size / 5;  		// outer circle  		double rad = -(Math.PI / 2);  		// 90�  		for (int idx = 0; idx < 10; idx += 2) {  			points [idx].X = pos.X + outerCircle * Math.Cos (rad);  			points [idx].Y = pos.Y + outerCircle * Math.Sin (rad);  			rad += radStep;  		}  		// inner circle  		rad = -(Math.PI / 4);  		// 45�  		double x = innerCircle * Math.Cos (rad);  		double y = innerCircle * Math.Sin (rad);  		points [1].X = pos.X + x;  		points [1].Y = pos.Y + y;  		points [9].X = pos.X - x;  		points [9].Y = pos.Y + y;  		rad += radStep;  		x = innerCircle * Math.Cos (rad);  		y = innerCircle * Math.Sin (rad);  		points [3].X = pos.X + x;  		points [3].Y = pos.Y + y;  		points [7].X = pos.X - x;  		points [7].Y = pos.Y + y;  		rad += radStep;  		y = innerCircle * Math.Sin (rad);  		points [5].X = pos.X;  		points [5].Y = pos.Y + y;  		gp.AddLines (points);  	}  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: y0 = pos.Y + size / 2;  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: y1 = pos.Y - size / 2;  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: g = Math.Sqrt (size * size * 4 / 3) / 2;  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: g = Math.Sqrt (size * size * 4 / 3) / 2;  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: g = Math.Sqrt (size * size * 4 / 3) / 2;  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: g = size2 / 4;  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: y0 = pos.Y - size2 / 3;  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: y1 = pos.Y + size2 / 3;  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: g = size / 4;  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: for (int idx = 0; idx < 10; idx += 2) {  	points [idx].X = pos.X + outerCircle * Math.Cos (rad);  	points [idx].Y = pos.Y + outerCircle * Math.Sin (rad);  	rad += radStep;  }  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: for (int idx = 0; idx < 10; idx += 2) {  	points [idx].X = pos.X + outerCircle * Math.Cos (rad);  	points [idx].Y = pos.Y + outerCircle * Math.Sin (rad);  	rad += radStep;  }  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: idx += 2
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: rad = -(Math.PI / 4);  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: points [9].X = pos.X - x;  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: points [9].Y = pos.Y + y;  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: points [3].X = pos.X + x;  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: points [3].Y = pos.Y + y;  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: points [7].X = pos.X - x;  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: points [7].Y = pos.Y + y;  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: points [5].X = pos.X;  
Magic Number,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following statement contains a magic number: points [5].Y = pos.Y + y;  
Magic Number,PdfSharp.Charting.Renderers,PieChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieChartRenderer.cs,Format,The following statement contains a magic number: cri.plotAreaRendererInfo.X += (chartRect.Width - edge) / 2;  
Magic Number,PdfSharp.Charting.Renderers,PieChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieChartRenderer.cs,Format,The following statement contains a magic number: cri.plotAreaRendererInfo.Y += (chartRect.Height - edge) / 2;  
Magic Number,PdfSharp.Charting.Renderers,PieClosedPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieClosedPlotAreaRenderer.cs,CalcSectors,The following statement contains a magic number: if (textMeasure != 0) {  	pieRect.X += textMeasure;  	pieRect.Y += textMeasure;  	pieRect.Width -= 2 * textMeasure;  	pieRect.Height -= 2 * textMeasure;  }  
Magic Number,PdfSharp.Charting.Renderers,PieClosedPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieClosedPlotAreaRenderer.cs,CalcSectors,The following statement contains a magic number: if (textMeasure != 0) {  	pieRect.X += textMeasure;  	pieRect.Y += textMeasure;  	pieRect.Width -= 2 * textMeasure;  	pieRect.Height -= 2 * textMeasure;  }  
Magic Number,PdfSharp.Charting.Renderers,PieClosedPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieClosedPlotAreaRenderer.cs,CalcSectors,The following statement contains a magic number: pieRect.Width -= 2 * textMeasure;  
Magic Number,PdfSharp.Charting.Renderers,PieClosedPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieClosedPlotAreaRenderer.cs,CalcSectors,The following statement contains a magic number: pieRect.Height -= 2 * textMeasure;  
Magic Number,PdfSharp.Charting.Renderers,PieClosedPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieClosedPlotAreaRenderer.cs,CalcSectors,The following statement contains a magic number: foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  	if (!double.IsNaN (sector.point.value) && sector.point.value != 0) {  		sweepAngle = 360 / (sumValues / Math.Abs (sector.point.value));  		sector.Rect = pieRect;  		sector.StartAngle = startAngle;  		sector.SweepAngle = sweepAngle;  		startAngle += sweepAngle;  	}  	else {  		sector.StartAngle = double.NaN;  		sector.SweepAngle = double.NaN;  	}  }  
Magic Number,PdfSharp.Charting.Renderers,PieClosedPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieClosedPlotAreaRenderer.cs,CalcSectors,The following statement contains a magic number: if (!double.IsNaN (sector.point.value) && sector.point.value != 0) {  	sweepAngle = 360 / (sumValues / Math.Abs (sector.point.value));  	sector.Rect = pieRect;  	sector.StartAngle = startAngle;  	sector.SweepAngle = sweepAngle;  	startAngle += sweepAngle;  }  else {  	sector.StartAngle = double.NaN;  	sector.SweepAngle = double.NaN;  }  
Magic Number,PdfSharp.Charting.Renderers,PieClosedPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieClosedPlotAreaRenderer.cs,CalcSectors,The following statement contains a magic number: sweepAngle = 360 / (sumValues / Math.Abs (sector.point.value));  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,Format,The following statement contains a magic number: foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  	DataLabelEntryRendererInfo dleri = new DataLabelEntryRendererInfo ();  	if (sri.dataLabelRendererInfo.Type != DataLabelType.None) {  		if (sri.dataLabelRendererInfo.Type == DataLabelType.Percent) {  			double percent = 100 / (sumValues / Math.Abs (sector.point.value));  			dleri.Text = percent.ToString (sri.dataLabelRendererInfo.Format) + "%";  		}  		else if (sri.dataLabelRendererInfo.Type == DataLabelType.Value)  			dleri.Text = sector.point.value.ToString (sri.dataLabelRendererInfo.Format);  		if (dleri.Text.Length > 0)  			dleri.Size = gfx.MeasureString (dleri.Text' sri.dataLabelRendererInfo.Font);  	}  	sri.dataLabelRendererInfo.Entries [index++] = dleri;  }  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,Format,The following statement contains a magic number: if (sri.dataLabelRendererInfo.Type != DataLabelType.None) {  	if (sri.dataLabelRendererInfo.Type == DataLabelType.Percent) {  		double percent = 100 / (sumValues / Math.Abs (sector.point.value));  		dleri.Text = percent.ToString (sri.dataLabelRendererInfo.Format) + "%";  	}  	else if (sri.dataLabelRendererInfo.Type == DataLabelType.Value)  		dleri.Text = sector.point.value.ToString (sri.dataLabelRendererInfo.Format);  	if (dleri.Text.Length > 0)  		dleri.Size = gfx.MeasureString (dleri.Text' sri.dataLabelRendererInfo.Font);  }  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,Format,The following statement contains a magic number: if (sri.dataLabelRendererInfo.Type == DataLabelType.Percent) {  	double percent = 100 / (sumValues / Math.Abs (sector.point.value));  	dleri.Text = percent.ToString (sri.dataLabelRendererInfo.Format) + "%";  }  else if (sri.dataLabelRendererInfo.Type == DataLabelType.Value)  	dleri.Text = sector.point.value.ToString (sri.dataLabelRendererInfo.Format);  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: if (cri.seriesRendererInfos.Length > 0) {  	SeriesRendererInfo sri = cri.seriesRendererInfos [0];  	if (sri != null && sri.dataLabelRendererInfo != null) {  		int sectorIndex = 0;  		foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  			// Determine output rectangle  			double midAngle = sector.StartAngle + sector.SweepAngle / 2;  			double radMidAngle = midAngle / 180 * Math.PI;  			XPoint origin = new XPoint (sector.Rect.X + sector.Rect.Width / 2' sector.Rect.Y + sector.Rect.Height / 2);  			double radius = sector.Rect.Width / 2;  			double halfradius = radius / 2;  			DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [sectorIndex++];  			switch (sri.dataLabelRendererInfo.Position) {  			case DataLabelPosition.OutsideEnd:  				// Outer border of the circle.  				dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  				dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  				if (dleri.X < origin.X)  					dleri.X -= dleri.Width;  				if (dleri.Y < origin.Y)  					dleri.Y -= dleri.Height;  				break;  			case DataLabelPosition.InsideEnd:  				// Inner border of the circle.  				dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  				dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  				if (dleri.X > origin.X)  					dleri.X -= dleri.Width;  				if (dleri.Y > origin.Y)  					dleri.Y -= dleri.Height;  				break;  			case DataLabelPosition.Center:  				// Centered  				dleri.X = origin.X + (halfradius * Math.Cos (radMidAngle));  				dleri.Y = origin.Y + (halfradius * Math.Sin (radMidAngle));  				dleri.X -= dleri.Width / 2;  				dleri.Y -= dleri.Height / 2;  				break;  			case DataLabelPosition.InsideBase:  				// Aligned at the base/center of the circle  				dleri.X = origin.X;  				dleri.Y = origin.Y;  				if (dleri.X < origin.X)  					dleri.X -= dleri.Width;  				if (dleri.Y < origin.Y)  					dleri.Y -= dleri.Height;  				break;  			}  		}  	}  }  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: if (cri.seriesRendererInfos.Length > 0) {  	SeriesRendererInfo sri = cri.seriesRendererInfos [0];  	if (sri != null && sri.dataLabelRendererInfo != null) {  		int sectorIndex = 0;  		foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  			// Determine output rectangle  			double midAngle = sector.StartAngle + sector.SweepAngle / 2;  			double radMidAngle = midAngle / 180 * Math.PI;  			XPoint origin = new XPoint (sector.Rect.X + sector.Rect.Width / 2' sector.Rect.Y + sector.Rect.Height / 2);  			double radius = sector.Rect.Width / 2;  			double halfradius = radius / 2;  			DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [sectorIndex++];  			switch (sri.dataLabelRendererInfo.Position) {  			case DataLabelPosition.OutsideEnd:  				// Outer border of the circle.  				dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  				dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  				if (dleri.X < origin.X)  					dleri.X -= dleri.Width;  				if (dleri.Y < origin.Y)  					dleri.Y -= dleri.Height;  				break;  			case DataLabelPosition.InsideEnd:  				// Inner border of the circle.  				dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  				dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  				if (dleri.X > origin.X)  					dleri.X -= dleri.Width;  				if (dleri.Y > origin.Y)  					dleri.Y -= dleri.Height;  				break;  			case DataLabelPosition.Center:  				// Centered  				dleri.X = origin.X + (halfradius * Math.Cos (radMidAngle));  				dleri.Y = origin.Y + (halfradius * Math.Sin (radMidAngle));  				dleri.X -= dleri.Width / 2;  				dleri.Y -= dleri.Height / 2;  				break;  			case DataLabelPosition.InsideBase:  				// Aligned at the base/center of the circle  				dleri.X = origin.X;  				dleri.Y = origin.Y;  				if (dleri.X < origin.X)  					dleri.X -= dleri.Width;  				if (dleri.Y < origin.Y)  					dleri.Y -= dleri.Height;  				break;  			}  		}  	}  }  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: if (cri.seriesRendererInfos.Length > 0) {  	SeriesRendererInfo sri = cri.seriesRendererInfos [0];  	if (sri != null && sri.dataLabelRendererInfo != null) {  		int sectorIndex = 0;  		foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  			// Determine output rectangle  			double midAngle = sector.StartAngle + sector.SweepAngle / 2;  			double radMidAngle = midAngle / 180 * Math.PI;  			XPoint origin = new XPoint (sector.Rect.X + sector.Rect.Width / 2' sector.Rect.Y + sector.Rect.Height / 2);  			double radius = sector.Rect.Width / 2;  			double halfradius = radius / 2;  			DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [sectorIndex++];  			switch (sri.dataLabelRendererInfo.Position) {  			case DataLabelPosition.OutsideEnd:  				// Outer border of the circle.  				dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  				dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  				if (dleri.X < origin.X)  					dleri.X -= dleri.Width;  				if (dleri.Y < origin.Y)  					dleri.Y -= dleri.Height;  				break;  			case DataLabelPosition.InsideEnd:  				// Inner border of the circle.  				dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  				dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  				if (dleri.X > origin.X)  					dleri.X -= dleri.Width;  				if (dleri.Y > origin.Y)  					dleri.Y -= dleri.Height;  				break;  			case DataLabelPosition.Center:  				// Centered  				dleri.X = origin.X + (halfradius * Math.Cos (radMidAngle));  				dleri.Y = origin.Y + (halfradius * Math.Sin (radMidAngle));  				dleri.X -= dleri.Width / 2;  				dleri.Y -= dleri.Height / 2;  				break;  			case DataLabelPosition.InsideBase:  				// Aligned at the base/center of the circle  				dleri.X = origin.X;  				dleri.Y = origin.Y;  				if (dleri.X < origin.X)  					dleri.X -= dleri.Width;  				if (dleri.Y < origin.Y)  					dleri.Y -= dleri.Height;  				break;  			}  		}  	}  }  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: if (cri.seriesRendererInfos.Length > 0) {  	SeriesRendererInfo sri = cri.seriesRendererInfos [0];  	if (sri != null && sri.dataLabelRendererInfo != null) {  		int sectorIndex = 0;  		foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  			// Determine output rectangle  			double midAngle = sector.StartAngle + sector.SweepAngle / 2;  			double radMidAngle = midAngle / 180 * Math.PI;  			XPoint origin = new XPoint (sector.Rect.X + sector.Rect.Width / 2' sector.Rect.Y + sector.Rect.Height / 2);  			double radius = sector.Rect.Width / 2;  			double halfradius = radius / 2;  			DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [sectorIndex++];  			switch (sri.dataLabelRendererInfo.Position) {  			case DataLabelPosition.OutsideEnd:  				// Outer border of the circle.  				dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  				dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  				if (dleri.X < origin.X)  					dleri.X -= dleri.Width;  				if (dleri.Y < origin.Y)  					dleri.Y -= dleri.Height;  				break;  			case DataLabelPosition.InsideEnd:  				// Inner border of the circle.  				dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  				dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  				if (dleri.X > origin.X)  					dleri.X -= dleri.Width;  				if (dleri.Y > origin.Y)  					dleri.Y -= dleri.Height;  				break;  			case DataLabelPosition.Center:  				// Centered  				dleri.X = origin.X + (halfradius * Math.Cos (radMidAngle));  				dleri.Y = origin.Y + (halfradius * Math.Sin (radMidAngle));  				dleri.X -= dleri.Width / 2;  				dleri.Y -= dleri.Height / 2;  				break;  			case DataLabelPosition.InsideBase:  				// Aligned at the base/center of the circle  				dleri.X = origin.X;  				dleri.Y = origin.Y;  				if (dleri.X < origin.X)  					dleri.X -= dleri.Width;  				if (dleri.Y < origin.Y)  					dleri.Y -= dleri.Height;  				break;  			}  		}  	}  }  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: if (cri.seriesRendererInfos.Length > 0) {  	SeriesRendererInfo sri = cri.seriesRendererInfos [0];  	if (sri != null && sri.dataLabelRendererInfo != null) {  		int sectorIndex = 0;  		foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  			// Determine output rectangle  			double midAngle = sector.StartAngle + sector.SweepAngle / 2;  			double radMidAngle = midAngle / 180 * Math.PI;  			XPoint origin = new XPoint (sector.Rect.X + sector.Rect.Width / 2' sector.Rect.Y + sector.Rect.Height / 2);  			double radius = sector.Rect.Width / 2;  			double halfradius = radius / 2;  			DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [sectorIndex++];  			switch (sri.dataLabelRendererInfo.Position) {  			case DataLabelPosition.OutsideEnd:  				// Outer border of the circle.  				dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  				dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  				if (dleri.X < origin.X)  					dleri.X -= dleri.Width;  				if (dleri.Y < origin.Y)  					dleri.Y -= dleri.Height;  				break;  			case DataLabelPosition.InsideEnd:  				// Inner border of the circle.  				dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  				dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  				if (dleri.X > origin.X)  					dleri.X -= dleri.Width;  				if (dleri.Y > origin.Y)  					dleri.Y -= dleri.Height;  				break;  			case DataLabelPosition.Center:  				// Centered  				dleri.X = origin.X + (halfradius * Math.Cos (radMidAngle));  				dleri.Y = origin.Y + (halfradius * Math.Sin (radMidAngle));  				dleri.X -= dleri.Width / 2;  				dleri.Y -= dleri.Height / 2;  				break;  			case DataLabelPosition.InsideBase:  				// Aligned at the base/center of the circle  				dleri.X = origin.X;  				dleri.Y = origin.Y;  				if (dleri.X < origin.X)  					dleri.X -= dleri.Width;  				if (dleri.Y < origin.Y)  					dleri.Y -= dleri.Height;  				break;  			}  		}  	}  }  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: if (cri.seriesRendererInfos.Length > 0) {  	SeriesRendererInfo sri = cri.seriesRendererInfos [0];  	if (sri != null && sri.dataLabelRendererInfo != null) {  		int sectorIndex = 0;  		foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  			// Determine output rectangle  			double midAngle = sector.StartAngle + sector.SweepAngle / 2;  			double radMidAngle = midAngle / 180 * Math.PI;  			XPoint origin = new XPoint (sector.Rect.X + sector.Rect.Width / 2' sector.Rect.Y + sector.Rect.Height / 2);  			double radius = sector.Rect.Width / 2;  			double halfradius = radius / 2;  			DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [sectorIndex++];  			switch (sri.dataLabelRendererInfo.Position) {  			case DataLabelPosition.OutsideEnd:  				// Outer border of the circle.  				dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  				dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  				if (dleri.X < origin.X)  					dleri.X -= dleri.Width;  				if (dleri.Y < origin.Y)  					dleri.Y -= dleri.Height;  				break;  			case DataLabelPosition.InsideEnd:  				// Inner border of the circle.  				dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  				dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  				if (dleri.X > origin.X)  					dleri.X -= dleri.Width;  				if (dleri.Y > origin.Y)  					dleri.Y -= dleri.Height;  				break;  			case DataLabelPosition.Center:  				// Centered  				dleri.X = origin.X + (halfradius * Math.Cos (radMidAngle));  				dleri.Y = origin.Y + (halfradius * Math.Sin (radMidAngle));  				dleri.X -= dleri.Width / 2;  				dleri.Y -= dleri.Height / 2;  				break;  			case DataLabelPosition.InsideBase:  				// Aligned at the base/center of the circle  				dleri.X = origin.X;  				dleri.Y = origin.Y;  				if (dleri.X < origin.X)  					dleri.X -= dleri.Width;  				if (dleri.Y < origin.Y)  					dleri.Y -= dleri.Height;  				break;  			}  		}  	}  }  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: if (cri.seriesRendererInfos.Length > 0) {  	SeriesRendererInfo sri = cri.seriesRendererInfos [0];  	if (sri != null && sri.dataLabelRendererInfo != null) {  		int sectorIndex = 0;  		foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  			// Determine output rectangle  			double midAngle = sector.StartAngle + sector.SweepAngle / 2;  			double radMidAngle = midAngle / 180 * Math.PI;  			XPoint origin = new XPoint (sector.Rect.X + sector.Rect.Width / 2' sector.Rect.Y + sector.Rect.Height / 2);  			double radius = sector.Rect.Width / 2;  			double halfradius = radius / 2;  			DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [sectorIndex++];  			switch (sri.dataLabelRendererInfo.Position) {  			case DataLabelPosition.OutsideEnd:  				// Outer border of the circle.  				dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  				dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  				if (dleri.X < origin.X)  					dleri.X -= dleri.Width;  				if (dleri.Y < origin.Y)  					dleri.Y -= dleri.Height;  				break;  			case DataLabelPosition.InsideEnd:  				// Inner border of the circle.  				dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  				dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  				if (dleri.X > origin.X)  					dleri.X -= dleri.Width;  				if (dleri.Y > origin.Y)  					dleri.Y -= dleri.Height;  				break;  			case DataLabelPosition.Center:  				// Centered  				dleri.X = origin.X + (halfradius * Math.Cos (radMidAngle));  				dleri.Y = origin.Y + (halfradius * Math.Sin (radMidAngle));  				dleri.X -= dleri.Width / 2;  				dleri.Y -= dleri.Height / 2;  				break;  			case DataLabelPosition.InsideBase:  				// Aligned at the base/center of the circle  				dleri.X = origin.X;  				dleri.Y = origin.Y;  				if (dleri.X < origin.X)  					dleri.X -= dleri.Width;  				if (dleri.Y < origin.Y)  					dleri.Y -= dleri.Height;  				break;  			}  		}  	}  }  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: if (cri.seriesRendererInfos.Length > 0) {  	SeriesRendererInfo sri = cri.seriesRendererInfos [0];  	if (sri != null && sri.dataLabelRendererInfo != null) {  		int sectorIndex = 0;  		foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  			// Determine output rectangle  			double midAngle = sector.StartAngle + sector.SweepAngle / 2;  			double radMidAngle = midAngle / 180 * Math.PI;  			XPoint origin = new XPoint (sector.Rect.X + sector.Rect.Width / 2' sector.Rect.Y + sector.Rect.Height / 2);  			double radius = sector.Rect.Width / 2;  			double halfradius = radius / 2;  			DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [sectorIndex++];  			switch (sri.dataLabelRendererInfo.Position) {  			case DataLabelPosition.OutsideEnd:  				// Outer border of the circle.  				dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  				dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  				if (dleri.X < origin.X)  					dleri.X -= dleri.Width;  				if (dleri.Y < origin.Y)  					dleri.Y -= dleri.Height;  				break;  			case DataLabelPosition.InsideEnd:  				// Inner border of the circle.  				dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  				dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  				if (dleri.X > origin.X)  					dleri.X -= dleri.Width;  				if (dleri.Y > origin.Y)  					dleri.Y -= dleri.Height;  				break;  			case DataLabelPosition.Center:  				// Centered  				dleri.X = origin.X + (halfradius * Math.Cos (radMidAngle));  				dleri.Y = origin.Y + (halfradius * Math.Sin (radMidAngle));  				dleri.X -= dleri.Width / 2;  				dleri.Y -= dleri.Height / 2;  				break;  			case DataLabelPosition.InsideBase:  				// Aligned at the base/center of the circle  				dleri.X = origin.X;  				dleri.Y = origin.Y;  				if (dleri.X < origin.X)  					dleri.X -= dleri.Width;  				if (dleri.Y < origin.Y)  					dleri.Y -= dleri.Height;  				break;  			}  		}  	}  }  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: if (sri != null && sri.dataLabelRendererInfo != null) {  	int sectorIndex = 0;  	foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  		// Determine output rectangle  		double midAngle = sector.StartAngle + sector.SweepAngle / 2;  		double radMidAngle = midAngle / 180 * Math.PI;  		XPoint origin = new XPoint (sector.Rect.X + sector.Rect.Width / 2' sector.Rect.Y + sector.Rect.Height / 2);  		double radius = sector.Rect.Width / 2;  		double halfradius = radius / 2;  		DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [sectorIndex++];  		switch (sri.dataLabelRendererInfo.Position) {  		case DataLabelPosition.OutsideEnd:  			// Outer border of the circle.  			dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  			dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  			if (dleri.X < origin.X)  				dleri.X -= dleri.Width;  			if (dleri.Y < origin.Y)  				dleri.Y -= dleri.Height;  			break;  		case DataLabelPosition.InsideEnd:  			// Inner border of the circle.  			dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  			dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  			if (dleri.X > origin.X)  				dleri.X -= dleri.Width;  			if (dleri.Y > origin.Y)  				dleri.Y -= dleri.Height;  			break;  		case DataLabelPosition.Center:  			// Centered  			dleri.X = origin.X + (halfradius * Math.Cos (radMidAngle));  			dleri.Y = origin.Y + (halfradius * Math.Sin (radMidAngle));  			dleri.X -= dleri.Width / 2;  			dleri.Y -= dleri.Height / 2;  			break;  		case DataLabelPosition.InsideBase:  			// Aligned at the base/center of the circle  			dleri.X = origin.X;  			dleri.Y = origin.Y;  			if (dleri.X < origin.X)  				dleri.X -= dleri.Width;  			if (dleri.Y < origin.Y)  				dleri.Y -= dleri.Height;  			break;  		}  	}  }  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: if (sri != null && sri.dataLabelRendererInfo != null) {  	int sectorIndex = 0;  	foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  		// Determine output rectangle  		double midAngle = sector.StartAngle + sector.SweepAngle / 2;  		double radMidAngle = midAngle / 180 * Math.PI;  		XPoint origin = new XPoint (sector.Rect.X + sector.Rect.Width / 2' sector.Rect.Y + sector.Rect.Height / 2);  		double radius = sector.Rect.Width / 2;  		double halfradius = radius / 2;  		DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [sectorIndex++];  		switch (sri.dataLabelRendererInfo.Position) {  		case DataLabelPosition.OutsideEnd:  			// Outer border of the circle.  			dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  			dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  			if (dleri.X < origin.X)  				dleri.X -= dleri.Width;  			if (dleri.Y < origin.Y)  				dleri.Y -= dleri.Height;  			break;  		case DataLabelPosition.InsideEnd:  			// Inner border of the circle.  			dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  			dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  			if (dleri.X > origin.X)  				dleri.X -= dleri.Width;  			if (dleri.Y > origin.Y)  				dleri.Y -= dleri.Height;  			break;  		case DataLabelPosition.Center:  			// Centered  			dleri.X = origin.X + (halfradius * Math.Cos (radMidAngle));  			dleri.Y = origin.Y + (halfradius * Math.Sin (radMidAngle));  			dleri.X -= dleri.Width / 2;  			dleri.Y -= dleri.Height / 2;  			break;  		case DataLabelPosition.InsideBase:  			// Aligned at the base/center of the circle  			dleri.X = origin.X;  			dleri.Y = origin.Y;  			if (dleri.X < origin.X)  				dleri.X -= dleri.Width;  			if (dleri.Y < origin.Y)  				dleri.Y -= dleri.Height;  			break;  		}  	}  }  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: if (sri != null && sri.dataLabelRendererInfo != null) {  	int sectorIndex = 0;  	foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  		// Determine output rectangle  		double midAngle = sector.StartAngle + sector.SweepAngle / 2;  		double radMidAngle = midAngle / 180 * Math.PI;  		XPoint origin = new XPoint (sector.Rect.X + sector.Rect.Width / 2' sector.Rect.Y + sector.Rect.Height / 2);  		double radius = sector.Rect.Width / 2;  		double halfradius = radius / 2;  		DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [sectorIndex++];  		switch (sri.dataLabelRendererInfo.Position) {  		case DataLabelPosition.OutsideEnd:  			// Outer border of the circle.  			dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  			dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  			if (dleri.X < origin.X)  				dleri.X -= dleri.Width;  			if (dleri.Y < origin.Y)  				dleri.Y -= dleri.Height;  			break;  		case DataLabelPosition.InsideEnd:  			// Inner border of the circle.  			dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  			dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  			if (dleri.X > origin.X)  				dleri.X -= dleri.Width;  			if (dleri.Y > origin.Y)  				dleri.Y -= dleri.Height;  			break;  		case DataLabelPosition.Center:  			// Centered  			dleri.X = origin.X + (halfradius * Math.Cos (radMidAngle));  			dleri.Y = origin.Y + (halfradius * Math.Sin (radMidAngle));  			dleri.X -= dleri.Width / 2;  			dleri.Y -= dleri.Height / 2;  			break;  		case DataLabelPosition.InsideBase:  			// Aligned at the base/center of the circle  			dleri.X = origin.X;  			dleri.Y = origin.Y;  			if (dleri.X < origin.X)  				dleri.X -= dleri.Width;  			if (dleri.Y < origin.Y)  				dleri.Y -= dleri.Height;  			break;  		}  	}  }  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: if (sri != null && sri.dataLabelRendererInfo != null) {  	int sectorIndex = 0;  	foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  		// Determine output rectangle  		double midAngle = sector.StartAngle + sector.SweepAngle / 2;  		double radMidAngle = midAngle / 180 * Math.PI;  		XPoint origin = new XPoint (sector.Rect.X + sector.Rect.Width / 2' sector.Rect.Y + sector.Rect.Height / 2);  		double radius = sector.Rect.Width / 2;  		double halfradius = radius / 2;  		DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [sectorIndex++];  		switch (sri.dataLabelRendererInfo.Position) {  		case DataLabelPosition.OutsideEnd:  			// Outer border of the circle.  			dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  			dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  			if (dleri.X < origin.X)  				dleri.X -= dleri.Width;  			if (dleri.Y < origin.Y)  				dleri.Y -= dleri.Height;  			break;  		case DataLabelPosition.InsideEnd:  			// Inner border of the circle.  			dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  			dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  			if (dleri.X > origin.X)  				dleri.X -= dleri.Width;  			if (dleri.Y > origin.Y)  				dleri.Y -= dleri.Height;  			break;  		case DataLabelPosition.Center:  			// Centered  			dleri.X = origin.X + (halfradius * Math.Cos (radMidAngle));  			dleri.Y = origin.Y + (halfradius * Math.Sin (radMidAngle));  			dleri.X -= dleri.Width / 2;  			dleri.Y -= dleri.Height / 2;  			break;  		case DataLabelPosition.InsideBase:  			// Aligned at the base/center of the circle  			dleri.X = origin.X;  			dleri.Y = origin.Y;  			if (dleri.X < origin.X)  				dleri.X -= dleri.Width;  			if (dleri.Y < origin.Y)  				dleri.Y -= dleri.Height;  			break;  		}  	}  }  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: if (sri != null && sri.dataLabelRendererInfo != null) {  	int sectorIndex = 0;  	foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  		// Determine output rectangle  		double midAngle = sector.StartAngle + sector.SweepAngle / 2;  		double radMidAngle = midAngle / 180 * Math.PI;  		XPoint origin = new XPoint (sector.Rect.X + sector.Rect.Width / 2' sector.Rect.Y + sector.Rect.Height / 2);  		double radius = sector.Rect.Width / 2;  		double halfradius = radius / 2;  		DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [sectorIndex++];  		switch (sri.dataLabelRendererInfo.Position) {  		case DataLabelPosition.OutsideEnd:  			// Outer border of the circle.  			dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  			dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  			if (dleri.X < origin.X)  				dleri.X -= dleri.Width;  			if (dleri.Y < origin.Y)  				dleri.Y -= dleri.Height;  			break;  		case DataLabelPosition.InsideEnd:  			// Inner border of the circle.  			dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  			dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  			if (dleri.X > origin.X)  				dleri.X -= dleri.Width;  			if (dleri.Y > origin.Y)  				dleri.Y -= dleri.Height;  			break;  		case DataLabelPosition.Center:  			// Centered  			dleri.X = origin.X + (halfradius * Math.Cos (radMidAngle));  			dleri.Y = origin.Y + (halfradius * Math.Sin (radMidAngle));  			dleri.X -= dleri.Width / 2;  			dleri.Y -= dleri.Height / 2;  			break;  		case DataLabelPosition.InsideBase:  			// Aligned at the base/center of the circle  			dleri.X = origin.X;  			dleri.Y = origin.Y;  			if (dleri.X < origin.X)  				dleri.X -= dleri.Width;  			if (dleri.Y < origin.Y)  				dleri.Y -= dleri.Height;  			break;  		}  	}  }  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: if (sri != null && sri.dataLabelRendererInfo != null) {  	int sectorIndex = 0;  	foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  		// Determine output rectangle  		double midAngle = sector.StartAngle + sector.SweepAngle / 2;  		double radMidAngle = midAngle / 180 * Math.PI;  		XPoint origin = new XPoint (sector.Rect.X + sector.Rect.Width / 2' sector.Rect.Y + sector.Rect.Height / 2);  		double radius = sector.Rect.Width / 2;  		double halfradius = radius / 2;  		DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [sectorIndex++];  		switch (sri.dataLabelRendererInfo.Position) {  		case DataLabelPosition.OutsideEnd:  			// Outer border of the circle.  			dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  			dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  			if (dleri.X < origin.X)  				dleri.X -= dleri.Width;  			if (dleri.Y < origin.Y)  				dleri.Y -= dleri.Height;  			break;  		case DataLabelPosition.InsideEnd:  			// Inner border of the circle.  			dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  			dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  			if (dleri.X > origin.X)  				dleri.X -= dleri.Width;  			if (dleri.Y > origin.Y)  				dleri.Y -= dleri.Height;  			break;  		case DataLabelPosition.Center:  			// Centered  			dleri.X = origin.X + (halfradius * Math.Cos (radMidAngle));  			dleri.Y = origin.Y + (halfradius * Math.Sin (radMidAngle));  			dleri.X -= dleri.Width / 2;  			dleri.Y -= dleri.Height / 2;  			break;  		case DataLabelPosition.InsideBase:  			// Aligned at the base/center of the circle  			dleri.X = origin.X;  			dleri.Y = origin.Y;  			if (dleri.X < origin.X)  				dleri.X -= dleri.Width;  			if (dleri.Y < origin.Y)  				dleri.Y -= dleri.Height;  			break;  		}  	}  }  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: if (sri != null && sri.dataLabelRendererInfo != null) {  	int sectorIndex = 0;  	foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  		// Determine output rectangle  		double midAngle = sector.StartAngle + sector.SweepAngle / 2;  		double radMidAngle = midAngle / 180 * Math.PI;  		XPoint origin = new XPoint (sector.Rect.X + sector.Rect.Width / 2' sector.Rect.Y + sector.Rect.Height / 2);  		double radius = sector.Rect.Width / 2;  		double halfradius = radius / 2;  		DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [sectorIndex++];  		switch (sri.dataLabelRendererInfo.Position) {  		case DataLabelPosition.OutsideEnd:  			// Outer border of the circle.  			dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  			dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  			if (dleri.X < origin.X)  				dleri.X -= dleri.Width;  			if (dleri.Y < origin.Y)  				dleri.Y -= dleri.Height;  			break;  		case DataLabelPosition.InsideEnd:  			// Inner border of the circle.  			dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  			dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  			if (dleri.X > origin.X)  				dleri.X -= dleri.Width;  			if (dleri.Y > origin.Y)  				dleri.Y -= dleri.Height;  			break;  		case DataLabelPosition.Center:  			// Centered  			dleri.X = origin.X + (halfradius * Math.Cos (radMidAngle));  			dleri.Y = origin.Y + (halfradius * Math.Sin (radMidAngle));  			dleri.X -= dleri.Width / 2;  			dleri.Y -= dleri.Height / 2;  			break;  		case DataLabelPosition.InsideBase:  			// Aligned at the base/center of the circle  			dleri.X = origin.X;  			dleri.Y = origin.Y;  			if (dleri.X < origin.X)  				dleri.X -= dleri.Width;  			if (dleri.Y < origin.Y)  				dleri.Y -= dleri.Height;  			break;  		}  	}  }  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: if (sri != null && sri.dataLabelRendererInfo != null) {  	int sectorIndex = 0;  	foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  		// Determine output rectangle  		double midAngle = sector.StartAngle + sector.SweepAngle / 2;  		double radMidAngle = midAngle / 180 * Math.PI;  		XPoint origin = new XPoint (sector.Rect.X + sector.Rect.Width / 2' sector.Rect.Y + sector.Rect.Height / 2);  		double radius = sector.Rect.Width / 2;  		double halfradius = radius / 2;  		DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [sectorIndex++];  		switch (sri.dataLabelRendererInfo.Position) {  		case DataLabelPosition.OutsideEnd:  			// Outer border of the circle.  			dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  			dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  			if (dleri.X < origin.X)  				dleri.X -= dleri.Width;  			if (dleri.Y < origin.Y)  				dleri.Y -= dleri.Height;  			break;  		case DataLabelPosition.InsideEnd:  			// Inner border of the circle.  			dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  			dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  			if (dleri.X > origin.X)  				dleri.X -= dleri.Width;  			if (dleri.Y > origin.Y)  				dleri.Y -= dleri.Height;  			break;  		case DataLabelPosition.Center:  			// Centered  			dleri.X = origin.X + (halfradius * Math.Cos (radMidAngle));  			dleri.Y = origin.Y + (halfradius * Math.Sin (radMidAngle));  			dleri.X -= dleri.Width / 2;  			dleri.Y -= dleri.Height / 2;  			break;  		case DataLabelPosition.InsideBase:  			// Aligned at the base/center of the circle  			dleri.X = origin.X;  			dleri.Y = origin.Y;  			if (dleri.X < origin.X)  				dleri.X -= dleri.Width;  			if (dleri.Y < origin.Y)  				dleri.Y -= dleri.Height;  			break;  		}  	}  }  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  	// Determine output rectangle  	double midAngle = sector.StartAngle + sector.SweepAngle / 2;  	double radMidAngle = midAngle / 180 * Math.PI;  	XPoint origin = new XPoint (sector.Rect.X + sector.Rect.Width / 2' sector.Rect.Y + sector.Rect.Height / 2);  	double radius = sector.Rect.Width / 2;  	double halfradius = radius / 2;  	DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [sectorIndex++];  	switch (sri.dataLabelRendererInfo.Position) {  	case DataLabelPosition.OutsideEnd:  		// Outer border of the circle.  		dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  		dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  		if (dleri.X < origin.X)  			dleri.X -= dleri.Width;  		if (dleri.Y < origin.Y)  			dleri.Y -= dleri.Height;  		break;  	case DataLabelPosition.InsideEnd:  		// Inner border of the circle.  		dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  		dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  		if (dleri.X > origin.X)  			dleri.X -= dleri.Width;  		if (dleri.Y > origin.Y)  			dleri.Y -= dleri.Height;  		break;  	case DataLabelPosition.Center:  		// Centered  		dleri.X = origin.X + (halfradius * Math.Cos (radMidAngle));  		dleri.Y = origin.Y + (halfradius * Math.Sin (radMidAngle));  		dleri.X -= dleri.Width / 2;  		dleri.Y -= dleri.Height / 2;  		break;  	case DataLabelPosition.InsideBase:  		// Aligned at the base/center of the circle  		dleri.X = origin.X;  		dleri.Y = origin.Y;  		if (dleri.X < origin.X)  			dleri.X -= dleri.Width;  		if (dleri.Y < origin.Y)  			dleri.Y -= dleri.Height;  		break;  	}  }  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  	// Determine output rectangle  	double midAngle = sector.StartAngle + sector.SweepAngle / 2;  	double radMidAngle = midAngle / 180 * Math.PI;  	XPoint origin = new XPoint (sector.Rect.X + sector.Rect.Width / 2' sector.Rect.Y + sector.Rect.Height / 2);  	double radius = sector.Rect.Width / 2;  	double halfradius = radius / 2;  	DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [sectorIndex++];  	switch (sri.dataLabelRendererInfo.Position) {  	case DataLabelPosition.OutsideEnd:  		// Outer border of the circle.  		dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  		dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  		if (dleri.X < origin.X)  			dleri.X -= dleri.Width;  		if (dleri.Y < origin.Y)  			dleri.Y -= dleri.Height;  		break;  	case DataLabelPosition.InsideEnd:  		// Inner border of the circle.  		dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  		dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  		if (dleri.X > origin.X)  			dleri.X -= dleri.Width;  		if (dleri.Y > origin.Y)  			dleri.Y -= dleri.Height;  		break;  	case DataLabelPosition.Center:  		// Centered  		dleri.X = origin.X + (halfradius * Math.Cos (radMidAngle));  		dleri.Y = origin.Y + (halfradius * Math.Sin (radMidAngle));  		dleri.X -= dleri.Width / 2;  		dleri.Y -= dleri.Height / 2;  		break;  	case DataLabelPosition.InsideBase:  		// Aligned at the base/center of the circle  		dleri.X = origin.X;  		dleri.Y = origin.Y;  		if (dleri.X < origin.X)  			dleri.X -= dleri.Width;  		if (dleri.Y < origin.Y)  			dleri.Y -= dleri.Height;  		break;  	}  }  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  	// Determine output rectangle  	double midAngle = sector.StartAngle + sector.SweepAngle / 2;  	double radMidAngle = midAngle / 180 * Math.PI;  	XPoint origin = new XPoint (sector.Rect.X + sector.Rect.Width / 2' sector.Rect.Y + sector.Rect.Height / 2);  	double radius = sector.Rect.Width / 2;  	double halfradius = radius / 2;  	DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [sectorIndex++];  	switch (sri.dataLabelRendererInfo.Position) {  	case DataLabelPosition.OutsideEnd:  		// Outer border of the circle.  		dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  		dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  		if (dleri.X < origin.X)  			dleri.X -= dleri.Width;  		if (dleri.Y < origin.Y)  			dleri.Y -= dleri.Height;  		break;  	case DataLabelPosition.InsideEnd:  		// Inner border of the circle.  		dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  		dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  		if (dleri.X > origin.X)  			dleri.X -= dleri.Width;  		if (dleri.Y > origin.Y)  			dleri.Y -= dleri.Height;  		break;  	case DataLabelPosition.Center:  		// Centered  		dleri.X = origin.X + (halfradius * Math.Cos (radMidAngle));  		dleri.Y = origin.Y + (halfradius * Math.Sin (radMidAngle));  		dleri.X -= dleri.Width / 2;  		dleri.Y -= dleri.Height / 2;  		break;  	case DataLabelPosition.InsideBase:  		// Aligned at the base/center of the circle  		dleri.X = origin.X;  		dleri.Y = origin.Y;  		if (dleri.X < origin.X)  			dleri.X -= dleri.Width;  		if (dleri.Y < origin.Y)  			dleri.Y -= dleri.Height;  		break;  	}  }  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  	// Determine output rectangle  	double midAngle = sector.StartAngle + sector.SweepAngle / 2;  	double radMidAngle = midAngle / 180 * Math.PI;  	XPoint origin = new XPoint (sector.Rect.X + sector.Rect.Width / 2' sector.Rect.Y + sector.Rect.Height / 2);  	double radius = sector.Rect.Width / 2;  	double halfradius = radius / 2;  	DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [sectorIndex++];  	switch (sri.dataLabelRendererInfo.Position) {  	case DataLabelPosition.OutsideEnd:  		// Outer border of the circle.  		dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  		dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  		if (dleri.X < origin.X)  			dleri.X -= dleri.Width;  		if (dleri.Y < origin.Y)  			dleri.Y -= dleri.Height;  		break;  	case DataLabelPosition.InsideEnd:  		// Inner border of the circle.  		dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  		dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  		if (dleri.X > origin.X)  			dleri.X -= dleri.Width;  		if (dleri.Y > origin.Y)  			dleri.Y -= dleri.Height;  		break;  	case DataLabelPosition.Center:  		// Centered  		dleri.X = origin.X + (halfradius * Math.Cos (radMidAngle));  		dleri.Y = origin.Y + (halfradius * Math.Sin (radMidAngle));  		dleri.X -= dleri.Width / 2;  		dleri.Y -= dleri.Height / 2;  		break;  	case DataLabelPosition.InsideBase:  		// Aligned at the base/center of the circle  		dleri.X = origin.X;  		dleri.Y = origin.Y;  		if (dleri.X < origin.X)  			dleri.X -= dleri.Width;  		if (dleri.Y < origin.Y)  			dleri.Y -= dleri.Height;  		break;  	}  }  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  	// Determine output rectangle  	double midAngle = sector.StartAngle + sector.SweepAngle / 2;  	double radMidAngle = midAngle / 180 * Math.PI;  	XPoint origin = new XPoint (sector.Rect.X + sector.Rect.Width / 2' sector.Rect.Y + sector.Rect.Height / 2);  	double radius = sector.Rect.Width / 2;  	double halfradius = radius / 2;  	DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [sectorIndex++];  	switch (sri.dataLabelRendererInfo.Position) {  	case DataLabelPosition.OutsideEnd:  		// Outer border of the circle.  		dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  		dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  		if (dleri.X < origin.X)  			dleri.X -= dleri.Width;  		if (dleri.Y < origin.Y)  			dleri.Y -= dleri.Height;  		break;  	case DataLabelPosition.InsideEnd:  		// Inner border of the circle.  		dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  		dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  		if (dleri.X > origin.X)  			dleri.X -= dleri.Width;  		if (dleri.Y > origin.Y)  			dleri.Y -= dleri.Height;  		break;  	case DataLabelPosition.Center:  		// Centered  		dleri.X = origin.X + (halfradius * Math.Cos (radMidAngle));  		dleri.Y = origin.Y + (halfradius * Math.Sin (radMidAngle));  		dleri.X -= dleri.Width / 2;  		dleri.Y -= dleri.Height / 2;  		break;  	case DataLabelPosition.InsideBase:  		// Aligned at the base/center of the circle  		dleri.X = origin.X;  		dleri.Y = origin.Y;  		if (dleri.X < origin.X)  			dleri.X -= dleri.Width;  		if (dleri.Y < origin.Y)  			dleri.Y -= dleri.Height;  		break;  	}  }  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  	// Determine output rectangle  	double midAngle = sector.StartAngle + sector.SweepAngle / 2;  	double radMidAngle = midAngle / 180 * Math.PI;  	XPoint origin = new XPoint (sector.Rect.X + sector.Rect.Width / 2' sector.Rect.Y + sector.Rect.Height / 2);  	double radius = sector.Rect.Width / 2;  	double halfradius = radius / 2;  	DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [sectorIndex++];  	switch (sri.dataLabelRendererInfo.Position) {  	case DataLabelPosition.OutsideEnd:  		// Outer border of the circle.  		dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  		dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  		if (dleri.X < origin.X)  			dleri.X -= dleri.Width;  		if (dleri.Y < origin.Y)  			dleri.Y -= dleri.Height;  		break;  	case DataLabelPosition.InsideEnd:  		// Inner border of the circle.  		dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  		dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  		if (dleri.X > origin.X)  			dleri.X -= dleri.Width;  		if (dleri.Y > origin.Y)  			dleri.Y -= dleri.Height;  		break;  	case DataLabelPosition.Center:  		// Centered  		dleri.X = origin.X + (halfradius * Math.Cos (radMidAngle));  		dleri.Y = origin.Y + (halfradius * Math.Sin (radMidAngle));  		dleri.X -= dleri.Width / 2;  		dleri.Y -= dleri.Height / 2;  		break;  	case DataLabelPosition.InsideBase:  		// Aligned at the base/center of the circle  		dleri.X = origin.X;  		dleri.Y = origin.Y;  		if (dleri.X < origin.X)  			dleri.X -= dleri.Width;  		if (dleri.Y < origin.Y)  			dleri.Y -= dleri.Height;  		break;  	}  }  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  	// Determine output rectangle  	double midAngle = sector.StartAngle + sector.SweepAngle / 2;  	double radMidAngle = midAngle / 180 * Math.PI;  	XPoint origin = new XPoint (sector.Rect.X + sector.Rect.Width / 2' sector.Rect.Y + sector.Rect.Height / 2);  	double radius = sector.Rect.Width / 2;  	double halfradius = radius / 2;  	DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [sectorIndex++];  	switch (sri.dataLabelRendererInfo.Position) {  	case DataLabelPosition.OutsideEnd:  		// Outer border of the circle.  		dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  		dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  		if (dleri.X < origin.X)  			dleri.X -= dleri.Width;  		if (dleri.Y < origin.Y)  			dleri.Y -= dleri.Height;  		break;  	case DataLabelPosition.InsideEnd:  		// Inner border of the circle.  		dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  		dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  		if (dleri.X > origin.X)  			dleri.X -= dleri.Width;  		if (dleri.Y > origin.Y)  			dleri.Y -= dleri.Height;  		break;  	case DataLabelPosition.Center:  		// Centered  		dleri.X = origin.X + (halfradius * Math.Cos (radMidAngle));  		dleri.Y = origin.Y + (halfradius * Math.Sin (radMidAngle));  		dleri.X -= dleri.Width / 2;  		dleri.Y -= dleri.Height / 2;  		break;  	case DataLabelPosition.InsideBase:  		// Aligned at the base/center of the circle  		dleri.X = origin.X;  		dleri.Y = origin.Y;  		if (dleri.X < origin.X)  			dleri.X -= dleri.Width;  		if (dleri.Y < origin.Y)  			dleri.Y -= dleri.Height;  		break;  	}  }  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  	// Determine output rectangle  	double midAngle = sector.StartAngle + sector.SweepAngle / 2;  	double radMidAngle = midAngle / 180 * Math.PI;  	XPoint origin = new XPoint (sector.Rect.X + sector.Rect.Width / 2' sector.Rect.Y + sector.Rect.Height / 2);  	double radius = sector.Rect.Width / 2;  	double halfradius = radius / 2;  	DataLabelEntryRendererInfo dleri = sri.dataLabelRendererInfo.Entries [sectorIndex++];  	switch (sri.dataLabelRendererInfo.Position) {  	case DataLabelPosition.OutsideEnd:  		// Outer border of the circle.  		dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  		dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  		if (dleri.X < origin.X)  			dleri.X -= dleri.Width;  		if (dleri.Y < origin.Y)  			dleri.Y -= dleri.Height;  		break;  	case DataLabelPosition.InsideEnd:  		// Inner border of the circle.  		dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  		dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  		if (dleri.X > origin.X)  			dleri.X -= dleri.Width;  		if (dleri.Y > origin.Y)  			dleri.Y -= dleri.Height;  		break;  	case DataLabelPosition.Center:  		// Centered  		dleri.X = origin.X + (halfradius * Math.Cos (radMidAngle));  		dleri.Y = origin.Y + (halfradius * Math.Sin (radMidAngle));  		dleri.X -= dleri.Width / 2;  		dleri.Y -= dleri.Height / 2;  		break;  	case DataLabelPosition.InsideBase:  		// Aligned at the base/center of the circle  		dleri.X = origin.X;  		dleri.Y = origin.Y;  		if (dleri.X < origin.X)  			dleri.X -= dleri.Width;  		if (dleri.Y < origin.Y)  			dleri.Y -= dleri.Height;  		break;  	}  }  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: switch (sri.dataLabelRendererInfo.Position) {  case DataLabelPosition.OutsideEnd:  	// Outer border of the circle.  	dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  	dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  	if (dleri.X < origin.X)  		dleri.X -= dleri.Width;  	if (dleri.Y < origin.Y)  		dleri.Y -= dleri.Height;  	break;  case DataLabelPosition.InsideEnd:  	// Inner border of the circle.  	dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  	dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  	if (dleri.X > origin.X)  		dleri.X -= dleri.Width;  	if (dleri.Y > origin.Y)  		dleri.Y -= dleri.Height;  	break;  case DataLabelPosition.Center:  	// Centered  	dleri.X = origin.X + (halfradius * Math.Cos (radMidAngle));  	dleri.Y = origin.Y + (halfradius * Math.Sin (radMidAngle));  	dleri.X -= dleri.Width / 2;  	dleri.Y -= dleri.Height / 2;  	break;  case DataLabelPosition.InsideBase:  	// Aligned at the base/center of the circle  	dleri.X = origin.X;  	dleri.Y = origin.Y;  	if (dleri.X < origin.X)  		dleri.X -= dleri.Width;  	if (dleri.Y < origin.Y)  		dleri.Y -= dleri.Height;  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: switch (sri.dataLabelRendererInfo.Position) {  case DataLabelPosition.OutsideEnd:  	// Outer border of the circle.  	dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  	dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  	if (dleri.X < origin.X)  		dleri.X -= dleri.Width;  	if (dleri.Y < origin.Y)  		dleri.Y -= dleri.Height;  	break;  case DataLabelPosition.InsideEnd:  	// Inner border of the circle.  	dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  	dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  	if (dleri.X > origin.X)  		dleri.X -= dleri.Width;  	if (dleri.Y > origin.Y)  		dleri.Y -= dleri.Height;  	break;  case DataLabelPosition.Center:  	// Centered  	dleri.X = origin.X + (halfradius * Math.Cos (radMidAngle));  	dleri.Y = origin.Y + (halfradius * Math.Sin (radMidAngle));  	dleri.X -= dleri.Width / 2;  	dleri.Y -= dleri.Height / 2;  	break;  case DataLabelPosition.InsideBase:  	// Aligned at the base/center of the circle  	dleri.X = origin.X;  	dleri.Y = origin.Y;  	if (dleri.X < origin.X)  		dleri.X -= dleri.Width;  	if (dleri.Y < origin.Y)  		dleri.Y -= dleri.Height;  	break;  }  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: dleri.X -= dleri.Width / 2;  
Magic Number,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,CalcPositions,The following statement contains a magic number: dleri.Y -= dleri.Height / 2;  
Magic Number,PdfSharp.Charting.Renderers,PieExplodedPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieExplodedPlotAreaRenderer.cs,CalcSectors,The following statement contains a magic number: if (textMeasure != 0) {  	pieRect.X += textMeasure;  	pieRect.Y += textMeasure;  	pieRect.Width -= 2 * textMeasure;  	pieRect.Height -= 2 * textMeasure;  }  
Magic Number,PdfSharp.Charting.Renderers,PieExplodedPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieExplodedPlotAreaRenderer.cs,CalcSectors,The following statement contains a magic number: if (textMeasure != 0) {  	pieRect.X += textMeasure;  	pieRect.Y += textMeasure;  	pieRect.Width -= 2 * textMeasure;  	pieRect.Height -= 2 * textMeasure;  }  
Magic Number,PdfSharp.Charting.Renderers,PieExplodedPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieExplodedPlotAreaRenderer.cs,CalcSectors,The following statement contains a magic number: pieRect.Width -= 2 * textMeasure;  
Magic Number,PdfSharp.Charting.Renderers,PieExplodedPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieExplodedPlotAreaRenderer.cs,CalcSectors,The following statement contains a magic number: pieRect.Height -= 2 * textMeasure;  
Magic Number,PdfSharp.Charting.Renderers,PieExplodedPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieExplodedPlotAreaRenderer.cs,CalcSectors,The following statement contains a magic number: foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  	if (!double.IsNaN (sector.point.value) && sector.point.value != 0) {  		sweepAngle = 360 / (sumValues / Math.Abs (sector.point.value));  		midAngle = startAngle + sweepAngle / 2;  		sectorStartAngle = Math.Max (0' startAngle + deltaAngle);  		sectorSweepAngle = Math.Max (sweepAngle' sweepAngle - deltaAngle);  		p1.X = origin.X + rInnerCircle * Math.Cos (midAngle / 180 * Math.PI);  		p1.Y = origin.Y + rInnerCircle * Math.Sin (midAngle / 180 * Math.PI);  		innerRect.X = p1.X - rOuterCircle + rInnerCircle;  		innerRect.Y = p1.Y - rOuterCircle + rInnerCircle;  		innerRect.Width = (rOuterCircle - rInnerCircle) * 2;  		innerRect.Height = innerRect.Width;  		sector.Rect = innerRect;  		sector.StartAngle = sectorStartAngle;  		sector.SweepAngle = sectorSweepAngle;  		startAngle += sweepAngle;  	}  	else {  		sector.StartAngle = double.NaN;  		sector.SweepAngle = double.NaN;  	}  }  
Magic Number,PdfSharp.Charting.Renderers,PieExplodedPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieExplodedPlotAreaRenderer.cs,CalcSectors,The following statement contains a magic number: foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  	if (!double.IsNaN (sector.point.value) && sector.point.value != 0) {  		sweepAngle = 360 / (sumValues / Math.Abs (sector.point.value));  		midAngle = startAngle + sweepAngle / 2;  		sectorStartAngle = Math.Max (0' startAngle + deltaAngle);  		sectorSweepAngle = Math.Max (sweepAngle' sweepAngle - deltaAngle);  		p1.X = origin.X + rInnerCircle * Math.Cos (midAngle / 180 * Math.PI);  		p1.Y = origin.Y + rInnerCircle * Math.Sin (midAngle / 180 * Math.PI);  		innerRect.X = p1.X - rOuterCircle + rInnerCircle;  		innerRect.Y = p1.Y - rOuterCircle + rInnerCircle;  		innerRect.Width = (rOuterCircle - rInnerCircle) * 2;  		innerRect.Height = innerRect.Width;  		sector.Rect = innerRect;  		sector.StartAngle = sectorStartAngle;  		sector.SweepAngle = sectorSweepAngle;  		startAngle += sweepAngle;  	}  	else {  		sector.StartAngle = double.NaN;  		sector.SweepAngle = double.NaN;  	}  }  
Magic Number,PdfSharp.Charting.Renderers,PieExplodedPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieExplodedPlotAreaRenderer.cs,CalcSectors,The following statement contains a magic number: foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  	if (!double.IsNaN (sector.point.value) && sector.point.value != 0) {  		sweepAngle = 360 / (sumValues / Math.Abs (sector.point.value));  		midAngle = startAngle + sweepAngle / 2;  		sectorStartAngle = Math.Max (0' startAngle + deltaAngle);  		sectorSweepAngle = Math.Max (sweepAngle' sweepAngle - deltaAngle);  		p1.X = origin.X + rInnerCircle * Math.Cos (midAngle / 180 * Math.PI);  		p1.Y = origin.Y + rInnerCircle * Math.Sin (midAngle / 180 * Math.PI);  		innerRect.X = p1.X - rOuterCircle + rInnerCircle;  		innerRect.Y = p1.Y - rOuterCircle + rInnerCircle;  		innerRect.Width = (rOuterCircle - rInnerCircle) * 2;  		innerRect.Height = innerRect.Width;  		sector.Rect = innerRect;  		sector.StartAngle = sectorStartAngle;  		sector.SweepAngle = sectorSweepAngle;  		startAngle += sweepAngle;  	}  	else {  		sector.StartAngle = double.NaN;  		sector.SweepAngle = double.NaN;  	}  }  
Magic Number,PdfSharp.Charting.Renderers,PieExplodedPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieExplodedPlotAreaRenderer.cs,CalcSectors,The following statement contains a magic number: foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  	if (!double.IsNaN (sector.point.value) && sector.point.value != 0) {  		sweepAngle = 360 / (sumValues / Math.Abs (sector.point.value));  		midAngle = startAngle + sweepAngle / 2;  		sectorStartAngle = Math.Max (0' startAngle + deltaAngle);  		sectorSweepAngle = Math.Max (sweepAngle' sweepAngle - deltaAngle);  		p1.X = origin.X + rInnerCircle * Math.Cos (midAngle / 180 * Math.PI);  		p1.Y = origin.Y + rInnerCircle * Math.Sin (midAngle / 180 * Math.PI);  		innerRect.X = p1.X - rOuterCircle + rInnerCircle;  		innerRect.Y = p1.Y - rOuterCircle + rInnerCircle;  		innerRect.Width = (rOuterCircle - rInnerCircle) * 2;  		innerRect.Height = innerRect.Width;  		sector.Rect = innerRect;  		sector.StartAngle = sectorStartAngle;  		sector.SweepAngle = sectorSweepAngle;  		startAngle += sweepAngle;  	}  	else {  		sector.StartAngle = double.NaN;  		sector.SweepAngle = double.NaN;  	}  }  
Magic Number,PdfSharp.Charting.Renderers,PieExplodedPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieExplodedPlotAreaRenderer.cs,CalcSectors,The following statement contains a magic number: foreach (SectorRendererInfo sector in sri.pointRendererInfos) {  	if (!double.IsNaN (sector.point.value) && sector.point.value != 0) {  		sweepAngle = 360 / (sumValues / Math.Abs (sector.point.value));  		midAngle = startAngle + sweepAngle / 2;  		sectorStartAngle = Math.Max (0' startAngle + deltaAngle);  		sectorSweepAngle = Math.Max (sweepAngle' sweepAngle - deltaAngle);  		p1.X = origin.X + rInnerCircle * Math.Cos (midAngle / 180 * Math.PI);  		p1.Y = origin.Y + rInnerCircle * Math.Sin (midAngle / 180 * Math.PI);  		innerRect.X = p1.X - rOuterCircle + rInnerCircle;  		innerRect.Y = p1.Y - rOuterCircle + rInnerCircle;  		innerRect.Width = (rOuterCircle - rInnerCircle) * 2;  		innerRect.Height = innerRect.Width;  		sector.Rect = innerRect;  		sector.StartAngle = sectorStartAngle;  		sector.SweepAngle = sectorSweepAngle;  		startAngle += sweepAngle;  	}  	else {  		sector.StartAngle = double.NaN;  		sector.SweepAngle = double.NaN;  	}  }  
Magic Number,PdfSharp.Charting.Renderers,PieExplodedPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieExplodedPlotAreaRenderer.cs,CalcSectors,The following statement contains a magic number: if (!double.IsNaN (sector.point.value) && sector.point.value != 0) {  	sweepAngle = 360 / (sumValues / Math.Abs (sector.point.value));  	midAngle = startAngle + sweepAngle / 2;  	sectorStartAngle = Math.Max (0' startAngle + deltaAngle);  	sectorSweepAngle = Math.Max (sweepAngle' sweepAngle - deltaAngle);  	p1.X = origin.X + rInnerCircle * Math.Cos (midAngle / 180 * Math.PI);  	p1.Y = origin.Y + rInnerCircle * Math.Sin (midAngle / 180 * Math.PI);  	innerRect.X = p1.X - rOuterCircle + rInnerCircle;  	innerRect.Y = p1.Y - rOuterCircle + rInnerCircle;  	innerRect.Width = (rOuterCircle - rInnerCircle) * 2;  	innerRect.Height = innerRect.Width;  	sector.Rect = innerRect;  	sector.StartAngle = sectorStartAngle;  	sector.SweepAngle = sectorSweepAngle;  	startAngle += sweepAngle;  }  else {  	sector.StartAngle = double.NaN;  	sector.SweepAngle = double.NaN;  }  
Magic Number,PdfSharp.Charting.Renderers,PieExplodedPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieExplodedPlotAreaRenderer.cs,CalcSectors,The following statement contains a magic number: if (!double.IsNaN (sector.point.value) && sector.point.value != 0) {  	sweepAngle = 360 / (sumValues / Math.Abs (sector.point.value));  	midAngle = startAngle + sweepAngle / 2;  	sectorStartAngle = Math.Max (0' startAngle + deltaAngle);  	sectorSweepAngle = Math.Max (sweepAngle' sweepAngle - deltaAngle);  	p1.X = origin.X + rInnerCircle * Math.Cos (midAngle / 180 * Math.PI);  	p1.Y = origin.Y + rInnerCircle * Math.Sin (midAngle / 180 * Math.PI);  	innerRect.X = p1.X - rOuterCircle + rInnerCircle;  	innerRect.Y = p1.Y - rOuterCircle + rInnerCircle;  	innerRect.Width = (rOuterCircle - rInnerCircle) * 2;  	innerRect.Height = innerRect.Width;  	sector.Rect = innerRect;  	sector.StartAngle = sectorStartAngle;  	sector.SweepAngle = sectorSweepAngle;  	startAngle += sweepAngle;  }  else {  	sector.StartAngle = double.NaN;  	sector.SweepAngle = double.NaN;  }  
Magic Number,PdfSharp.Charting.Renderers,PieExplodedPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieExplodedPlotAreaRenderer.cs,CalcSectors,The following statement contains a magic number: if (!double.IsNaN (sector.point.value) && sector.point.value != 0) {  	sweepAngle = 360 / (sumValues / Math.Abs (sector.point.value));  	midAngle = startAngle + sweepAngle / 2;  	sectorStartAngle = Math.Max (0' startAngle + deltaAngle);  	sectorSweepAngle = Math.Max (sweepAngle' sweepAngle - deltaAngle);  	p1.X = origin.X + rInnerCircle * Math.Cos (midAngle / 180 * Math.PI);  	p1.Y = origin.Y + rInnerCircle * Math.Sin (midAngle / 180 * Math.PI);  	innerRect.X = p1.X - rOuterCircle + rInnerCircle;  	innerRect.Y = p1.Y - rOuterCircle + rInnerCircle;  	innerRect.Width = (rOuterCircle - rInnerCircle) * 2;  	innerRect.Height = innerRect.Width;  	sector.Rect = innerRect;  	sector.StartAngle = sectorStartAngle;  	sector.SweepAngle = sectorSweepAngle;  	startAngle += sweepAngle;  }  else {  	sector.StartAngle = double.NaN;  	sector.SweepAngle = double.NaN;  }  
Magic Number,PdfSharp.Charting.Renderers,PieExplodedPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieExplodedPlotAreaRenderer.cs,CalcSectors,The following statement contains a magic number: if (!double.IsNaN (sector.point.value) && sector.point.value != 0) {  	sweepAngle = 360 / (sumValues / Math.Abs (sector.point.value));  	midAngle = startAngle + sweepAngle / 2;  	sectorStartAngle = Math.Max (0' startAngle + deltaAngle);  	sectorSweepAngle = Math.Max (sweepAngle' sweepAngle - deltaAngle);  	p1.X = origin.X + rInnerCircle * Math.Cos (midAngle / 180 * Math.PI);  	p1.Y = origin.Y + rInnerCircle * Math.Sin (midAngle / 180 * Math.PI);  	innerRect.X = p1.X - rOuterCircle + rInnerCircle;  	innerRect.Y = p1.Y - rOuterCircle + rInnerCircle;  	innerRect.Width = (rOuterCircle - rInnerCircle) * 2;  	innerRect.Height = innerRect.Width;  	sector.Rect = innerRect;  	sector.StartAngle = sectorStartAngle;  	sector.SweepAngle = sectorSweepAngle;  	startAngle += sweepAngle;  }  else {  	sector.StartAngle = double.NaN;  	sector.SweepAngle = double.NaN;  }  
Magic Number,PdfSharp.Charting.Renderers,PieExplodedPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieExplodedPlotAreaRenderer.cs,CalcSectors,The following statement contains a magic number: if (!double.IsNaN (sector.point.value) && sector.point.value != 0) {  	sweepAngle = 360 / (sumValues / Math.Abs (sector.point.value));  	midAngle = startAngle + sweepAngle / 2;  	sectorStartAngle = Math.Max (0' startAngle + deltaAngle);  	sectorSweepAngle = Math.Max (sweepAngle' sweepAngle - deltaAngle);  	p1.X = origin.X + rInnerCircle * Math.Cos (midAngle / 180 * Math.PI);  	p1.Y = origin.Y + rInnerCircle * Math.Sin (midAngle / 180 * Math.PI);  	innerRect.X = p1.X - rOuterCircle + rInnerCircle;  	innerRect.Y = p1.Y - rOuterCircle + rInnerCircle;  	innerRect.Width = (rOuterCircle - rInnerCircle) * 2;  	innerRect.Height = innerRect.Width;  	sector.Rect = innerRect;  	sector.StartAngle = sectorStartAngle;  	sector.SweepAngle = sectorSweepAngle;  	startAngle += sweepAngle;  }  else {  	sector.StartAngle = double.NaN;  	sector.SweepAngle = double.NaN;  }  
Magic Number,PdfSharp.Charting.Renderers,PieExplodedPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieExplodedPlotAreaRenderer.cs,CalcSectors,The following statement contains a magic number: sweepAngle = 360 / (sumValues / Math.Abs (sector.point.value));  
Magic Number,PdfSharp.Charting.Renderers,PieExplodedPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieExplodedPlotAreaRenderer.cs,CalcSectors,The following statement contains a magic number: midAngle = startAngle + sweepAngle / 2;  
Magic Number,PdfSharp.Charting.Renderers,PieExplodedPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieExplodedPlotAreaRenderer.cs,CalcSectors,The following statement contains a magic number: p1.X = origin.X + rInnerCircle * Math.Cos (midAngle / 180 * Math.PI);  
Magic Number,PdfSharp.Charting.Renderers,PieExplodedPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieExplodedPlotAreaRenderer.cs,CalcSectors,The following statement contains a magic number: p1.Y = origin.Y + rInnerCircle * Math.Sin (midAngle / 180 * Math.PI);  
Magic Number,PdfSharp.Charting.Renderers,PieExplodedPlotAreaRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieExplodedPlotAreaRenderer.cs,CalcSectors,The following statement contains a magic number: innerRect.Width = (rOuterCircle - rInnerCircle) * 2;  
Magic Number,PdfSharp.Charting.Renderers,VerticalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalXAxisRenderer.cs,Draw,The following statement contains a magic number: foreach (XSeries xs in xari.XValues) {  	for (int idx = countTickLabels - 1; idx >= 0; --idx) {  		XValue xv = xs [idx];  		string tickLabel = xv.Value;  		XSize size = gfx.MeasureString (tickLabel' xari.TickLabelsFont);  		gfx.DrawString (tickLabel' xari.TickLabelsFont' xari.TickLabelsBrush' startPos.X - size.Width' startPos.Y + size.Height / 2);  		startPos.Y += tickLabelStep;  	}  }  
Magic Number,PdfSharp.Charting.Renderers,VerticalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalXAxisRenderer.cs,Draw,The following statement contains a magic number: for (int idx = countTickLabels - 1; idx >= 0; --idx) {  	XValue xv = xs [idx];  	string tickLabel = xv.Value;  	XSize size = gfx.MeasureString (tickLabel' xari.TickLabelsFont);  	gfx.DrawString (tickLabel' xari.TickLabelsFont' xari.TickLabelsBrush' startPos.X - size.Width' startPos.Y + size.Height / 2);  	startPos.Y += tickLabelStep;  }  
Magic Number,PdfSharp.Charting.Renderers,VerticalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalXAxisRenderer.cs,Draw,The following statement contains a magic number: gfx.DrawString (tickLabel' xari.TickLabelsFont' xari.TickLabelsBrush' startPos.X - size.Width' startPos.Y + size.Height / 2);  
Magic Number,PdfSharp.Charting.Renderers,VerticalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalXAxisRenderer.cs,Draw,The following statement contains a magic number: if (xari.LineFormat != null) {  	points [0].X = xari.X + xari.Width;  	points [0].Y = xari.Y;  	points [1].X = xari.X + xari.Width;  	points [1].Y = xari.Y + xari.Height;  	if (xari.MajorTickMark != TickMarkType.None) {  		points [0].Y -= xari.LineFormat.Width / 2;  		points [1].Y += xari.LineFormat.Width / 2;  	}  	lineFormatRenderer.DrawLine (points [0]' points [1]);  }  
Magic Number,PdfSharp.Charting.Renderers,VerticalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalXAxisRenderer.cs,Draw,The following statement contains a magic number: if (xari.LineFormat != null) {  	points [0].X = xari.X + xari.Width;  	points [0].Y = xari.Y;  	points [1].X = xari.X + xari.Width;  	points [1].Y = xari.Y + xari.Height;  	if (xari.MajorTickMark != TickMarkType.None) {  		points [0].Y -= xari.LineFormat.Width / 2;  		points [1].Y += xari.LineFormat.Width / 2;  	}  	lineFormatRenderer.DrawLine (points [0]' points [1]);  }  
Magic Number,PdfSharp.Charting.Renderers,VerticalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalXAxisRenderer.cs,Draw,The following statement contains a magic number: if (xari.MajorTickMark != TickMarkType.None) {  	points [0].Y -= xari.LineFormat.Width / 2;  	points [1].Y += xari.LineFormat.Width / 2;  }  
Magic Number,PdfSharp.Charting.Renderers,VerticalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalXAxisRenderer.cs,Draw,The following statement contains a magic number: if (xari.MajorTickMark != TickMarkType.None) {  	points [0].Y -= xari.LineFormat.Width / 2;  	points [1].Y += xari.LineFormat.Width / 2;  }  
Magic Number,PdfSharp.Charting.Renderers,VerticalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalXAxisRenderer.cs,Draw,The following statement contains a magic number: points [0].Y -= xari.LineFormat.Width / 2;  
Magic Number,PdfSharp.Charting.Renderers,VerticalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalXAxisRenderer.cs,Draw,The following statement contains a magic number: points [1].Y += xari.LineFormat.Width / 2;  
Magic Number,PdfSharp.Charting.Renderers,VerticalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalXAxisRenderer.cs,Draw,The following statement contains a magic number: if (atri != null && atri.AxisTitleText != null && atri.AxisTitleText.Length > 0) {  	XRect rect = new XRect (xari.X' xari.Y + xari.Height / 2' atri.AxisTitleSize.Width' 0);  	gfx.DrawString (atri.AxisTitleText' atri.AxisTitleFont' atri.AxisTitleBrush' rect);  }  
Magic Number,PdfSharp.Charting.Renderers,VerticalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalXAxisRenderer.cs,CalculateXAxisValues,The following statement contains a magic number: rendererInfo.MinorTick = 0.5;  
Magic Number,PdfSharp.Charting.Renderers,VerticalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalYAxisRenderer.cs,Format,The following statement contains a magic number: if (yari.axis != null) {  	XGraphics gfx = this.rendererParms.Graphics;  	XSize size = new XSize (0' 0);  	// height of all ticklabels  	double yMin = yari.MinimumScale;  	double yMax = yari.MaximumScale;  	double yMajorTick = yari.MajorTick;  	double lineHeight = Double.MinValue;  	XSize labelSize = new XSize (0' 0);  	for (double y = yMin; y <= yMax; y += yMajorTick) {  		string str = y.ToString (yari.TickLabelsFormat);  		labelSize = gfx.MeasureString (str' yari.TickLabelsFont);  		size.Height += labelSize.Height;  		size.Width = Math.Max (size.Width' labelSize.Width);  		lineHeight = Math.Max (lineHeight' labelSize.Height);  	}  	// add space for tickmarks  	size.Width += yari.MajorTickMarkWidth * 1.5;  	// Measure axis title  	XSize titleSize = new XSize (0' 0);  	if (yari.axisTitleRendererInfo != null) {  		RendererParameters parms = new RendererParameters ();  		parms.Graphics = gfx;  		parms.RendererInfo = yari;  		AxisTitleRenderer atr = new AxisTitleRenderer (parms);  		atr.Format ();  		titleSize.Height = yari.axisTitleRendererInfo.Height;  		titleSize.Width = yari.axisTitleRendererInfo.Width;  	}  	yari.Height = Math.Max (size.Height' titleSize.Height);  	yari.Width = size.Width + titleSize.Width;  	yari.InnerRect = yari.Rect;  	yari.InnerRect.Y += yari.TickLabelsFont.Height / 2;  	yari.LabelSize = labelSize;  }  
Magic Number,PdfSharp.Charting.Renderers,VerticalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalYAxisRenderer.cs,Format,The following statement contains a magic number: if (yari.axis != null) {  	XGraphics gfx = this.rendererParms.Graphics;  	XSize size = new XSize (0' 0);  	// height of all ticklabels  	double yMin = yari.MinimumScale;  	double yMax = yari.MaximumScale;  	double yMajorTick = yari.MajorTick;  	double lineHeight = Double.MinValue;  	XSize labelSize = new XSize (0' 0);  	for (double y = yMin; y <= yMax; y += yMajorTick) {  		string str = y.ToString (yari.TickLabelsFormat);  		labelSize = gfx.MeasureString (str' yari.TickLabelsFont);  		size.Height += labelSize.Height;  		size.Width = Math.Max (size.Width' labelSize.Width);  		lineHeight = Math.Max (lineHeight' labelSize.Height);  	}  	// add space for tickmarks  	size.Width += yari.MajorTickMarkWidth * 1.5;  	// Measure axis title  	XSize titleSize = new XSize (0' 0);  	if (yari.axisTitleRendererInfo != null) {  		RendererParameters parms = new RendererParameters ();  		parms.Graphics = gfx;  		parms.RendererInfo = yari;  		AxisTitleRenderer atr = new AxisTitleRenderer (parms);  		atr.Format ();  		titleSize.Height = yari.axisTitleRendererInfo.Height;  		titleSize.Width = yari.axisTitleRendererInfo.Width;  	}  	yari.Height = Math.Max (size.Height' titleSize.Height);  	yari.Width = size.Width + titleSize.Width;  	yari.InnerRect = yari.Rect;  	yari.InnerRect.Y += yari.TickLabelsFont.Height / 2;  	yari.LabelSize = labelSize;  }  
Magic Number,PdfSharp.Charting.Renderers,VerticalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalYAxisRenderer.cs,Format,The following statement contains a magic number: size.Width += yari.MajorTickMarkWidth * 1.5;  
Magic Number,PdfSharp.Charting.Renderers,VerticalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalYAxisRenderer.cs,Format,The following statement contains a magic number: yari.InnerRect.Y += yari.TickLabelsFont.Height / 2;  
Magic Number,PdfSharp.Charting.Renderers,VerticalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalYAxisRenderer.cs,Draw,The following statement contains a magic number: for (int i = 0; i < countTickLabels; ++i) {  	double y = yMin + yMajorTick * i;  	string str = y.ToString (yari.TickLabelsFormat);  	labelSize.Width = gfx.MeasureString (str' yari.TickLabelsFont).Width;  	// Draw major tick marks.  	if (yari.MajorTickMark != TickMarkType.None) {  		labelSize.Width += yari.MajorTickMarkWidth * 1.5;  		points [0].X = majorTickMarkStart;  		points [0].Y = y;  		points [1].X = majorTickMarkEnd;  		points [1].Y = y;  		matrix.TransformPoints (points);  		majorTickMarkLineFormat.DrawLine (points [0]' points [1]);  	}  	else  		labelSize.Width += SpaceBetweenLabelAndTickmark;  	// Draw label text.  	XPoint[] layoutText = new XPoint[1];  	layoutText [0].X = yari.InnerRect.X + yari.InnerRect.Width - labelSize.Width;  	layoutText [0].Y = y;  	matrix.TransformPoints (layoutText);  	layoutText [0].Y += labelSize.Height / 2;  	// Center text vertically.  	gfx.DrawString (str' yari.TickLabelsFont' yari.TickLabelsBrush' layoutText [0]);  }  
Magic Number,PdfSharp.Charting.Renderers,VerticalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalYAxisRenderer.cs,Draw,The following statement contains a magic number: for (int i = 0; i < countTickLabels; ++i) {  	double y = yMin + yMajorTick * i;  	string str = y.ToString (yari.TickLabelsFormat);  	labelSize.Width = gfx.MeasureString (str' yari.TickLabelsFont).Width;  	// Draw major tick marks.  	if (yari.MajorTickMark != TickMarkType.None) {  		labelSize.Width += yari.MajorTickMarkWidth * 1.5;  		points [0].X = majorTickMarkStart;  		points [0].Y = y;  		points [1].X = majorTickMarkEnd;  		points [1].Y = y;  		matrix.TransformPoints (points);  		majorTickMarkLineFormat.DrawLine (points [0]' points [1]);  	}  	else  		labelSize.Width += SpaceBetweenLabelAndTickmark;  	// Draw label text.  	XPoint[] layoutText = new XPoint[1];  	layoutText [0].X = yari.InnerRect.X + yari.InnerRect.Width - labelSize.Width;  	layoutText [0].Y = y;  	matrix.TransformPoints (layoutText);  	layoutText [0].Y += labelSize.Height / 2;  	// Center text vertically.  	gfx.DrawString (str' yari.TickLabelsFont' yari.TickLabelsBrush' layoutText [0]);  }  
Magic Number,PdfSharp.Charting.Renderers,VerticalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalYAxisRenderer.cs,Draw,The following statement contains a magic number: if (yari.MajorTickMark != TickMarkType.None) {  	labelSize.Width += yari.MajorTickMarkWidth * 1.5;  	points [0].X = majorTickMarkStart;  	points [0].Y = y;  	points [1].X = majorTickMarkEnd;  	points [1].Y = y;  	matrix.TransformPoints (points);  	majorTickMarkLineFormat.DrawLine (points [0]' points [1]);  }  else  	labelSize.Width += SpaceBetweenLabelAndTickmark;  
Magic Number,PdfSharp.Charting.Renderers,VerticalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalYAxisRenderer.cs,Draw,The following statement contains a magic number: labelSize.Width += yari.MajorTickMarkWidth * 1.5;  
Magic Number,PdfSharp.Charting.Renderers,VerticalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalYAxisRenderer.cs,Draw,The following statement contains a magic number: layoutText [0].Y += labelSize.Height / 2;  
Magic Number,PdfSharp.Charting.Renderers,VerticalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalYAxisRenderer.cs,Draw,The following statement contains a magic number: if (yari.LineFormat != null && yari.LineFormat.Width > 0) {  	points [0].X = yari.InnerRect.X + yari.InnerRect.Width;  	points [0].Y = yMin;  	points [1].X = yari.InnerRect.X + yari.InnerRect.Width;  	points [1].Y = yMax;  	matrix.TransformPoints (points);  	if (yari.MajorTickMark != TickMarkType.None) {  		// yMax is at the upper side of the axis  		points [1].Y -= yari.LineFormat.Width / 2;  		points [0].Y += yari.LineFormat.Width / 2;  	}  	lineFormatRenderer.DrawLine (points [0]' points [1]);  }  
Magic Number,PdfSharp.Charting.Renderers,VerticalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalYAxisRenderer.cs,Draw,The following statement contains a magic number: if (yari.LineFormat != null && yari.LineFormat.Width > 0) {  	points [0].X = yari.InnerRect.X + yari.InnerRect.Width;  	points [0].Y = yMin;  	points [1].X = yari.InnerRect.X + yari.InnerRect.Width;  	points [1].Y = yMax;  	matrix.TransformPoints (points);  	if (yari.MajorTickMark != TickMarkType.None) {  		// yMax is at the upper side of the axis  		points [1].Y -= yari.LineFormat.Width / 2;  		points [0].Y += yari.LineFormat.Width / 2;  	}  	lineFormatRenderer.DrawLine (points [0]' points [1]);  }  
Magic Number,PdfSharp.Charting.Renderers,VerticalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalYAxisRenderer.cs,Draw,The following statement contains a magic number: if (yari.MajorTickMark != TickMarkType.None) {  	// yMax is at the upper side of the axis  	points [1].Y -= yari.LineFormat.Width / 2;  	points [0].Y += yari.LineFormat.Width / 2;  }  
Magic Number,PdfSharp.Charting.Renderers,VerticalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalYAxisRenderer.cs,Draw,The following statement contains a magic number: if (yari.MajorTickMark != TickMarkType.None) {  	// yMax is at the upper side of the axis  	points [1].Y -= yari.LineFormat.Width / 2;  	points [0].Y += yari.LineFormat.Width / 2;  }  
Magic Number,PdfSharp.Charting.Renderers,VerticalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalYAxisRenderer.cs,Draw,The following statement contains a magic number: points [1].Y -= yari.LineFormat.Width / 2;  
Magic Number,PdfSharp.Charting.Renderers,VerticalYAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalYAxisRenderer.cs,Draw,The following statement contains a magic number: points [0].Y += yari.LineFormat.Width / 2;  
Magic Number,PdfSharp.Charting.Renderers,YAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\YAxisRenderer.cs,FineTuneYAxis,The following statement contains a magic number: if (yMin != 0) {  	if (yMin < 0 && yMax < 0) {  		if (yMin / yMax >= 1.2)  			yMax = 0;  	}  	else if (yMax / yMin >= 1.2)  		yMin = 0;  }  
Magic Number,PdfSharp.Charting.Renderers,YAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\YAxisRenderer.cs,FineTuneYAxis,The following statement contains a magic number: if (yMin != 0) {  	if (yMin < 0 && yMax < 0) {  		if (yMin / yMax >= 1.2)  			yMax = 0;  	}  	else if (yMax / yMin >= 1.2)  		yMin = 0;  }  
Magic Number,PdfSharp.Charting.Renderers,YAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\YAxisRenderer.cs,FineTuneYAxis,The following statement contains a magic number: if (yMin < 0 && yMax < 0) {  	if (yMin / yMax >= 1.2)  		yMax = 0;  }  else if (yMax / yMin >= 1.2)  	yMin = 0;  
Magic Number,PdfSharp.Charting.Renderers,YAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\YAxisRenderer.cs,FineTuneYAxis,The following statement contains a magic number: if (yMin < 0 && yMax < 0) {  	if (yMin / yMax >= 1.2)  		yMax = 0;  }  else if (yMax / yMin >= 1.2)  	yMin = 0;  
Magic Number,PdfSharp.Charting.Renderers,YAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\YAxisRenderer.cs,FineTuneYAxis,The following statement contains a magic number: if (yMin / yMax >= 1.2)  	yMax = 0;  
Magic Number,PdfSharp.Charting.Renderers,YAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\YAxisRenderer.cs,FineTuneYAxis,The following statement contains a magic number: if (yMax / yMin >= 1.2)  	yMin = 0;  
Magic Number,PdfSharp.Charting.Renderers,YAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\YAxisRenderer.cs,FineTuneYAxis,The following statement contains a magic number: if (normed < 2)  	normedStepWidth = 0.2f;  else if (normed < 5)  	normedStepWidth = 0.5f;  
Magic Number,PdfSharp.Charting.Renderers,YAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\YAxisRenderer.cs,FineTuneYAxis,The following statement contains a magic number: if (normed < 2)  	normedStepWidth = 0.2f;  else if (normed < 5)  	normedStepWidth = 0.5f;  
Magic Number,PdfSharp.Charting.Renderers,YAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\YAxisRenderer.cs,FineTuneYAxis,The following statement contains a magic number: if (normed < 5)  	normedStepWidth = 0.5f;  
Magic Number,PdfSharp.Charting.Renderers,YAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\YAxisRenderer.cs,FineTuneYAxis,The following statement contains a magic number: if (yari.axis == null || double.IsNaN (yari.axis.minorTick))  	yari.MinorTick = yari.MajorTick / 5;  else  	yari.MinorTick = yari.axis.minorTick;  
Magic Number,PdfSharp.Charting.Renderers,YAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\YAxisRenderer.cs,FineTuneYAxis,The following statement contains a magic number: yari.MinorTick = yari.MajorTick / 5;  
Magic Number,PdfSharp.Charting,ChartFrame,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting\ChartFrame.cs,Draw,The following statement contains a magic number: gfx.DrawRoundedRectangle (XBrushes.Gainsboro' this.location.X + dx' this.location.Y + dy' this.size.Width' this.size.Height' 20' 20);  
Magic Number,PdfSharp.Charting,ChartFrame,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting\ChartFrame.cs,Draw,The following statement contains a magic number: gfx.DrawRoundedRectangle (XBrushes.Gainsboro' this.location.X + dx' this.location.Y + dy' this.size.Width' this.size.Height' 20' 20);  
Magic Number,PdfSharp.Charting,ChartFrame,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting\ChartFrame.cs,Draw,The following statement contains a magic number: gfx.DrawRoundedRectangle (penBorder' brush' this.location.X' this.location.Y' this.size.Width' this.size.Height' 15' 15);  
Magic Number,PdfSharp.Charting,ChartFrame,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting\ChartFrame.cs,Draw,The following statement contains a magic number: gfx.DrawRoundedRectangle (penBorder' brush' this.location.X' this.location.Y' this.size.Width' this.size.Height' 15' 15);  
Missing Default,PdfSharp.Charting.Renderers,BarChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\BarChartRenderer.cs,GetPlotAreaRenderer,The following switch statement is missing a default case: switch (chart.type) {  case ChartType.Bar2D:  	return new BarClusteredPlotAreaRenderer (this.rendererParms);  case ChartType.BarStacked2D:  	return new BarStackedPlotAreaRenderer (this.rendererParms);  }  
Missing Default,PdfSharp.Charting.Renderers,BarChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\BarChartRenderer.cs,GetLegendRenderer,The following switch statement is missing a default case: switch (chart.type) {  case ChartType.Bar2D:  	return new BarClusteredLegendRenderer (this.rendererParms);  case ChartType.BarStacked2D:  	return new ColumnLikeLegendRenderer (this.rendererParms);  }  
Missing Default,PdfSharp.Charting.Renderers,BarChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\BarChartRenderer.cs,GetYAxisRenderer,The following switch statement is missing a default case: switch (chart.type) {  case ChartType.Bar2D:  	return new HorizontalYAxisRenderer (this.rendererParms);  case ChartType.BarStacked2D:  	return new HorizontalStackedYAxisRenderer (this.rendererParms);  }  
Missing Default,PdfSharp.Charting.Renderers,BarDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\BarDataLabelRenderer.cs,CalcPositions,The following switch statement is missing a default case: switch (sri.dataLabelRendererInfo.Position) {  case DataLabelPosition.InsideEnd:  	// Inner border of the column.  	dleri.X = bar.Rect.X;  	if (bar.point.value > 0)  		dleri.X += bar.Rect.Width - dleri.Width;  	break;  case DataLabelPosition.Center:  	// Centered inside the column.  	dleri.X = bar.Rect.X + (bar.Rect.Width - dleri.Width) / 2;  	break;  case DataLabelPosition.InsideBase:  	// Aligned at the base of the column.  	dleri.X = bar.Rect.X;  	if (bar.point.value < 0)  		dleri.X += bar.Rect.Width - dleri.Width;  	break;  case DataLabelPosition.OutsideEnd:  	// Outer border of the column.  	dleri.X = bar.Rect.X;  	if (bar.point.value > 0)  		dleri.X += bar.Rect.Width;  	else  		dleri.X -= dleri.Width;  	break;  }  
Missing Default,PdfSharp.Charting.Renderers,ChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ChartRenderer.cs,LayoutLegend,The following switch statement is missing a default case: switch (cri.legendRendererInfo.legend.Docking) {  case DockingType.Left:  	cri.legendRendererInfo.X = remainingRect.Left;  	cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  	double width = cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  	remainingRect.X += width;  	remainingRect.Width -= width;  	break;  case DockingType.Right:  	cri.legendRendererInfo.X = remainingRect.Right - cri.legendRendererInfo.Width;  	cri.legendRendererInfo.Y = remainingRect.Height / 2 - cri.legendRendererInfo.Height / 2;  	remainingRect.Width -= cri.legendRendererInfo.Width + ChartRenderer.LegendSpacing;  	break;  case DockingType.Top:  	cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  	cri.legendRendererInfo.Y = remainingRect.Top;  	double height = cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  	remainingRect.Y += height;  	remainingRect.Height -= height;  	break;  case DockingType.Bottom:  	cri.legendRendererInfo.X = remainingRect.Width / 2 - cri.legendRendererInfo.Width / 2;  	cri.legendRendererInfo.Y = remainingRect.Bottom - cri.legendRendererInfo.Height;  	remainingRect.Height -= cri.legendRendererInfo.Height + ChartRenderer.LegendSpacing;  	break;  }  
Missing Default,PdfSharp.Charting.Renderers,ColumnChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ColumnChartRenderer.cs,GetPlotAreaRenderer,The following switch statement is missing a default case: switch (chart.type) {  case ChartType.Column2D:  	return new ColumnClusteredPlotAreaRenderer (this.rendererParms);  case ChartType.ColumnStacked2D:  	return new ColumnStackedPlotAreaRenderer (this.rendererParms);  }  
Missing Default,PdfSharp.Charting.Renderers,ColumnChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ColumnChartRenderer.cs,GetYAxisRenderer,The following switch statement is missing a default case: switch (chart.type) {  case ChartType.Column2D:  	return new VerticalYAxisRenderer (this.rendererParms);  case ChartType.ColumnStacked2D:  	return new VerticalStackedYAxisRenderer (this.rendererParms);  }  
Missing Default,PdfSharp.Charting.Renderers,ColumnDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\ColumnDataLabelRenderer.cs,CalcPositions,The following switch statement is missing a default case: switch (sri.dataLabelRendererInfo.Position) {  case DataLabelPosition.InsideEnd:  	// Inner border of the column.  	dleri.Y = column.Rect.Y;  	if (column.point.value < 0)  		dleri.Y = column.Rect.Y + column.Rect.Height - dleri.Height;  	break;  case DataLabelPosition.Center:  	// Centered inside the column.  	dleri.Y = column.Rect.Y + column.Rect.Height / 2 - dleri.Height / 2;  	break;  case DataLabelPosition.InsideBase:  	// Aligned at the base of the column.  	dleri.Y = column.Rect.Y + column.Rect.Height - dleri.Height;  	if (column.point.value < 0)  		dleri.Y = column.Rect.Y;  	break;  case DataLabelPosition.OutsideEnd:  	// Outer border of the column.  	dleri.Y = column.Rect.Y - dleri.Height;  	if (column.point.value < 0)  		dleri.Y = column.Rect.Y + column.Rect.Height;  	break;  }  
Missing Default,PdfSharp.Charting.Renderers,HorizontalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalXAxisRenderer.cs,GetTickMarkPos,The following switch statement is missing a default case: switch (rendererInfo.MajorTickMark) {  case TickMarkType.Inside:  	majorTickMarkStart = rect.Y;  	majorTickMarkEnd = rect.Y - majorTickMarkWidth;  	break;  case TickMarkType.Outside:  	majorTickMarkStart = rect.Y;  	majorTickMarkEnd = rect.Y + majorTickMarkWidth;  	break;  case TickMarkType.Cross:  	majorTickMarkStart = rect.Y + majorTickMarkWidth;  	majorTickMarkEnd = rect.Y - majorTickMarkWidth;  	break;  case TickMarkType.None:  	majorTickMarkStart = 0;  	majorTickMarkEnd = 0;  	break;  }  
Missing Default,PdfSharp.Charting.Renderers,HorizontalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\HorizontalXAxisRenderer.cs,GetTickMarkPos,The following switch statement is missing a default case: switch (rendererInfo.MinorTickMark) {  case TickMarkType.Inside:  	minorTickMarkStart = rect.Y;  	minorTickMarkEnd = rect.Y - minorTickMarkWidth;  	break;  case TickMarkType.Outside:  	minorTickMarkStart = rect.Y;  	minorTickMarkEnd = rect.Y + minorTickMarkWidth;  	break;  case TickMarkType.Cross:  	minorTickMarkStart = rect.Y + minorTickMarkWidth;  	minorTickMarkEnd = rect.Y - minorTickMarkWidth;  	break;  case TickMarkType.None:  	minorTickMarkStart = 0;  	minorTickMarkEnd = 0;  	break;  }  
Missing Default,PdfSharp.Charting.Renderers,MarkerRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\MarkerRenderer.cs,Draw,The following switch statement is missing a default case: switch (rendererInfo.MarkerStyle) {  case MarkerStyle.Square:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	x1 = pos.X + size2;  	y1 = pos.Y + size2;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.Diamond:  	gp.AddLine (x1 = pos.X + size2' pos.Y' pos.X' y0 = pos.Y - size2);  	gp.AddLine (pos.X' y0' x0 = pos.X - size2' pos.Y);  	gp.AddLine (x0' pos.Y' pos.X' y1 = pos.Y + size2);  	gp.AddLine (pos.X' y1' x1' pos.Y);  	break;  case MarkerStyle.Triangle:  	y0 = pos.Y + size / 2;  	y1 = pos.Y - size / 2;  	g = Math.Sqrt (size * size * 4 / 3) / 2;  	gp.AddLine (pos.X' y1' pos.X + g' y0);  	gp.AddLine (pos.X + g' y0' pos.X - g' y0);  	gp.AddLine (pos.X - g' y0' pos.X' y1);  	break;  case MarkerStyle.Plus:  	g = size2 / 4;  	gp.AddLine (pos.X - size2' pos.Y + g' pos.X - g' pos.Y + g);  	gp.AddLine (pos.X - g' pos.Y + g' pos.X - g' pos.Y + size2);  	gp.AddLine (pos.X - g' pos.Y + size2' pos.X + g' pos.Y + size2);  	gp.AddLine (pos.X + g' pos.Y + size2' pos.X + g' pos.Y + g);  	gp.AddLine (pos.X + g' pos.Y + g' pos.X + size2' pos.Y + g);  	gp.AddLine (pos.X + size2' pos.Y + g' pos.X + size2' pos.Y - g);  	gp.AddLine (pos.X + size2' pos.Y - g' pos.X + g' pos.Y - g);  	gp.AddLine (pos.X + g' pos.Y - g' pos.X + g' pos.Y - size2);  	gp.AddLine (pos.X + g' pos.Y - size2' pos.X - g' pos.Y - size2);  	gp.AddLine (pos.X - g' pos.Y - size2' pos.X - g' pos.Y - g);  	gp.AddLine (pos.X - g' pos.Y - g' pos.X - size2' pos.Y - g);  	gp.AddLine (pos.X - size2' pos.Y - g' pos.X - size2' pos.Y + g);  	break;  case MarkerStyle.Circle:  case MarkerStyle.Dot:  	x0 = pos.X - size2;  	y0 = pos.Y - size2;  	gp.AddEllipse (x0' y0' size' size);  	break;  case MarkerStyle.Dash:  	x0 = pos.X - size2;  	y0 = pos.Y - size2 / 3;  	x1 = pos.X + size2;  	y1 = pos.Y + size2 / 3;  	gp.AddLine (x0' y0' x1' y0);  	gp.AddLine (x1' y0' x1' y1);  	gp.AddLine (x1' y1' x0' y1);  	gp.AddLine (x0' y1' x0' y0);  	break;  case MarkerStyle.X:  	g = size / 4;  	gp.AddLine (pos.X - size2 + g' pos.Y - size2' pos.X' pos.Y - g);  	gp.AddLine (pos.X' pos.Y - g' pos.X + size2 - g' pos.Y - size2);  	gp.AddLine (pos.X + size2 - g' pos.Y - size2' pos.X + size2' pos.Y - size2 + g);  	gp.AddLine (pos.X + size2' pos.Y - size2 + g' pos.X + g' pos.Y);  	gp.AddLine (pos.X + g' pos.Y' pos.X + size2' pos.Y + size2 - g);  	gp.AddLine (pos.X + size2' pos.Y + size2 - g' pos.X + size2 - g' pos.Y + size2);  	gp.AddLine (pos.X + size2 - g' pos.Y + size2' pos.X' pos.Y + g);  	gp.AddLine (pos.X' pos.Y + g' pos.X - size2 + g' pos.Y + size2);  	gp.AddLine (pos.X - size2 + g' pos.Y + size2' pos.X - size2' pos.Y + size2 - g);  	gp.AddLine (pos.X - size2' pos.Y + size2 - g' pos.X - g' pos.Y);  	gp.AddLine (pos.X - g' pos.Y' pos.X - size2' pos.Y - size2 + g);  	break;  case MarkerStyle.Star:  	{  		XPoint[] points = new XPoint[10];  		double radStep = 2 * Math.PI / 5;  		double outerCircle = size / 2;  		double innerCircle = size / 5;  		// outer circle  		double rad = -(Math.PI / 2);  		// 90�  		for (int idx = 0; idx < 10; idx += 2) {  			points [idx].X = pos.X + outerCircle * Math.Cos (rad);  			points [idx].Y = pos.Y + outerCircle * Math.Sin (rad);  			rad += radStep;  		}  		// inner circle  		rad = -(Math.PI / 4);  		// 45�  		double x = innerCircle * Math.Cos (rad);  		double y = innerCircle * Math.Sin (rad);  		points [1].X = pos.X + x;  		points [1].Y = pos.Y + y;  		points [9].X = pos.X - x;  		points [9].Y = pos.Y + y;  		rad += radStep;  		x = innerCircle * Math.Cos (rad);  		y = innerCircle * Math.Sin (rad);  		points [3].X = pos.X + x;  		points [3].Y = pos.Y + y;  		points [7].X = pos.X - x;  		points [7].Y = pos.Y + y;  		rad += radStep;  		y = innerCircle * Math.Sin (rad);  		points [5].X = pos.X;  		points [5].Y = pos.Y + y;  		gp.AddLines (points);  	}  	break;  }  
Missing Default,PdfSharp.Charting.Renderers,PieChartRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieChartRenderer.cs,GetPlotAreaRenderer,The following switch statement is missing a default case: switch (chart.type) {  case ChartType.Pie2D:  	return new PieClosedPlotAreaRenderer (this.rendererParms);  case ChartType.PieExploded2D:  	return new PieExplodedPlotAreaRenderer (this.rendererParms);  }  
Missing Default,PdfSharp.Charting.Renderers,PieDataLabelRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\PieDataLabelRenderer.cs,CalcPositions,The following switch statement is missing a default case: switch (sri.dataLabelRendererInfo.Position) {  case DataLabelPosition.OutsideEnd:  	// Outer border of the circle.  	dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  	dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  	if (dleri.X < origin.X)  		dleri.X -= dleri.Width;  	if (dleri.Y < origin.Y)  		dleri.Y -= dleri.Height;  	break;  case DataLabelPosition.InsideEnd:  	// Inner border of the circle.  	dleri.X = origin.X + (radius * Math.Cos (radMidAngle));  	dleri.Y = origin.Y + (radius * Math.Sin (radMidAngle));  	if (dleri.X > origin.X)  		dleri.X -= dleri.Width;  	if (dleri.Y > origin.Y)  		dleri.Y -= dleri.Height;  	break;  case DataLabelPosition.Center:  	// Centered  	dleri.X = origin.X + (halfradius * Math.Cos (radMidAngle));  	dleri.Y = origin.Y + (halfradius * Math.Sin (radMidAngle));  	dleri.X -= dleri.Width / 2;  	dleri.Y -= dleri.Height / 2;  	break;  case DataLabelPosition.InsideBase:  	// Aligned at the base/center of the circle  	dleri.X = origin.X;  	dleri.Y = origin.Y;  	if (dleri.X < origin.X)  		dleri.X -= dleri.Width;  	if (dleri.Y < origin.Y)  		dleri.Y -= dleri.Height;  	break;  }  
Missing Default,PdfSharp.Charting.Renderers,VerticalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalXAxisRenderer.cs,GetTickMarkPos,The following switch statement is missing a default case: switch (rendererInfo.MajorTickMark) {  case TickMarkType.Inside:  	majorTickMarkStart = x;  	majorTickMarkEnd = x + majorTickMarkWidth;  	break;  case TickMarkType.Outside:  	majorTickMarkStart = x - majorTickMarkWidth;  	majorTickMarkEnd = x;  	break;  case TickMarkType.Cross:  	majorTickMarkStart = x - majorTickMarkWidth;  	majorTickMarkEnd = x + majorTickMarkWidth;  	break;  case TickMarkType.None:  	majorTickMarkStart = 0;  	majorTickMarkEnd = 0;  	break;  }  
Missing Default,PdfSharp.Charting.Renderers,VerticalXAxisRenderer,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting.Renderers\VerticalXAxisRenderer.cs,GetTickMarkPos,The following switch statement is missing a default case: switch (rendererInfo.MinorTickMark) {  case TickMarkType.Inside:  	minorTickMarkStart = x;  	minorTickMarkEnd = x + minorTickMarkWidth;  	break;  case TickMarkType.Outside:  	minorTickMarkStart = x - minorTickMarkWidth;  	minorTickMarkEnd = x;  	break;  case TickMarkType.Cross:  	minorTickMarkStart = x - minorTickMarkWidth;  	minorTickMarkEnd = x + minorTickMarkWidth;  	break;  case TickMarkType.None:  	minorTickMarkStart = 0;  	minorTickMarkEnd = 0;  	break;  }  
Missing Default,PdfSharp.Charting,ChartFrame,C:\repos\Lakerfield_PdfSharp\PDFsharp\code\PdfSharp.Charting\PdfSharp.Charting\ChartFrame.cs,GetChartRenderer,The following switch statement is missing a default case: switch (chartType) {  case ChartType.Line:  	return new LineChartRenderer (parms);  case ChartType.Column2D:  case ChartType.ColumnStacked2D:  	return new ColumnChartRenderer (parms);  case ChartType.Bar2D:  case ChartType.BarStacked2D:  	return new BarChartRenderer (parms);  case ChartType.Area2D:  	return new AreaChartRenderer (parms);  case ChartType.Pie2D:  case ChartType.PieExploded2D:  	return new PieChartRenderer (parms);  }  
