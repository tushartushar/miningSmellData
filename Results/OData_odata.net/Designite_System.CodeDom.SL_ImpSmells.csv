Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.CodeDom,CodeTypeReference,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\CodeDom\CodeTypeReference.cs,Initialize,The method has 119 lines of code.
Long Method,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,GetBaseTypeOutput,The method has 108 lines of code.
Complex Method,System.CodeDom,CodeTypeReference,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\CodeDom\CodeTypeReference.cs,Initialize,Cyclomatic complexity of the method is 18
Complex Method,System.CodeDom,CodeTypeReference,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\CodeDom\CodeTypeReference.cs,RipOffAssemblyInformationFromTypeName,Cyclomatic complexity of the method is 9
Complex Method,System.CodeDom.Compiler,CodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\CodeDom\Compiler\CodeGenerator.cs,GenerateTypeMember,Cyclomatic complexity of the method is 8
Complex Method,System.CodeDom.Compiler,CodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\CodeDom\Compiler\CodeGenerator.cs,GenerateTypeConstructors,Cyclomatic complexity of the method is 8
Complex Method,System.CodeDom.Compiler,CodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\CodeDom\Compiler\CodeGenerator.cs,GenerateConstructors,Cyclomatic complexity of the method is 8
Complex Method,System.CodeDom.Compiler,CodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\CodeDom\Compiler\CodeGenerator.cs,GenerateEvents,Cyclomatic complexity of the method is 8
Complex Method,System.CodeDom.Compiler,CodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\CodeDom\Compiler\CodeGenerator.cs,GenerateFields,Cyclomatic complexity of the method is 8
Complex Method,System.CodeDom.Compiler,CodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\CodeDom\Compiler\CodeGenerator.cs,GenerateSnippetMembers,Cyclomatic complexity of the method is 9
Complex Method,System.CodeDom.Compiler,CodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\CodeDom\Compiler\CodeGenerator.cs,GenerateMethods,Cyclomatic complexity of the method is 9
Complex Method,System.CodeDom.Compiler,CodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\CodeDom\Compiler\CodeGenerator.cs,GenerateProperties,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,GenerateEvents,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,GenerateFields,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,GenerateMethods,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,GenerateMethod,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,GenerateProperties,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,GenerateProperty,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,GenerateConstructors,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,GenerateTypeMember,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,GenerateTypeConstructors,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,GenerateSnippetMembers,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,OutputTypeParameterConstraints,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,GenerateCompileUnitStart,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,GenerateAttributes,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.VisualBasic,VBCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\VisualBasic\VBCodeGenerator.cs,OutputAttributes,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.VisualBasic,VBCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\VisualBasic\VBCodeGenerator.cs,GenerateMethod,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.VisualBasic,VBCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\VisualBasic\VBCodeGenerator.cs,GenerateProperty,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.VisualBasic,VBCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\VisualBasic\VBCodeGenerator.cs,OutputTypeParameterConstraints,Cyclomatic complexity of the method is 9
Long Parameter List,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetMethod,The method has 5 parameters. Parameters: type' name' types' isPublic' isStatic
Long Parameter List,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetProperty,The method has 6 parameters. Parameters: type' name' isPublic' isStatic' returnType' parameterTypes
Long Parameter List,System.Collections.Specialized,FixedStringLookup,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\FixedStringLookup.cs,FindCharacter,The method has 5 parameters. Parameters: array' value' pos' min' max
Long Statement,System.CodeDom,CodeTypeReference,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\CodeDom\CodeTypeReference.cs,Initialize,The length of the statement  "                        // System.Collections.Generic.Dictionary`2[[System.String' mscorlib' Version=2.0.0.0' Culture=neutral' PublicKeyToken=b77a5c561934e089]'  " is 136.
Long Statement,System.CodeDom,CodeTypeReference,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\CodeDom\CodeTypeReference.cs,Initialize,The length of the statement  "                        //          [System.Collections.Generic.List`1[[System.Int32' mscorlib' Version=2.0.0.0' Culture=neutral' PublicKeyToken=b77a5c561934e089]]'  " is 140.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetTypeOrThrow,The length of the statement  "                // devnote (sparra): Not throwing a custom error message here because this method is expected to be removed. See comments above. " is 128.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetAllInstanceProperties,The length of the statement  "            // WIN8: The BindingFlags enum and all related reflection method overloads have been removed from Win8. Instead of trying to provide " is 132.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetAllInstanceProperties,The length of the statement  "            // a general purpose flags enum and methods that can take any combination of the flags' we provide more restrictive methods that " is 128.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetPublicProperties,The length of the statement  "            // WIN8: The BindingFlags enum and all related reflection method overloads have been removed from Win8. Instead of trying to provide " is 132.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetPublicProperties,The length of the statement  "            // a general purpose flags enum and methods that can take any combination of the flags' we provide more restrictive methods that " is 128.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetPublicProperties,The length of the statement  "            // WIN8: The BindingFlags enum and all related reflection method overloads have been removed from Win8. Instead of trying to provide " is 132.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetPublicProperties,The length of the statement  "            // a general purpose flags enum and methods that can take any combination of the flags' we provide more restrictive methods that " is 128.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetPublicProperties,The length of the statement  "            // TypeInfo.DeclaredProperties and Type.GetRuntimeProperties return both public and private properties' so need to filter out only public ones. " is 143.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetPublicProperties,The length of the statement  "            IEnumerable<PropertyInfo> properties = declaredOnly ? type.GetTypeInfo().DeclaredProperties : type.GetRuntimeProperties(); " is 122.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetInstanceConstructors,The length of the statement  "            // WIN8: The BindingFlags enum and all related reflection method overloads have been removed from Win8. Instead of trying to provide " is 132.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetInstanceConstructors,The length of the statement  "            // a general purpose flags enum and methods that can take any combination of the flags' we provide more restrictive methods that " is 128.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetInstanceConstructor,The length of the statement  "            // WIN8: The BindingFlags enum and all related reflection method overloads have been removed from Win8. Instead of trying to provide " is 132.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetInstanceConstructor,The length of the statement  "            // a general purpose flags enum and methods that can take any combination of the flags' we provide more restrictive methods that " is 128.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetMethod,The length of the statement  "            // WIN8: The BindingFlags enum and all related reflection method overloads have been removed from Win8. Instead of trying to provide " is 132.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetMethod,The length of the statement  "            // a general purpose flags enum and methods that can take any combination of the flags' we provide more restrictive methods that " is 128.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetMethod,The length of the statement  "            return type.GetRuntimeMethods().Where(m => m.Name == name && (isPublic == null || m.IsPublic == isPublic) && (isStatic == null || m.IsStatic == isStatic)).SingleOrDefault(); " is 173.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetMethod,The length of the statement  "            // WIN8: The BindingFlags enum and all related reflection method overloads have been removed from Win8. Instead of trying to provide " is 132.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetMethod,The length of the statement  "            // a general purpose flags enum and methods that can take any combination of the flags' we provide more restrictive methods that " is 128.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetField,The length of the statement  "            // WIN8: The BindingFlags enum and all related reflection method overloads have been removed from Win8. Instead of trying to provide " is 132.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetField,The length of the statement  "            // a general purpose flags enum and methods that can take any combination of the flags' we provide more restrictive methods that " is 128.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetField,The length of the statement  "            return type.GetRuntimeFields().Where(f => f.Name == name && (isPublic == null || f.IsPublic == isPublic) && (isStatic == null || f.IsStatic == isStatic)).SingleOrDefault(); " is 172.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetProperty,The length of the statement  "            // WIN8: The BindingFlags enum and all related reflection method overloads have been removed from Win8. Instead of trying to provide " is 132.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetProperty,The length of the statement  "            // a general purpose flags enum and methods that can take any combination of the flags' we provide more restrictive methods that " is 128.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetProperty,The length of the statement  "            return type.GetRuntimeProperties().Where(p => p.Name == name && (isPublic == null || p.GetMethod.IsPublic == isPublic) && (isStatic == null || p.GetMethod.IsStatic == isStatic)).SingleOrDefault(); " is 196.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetProperty,The length of the statement  "            var propertyCandidates = type.GetRuntimeProperties().Where(p => p.Name == name && (isPublic == null || p.GetMethod.IsPublic == isPublic) && (isStatic == null || p.GetMethod.IsStatic == isStatic)); " is 196.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetMethods,The length of the statement  "            // WIN8: The BindingFlags enum and all related reflection method overloads have been removed from Win8. Instead of trying to provide " is 132.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetMethods,The length of the statement  "            // a general purpose flags enum and methods that can take any combination of the flags' we provide more restrictive methods that " is 128.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetMethods,The length of the statement  "            return type.GetRuntimeMethods().Where(m => (isPublic == null || m.IsPublic == isPublic) &&  (isStatic == null || m.IsStatic == isStatic)); " is 138.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetFields,The length of the statement  "            // WIN8: The BindingFlags enum and all related reflection method overloads have been removed from Win8. Instead of trying to provide " is 132.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetFields,The length of the statement  "            // a general purpose flags enum and methods that can take any combination of the flags' we provide more restrictive methods that " is 128.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetFields,The length of the statement  "            return type.GetRuntimeFields().Where(f => (isPublic == null || f.IsPublic == isPublic) && (isStatic == null || f.IsStatic == isStatic)); " is 136.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetProperties,The length of the statement  "            // WIN8: The BindingFlags enum and all related reflection method overloads have been removed from Win8. Instead of trying to provide " is 132.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetProperties,The length of the statement  "            // a general purpose flags enum and methods that can take any combination of the flags' we provide more restrictive methods that " is 128.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetProperties,The length of the statement  "            return type.GetRuntimeProperties().Where(p => (isPublic == null || p.GetMethod.IsPublic == isPublic) && (isStatic == null || p.GetMethod.IsStatic == isStatic)); " is 160.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetNestedTypes,The length of the statement  "            return type.GetTypeInfo().DeclaredNestedTypes.Where(t => isPublic == null || t.IsPublic == isPublic).Select(t => t.AsType()); " is 125.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetNestedTypes,The length of the statement  "            // WIN8: The BindingFlags enum and all related reflection method overloads have been removed from Win8. Instead of trying to provide " is 132.
Long Statement,System.CodeDom,PlatformHelper,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\Source\PlatformHelper.cs,GetNestedTypes,The length of the statement  "            // a general purpose flags enum and methods that can take any combination of the flags' we provide more restrictive methods that " is 128.
Long Statement,System.Collections.Specialized,FixedStringLookup,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\FixedStringLookup.cs,VerifyLookupTable,The length of the statement  "                            Debug.Assert(string.Compare(lastValue' value' ((ignoreCase) ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal)) < 0'  " is 130.
Long Statement,System.Collections.Specialized,FixedStringLookup,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\FixedStringLookup.cs,VerifyLookupTable,The length of the statement  "                                         string.Format(CultureInfo.InvariantCulture' "Lookup table is out of order.  Items {0} and {1} are reversed"' lastValue' value)); " is 128.
Long Statement,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,GenerateDoubleValue,The length of the statement  "                // always mark a double as being a double in case we have no decimal portion (e.g write 1D instead of 1 which is an int) " is 120.
Long Statement,Microsoft.VisualBasic,VBCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\VisualBasic\VBCodeGenerator.cs,GeneratePrimitiveExpression,The length of the statement  "                Output.Write("Global.Microsoft.VisualBasic.ChrW(" + Convert.ToInt16(e.Value' CultureInfo.InvariantCulture).ToString(CultureInfo.InvariantCulture) + ")"); " is 153.
Long Statement,Microsoft.VisualBasic,VBCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\VisualBasic\VBCodeGenerator.cs,GenerateDoubleValue,The length of the statement  "                // always mark a double as being a double in case we have no decimal portion (e.g write 1D instead of 1 which is an int) " is 120.
Long Statement,Microsoft.VisualBasic,VBCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\VisualBasic\VBCodeGenerator.cs,GenerateMethod,The length of the statement  "            if (e.ReturnType.BaseType.Length == 0 || string.Compare(e.ReturnType.BaseType' typeof(void).FullName' StringComparison.OrdinalIgnoreCase) == 0) { " is 145.
Long Statement,Microsoft.VisualBasic,VBCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\VisualBasic\VBCodeGenerator.cs,GenerateTypeStart,The length of the statement  "                if (del.ReturnType.BaseType.Length > 0 && string.Compare(del.ReturnType.BaseType' "System.Void"' StringComparison.OrdinalIgnoreCase) != 0) " is 138.
Long Statement,Microsoft.VisualBasic,VBCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\VisualBasic\VBCodeGenerator.cs,GenerateTypeStart,The length of the statement  "                if (del.ReturnType.BaseType.Length > 0 && string.Compare(del.ReturnType.BaseType' "System.Void"' StringComparison.OrdinalIgnoreCase) != 0) { " is 140.
Complex Conditional,Microsoft.VisualBasic,VBCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\VisualBasic\VBCodeGenerator.cs,MethodIsOverloaded,The conditional expression  "!(en.Current is CodeTypeConstructor)                      && !(en.Current is CodeConstructor)                      && meth != e                      && meth.Name.Equals(e.Name' StringComparison.OrdinalIgnoreCase)                      && meth.PrivateImplementationType == null"  is complex.
Magic Number,System.CodeDom,CodeTypeReference,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\CodeDom\CodeTypeReference.cs,RipOffAssemblyInformationFromTypeName,The following statement contains a magic number: if(start < end) {                  if (typeName[start] =='[' && typeName[end] == ']') {                        start++;                      end--;                  }                    // if we still have a ] at the end' there's no assembly info.                   if (typeName[end] != ']') {                      int commaCount = 0;                                                  for(int index = end; index >= start; index--) {                          if( typeName[index] == ''') {                              commaCount++;                              if( commaCount == 4) {                                  result = typeName.Substring( start' index - start);                                   break;                              }                          }                      }                  }              }
Magic Number,System.CodeDom.Compiler,CodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\CodeDom\Compiler\CodeGenerator.cs,OutputParameters,The following statement contains a magic number: if (multiline) {                  Indent += 3;              }
Magic Number,System.CodeDom.Compiler,CodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\CodeDom\Compiler\CodeGenerator.cs,OutputParameters,The following statement contains a magic number: if (multiline) {                  Indent -= 3;              }
Magic Number,System.CodeDom.Compiler,CodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\CodeDom\Compiler\CodeGenerator.cs,GenerateBinaryOperatorExpression,The following statement contains a magic number: if (e.Left is CodeBinaryOperatorExpression || e.Right is CodeBinaryOperatorExpression) {                  // In case the line gets too long with nested binary operators' we need to output them on                  // different lines. However we want to indent them to maintain readability' but this needs                  // to be done only once;                  if (!inNestedBinary) {                      indentedExpression = true;                      inNestedBinary = true;                      Indent += 3;                  }                  ContinueOnNewLine("");              }
Magic Number,System.CodeDom.Compiler,CodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\CodeDom\Compiler\CodeGenerator.cs,GenerateBinaryOperatorExpression,The following statement contains a magic number: if (indentedExpression) {                  Indent -= 3;                  inNestedBinary = false;              }
Magic Number,System.Collections.Specialized,FixedStringLookup,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\FixedStringLookup.cs,FindCharacter,The following statement contains a magic number: while (min < max) {                  index = (min + max) / 2;                  char comp = array[index][pos];                  if (value == comp) {                      // We have a match. Now adjust to any adjacent matches                      int newMin = index;                      while (newMin > min && array[newMin - 1][pos] == value) {                          newMin--;                      }                      min = newMin;                        int newMax = index + 1;                      while (newMax < max && array[newMax][pos] == value) {                          newMax++;                      }                      max = newMax;                      return true;                  }                  if (value < comp) {                      max = index;                  }                  else {                      min = index + 1;                  }              }
Magic Number,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,QuoteSnippetStringCStyle,The following statement contains a magic number: StringBuilder b = new StringBuilder(value.Length+5);
Magic Number,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,QuoteSnippetStringVerbatimStyle,The following statement contains a magic number: StringBuilder b = new StringBuilder(value.Length+5);
Magic Number,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,QuoteSnippetString,The following statement contains a magic number: if (value.Length < 256 || value.Length > 1500 || (value.IndexOf('\0') != -1))                  return QuoteSnippetStringCStyle(value);
Magic Number,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,QuoteSnippetString,The following statement contains a magic number: if (value.Length < 256 || value.Length > 1500 || (value.IndexOf('\0') != -1))                  return QuoteSnippetStringCStyle(value);
Magic Number,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,GenerateBinaryOperatorExpression,The following statement contains a magic number: if (e.Left is CodeBinaryOperatorExpression || e.Right is CodeBinaryOperatorExpression) {                  // In case the line gets too long with nested binary operators' we need to output them on                  // different lines. However we want to indent them to maintain readability' but this needs                  // to be done only once;                  if (!inNestedBinary) {                      indentedExpression = true;                      inNestedBinary = true;                      Indent += 3;                  }                  ContinueOnNewLine("");              }
Magic Number,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,GenerateBinaryOperatorExpression,The following statement contains a magic number: if (indentedExpression) {                  Indent -= 3;                  inNestedBinary = false;              }
Magic Number,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,OutputParameters,The following statement contains a magic number: if (multiline) {                  Indent += 3;              }
Magic Number,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,OutputParameters,The following statement contains a magic number: if (multiline) {                  Indent -= 3;              }
Magic Number,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,IsPrefixTwoUnderscore,The following statement contains a magic number: if( value.Length < 3) {                  return false;              }              else {                  return ((value[0] == '_') && (value[1] == '_') && (value[2] != '_'));              }
Magic Number,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,IsPrefixTwoUnderscore,The following statement contains a magic number: if( value.Length < 3) {                  return false;              }              else {                  return ((value[0] == '_') && (value[1] == '_') && (value[2] != '_'));              }
Magic Number,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,IsValidIdentifier,The following statement contains a magic number: if (value.Length > 512)                  return false;
Magic Number,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,GetBaseTypeOutput,The following statement contains a magic number: switch (lowerCaseString) {                  case "system.int16":                                  s = "short";                      break;                     case "system.int32":                                  s = "int";                      break;                     case "system.int64":                                  s = "long";                      break;                     case "system.string":                                  s = "string";                      break;                     case "system.object":                                  s = "object";                      break;                     case "system.boolean":                                  s = "bool";                      break;                     case "system.void":                                  s = "void";                      break;                     case "system.char":                                  s = "char";                      break;                     case "system.byte":                                  s = "byte";                      break;                     case "system.uint16":                                  s = "ushort";                      break;                     case "system.uint32":                                  s = "uint";                      break;                     case "system.uint64":                                  s = "ulong";                      break;                     case "system.sbyte":                                  s = "sbyte";                      break;                                         case "system.single":                                  s = "float";                      break;                     case "system.double":                                  s = "double";                      break;                     case "system.decimal":                                  s = "decimal";                      break;                                         default:                      // replace + with . for nested classes.                      //                      StringBuilder sb = new StringBuilder(s.Length + 10);                                            if ((typeRef.Options & CodeTypeReferenceOptions.GlobalReference) != 0) {                          sb.Append("global::");                      }                        string baseType = typeRef.BaseType;                                            int lastIndex = 0;                      int currentTypeArgStart = 0;                      for (int i=0; i<baseType.Length; i++) {                          switch (baseType[i]) {                          case '+':                          case '.':                              sb.Append(CreateEscapedIdentifier(baseType.Substring(lastIndex' i-lastIndex)));                              sb.Append('.');                              i++;                              lastIndex = i;                              break;                                                        case '`':                              sb.Append(CreateEscapedIdentifier(baseType.Substring(lastIndex' i-lastIndex)));                              i++;    // skip the '                              int numTypeArgs = 0;                              while (i < baseType.Length && baseType[i] >= '0' && baseType[i] <='9') {                                  numTypeArgs = numTypeArgs*10 + (baseType[i] - '0');                                  i++;                              }                                                    GetTypeArgumentsOutput(typeRef.TypeArguments' currentTypeArgStart' numTypeArgs' sb);                              currentTypeArgStart += numTypeArgs;                                                    // Arity can be in the middle of a nested type name' so we might have a . or + after it.                               // Skip it if so.                               if (i < baseType.Length &&  (baseType[i] =='+' || baseType[i] == '.')) {                                  sb.Append('.');                                  i++;                              }                                                                lastIndex = i;                              break;                          }                      }                                            if (lastIndex < baseType.Length)                          sb.Append(CreateEscapedIdentifier(baseType.Substring(lastIndex)));                        return sb.ToString();              }
Magic Number,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,GetBaseTypeOutput,The following statement contains a magic number: switch (lowerCaseString) {                  case "system.int16":                                  s = "short";                      break;                     case "system.int32":                                  s = "int";                      break;                     case "system.int64":                                  s = "long";                      break;                     case "system.string":                                  s = "string";                      break;                     case "system.object":                                  s = "object";                      break;                     case "system.boolean":                                  s = "bool";                      break;                     case "system.void":                                  s = "void";                      break;                     case "system.char":                                  s = "char";                      break;                     case "system.byte":                                  s = "byte";                      break;                     case "system.uint16":                                  s = "ushort";                      break;                     case "system.uint32":                                  s = "uint";                      break;                     case "system.uint64":                                  s = "ulong";                      break;                     case "system.sbyte":                                  s = "sbyte";                      break;                                         case "system.single":                                  s = "float";                      break;                     case "system.double":                                  s = "double";                      break;                     case "system.decimal":                                  s = "decimal";                      break;                                         default:                      // replace + with . for nested classes.                      //                      StringBuilder sb = new StringBuilder(s.Length + 10);                                            if ((typeRef.Options & CodeTypeReferenceOptions.GlobalReference) != 0) {                          sb.Append("global::");                      }                        string baseType = typeRef.BaseType;                                            int lastIndex = 0;                      int currentTypeArgStart = 0;                      for (int i=0; i<baseType.Length; i++) {                          switch (baseType[i]) {                          case '+':                          case '.':                              sb.Append(CreateEscapedIdentifier(baseType.Substring(lastIndex' i-lastIndex)));                              sb.Append('.');                              i++;                              lastIndex = i;                              break;                                                        case '`':                              sb.Append(CreateEscapedIdentifier(baseType.Substring(lastIndex' i-lastIndex)));                              i++;    // skip the '                              int numTypeArgs = 0;                              while (i < baseType.Length && baseType[i] >= '0' && baseType[i] <='9') {                                  numTypeArgs = numTypeArgs*10 + (baseType[i] - '0');                                  i++;                              }                                                    GetTypeArgumentsOutput(typeRef.TypeArguments' currentTypeArgStart' numTypeArgs' sb);                              currentTypeArgStart += numTypeArgs;                                                    // Arity can be in the middle of a nested type name' so we might have a . or + after it.                               // Skip it if so.                               if (i < baseType.Length &&  (baseType[i] =='+' || baseType[i] == '.')) {                                  sb.Append('.');                                  i++;                              }                                                                lastIndex = i;                              break;                          }                      }                                            if (lastIndex < baseType.Length)                          sb.Append(CreateEscapedIdentifier(baseType.Substring(lastIndex)));                        return sb.ToString();              }
Magic Number,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,GetTypeArgumentsOutput,The following statement contains a magic number: StringBuilder sb = new StringBuilder(128);
Magic Number,Microsoft.VisualBasic,VBCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\VisualBasic\VBCodeGenerator.cs,QuoteSnippetString,The following statement contains a magic number: StringBuilder b = new StringBuilder(value.Length+5);
Magic Number,Microsoft.VisualBasic,VBCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\VisualBasic\VBCodeGenerator.cs,IsValidIdentifier,The following statement contains a magic number: if (value.Length > 1023)                  return false;
Magic Number,Microsoft.VisualBasic,VBCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\VisualBasic\VBCodeGenerator.cs,IsValidIdentifier,The following statement contains a magic number: if (value[0] != '[' || value[value.Length - 1] != ']') {                  if (IsKeyword(value)) {                      return false;                  }              } else {                  value = value.Substring(1' value.Length - 2);              }
Magic Number,Microsoft.VisualBasic,VBCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\VisualBasic\VBCodeGenerator.cs,GetBaseTypeOutput,The following statement contains a magic number: if (baseType.Length == 0) {                  return "Void";              }               else if (string.Compare(baseType' "System.Byte"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "Byte";              }              else if (string.Compare(baseType' "System.SByte"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "SByte";              }              else if (string.Compare(baseType' "System.Int16"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "Short";              }              else if (string.Compare(baseType' "System.Int32"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "Integer";              }              else if (string.Compare(baseType' "System.Int64"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "Long";              }              else if (string.Compare(baseType' "System.UInt16"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "UShort";              }              else if (string.Compare(baseType' "System.UInt32"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "UInteger";              }              else if (string.Compare(baseType' "System.UInt64"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "ULong";              }              else if (string.Compare(baseType' "System.String"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "String";              }              else if (string.Compare(baseType' "System.DateTime"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "Date";              }              else if (string.Compare(baseType' "System.Decimal"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "Decimal";              }              else if (string.Compare(baseType' "System.Single"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "Single";              }              else if (string.Compare(baseType' "System.Double"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "Double";              }              else if (string.Compare(baseType' "System.Boolean"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "Boolean";              }              else if (string.Compare(baseType' "System.Char"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "Char";              }              else if (string.Compare(baseType' "System.Object"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "Object";              }              else {                  StringBuilder sb = new StringBuilder(baseType.Length + 10);                  if((typeRef.Options & CodeTypeReferenceOptions.GlobalReference) != 0) {                      sb.Append("Global.");                  }                    int lastIndex = 0;                  int currentTypeArgStart = 0;                  for (int i=0; i<baseType.Length; i++) {                      switch (baseType[i]) {                      case '+':                      case '.':                          sb.Append(CreateEscapedIdentifier(baseType.Substring(lastIndex' i-lastIndex)));                          sb.Append('.');                          i++;                          lastIndex = i;                          break;                                                case '`':                          sb.Append(CreateEscapedIdentifier(baseType.Substring(lastIndex' i-lastIndex)));                          i++;    // skip the '                          int numTypeArgs = 0;                          while (i < baseType.Length && baseType[i] >= '0' && baseType[i] <='9') {                              numTypeArgs = numTypeArgs*10 + (baseType[i] - '0');                              i++;                          }                                            GetTypeArgumentsOutput(typeRef.TypeArguments' currentTypeArgStart' numTypeArgs' sb);                          currentTypeArgStart += numTypeArgs;                                            // Arity can be in the middle of a nested type name' so we might have a . or + after it.                           // Skip it if so.                           if (i < baseType.Length &&  (baseType[i] =='+' || baseType[i] == '.')) {                              sb.Append('.');                              i++;                          }                                                        lastIndex = i;                          break;                      }                  }                                    if (lastIndex < baseType.Length)                      sb.Append(CreateEscapedIdentifier(baseType.Substring(lastIndex)));                    return sb.ToString();                              }
Magic Number,Microsoft.VisualBasic,VBCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\VisualBasic\VBCodeGenerator.cs,GetBaseTypeOutput,The following statement contains a magic number: if (baseType.Length == 0) {                  return "Void";              }               else if (string.Compare(baseType' "System.Byte"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "Byte";              }              else if (string.Compare(baseType' "System.SByte"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "SByte";              }              else if (string.Compare(baseType' "System.Int16"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "Short";              }              else if (string.Compare(baseType' "System.Int32"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "Integer";              }              else if (string.Compare(baseType' "System.Int64"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "Long";              }              else if (string.Compare(baseType' "System.UInt16"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "UShort";              }              else if (string.Compare(baseType' "System.UInt32"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "UInteger";              }              else if (string.Compare(baseType' "System.UInt64"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "ULong";              }              else if (string.Compare(baseType' "System.String"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "String";              }              else if (string.Compare(baseType' "System.DateTime"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "Date";              }              else if (string.Compare(baseType' "System.Decimal"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "Decimal";              }              else if (string.Compare(baseType' "System.Single"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "Single";              }              else if (string.Compare(baseType' "System.Double"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "Double";              }              else if (string.Compare(baseType' "System.Boolean"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "Boolean";              }              else if (string.Compare(baseType' "System.Char"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "Char";              }              else if (string.Compare(baseType' "System.Object"' StringComparison.OrdinalIgnoreCase) == 0) {                  return "Object";              }              else {                  StringBuilder sb = new StringBuilder(baseType.Length + 10);                  if((typeRef.Options & CodeTypeReferenceOptions.GlobalReference) != 0) {                      sb.Append("Global.");                  }                    int lastIndex = 0;                  int currentTypeArgStart = 0;                  for (int i=0; i<baseType.Length; i++) {                      switch (baseType[i]) {                      case '+':                      case '.':                          sb.Append(CreateEscapedIdentifier(baseType.Substring(lastIndex' i-lastIndex)));                          sb.Append('.');                          i++;                          lastIndex = i;                          break;                                                case '`':                          sb.Append(CreateEscapedIdentifier(baseType.Substring(lastIndex' i-lastIndex)));                          i++;    // skip the '                          int numTypeArgs = 0;                          while (i < baseType.Length && baseType[i] >= '0' && baseType[i] <='9') {                              numTypeArgs = numTypeArgs*10 + (baseType[i] - '0');                              i++;                          }                                            GetTypeArgumentsOutput(typeRef.TypeArguments' currentTypeArgStart' numTypeArgs' sb);                          currentTypeArgStart += numTypeArgs;                                            // Arity can be in the middle of a nested type name' so we might have a . or + after it.                           // Skip it if so.                           if (i < baseType.Length &&  (baseType[i] =='+' || baseType[i] == '.')) {                              sb.Append('.');                              i++;                          }                                                        lastIndex = i;                          break;                      }                  }                                    if (lastIndex < baseType.Length)                      sb.Append(CreateEscapedIdentifier(baseType.Substring(lastIndex)));                    return sb.ToString();                              }
Magic Number,Microsoft.VisualBasic,VBCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\VisualBasic\VBCodeGenerator.cs,GetTypeArgumentsOutput,The following statement contains a magic number: StringBuilder sb = new StringBuilder(128);
Missing Default,System.CodeDom.Compiler,CodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\CodeDom\Compiler\CodeGenerator.cs,OutputDirection,The following switch statement is missing a default case: switch (dir) {                  case FieldDirection.In:                      break;                  case FieldDirection.Out:                      Output.Write("out ");                      break;                  case FieldDirection.Ref:                      Output.Write("ref ");                      break;              }
Missing Default,System.CodeDom.Compiler,CodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\CodeDom\Compiler\CodeGenerator.cs,OutputFieldScopeModifier,The following switch statement is missing a default case: switch (attributes & MemberAttributes.VTableMask) {                  case MemberAttributes.New:                      Output.Write("new ");                      break;              }
Missing Default,System.CodeDom.Compiler,CodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\CodeDom\Compiler\CodeGenerator.cs,OutputMemberAccessModifier,The following switch statement is missing a default case: switch (attributes & MemberAttributes.AccessMask) {                  case MemberAttributes.Assembly:                      Output.Write("internal ");                      break;                  case MemberAttributes.FamilyAndAssembly:                      Output.Write("internal ");  /*FamANDAssem*/                       break;                  case MemberAttributes.Family:                      Output.Write("protected ");                      break;                  case MemberAttributes.FamilyOrAssembly:                      Output.Write("protected internal ");                      break;                  case MemberAttributes.Private:                      Output.Write("private ");                      break;                  case MemberAttributes.Public:                      Output.Write("public ");                      break;              }
Missing Default,System.CodeDom.Compiler,CodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\CodeDom\Compiler\CodeGenerator.cs,OutputMemberScopeModifier,The following switch statement is missing a default case: switch (attributes & MemberAttributes.VTableMask) {                  case MemberAttributes.New:                      Output.Write("new ");                      break;              }
Missing Default,System.CodeDom.Compiler,CodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\CodeDom\Compiler\CodeGenerator.cs,OutputTypeAttributes,The following switch statement is missing a default case: switch(attributes & TypeAttributes.VisibilityMask) {                  case TypeAttributes.Public:                                    case TypeAttributes.NestedPublic:                                          Output.Write("public ");                      break;                  case TypeAttributes.NestedPrivate:                      Output.Write("private ");                      break;              }
Missing Default,System.CodeDom.Compiler,CodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\CodeDom\Compiler\CodeGenerator.cs,OutputTypeAttributes,The following switch statement is missing a default case: switch (attributes & TypeAttributes.ClassSemanticsMask) {                      case TypeAttributes.Class:                          if ((attributes & TypeAttributes.Sealed) == TypeAttributes.Sealed) {                              Output.Write("sealed ");                          }                          if ((attributes & TypeAttributes.Abstract) == TypeAttributes.Abstract) {                              Output.Write("abstract ");                          }                          Output.Write("class ");                          break;                                      case TypeAttributes.Interface:                          Output.Write("interface ");                          break;                  }
Missing Default,System.CodeDom.Compiler,CodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\CodeDom\Compiler\CodeGenerator.cs,OutputOperator,The following switch statement is missing a default case: switch (op) {                  case CodeBinaryOperatorType.Add:                      Output.Write("+");                      break;                  case CodeBinaryOperatorType.Subtract:                      Output.Write("-");                      break;                  case CodeBinaryOperatorType.Multiply:                      Output.Write("*");                      break;                  case CodeBinaryOperatorType.Divide:                      Output.Write("/");                      break;                  case CodeBinaryOperatorType.Modulus:                      Output.Write("%");                      break;                  case CodeBinaryOperatorType.Assign:                      Output.Write("=");                      break;                  case CodeBinaryOperatorType.IdentityInequality:                      Output.Write("!=");                      break;                  case CodeBinaryOperatorType.IdentityEquality:                      Output.Write("==");                      break;                  case CodeBinaryOperatorType.ValueEquality:                      Output.Write("==");                      break;                  case CodeBinaryOperatorType.BitwiseOr:                      Output.Write("|");                      break;                  case CodeBinaryOperatorType.BitwiseAnd:                      Output.Write("&");                      break;                  case CodeBinaryOperatorType.BooleanOr:                      Output.Write("||");                      break;                  case CodeBinaryOperatorType.BooleanAnd:                      Output.Write("&&");                      break;                  case CodeBinaryOperatorType.LessThan:                      Output.Write("<");                      break;                  case CodeBinaryOperatorType.LessThanOrEqual:                      Output.Write("<=");                      break;                  case CodeBinaryOperatorType.GreaterThan:                      Output.Write(">");                      break;                  case CodeBinaryOperatorType.GreaterThanOrEqual:                      Output.Write(">=");                      break;              }
Missing Default,System.CodeDom.Compiler,CodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\CodeDom\Compiler\CodeGenerator.cs,IsSpecialTypeChar,The following switch statement is missing a default case: switch(ch) {                  case ':':                  case '.':                  case '$':                  case '+':                  case '<':                  case '>':                  case '-':                  case '[':                  case ']':                  case ''':                  case '&':                  case '*':                      nextMustBeStartChar = true;                      return true;                    case '`':                      return true;              }
Missing Default,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,OutputVTableModifier,The following switch statement is missing a default case: switch (attributes & MemberAttributes.VTableMask) {                  case MemberAttributes.New:                      Output.Write("new ");                      break;              }
Missing Default,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,OutputMemberAccessModifier,The following switch statement is missing a default case: switch (attributes & MemberAttributes.AccessMask) {                  case MemberAttributes.Assembly:                      Output.Write("internal ");                      break;                  case MemberAttributes.FamilyAndAssembly:                      Output.Write("internal ");  /*FamANDAssem*/                       break;                  case MemberAttributes.Family:                      Output.Write("protected ");                      break;                  case MemberAttributes.FamilyOrAssembly:                      Output.Write("protected internal ");                      break;                  case MemberAttributes.Private:                      Output.Write("private ");                      break;                  case MemberAttributes.Public:                      Output.Write("public ");                      break;              }
Missing Default,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,OutputOperator,The following switch statement is missing a default case: switch (op) {                  case CodeBinaryOperatorType.Add:                      Output.Write("+");                      break;                  case CodeBinaryOperatorType.Subtract:                      Output.Write("-");                      break;                  case CodeBinaryOperatorType.Multiply:                      Output.Write("*");                      break;                  case CodeBinaryOperatorType.Divide:                      Output.Write("/");                      break;                  case CodeBinaryOperatorType.Modulus:                      Output.Write("%");                      break;                  case CodeBinaryOperatorType.Assign:                      Output.Write("=");                      break;                  case CodeBinaryOperatorType.IdentityInequality:                      Output.Write("!=");                      break;                  case CodeBinaryOperatorType.IdentityEquality:                      Output.Write("==");                      break;                  case CodeBinaryOperatorType.ValueEquality:                      Output.Write("==");                      break;                  case CodeBinaryOperatorType.BitwiseOr:                      Output.Write("|");                      break;                  case CodeBinaryOperatorType.BitwiseAnd:                      Output.Write("&");                      break;                  case CodeBinaryOperatorType.BooleanOr:                      Output.Write("||");                      break;                  case CodeBinaryOperatorType.BooleanAnd:                      Output.Write("&&");                      break;                  case CodeBinaryOperatorType.LessThan:                      Output.Write("<");                      break;                  case CodeBinaryOperatorType.LessThanOrEqual:                      Output.Write("<=");                      break;                  case CodeBinaryOperatorType.GreaterThan:                      Output.Write(">");                      break;                  case CodeBinaryOperatorType.GreaterThanOrEqual:                      Output.Write(">=");                      break;              }
Missing Default,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,OutputDirection,The following switch statement is missing a default case: switch (dir) {                  case FieldDirection.In:                      break;                  case FieldDirection.Out:                      Output.Write("out ");                      break;                  case FieldDirection.Ref:                      Output.Write("ref ");                      break;              }
Missing Default,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,OutputTypeAttributes,The following switch statement is missing a default case: switch(attributes & TypeAttributes.VisibilityMask) {                  case TypeAttributes.Public:                                    case TypeAttributes.NestedPublic:                      Output.Write("public ");                      break;                  case TypeAttributes.NestedPrivate:                      Output.Write("private ");                      break;                  case TypeAttributes.NestedFamily:                      Output.Write("protected ");                      break;                  case TypeAttributes.NotPublic:                  case TypeAttributes.NestedAssembly:                  case TypeAttributes.NestedFamANDAssem:                      Output.Write("internal ");                      break;                  case TypeAttributes.NestedFamORAssem:                      Output.Write("protected internal ");                      break;              }
Missing Default,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,OutputTypeAttributes,The following switch statement is missing a default case: switch (attributes & TypeAttributes.ClassSemanticsMask) {                      case TypeAttributes.Class:                          if ((attributes & TypeAttributes.Sealed) == TypeAttributes.Sealed) {                              Output.Write("sealed ");                          }                          if ((attributes & TypeAttributes.Abstract) == TypeAttributes.Abstract)  {                              Output.Write("abstract ");                          }                          if (e.IsPartial) {                              Output.Write("partial ");                          }                                                                    Output.Write("class ");                            break;                                      case TypeAttributes.Interface:                          if (e.IsPartial) {                              Output.Write("partial ");                          }                          Output.Write("interface ");                          break;                  }
Missing Default,Microsoft.CSharp,CSharpCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\CSharp\CSharpCodeGenerator.cs,GetBaseTypeOutput,The following switch statement is missing a default case: switch (baseType[i]) {                          case '+':                          case '.':                              sb.Append(CreateEscapedIdentifier(baseType.Substring(lastIndex' i-lastIndex)));                              sb.Append('.');                              i++;                              lastIndex = i;                              break;                                                        case '`':                              sb.Append(CreateEscapedIdentifier(baseType.Substring(lastIndex' i-lastIndex)));                              i++;    // skip the '                              int numTypeArgs = 0;                              while (i < baseType.Length && baseType[i] >= '0' && baseType[i] <='9') {                                  numTypeArgs = numTypeArgs*10 + (baseType[i] - '0');                                  i++;                              }                                                    GetTypeArgumentsOutput(typeRef.TypeArguments' currentTypeArgStart' numTypeArgs' sb);                              currentTypeArgStart += numTypeArgs;                                                    // Arity can be in the middle of a nested type name' so we might have a . or + after it.                               // Skip it if so.                               if (i < baseType.Length &&  (baseType[i] =='+' || baseType[i] == '.')) {                                  sb.Append('.');                                  i++;                              }                                                                lastIndex = i;                              break;                          }
Missing Default,Microsoft.VisualBasic,VBCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\VisualBasic\VBCodeGenerator.cs,OutputDirection,The following switch statement is missing a default case: switch (dir) {                  case FieldDirection.In:                      Output.Write("ByVal ");                      break;                  case FieldDirection.Out:                  case FieldDirection.Ref:                      Output.Write("ByRef ");                      break;              }
Missing Default,Microsoft.VisualBasic,VBCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\VisualBasic\VBCodeGenerator.cs,OutputMemberAccessModifier,The following switch statement is missing a default case: switch (attributes & MemberAttributes.AccessMask) {                  case MemberAttributes.Assembly:                      Output.Write("Friend ");                      break;                  case MemberAttributes.FamilyAndAssembly:                      Output.Write("Friend ");                      break;                  case MemberAttributes.Family:                      Output.Write("Protected ");                      break;                  case MemberAttributes.FamilyOrAssembly:                      Output.Write("Protected Friend ");                      break;                  case MemberAttributes.Private:                      Output.Write("Private ");                      break;                  case MemberAttributes.Public:                      Output.Write("Public ");                      break;              }
Missing Default,Microsoft.VisualBasic,VBCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\VisualBasic\VBCodeGenerator.cs,OutputVTableModifier,The following switch statement is missing a default case: switch (attributes & MemberAttributes.VTableMask) {                  case MemberAttributes.New:                      Output.Write("Shadows ");                      break;              }
Missing Default,Microsoft.VisualBasic,VBCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\VisualBasic\VBCodeGenerator.cs,OutputTypeAttributes,The following switch statement is missing a default case: switch(attributes & TypeAttributes.VisibilityMask) {                  case TypeAttributes.Public:                                    case TypeAttributes.NestedPublic:                      Output.Write("Public ");                      break;                  case TypeAttributes.NestedPrivate:                      Output.Write("Private ");                      break;                    case TypeAttributes.NestedFamily:                      Output.Write("Protected ");                      break;                  case TypeAttributes.NotPublic:                  case TypeAttributes.NestedAssembly:                  case TypeAttributes.NestedFamANDAssem:                      Output.Write("Friend ");                      break;                  case TypeAttributes.NestedFamORAssem:                      Output.Write("Protected Friend ");                      break;              }
Missing Default,Microsoft.VisualBasic,VBCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\VisualBasic\VBCodeGenerator.cs,OutputTypeAttributes,The following switch statement is missing a default case: switch (attributes & TypeAttributes.ClassSemanticsMask) {                      case TypeAttributes.Class:                          // if this "class" should generate as a module' then don't check                          //  inheritance flags since modules can't inherit                          if (IsCurrentModule) {                              Output.Write("Module ");                          }                          else {                              if ((attributes & TypeAttributes.Sealed) == TypeAttributes.Sealed) {                                  Output.Write("NotInheritable ");                              }                              if ((attributes & TypeAttributes.Abstract) == TypeAttributes.Abstract)  {                                  Output.Write("MustInherit ");                              }                              Output.Write("Class ");                          }                          break;                                      case TypeAttributes.Interface:                          Output.Write("Interface ");                          break;                  }
Missing Default,Microsoft.VisualBasic,VBCodeGenerator,C:\repos\OData_odata.net\test\FunctionalTests\Taupo\External\System.CodeDom.SL\Microsoft\VisualBasic\VBCodeGenerator.cs,GetBaseTypeOutput,The following switch statement is missing a default case: switch (baseType[i]) {                      case '+':                      case '.':                          sb.Append(CreateEscapedIdentifier(baseType.Substring(lastIndex' i-lastIndex)));                          sb.Append('.');                          i++;                          lastIndex = i;                          break;                                                case '`':                          sb.Append(CreateEscapedIdentifier(baseType.Substring(lastIndex' i-lastIndex)));                          i++;    // skip the '                          int numTypeArgs = 0;                          while (i < baseType.Length && baseType[i] >= '0' && baseType[i] <='9') {                              numTypeArgs = numTypeArgs*10 + (baseType[i] - '0');                              i++;                          }                                            GetTypeArgumentsOutput(typeRef.TypeArguments' currentTypeArgStart' numTypeArgs' sb);                          currentTypeArgStart += numTypeArgs;                                            // Arity can be in the middle of a nested type name' so we might have a . or + after it.                           // Skip it if so.                           if (i < baseType.Length &&  (baseType[i] =='+' || baseType[i] == '.')) {                              sb.Append('.');                              i++;                          }                                                        lastIndex = i;                          break;                      }
