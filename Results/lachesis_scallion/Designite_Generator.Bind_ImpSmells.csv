Implementation smell,Namespace,Class,File,Method,Description
Long Method,Bind,FuncProcessor,C:\repos\lachesis_scallion\opentk\Source\Bind\FuncProcessor.cs,CreateBody,The method has 177 lines of code.
Long Method,Bind,MainClass,C:\repos\lachesis_scallion\opentk\Source\Bind\Main.cs,Main,The method has 177 lines of code.
Complex Method,Bind,CppSpecWriter,C:\repos\lachesis_scallion\opentk\Source\Bind\CppSpecWriter.cs,GenerateParameterString,Cyclomatic complexity of the method is 10
Complex Method,Bind,CppSpecWriter,C:\repos\lachesis_scallion\opentk\Source\Bind\CppSpecWriter.cs,WriteDefinitions,Cyclomatic complexity of the method is 10
Complex Method,Bind,CppSpecWriter,C:\repos\lachesis_scallion\opentk\Source\Bind\CppSpecWriter.cs,WriteDocumentation,Cyclomatic complexity of the method is 9
Complex Method,Bind,CSharpSpecWriter,C:\repos\lachesis_scallion\opentk\Source\Bind\CSharpSpecWriter.cs,WriteDocumentation,Cyclomatic complexity of the method is 9
Complex Method,Bind,CSharpSpecWriter,C:\repos\lachesis_scallion\opentk\Source\Bind\CSharpSpecWriter.cs,WriteEnums,Cyclomatic complexity of the method is 8
Complex Method,Bind,FuncProcessor,C:\repos\lachesis_scallion\opentk\Source\Bind\FuncProcessor.cs,TranslateReturnType,Cyclomatic complexity of the method is 8
Complex Method,Bind,FuncProcessor,C:\repos\lachesis_scallion\opentk\Source\Bind\FuncProcessor.cs,WrapParameters,Cyclomatic complexity of the method is 11
Complex Method,Bind,FuncProcessor,C:\repos\lachesis_scallion\opentk\Source\Bind\FuncProcessor.cs,CreateBody,Cyclomatic complexity of the method is 23
Complex Method,Bind,JavaSpecWriter,C:\repos\lachesis_scallion\opentk\Source\Bind\JavaSpecWriter.cs,GenerateParameterString,Cyclomatic complexity of the method is 9
Complex Method,Bind,JavaSpecWriter,C:\repos\lachesis_scallion\opentk\Source\Bind\JavaSpecWriter.cs,WriteDocumentation,Cyclomatic complexity of the method is 9
Complex Method,Bind,EnumProcessor,C:\repos\lachesis_scallion\opentk\Source\Bind\EnumProcessor.cs,TranslateEnumName,Cyclomatic complexity of the method is 8
Complex Method,Bind.Structures,Function,C:\repos\lachesis_scallion\opentk\Source\Bind\Structures\Function.cs,ToString,Cyclomatic complexity of the method is 9
Long Statement,Bind,CSharpSpecWriter,C:\repos\lachesis_scallion\opentk\Source\Bind\CSharpSpecWriter.cs,WriteDelegates,The length of the statement  "            Trace.WriteLine(String.Format("Writing delegates to:\t{0}.{1}.{2}"' Settings.OutputNamespace' Settings.OutputClass' Settings.DelegatesClass)); " is 142.
Long Statement,Bind,CSharpSpecWriter,C:\repos\lachesis_scallion\opentk\Source\Bind\CSharpSpecWriter.cs,WriteImports,The length of the statement  "            Trace.WriteLine(String.Format("Writing imports to:\t{0}.{1}.{2}"' Settings.OutputNamespace' Settings.OutputClass' Settings.ImportsClass)); " is 138.
Long Statement,Bind,CSharpSpecWriter,C:\repos\lachesis_scallion\opentk\Source\Bind\CSharpSpecWriter.cs,WriteEnums,The length of the statement  "                Trace.WriteLine(String.Format("Writing enums to:\t{0}.{1}.{2}"' Settings.OutputNamespace' Settings.OutputClass' Settings.NestedEnumsClass)); " is 140.
Long Statement,Bind,CSharpSpecWriter,C:\repos\lachesis_scallion\opentk\Source\Bind\CSharpSpecWriter.cs,WriteEnums,The length of the statement  "                            select Settings.GLClass + (function.Extension != "Core" ? ("." + function.Extension) : "") + "." + function.TrimmedName) " is 120.
Long Statement,Bind,CSharpSpecWriter,C:\repos\lachesis_scallion\opentk\Source\Bind\CSharpSpecWriter.cs,WriteEnums,The length of the statement  "                            Char.IsDigit(c.Value[0]) ? c.Value : c.Value.StartsWith(Settings.ConstantPrefix) ? c.Value : Settings.ConstantPrefix + c.Value' " is 127.
Long Statement,Bind,MainClass,C:\repos\lachesis_scallion\opentk\Source\Bind\Main.cs,Main,The length of the statement  "                                Settings.Compatibility |= val.ToLower() == "simple_enums" ? Settings.Legacy.NoAdvancedEnumProcessing : Settings.Legacy.None; " is 124.
Long Statement,Bind,MainClass,C:\repos\lachesis_scallion\opentk\Source\Bind\Main.cs,Main,The length of the statement  "                                //Settings.Compatibility |= b[1].ToLower().Contains("novoid") ? Settings.Legacy.TurnVoidPointersToIntPtr : Settings.Legacy.None; " is 128.
Long Statement,Bind,MainClass,C:\repos\lachesis_scallion\opentk\Source\Bind\Main.cs,Main,The length of the statement  "                                Settings.Compatibility |= val.ToLower() == "permutations" ? Settings.Legacy.GenerateAllPermutations : Settings.Legacy.None; " is 123.
Long Statement,Bind,MainClass,C:\repos\lachesis_scallion\opentk\Source\Bind\Main.cs,Main,The length of the statement  "                                Settings.Compatibility |= val.ToLower() == "keep_untyped_enums" ? Settings.Legacy.KeepUntypedEnums : Settings.Legacy.None; " is 122.
Long Statement,Bind,EnumProcessor,C:\repos\lachesis_scallion\opentk\Source\Bind\EnumProcessor.cs,ReplaceConstant,The length of the statement  "                XPathNavigator constant_override = enum_override.SelectSingleNode(String.Format("token[@name='{0}']"' c.OriginalName)) ?? " is 121.
Long Statement,Bind.Structures,Type,C:\repos\lachesis_scallion\opentk\Source\Bind\Structures\Type.cs,Translate,The length of the statement  "            XPathNavigator enum_override = overrides.SelectSingleNode(String.Format("/signatures/replace/enum[@name='{0}']/name"' CurrentType)); " is 132.
Long Statement,Bind.Structures,FunctionCollection,C:\repos\lachesis_scallion\opentk\Source\Bind\Structures\Function.cs,AddChecked,The length of the statement  "                    if ((existing.Parameters.HasUnsignedParameters && !unsignedFunctions.IsMatch(existing.Name) && unsignedFunctions.IsMatch(f.Name)) || " is 132.
Long Statement,Bind.Structures,FunctionCollection,C:\repos\lachesis_scallion\opentk\Source\Bind\Structures\Function.cs,AddChecked,The length of the statement  "                        (!existing.Parameters.HasUnsignedParameters && unsignedFunctions.IsMatch(existing.Name) && !unsignedFunctions.IsMatch(f.Name))) " is 127.
Long Statement,Bind.Structures,Constant,C:\repos\lachesis_scallion\opentk\Source\Bind\Structures\Constant.cs,TranslateConstantWithReference,The length of the statement  "                else if (auxEnums != null && auxEnums.ContainsKey(c.Reference) && auxEnums[c.Reference].ConstantCollection.ContainsKey(c.Value)) " is 128.
Long Statement,Bind.Structures,Parameter,C:\repos\lachesis_scallion\opentk\Source\Bind\Structures\Parameter.cs,ToString,The length of the statement  "                if (!override_unsafe_setting && ((Settings.Compatibility & Settings.Legacy.NoPublicUnsafeFunctions) != Settings.Legacy.None)) " is 125.
Long Statement,Bind.Structures,Parameter,C:\repos\lachesis_scallion\opentk\Source\Bind\Structures\Parameter.cs,Translate,The length of the statement  "                    (!String.IsNullOrEmpty(PreviousType) && PreviousType.ToLower().Contains("void"))) /*|| CurrentType.Contains("IntPtr"))*/ " is 120.
Complex Conditional,Bind,FuncProcessor,C:\repos\lachesis_scallion\opentk\Source\Bind\FuncProcessor.cs,TrimName,The conditional expression  "m.Value[m.Length - 1] == 'v' && EndingsAddV.IsMatch(name) &&                          !name.StartsWith("Get") && !name.StartsWith("MatrixIndex")"  is complex.
Complex Conditional,Bind,MainClass,C:\repos\lachesis_scallion\opentk\Source\Bind\Main.cs,SetGeneratorMode,The conditional expression  "arg == "gl" || arg == "gl2" || arg == "gl3" || arg == "gl4""  is complex.
Complex Conditional,Bind,BindStreamWriter,C:\repos\lachesis_scallion\opentk\Source\Bind\BindStreamWriter.cs,WriteLine,The conditional expression  "Environment.OSVersion.Platform == PlatformID.Win32Windows ||                  Environment.OSVersion.Platform == PlatformID.Win32NT ||                  Environment.OSVersion.Platform == PlatformID.Win32S ||                  Environment.OSVersion.Platform == PlatformID.WinCE"  is complex.
Complex Conditional,Bind,EnumProcessor,C:\repos\lachesis_scallion\opentk\Source\Bind\EnumProcessor.cs,TranslateConstantName,The conditional expression  "is_after_digit && (c == 'D' || c == 'R' || c == 'G' || c == 'B' || c == 'A')"  is complex.
Complex Conditional,Bind.Structures,FunctionCollection,C:\repos\lachesis_scallion\opentk\Source\Bind\Structures\Function.cs,AddChecked,The conditional expression  "(existing.Parameters.HasUnsignedParameters && !unsignedFunctions.IsMatch(existing.Name) && unsignedFunctions.IsMatch(f.Name)) ||                          (!existing.Parameters.HasUnsignedParameters && unsignedFunctions.IsMatch(existing.Name) && !unsignedFunctions.IsMatch(f.Name))"  is complex.
Magic Number,Bind,CppSpecWriter,C:\repos\lachesis_scallion\opentk\Source\Bind\CppSpecWriter.cs,GenerateParameterString,The following statement contains a magic number: if (d.Parameters.Count > 0)              {                  foreach (var p in d.Parameters)                  {                      if (p.CurrentType.ToLower() == "string[]")                          p.CurrentType = "char**";                      if (p.CurrentType.ToLower() == "string")                          p.CurrentType = "char*";                        if (p.Reference)                      {                         if (/*check_validity &&*/ p.Generic)                          {                              // We don't need generic parameters in C++ and void& is illegal.                              valid = false;                              return String.Empty;                          }                            if (p.Flow != FlowDirection.Out)                              sb.Append("const ");                          sb.Append(p.QualifiedType);                          sb.Append('*'' p.Array);                          sb.Append("&");                      }                      else if (p.Array > 0)                      {                          // Hack: generic parameters with array types are                          // not real (i.e. they are created by the generator                          // specifically for managed languages). We don't                          // need them in C++.                          // Todo: move C#/Java-specific code to their respective                          // classes' instead of the main generator.                          // Note: the 1-dimensional array is handled through the pointer case below.                          // (C# differentiates between arrays and pointers' C++ doesn't).                          if (check_validity && (p.Generic || p.Array == 1))                          {                              valid = false;                              return String.Empty;                          }                            if (p.Flow != FlowDirection.Out)                              sb.Append("const ");                          sb.Append(p.Generic ? "void" : p.QualifiedType); // We don't need generic parameters in C++.                          sb.Append('*'' p.Array);                      }                      else if (p.Pointer > 0)                      {                          if (p.Flow != FlowDirection.Out)                              sb.Append("const ");                          sb.Append(p.Generic ? "void" : p.QualifiedType); // We don't need generic parameters in C++.                          sb.Append('*'' p.Pointer);                      }                      else if (p.CurrentType == "IntPtr")                      {                          if (p.Flow != FlowDirection.Out)                              sb.Append("const ");                          sb.Append("void*");                      }                      else                      {                          sb.Append(p.QualifiedType);                      }                        sb.Append(" ");                      sb.Append(p.Name);                      sb.Append("' ");                  }                    if (d.Parameters.Count > 0)                      sb.Remove(sb.Length - 2' 2);              }
Magic Number,Bind,CppSpecWriter,C:\repos\lachesis_scallion\opentk\Source\Bind\CppSpecWriter.cs,GenerateParameterString,The following statement contains a magic number: if (d.Parameters.Count > 0)              {                  foreach (var p in d.Parameters)                  {                      if (p.CurrentType.ToLower() == "string[]")                          p.CurrentType = "char**";                      if (p.CurrentType.ToLower() == "string")                          p.CurrentType = "char*";                        if (p.Reference)                      {                         if (/*check_validity &&*/ p.Generic)                          {                              // We don't need generic parameters in C++ and void& is illegal.                              valid = false;                              return String.Empty;                          }                            if (p.Flow != FlowDirection.Out)                              sb.Append("const ");                          sb.Append(p.QualifiedType);                          sb.Append('*'' p.Array);                          sb.Append("&");                      }                      else if (p.Array > 0)                      {                          // Hack: generic parameters with array types are                          // not real (i.e. they are created by the generator                          // specifically for managed languages). We don't                          // need them in C++.                          // Todo: move C#/Java-specific code to their respective                          // classes' instead of the main generator.                          // Note: the 1-dimensional array is handled through the pointer case below.                          // (C# differentiates between arrays and pointers' C++ doesn't).                          if (check_validity && (p.Generic || p.Array == 1))                          {                              valid = false;                              return String.Empty;                          }                            if (p.Flow != FlowDirection.Out)                              sb.Append("const ");                          sb.Append(p.Generic ? "void" : p.QualifiedType); // We don't need generic parameters in C++.                          sb.Append('*'' p.Array);                      }                      else if (p.Pointer > 0)                      {                          if (p.Flow != FlowDirection.Out)                              sb.Append("const ");                          sb.Append(p.Generic ? "void" : p.QualifiedType); // We don't need generic parameters in C++.                          sb.Append('*'' p.Pointer);                      }                      else if (p.CurrentType == "IntPtr")                      {                          if (p.Flow != FlowDirection.Out)                              sb.Append("const ");                          sb.Append("void*");                      }                      else                      {                          sb.Append(p.QualifiedType);                      }                        sb.Append(" ");                      sb.Append(p.Name);                      sb.Append("' ");                  }                    if (d.Parameters.Count > 0)                      sb.Remove(sb.Length - 2' 2);              }
Magic Number,Bind,CppSpecWriter,C:\repos\lachesis_scallion\opentk\Source\Bind\CppSpecWriter.cs,GenerateCallString,The following statement contains a magic number: if (f.Parameters.Count > 0)                  sb.Remove(sb.Length - 2' 2);
Magic Number,Bind,CppSpecWriter,C:\repos\lachesis_scallion\opentk\Source\Bind\CppSpecWriter.cs,GenerateCallString,The following statement contains a magic number: if (f.Parameters.Count > 0)                  sb.Remove(sb.Length - 2' 2);
Magic Number,Bind,FuncProcessor,C:\repos\lachesis_scallion\opentk\Source\Bind\FuncProcessor.cs,WrapVoidPointers,The following statement contains a magic number: if (index >= 0 && index < func.Parameters.Count)              {                  if (func.Parameters[index].WrapperType == WrapperTypes.GenericParameter)                  {                      // Recurse to the last parameter                      ++index;                      foreach (var w in WrapVoidPointers(func' enums))                          yield return w;                      --index;                        // On stack rewind' create generic wrappers                      func.Parameters[index].Reference = true;                      func.Parameters[index].Array = 0;                      func.Parameters[index].Pointer = 0;                      func.Parameters[index].Generic = true;                      func.Parameters[index].CurrentType = "T" + index.ToString();                      func.Parameters[index].Flow = FlowDirection.Undefined;                      func.Parameters.Rebuild = true;                      CreateBody(func' false' enums);                      yield return new Function(func);                        func.Parameters[index].Reference = false;                      func.Parameters[index].Array = 1;                      func.Parameters[index].Pointer = 0;                      func.Parameters[index].Generic = true;                      func.Parameters[index].CurrentType = "T" + index.ToString();                      func.Parameters[index].Flow = FlowDirection.Undefined;                      func.Parameters.Rebuild = true;                      CreateBody(func' false' enums);                      yield return new Function(func);                        func.Parameters[index].Reference = false;                      func.Parameters[index].Array = 2;                      func.Parameters[index].Pointer = 0;                      func.Parameters[index].Generic = true;                      func.Parameters[index].CurrentType = "T" + index.ToString();                      func.Parameters[index].Flow = FlowDirection.Undefined;                      func.Parameters.Rebuild = true;                      CreateBody(func' false' enums);                      yield return new Function(func);                        func.Parameters[index].Reference = false;                      func.Parameters[index].Array = 3;                      func.Parameters[index].Pointer = 0;                      func.Parameters[index].Generic = true;                      func.Parameters[index].CurrentType = "T" + index.ToString();                      func.Parameters[index].Flow = FlowDirection.Undefined;                      func.Parameters.Rebuild = true;                      CreateBody(func' false' enums);                      yield return new Function(func);                  }                  else                  {                      // Recurse to the last parameter                      ++index;                      foreach (var w in WrapVoidPointers(func' enums))                          yield return w;                      --index;                  }              }
Magic Number,Bind,FuncProcessor,C:\repos\lachesis_scallion\opentk\Source\Bind\FuncProcessor.cs,WrapVoidPointers,The following statement contains a magic number: if (index >= 0 && index < func.Parameters.Count)              {                  if (func.Parameters[index].WrapperType == WrapperTypes.GenericParameter)                  {                      // Recurse to the last parameter                      ++index;                      foreach (var w in WrapVoidPointers(func' enums))                          yield return w;                      --index;                        // On stack rewind' create generic wrappers                      func.Parameters[index].Reference = true;                      func.Parameters[index].Array = 0;                      func.Parameters[index].Pointer = 0;                      func.Parameters[index].Generic = true;                      func.Parameters[index].CurrentType = "T" + index.ToString();                      func.Parameters[index].Flow = FlowDirection.Undefined;                      func.Parameters.Rebuild = true;                      CreateBody(func' false' enums);                      yield return new Function(func);                        func.Parameters[index].Reference = false;                      func.Parameters[index].Array = 1;                      func.Parameters[index].Pointer = 0;                      func.Parameters[index].Generic = true;                      func.Parameters[index].CurrentType = "T" + index.ToString();                      func.Parameters[index].Flow = FlowDirection.Undefined;                      func.Parameters.Rebuild = true;                      CreateBody(func' false' enums);                      yield return new Function(func);                        func.Parameters[index].Reference = false;                      func.Parameters[index].Array = 2;                      func.Parameters[index].Pointer = 0;                      func.Parameters[index].Generic = true;                      func.Parameters[index].CurrentType = "T" + index.ToString();                      func.Parameters[index].Flow = FlowDirection.Undefined;                      func.Parameters.Rebuild = true;                      CreateBody(func' false' enums);                      yield return new Function(func);                        func.Parameters[index].Reference = false;                      func.Parameters[index].Array = 3;                      func.Parameters[index].Pointer = 0;                      func.Parameters[index].Generic = true;                      func.Parameters[index].CurrentType = "T" + index.ToString();                      func.Parameters[index].Flow = FlowDirection.Undefined;                      func.Parameters.Rebuild = true;                      CreateBody(func' false' enums);                      yield return new Function(func);                  }                  else                  {                      // Recurse to the last parameter                      ++index;                      foreach (var w in WrapVoidPointers(func' enums))                          yield return w;                      --index;                  }              }
Magic Number,Bind,JavaSpecWriter,C:\repos\lachesis_scallion\opentk\Source\Bind\JavaSpecWriter.cs,GenerateParameterString,The following statement contains a magic number: if (f.Parameters.Count > 0)              {                  foreach (var p in f.Parameters)                  {                      if (p.Reference)                      {                          // Use a boxed type instead of primitives (i.e. "Byte" rather than "byte")' since                          // the former are reference types. We don't need to do anything for regular reference                          // types.                          // Hack: we do this by upper-casing the first letter of the type. This should work for                          // all primitive types' but won't work for enums and other reference types. In these                          // cases' we'll just ignore the reference overload.                          if (Char.IsLower(p.CurrentType[0]))                          {                              // Hack: Int -> Integer and Bool -> Boolean                              if (p.CurrentType == "int")                                  sb.Append("Integer");                              else if (p.CurrentType == "bool")                                  sb.Append("Boolean");                              else                                  sb.Append(Char.ToUpper(p.CurrentType[0]) + p.CurrentType.Substring(1));                          }                          else                          {                              valid = false;                              return String.Empty;                          }                      }                      else if (p.Array > 0)                      {                          // Generic arrays are handled in the IntPtr case below.                          if (p.Generic)                          {                              valid = false;                              return String.Empty;                          }                            sb.Append(p.CurrentType);                          for (int i = 0; i < p.Array; i++)                              sb.Append("[]");                      }                      else if (p.Pointer > 0)                      {                          // Java does not support pointers                          // Todo: maybe use one of the java.nio.* pointer classes?                          valid = false;                          return String.Empty;                      }                      else if (p.CurrentType == "IntPtr")                      {                          sb.Append("Buffer");                      }                      else                      {                          sb.Append(p.CurrentType);                      }                        sb.Append(" ");                      sb.Append(p.Name);                      sb.Append("' ");                  }                    if (f.Parameters.Count > 0)                      sb.Remove(sb.Length - 2' 2);              }
Magic Number,Bind,JavaSpecWriter,C:\repos\lachesis_scallion\opentk\Source\Bind\JavaSpecWriter.cs,GenerateParameterString,The following statement contains a magic number: if (f.Parameters.Count > 0)              {                  foreach (var p in f.Parameters)                  {                      if (p.Reference)                      {                          // Use a boxed type instead of primitives (i.e. "Byte" rather than "byte")' since                          // the former are reference types. We don't need to do anything for regular reference                          // types.                          // Hack: we do this by upper-casing the first letter of the type. This should work for                          // all primitive types' but won't work for enums and other reference types. In these                          // cases' we'll just ignore the reference overload.                          if (Char.IsLower(p.CurrentType[0]))                          {                              // Hack: Int -> Integer and Bool -> Boolean                              if (p.CurrentType == "int")                                  sb.Append("Integer");                              else if (p.CurrentType == "bool")                                  sb.Append("Boolean");                              else                                  sb.Append(Char.ToUpper(p.CurrentType[0]) + p.CurrentType.Substring(1));                          }                          else                          {                              valid = false;                              return String.Empty;                          }                      }                      else if (p.Array > 0)                      {                          // Generic arrays are handled in the IntPtr case below.                          if (p.Generic)                          {                              valid = false;                              return String.Empty;                          }                            sb.Append(p.CurrentType);                          for (int i = 0; i < p.Array; i++)                              sb.Append("[]");                      }                      else if (p.Pointer > 0)                      {                          // Java does not support pointers                          // Todo: maybe use one of the java.nio.* pointer classes?                          valid = false;                          return String.Empty;                      }                      else if (p.CurrentType == "IntPtr")                      {                          sb.Append("Buffer");                      }                      else                      {                          sb.Append(p.CurrentType);                      }                        sb.Append(" ");                      sb.Append(p.Name);                      sb.Append("' ");                  }                    if (f.Parameters.Count > 0)                      sb.Remove(sb.Length - 2' 2);              }
Magic Number,Bind,JavaSpecWriter,C:\repos\lachesis_scallion\opentk\Source\Bind\JavaSpecWriter.cs,GenerateGenericTypeString,The following statement contains a magic number: if (parameters.Count() > 0)              {                  var sb = new StringBuilder();                  foreach (var p in f.Parameters.Where(p => p.Generic))                  {                      sb.Append(p.CurrentType);                      sb.Append("' ");                  }                  if (parameters.Count() > 0)                      sb.Remove(sb.Length - 2' 2);                    return sb.ToString();              }
Magic Number,Bind,JavaSpecWriter,C:\repos\lachesis_scallion\opentk\Source\Bind\JavaSpecWriter.cs,GenerateGenericTypeString,The following statement contains a magic number: if (parameters.Count() > 0)              {                  var sb = new StringBuilder();                  foreach (var p in f.Parameters.Where(p => p.Generic))                  {                      sb.Append(p.CurrentType);                      sb.Append("' ");                  }                  if (parameters.Count() > 0)                      sb.Remove(sb.Length - 2' 2);                    return sb.ToString();              }
Magic Number,Bind,MainClass,C:\repos\lachesis_scallion\opentk\Source\Bind\Main.cs,Main,The following statement contains a magic number: try              {                  long ticks = DateTime.Now.Ticks;                    switch (mode)                  {                      case GeneratorMode.GL3:                      case GeneratorMode.GL2:                          Generator = new GL4Generator("OpenGL"' dirName);                          break;                        case GeneratorMode.ES10:                          Generator = new ESGenerator("ES10"' dirName);                          break;                                            case GeneratorMode.ES11:                          Generator = new ESGenerator("ES11"' dirName);                          break;                                            case GeneratorMode.ES20:                          Generator = new ESGenerator("ES20"' dirName);                          break;                        case GeneratorMode.CL10:                          Generator = new CLGenerator("CL10"' dirName);                          break;                                            case GeneratorMode.Unknown:                      default:                          Console.WriteLine("Please specify a generator mode (use '-mode:gl2/gl3/glu/wgl/glx])'");                          return;                  }                    Generator.Process();                  ISpecWriter writer = null;                  switch (Settings.Language)                  {                      case GeneratorLanguage.Cpp:                          writer = new CppSpecWriter();                          break;                        case GeneratorLanguage.Java:                          writer = new JavaSpecWriter();                          break;                        case GeneratorLanguage.CSharp:                      default:                          writer = new CSharpSpecWriter();                          break;                  }                  writer.WriteBindings(Generator);                    ticks = DateTime.Now.Ticks - ticks;                    Console.WriteLine();                  Console.WriteLine("Bindings generated in {0} seconds."' ticks / (double)10000000.0);                  Console.WriteLine();                  if (Debugger.IsAttached)                  {                      Console.WriteLine("Press any key to continue...");                      Console.ReadKey(true);                  }              }              catch (SecurityException e)              {                  Console.WriteLine("Security violation \"{0}\" in method \"{1}\"."' e.Message' e.Method);                  Console.WriteLine("This application does not have permission to take the requested actions.");              }              catch (NotImplementedException e)              {                  Console.WriteLine(e.Message);                  Console.WriteLine("The requested functionality is not implemented yet.");              }
Magic Number,Bind,DocProcessor,C:\repos\lachesis_scallion\opentk\Source\Bind\DocProcessor.cs,ProcessFile,The following statement contains a magic number: while (m.Length > 0)              {                  string removed = Text.Substring(m.Index' m.Length);                  Text = Text.Remove(m.Index' m.Length);                  int equation = removed.IndexOf("eqn");                  if (equation > 0)                  {                      // Find the start and end of the equation string                      int eqn_start = equation + 4;                      int eqn_end = removed.IndexOf(":-->") - equation - 4;                      if (eqn_end < 0)                      {                          // Note: a few docs from man4 delimit eqn end with ": -->"                          eqn_end = removed.IndexOf(": -->") - equation - 4;                      }                      if (eqn_end < 0)                      {                          Console.WriteLine("[Warning] Failed to find equation for mml.");                          goto next;                      }                        string eqn_substring = removed.Substring(eqn_start' eqn_end);                      Text = Text.Insert(m.Index' "<![CDATA[" + eqn_substring + "]]>");                  }                next:                  m = remove_mathml.Match(Text);              }
Magic Number,Bind,DocProcessor,C:\repos\lachesis_scallion\opentk\Source\Bind\DocProcessor.cs,ProcessFile,The following statement contains a magic number: while (m.Length > 0)              {                  string removed = Text.Substring(m.Index' m.Length);                  Text = Text.Remove(m.Index' m.Length);                  int equation = removed.IndexOf("eqn");                  if (equation > 0)                  {                      // Find the start and end of the equation string                      int eqn_start = equation + 4;                      int eqn_end = removed.IndexOf(":-->") - equation - 4;                      if (eqn_end < 0)                      {                          // Note: a few docs from man4 delimit eqn end with ": -->"                          eqn_end = removed.IndexOf(": -->") - equation - 4;                      }                      if (eqn_end < 0)                      {                          Console.WriteLine("[Warning] Failed to find equation for mml.");                          goto next;                      }                        string eqn_substring = removed.Substring(eqn_start' eqn_end);                      Text = Text.Insert(m.Index' "<![CDATA[" + eqn_substring + "]]>");                  }                next:                  m = remove_mathml.Match(Text);              }
Magic Number,Bind,DocProcessor,C:\repos\lachesis_scallion\opentk\Source\Bind\DocProcessor.cs,ProcessFile,The following statement contains a magic number: while (m.Length > 0)              {                  string removed = Text.Substring(m.Index' m.Length);                  Text = Text.Remove(m.Index' m.Length);                  int equation = removed.IndexOf("eqn");                  if (equation > 0)                  {                      // Find the start and end of the equation string                      int eqn_start = equation + 4;                      int eqn_end = removed.IndexOf(":-->") - equation - 4;                      if (eqn_end < 0)                      {                          // Note: a few docs from man4 delimit eqn end with ": -->"                          eqn_end = removed.IndexOf(": -->") - equation - 4;                      }                      if (eqn_end < 0)                      {                          Console.WriteLine("[Warning] Failed to find equation for mml.");                          goto next;                      }                        string eqn_substring = removed.Substring(eqn_start' eqn_end);                      Text = Text.Insert(m.Index' "<![CDATA[" + eqn_substring + "]]>");                  }                next:                  m = remove_mathml.Match(Text);              }
Magic Number,Bind,EnumProcessor,C:\repos\lachesis_scallion\opentk\Source\Bind\EnumProcessor.cs,TranslateConstantValue,The following statement contains a magic number: if (value.ToLower().StartsWith("0x"))              {                  // Trim the unsigned or long specifiers used in C constants ('u' or 'ull').                  if (value.ToLower().EndsWith("ull"))                      value = value.Substring(0' value.Length - 3);                  if (value.ToLower().EndsWith("u"))                      value = value.Substring(0' value.Length - 1);              }
Magic Number,Bind,Utilities,C:\repos\lachesis_scallion\opentk\Source\Bind\Utilities.cs,GetGL2Extension,The following statement contains a magic number: if (match.Success)              {                  string ext = match.Value;                  if (ext.Length > 2)                  {                      ext = ext[0] + ext.Substring(1).ToLower();                  }                  return ext;              }              else              {                  return String.Empty;              }
Magic Number,Bind,XmlSpecReader,C:\repos\lachesis_scallion\opentk\Source\Bind\XmlSpecReader.cs,ReadTypeMap,The following statement contains a magic number: using (var sr = new StreamReader(file))              {                  Console.WriteLine("Reading opengl types.");                  Dictionary<string' string> GLTypes = new Dictionary<string' string>();                    if (sr == null)                      return GLTypes;                    do                  {                      string line = sr.ReadLine();                        if (String.IsNullOrEmpty(line) || line.StartsWith("#"))                          continue;                        string[] words = line.Split(" '*\t".ToCharArray()' StringSplitOptions.RemoveEmptyEntries);                        if (words[0].ToLower() == "void")                      {                          // Special case for "void" -> "". We make it "void" -> "void"                          GLTypes.Add(words[0]' "void");                      }                      else if (words[0] == "VoidPointer" || words[0] == "ConstVoidPointer")                      {                          // "(Const)VoidPointer" -> "void*"                          GLTypes.Add(words[0]' "void*");                      }                      else if (words[0] == "CharPointer" || words[0] == "charPointerARB")                      {                          // The typematching logic cannot handle pointers to pointers' e.g. CharPointer* -> char** -> string* -> string[].                          // Hence we give it a push.                          // Note: When both CurrentType == "String" and Pointer == true' the typematching is hardcoded to use                          // String[] or StringBuilder[].                          GLTypes.Add(words[0]' "String");                      }                      /*else if (words[0].Contains("Pointer"))                      {                          GLTypes.Add(words[0]' words[1].Replace("Pointer"' "*"));                      }*/                      else if (words[1].Contains("GLvoid"))                      {                          GLTypes.Add(words[0]' "void");                      }                      else if (words[1] == "const" && words[2] == "GLubyte")                      {                          GLTypes.Add(words[0]' "String");                      }                      else if (words[1] == "struct")                      {                          GLTypes.Add(words[0]' words[2]);                      }                      else                      {                          GLTypes.Add(words[0]' words[1]);                      }                  }                  while (!sr.EndOfStream);                    return GLTypes;              }
Magic Number,Bind,XmlSpecReader,C:\repos\lachesis_scallion\opentk\Source\Bind\XmlSpecReader.cs,ReadTypeMap,The following statement contains a magic number: using (var sr = new StreamReader(file))              {                  Console.WriteLine("Reading opengl types.");                  Dictionary<string' string> GLTypes = new Dictionary<string' string>();                    if (sr == null)                      return GLTypes;                    do                  {                      string line = sr.ReadLine();                        if (String.IsNullOrEmpty(line) || line.StartsWith("#"))                          continue;                        string[] words = line.Split(" '*\t".ToCharArray()' StringSplitOptions.RemoveEmptyEntries);                        if (words[0].ToLower() == "void")                      {                          // Special case for "void" -> "". We make it "void" -> "void"                          GLTypes.Add(words[0]' "void");                      }                      else if (words[0] == "VoidPointer" || words[0] == "ConstVoidPointer")                      {                          // "(Const)VoidPointer" -> "void*"                          GLTypes.Add(words[0]' "void*");                      }                      else if (words[0] == "CharPointer" || words[0] == "charPointerARB")                      {                          // The typematching logic cannot handle pointers to pointers' e.g. CharPointer* -> char** -> string* -> string[].                          // Hence we give it a push.                          // Note: When both CurrentType == "String" and Pointer == true' the typematching is hardcoded to use                          // String[] or StringBuilder[].                          GLTypes.Add(words[0]' "String");                      }                      /*else if (words[0].Contains("Pointer"))                      {                          GLTypes.Add(words[0]' words[1].Replace("Pointer"' "*"));                      }*/                      else if (words[1].Contains("GLvoid"))                      {                          GLTypes.Add(words[0]' "void");                      }                      else if (words[1] == "const" && words[2] == "GLubyte")                      {                          GLTypes.Add(words[0]' "String");                      }                      else if (words[1] == "struct")                      {                          GLTypes.Add(words[0]' words[2]);                      }                      else                      {                          GLTypes.Add(words[0]' words[1]);                      }                  }                  while (!sr.EndOfStream);                    return GLTypes;              }
Magic Number,Bind,XmlSpecReader,C:\repos\lachesis_scallion\opentk\Source\Bind\XmlSpecReader.cs,ReadCSTypeMap,The following statement contains a magic number: using (var sr = new StreamReader(file))              {                  Dictionary<string' string> CSTypes = new Dictionary<string' string>();                  Console.WriteLine("Reading C# types.");                    while (!sr.EndOfStream)                  {                      string line = sr.ReadLine();                      if (String.IsNullOrEmpty(line) || line.StartsWith("#"))                          continue;                        string[] words = line.Split(" '\t".ToCharArray()' StringSplitOptions.RemoveEmptyEntries);                      if (words.Length < 2)                          continue;                        if (((Settings.Compatibility & Settings.Legacy.NoBoolParameters) != Settings.Legacy.None) && words[1] == "bool")                          words[1] = "Int32";                        CSTypes.Add(words[0]' words[1]);                  }                    return CSTypes;              }
Magic Number,Bind.Structures,FunctionBody,C:\repos\lachesis_scallion\opentk\Source\Bind\Structures\Function.cs,Unindent,The following statement contains a magic number: if (indent.Length >= 4)                  indent = indent.Substring(4);
Magic Number,Bind.Structures,FunctionBody,C:\repos\lachesis_scallion\opentk\Source\Bind\Structures\Function.cs,Unindent,The following statement contains a magic number: if (indent.Length >= 4)                  indent = indent.Substring(4);
Magic Number,Bind.Structures,ParameterCollection,C:\repos\lachesis_scallion\opentk\Source\Bind\Structures\Parameter.cs,BuildToStringCache,The following statement contains a magic number: if (Count > 0)              {                  foreach (Parameter p in this)                  {                      sb.Append(p.ToString(override_unsafe_setting));                      sb.Append("' ");                  }                  sb.Replace("' "' ")"' sb.Length - 2' 2);              }              else                  sb.Append(")");
Magic Number,Bind.Structures,ParameterCollection,C:\repos\lachesis_scallion\opentk\Source\Bind\Structures\Parameter.cs,BuildToStringCache,The following statement contains a magic number: if (Count > 0)              {                  foreach (Parameter p in this)                  {                      sb.Append(p.ToString(override_unsafe_setting));                      sb.Append("' ");                  }                  sb.Replace("' "' ")"' sb.Length - 2' 2);              }              else                  sb.Append(")");
Magic Number,Bind.Structures,ParameterCollection,C:\repos\lachesis_scallion\opentk\Source\Bind\Structures\Parameter.cs,BuildCallStringCache,The following statement contains a magic number: if (Count > 0)              {                  foreach (Parameter p in this)                  {                      if (p.Unchecked)                          sb.Append("unchecked((" + p.QualifiedType + ")");                        if (!p.Generic && p.CurrentType != "object")                      {                          if (p.CurrentType.ToLower().Contains("string"))                          {                              sb.Append(String.Format("({0}{1})"'                                  p.QualifiedType' (p.Array > 0) ? "[]" : ""));                          }                          else if (p.IndirectionLevel != 0)                          {                              if (((Settings.Compatibility & Settings.Legacy.TurnVoidPointersToIntPtr) != Settings.Legacy.None) &&                                  p.Pointer != 0 && p.CurrentType.Contains("void"))                                  sb.Append("(IntPtr)");                              else                              {                                  sb.Append("(");                                  sb.Append(p.QualifiedType);                                  for (int i = 0; i < p.IndirectionLevel; i++)                                      sb.Append("*");                                  sb.Append(")");                              }                          }                          else                          {                              sb.Append(String.Format("({0})"' p.QualifiedType));                          }                      }                        sb.Append(p.Name);                        if (p.Unchecked)                          sb.Append(")");                        sb.Append("' ");                  }                  sb.Replace("' "' ")"' sb.Length - 2' 2);              }              else              {                  sb.Append(")");              }
Magic Number,Bind.Structures,ParameterCollection,C:\repos\lachesis_scallion\opentk\Source\Bind\Structures\Parameter.cs,BuildCallStringCache,The following statement contains a magic number: if (Count > 0)              {                  foreach (Parameter p in this)                  {                      if (p.Unchecked)                          sb.Append("unchecked((" + p.QualifiedType + ")");                        if (!p.Generic && p.CurrentType != "object")                      {                          if (p.CurrentType.ToLower().Contains("string"))                          {                              sb.Append(String.Format("({0}{1})"'                                  p.QualifiedType' (p.Array > 0) ? "[]" : ""));                          }                          else if (p.IndirectionLevel != 0)                          {                              if (((Settings.Compatibility & Settings.Legacy.TurnVoidPointersToIntPtr) != Settings.Legacy.None) &&                                  p.Pointer != 0 && p.CurrentType.Contains("void"))                                  sb.Append("(IntPtr)");                              else                              {                                  sb.Append("(");                                  sb.Append(p.QualifiedType);                                  for (int i = 0; i < p.IndirectionLevel; i++)                                      sb.Append("*");                                  sb.Append(")");                              }                          }                          else                          {                              sb.Append(String.Format("({0})"' p.QualifiedType));                          }                      }                        sb.Append(p.Name);                        if (p.Unchecked)                          sb.Append(")");                        sb.Append("' ");                  }                  sb.Replace("' "' ")"' sb.Length - 2' 2);              }              else              {                  sb.Append(")");              }
Missing Default,Bind,FuncProcessor,C:\repos\lachesis_scallion\opentk\Source\Bind\FuncProcessor.cs,TranslateParameters,The following switch statement is missing a default case: switch (node.Name)                              {                                  case "type":                                      d.Parameters[i].CurrentType = (string)node.TypedValue;                                      break;                                  case "name":                                      d.Parameters[i].Name = (string)node.TypedValue;                                      break;                                  case "flow":                                      d.Parameters[i].Flow = Parameter.GetFlowDirection((string)node.TypedValue);                                      break;                              }
Missing Default,Bind,FuncProcessor,C:\repos\lachesis_scallion\opentk\Source\Bind\FuncProcessor.cs,WrapReturnType,The following switch statement is missing a default case: switch (func.ReturnType.WrapperType)              {                  case WrapperTypes.StringReturnType:                      func.ReturnType.QualifiedType = "String";                      break;              }
Missing Default,Bind,EnumProcessor,C:\repos\lachesis_scallion\opentk\Source\Bind\EnumProcessor.cs,ReplaceConstant,The following switch statement is missing a default case: switch (node.Name)                          {                              case "name": c.Name = (string)node.TypedValue; break;                              case "value": c.Value = (string)node.TypedValue; break;                          }
Missing Default,Bind,XmlSpecReader,C:\repos\lachesis_scallion\opentk\Source\Bind\XmlSpecReader.cs,ReadDelegates,The following switch statement is missing a default case: switch (param.Name)                      {                          case "returns":                              d.ReturnType.CurrentType = param.GetAttribute("type"' String.Empty);                              break;                            case "param":                              Parameter p = new Parameter();                              p.CurrentType = param.GetAttribute("type"' String.Empty);                              p.Name = param.GetAttribute("name"' String.Empty);                                string element_count = param.GetAttribute("elementcount"' String.Empty);                              if (String.IsNullOrEmpty(element_count))                                  element_count = param.GetAttribute("count"' String.Empty);                              if (!String.IsNullOrEmpty(element_count))                                  p.ElementCount = Int32.Parse(element_count);                                p.Flow = Parameter.GetFlowDirection(param.GetAttribute("flow"' String.Empty));                                d.Parameters.Add(p);                              break;                      }
Missing Default,Bind.Structures,Type,C:\repos\lachesis_scallion\opentk\Source\Bind\Structures\Type.cs,GetCLSCompliantType,The following switch statement is missing a default case: switch (CurrentType)                  {                      case "UInt16":                      case "ushort":                          return "Int16";                      case "UInt32":                      case "uint":                          return "Int32";                      case "UInt64":                      case "ulong":                          return "Int64";                      case "SByte":                      case "sbyte":                          return "Byte";                      case "UIntPtr":                          return "IntPtr";                  }
Missing Default,Bind.Structures,Type,C:\repos\lachesis_scallion\opentk\Source\Bind\Structures\Type.cs,Translate,The following switch statement is missing a default case: switch (CurrentType.ToLower())                      {                          case "string": QualifiedType = "String"; break;                      }
