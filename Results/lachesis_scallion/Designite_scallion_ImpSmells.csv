Implementation smell,Namespace,Class,File,Method,Description
Long Method,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The method has 253 lines of code.
Long Method,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PackOne,The method has 141 lines of code.
Long Method,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The method has 234 lines of code.
Complex Method,scallion,Program,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Program.cs,Main,Cyclomatic complexity of the method is 9
Complex Method,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,Cyclomatic complexity of the method is 11
Complex Method,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,Cyclomatic complexity of the method is 9
Complex Method,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,Cyclomatic complexity of the method is 24
Complex Method,Mono.Options,Option,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Options.cs,Option,Cyclomatic complexity of the method is 8
Complex Method,Mono.Options,Option,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Options.cs,ParsePrototype,Cyclomatic complexity of the method is 10
Complex Method,Mono.Options,Option,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Options.cs,AddSeparators,Cyclomatic complexity of the method is 8
Complex Method,Mono.Options,ArgumentSource,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Options.cs,GetArguments,Cyclomatic complexity of the method is 9
Complex Method,Mono.Options,OptionSet,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Options.cs,Parse,Cyclomatic complexity of the method is 8
Complex Method,Mono.Options,OptionSet,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Options.cs,WriteOptionDescriptions,Cyclomatic complexity of the method is 9
Complex Method,Mono.Options,OptionSet,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Options.cs,WriteOptionPrototype,Cyclomatic complexity of the method is 8
Complex Method,Mono.Options,OptionSet,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Options.cs,GetDescription,Cyclomatic complexity of the method is 12
Complex Method,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PackOne,Cyclomatic complexity of the method is 35
Complex Method,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,Cyclomatic complexity of the method is 60
Long Parameter List,scallion,CLKernel,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLContext.cs,CLKernel,The method has 5 parameters. Parameters: deviceId' contextId' commandQueueId' programId' kernelName
Long Parameter List,Mono.Options,OptionSet,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Options.cs,GetOptionParts,The method has 5 parameters. Parameters: argument' flag' name' sep' value
Long Parameter List,Mono.Options,OptionSet,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Options.cs,WriteDescription,The method has 5 parameters. Parameters: o' value' prefix' firstWidth' remWidth
Long Statement,scallion,CLContext,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLContext.cs,CreateAndCompileProgram,The length of the statement  "			if (error != ErrorCode.Success) throw new System.InvalidOperationException(String.Format("Error calling CreateProgramWithSource: {0}"'error)); " is 142.
Long Statement,scallion,CLContext,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLContext.cs,CreateAndCompileProgram,The length of the statement  "				CL.GetProgramBuildInfo(programId' DeviceId' ProgramBuildInfo.ProgramBuildLog' IntPtr.Zero' IntPtr.Zero' (IntPtr*)&parmSize); " is 124.
Long Statement,scallion,CLContext,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLContext.cs,CreateAndCompileProgram,The length of the statement  "					error = (ErrorCode)CL.GetProgramBuildInfo(programId' DeviceId' ProgramBuildInfo.ProgramBuildLog' new IntPtr(&parmSize)' new IntPtr(valuePtr)' (IntPtr*)IntPtr.Zero.ToPointer()); " is 176.
Long Statement,scallion,CLContext,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLContext.cs,CreateAndCompileProgram,The length of the statement  "				if (error != ErrorCode.Success) throw new System.InvalidOperationException(String.Format("Error calling GetProgramBuildInfo: {0}"'error)); " is 138.
Long Statement,scallion,CLBuffer<T>,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLContext.cs,EnqueueWrite,The length of the statement  "			if (error != ErrorCode.Success) throw new System.InvalidOperationException(String.Format("Error calling EnqueueWriteBuffer: {0}"'error)); " is 137.
Long Statement,scallion,CLBuffer<T>,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLContext.cs,EnqueueRead,The length of the statement  "			if (error != ErrorCode.Success) throw new System.InvalidOperationException(String.Format("Error calling EnqueueReadBuffer: {0}"'error)); " is 136.
Long Statement,scallion,CLKernel,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLContext.cs,EnqueueNDRangeKernel,The length of the statement  "			error = (ErrorCode)CL.EnqueueNDRangeKernel(CommandQueueId' KernelId' 1' null' &pglobalWorkSize' &plocalWorkSize' 0' null' null); " is 128.
Long Statement,scallion,CLKernel,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLContext.cs,EnqueueNDRangeKernel,The length of the statement  "			if (error != ErrorCode.Success) throw new System.InvalidOperationException(String.Format("Error calling EnqueueNDRangeKernel: {0}"'error)); " is 139.
Long Statement,scallion,CLKernel,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLContext.cs,SetKernelArgLocal,The length of the statement  "			if (error != ErrorCode.Success) throw new System.InvalidOperationException(String.Format("Error calling SetKernelArg: {0}"'error)); " is 131.
Long Statement,scallion,CLKernel,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLContext.cs,SetKernelArg,The length of the statement  "			if (error != ErrorCode.Success) throw new System.InvalidOperationException(String.Format("Error calling SetKernelArg: {0}"'error)); " is 131.
Long Statement,scallion,CLKernel,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLContext.cs,SetKernelArg,The length of the statement  "			if (error != ErrorCode.Success) throw new System.InvalidOperationException(String.Format("Error calling SetKernelArg: {0}"'error)); " is 131.
Long Statement,scallion,KernelGenerator,D:\research\architectureSmells\repos\lachesis_scallion\scallion\KernelGenerator.cs,GenerateKernel,The length of the statement  "			string kernelFile = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location) + Path.DirectorySeparatorChar + "kernel.cl"; " is 128.
Long Statement,scallion,KernelGenerator,D:\research\architectureSmells\repos\lachesis_scallion\scallion\KernelGenerator.cs,GenerateExpLoadingCode,The length of the statement  "			builder.AppendFormat("W[{0}] |= exp >> {1} & 0x{2:x}u; // OR in the first part of the exp\n"' firstWord' (8*offset)' mask1); " is 124.
Long Statement,scallion,KernelGenerator,D:\research\architectureSmells\repos\lachesis_scallion\scallion\KernelGenerator.cs,GenerateExpLoadingCode,The length of the statement  "			builder.AppendFormat("W[{0}] |= exp << {1} & 0x{2:x}u; // OR in the second part of the exp\n"' firstWord + 1' (32 - 8*offset)' ~mask1); " is 135.
Long Statement,scallion,KernelGenerator,D:\research\architectureSmells\repos\lachesis_scallion\scallion\KernelGenerator.cs,GenerateCheckingCode,The length of the statement  "					       .Select(i => string.Format("    if(DataArray[dataaddr + {0}] == fnv) Results[get_local_id(0) % ResultsArraySize] = exp;"' i))); " is 127.
Long Statement,scallion,Program,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Program.cs,ListDevices,The length of the statement  "                ulong preferredWorkGroupSize = getPreferredWorkGroupSize(device.DeviceId);  // moved to external function as we call it also in Main " is 132.
Long Statement,scallion,Program,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Program.cs,Main,The length of the statement  "			r.Rsa.PublicModulus = BigNumber.FromHexString("00E2FC646FF48AFC8C2A7DDF1B99CECD21A0AEC603DBAAA1A7ADF6836A6CED82BAE694AC5A4ACBD7FC1D36B2C677BE25E400330D295D044C9F6AFAEA45A8CF370F59E398F853FFCED03395D297CEED47C0E9EF2C358C05399E1F8A878E6E044F1AB7D82A162C77EE956B0A9B54C910000EF7122CC8BBB1746872968F05E7CFD563"); " is 308.
Long Statement,scallion,Program,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Program.cs,Main,The length of the statement  "                .Add<uint>("t|cputhreads="' "Specifies the number of CPU threads to use when creating work. (EXPERIMENTAL - OpenSSL not thread-safe)"' (i) => parms.CpuThreads = i) " is 163.
Long Statement,scallion,Program,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Program.cs,Main,The length of the statement  "				.Add("skip-sha-test"' "Skip the SHA-1 test at startup."' (i) => { if (!string.IsNullOrEmpty(i)) parms.SkipShaTest = true; }) " is 124.
Long Statement,scallion,Program,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Program.cs,Main,The length of the statement  "                .Add("c|continue"' "Continue to search for keys rather than exiting when a key is found."' (i) => { if (!string.IsNullOrEmpty(i)) parms.ContinueGeneration = true; }) " is 165.
Long Statement,scallion,Program,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Program.cs,Main,The length of the statement  "                .Add<string>("command="' "When a match is found specified external program is called with key passed to stdin.\nExample: \"--command 'tee example.txt'\" would save the key to example.txt\nIf the command returns with a non-zero exit code' the program will return the same code."' (i) => parms.Command = i) " is 304.
Long Statement,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,pad_data,The length of the statement  "			return (new byte[][] { data' new byte[] {0x80}' new byte[midlength]' Mono.DataConverter.Pack("^L"'new object[] { data.Length*8 }) }).SelectMany(i=>i).ToArray(); " is 160.
Long Statement,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,ToUIntArray,The length of the statement  "				ret[i / 4] = (uint)(padded[i] << 24) | (uint)(padded[i + 1] << 16) | (uint)(padded[i + 2] << 8) | (uint)(padded[i + 3] << 0); " is 125.
Long Statement,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,OutputKey,The length of the statement  "				System.IO.File.AppendAllText(parms.KeyOutputPath'"Public Exponent: " + rsa.Rsa.PublicExponent.ToDecimalString() + "\n"); " is 120.
Long Statement,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The length of the statement  "			//string kernel_text = KernelGenerator.GenerateKernel(parms'gpu_bitmasks.Length/3'max_items_per_key'gpu_bitmasks.Take(3).ToArray()'all_patterns[0]'all_patterns.Length'parms.ExponentIndex); " is 188.
Long Statement,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The length of the statement  "                CLBuffer<uint> bufSuccess = context.CreateBuffer(OpenTK.Compute.CL10.MemFlags.MemReadWrite | OpenTK.Compute.CL10.MemFlags.MemCopyHostPtr' new uint[5]); " is 151.
Long Statement,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The length of the statement  "                String gpuhex = String.Format("{0:x8}{1:x8}{2:x8}{3:x8}{4:x8}"' bufSuccess.Data[0]' bufSuccess.Data[1]' bufSuccess.Data[2]' bufSuccess.Data[3]' bufSuccess.Data[4]);   " is 164.
Long Statement,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The length of the statement  "				bufLastWs = context.CreateBuffer(OpenTK.Compute.CL10.MemFlags.MemReadOnly | OpenTK.Compute.CL10.MemFlags.MemCopyHostPtr' LastWs); " is 129.
Long Statement,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The length of the statement  "				bufMidstates = context.CreateBuffer(OpenTK.Compute.CL10.MemFlags.MemReadOnly | OpenTK.Compute.CL10.MemFlags.MemCopyHostPtr' Midstates); " is 135.
Long Statement,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The length of the statement  "				bufExpIndexes = context.CreateBuffer(OpenTK.Compute.CL10.MemFlags.MemReadOnly | OpenTK.Compute.CL10.MemFlags.MemCopyHostPtr' ExpIndexes); " is 137.
Long Statement,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The length of the statement  "				bufResults = context.CreateBuffer(OpenTK.Compute.CL10.MemFlags.MemReadWrite | OpenTK.Compute.CL10.MemFlags.MemCopyHostPtr' Results); " is 132.
Long Statement,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The length of the statement  "				bufHashTable = context.CreateBuffer(OpenTK.Compute.CL10.MemFlags.MemReadOnly | OpenTK.Compute.CL10.MemFlags.MemCopyHostPtr' parms.ToolConfig.HashTable); " is 152.
Long Statement,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The length of the statement  "				bufDataArray = context.CreateBuffer(OpenTK.Compute.CL10.MemFlags.MemReadOnly | OpenTK.Compute.CL10.MemFlags.MemCopyHostPtr' parms.ToolConfig.PackedPatterns); " is 157.
Long Statement,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The length of the statement  "				bufBitmasks = context.CreateBuffer(OpenTK.Compute.CL10.MemFlags.MemReadOnly | OpenTK.Compute.CL10.MemFlags.MemCopyHostPtr' parms.ToolConfig.PackedBitmasks); " is 156.
Long Statement,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The length of the statement  "				String gpuhashhex = String.Format("{0:x8}{1:x8}{2:x8}{3:x8}{4:x8}"' input.Results[0]' input.Results[1]' input.Results[2]' input.Results[3]' input.Results[4]); " is 158.
Long Statement,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The length of the statement  "							//System.IO.File.WriteAllText(String.Format("/tmp/{0}.sec.asc"' input.Rsa.GPG_fingerprint_string)' input.Rsa.GPG_privkey_export); " is 129.
Long Statement,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The length of the statement  "			Console.WriteLine("{0:0.00} million hashes per second"' ((long)loop * (long)workSize * (long)1000) / (double)profiler.GetTotalMS("total without init") / (double)1000000); " is 170.
Complex Conditional,Mono.Options,Option,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Options.cs,Option,The conditional expression  "Array.IndexOf (names' "<>") >= 0 &&   					((names.Length == 1 && this.type != OptionValueType.None) ||  					 (names.Length > 1 && this.MaxValueCount > 1))"  is complex.
Complex Conditional,Mono.Options,OptionSet,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Options.cs,ParseBool,The conditional expression  "n.Length >= 1 && (n [n.Length-1] == '+' || n [n.Length-1] == '-') &&  					Contains ((rn = n.Substring (0' n.Length-1)))"  is complex.
Complex Conditional,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The conditional expression  "buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0"  is complex.
Virtual Method Call from Constructor,scallion,ToolConfig,D:\research\architectureSmells\repos\lachesis_scallion\scallion\ToolConfig.cs,ToolConfig,The constructor "ToolConfig" calls a virtual method "CreateRegexPattern".
Virtual Method Call from Constructor,scallion,ToolConfig,D:\research\architectureSmells\repos\lachesis_scallion\scallion\ToolConfig.cs,ToolConfig,The constructor "ToolConfig" calls a virtual method "GenerateBitmaskPatterns".
Empty Catch Block,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The method has an empty catch block.
Magic Number,scallion,CLDeviceInfo,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLDeviceInfo.cs,GetDeviceInfo_size_t,The following statement contains a magic number: AddressBits == 32
Magic Number,scallion,KernelGenerator,D:\research\architectureSmells\repos\lachesis_scallion\scallion\KernelGenerator.cs,GenerateExpLoadingCode,The following statement contains a magic number: int firstWord = expIndexInBytes / 4;
Magic Number,scallion,KernelGenerator,D:\research\architectureSmells\repos\lachesis_scallion\scallion\KernelGenerator.cs,GenerateExpLoadingCode,The following statement contains a magic number: int offset = expIndexInBytes % 4;
Magic Number,scallion,KernelGenerator,D:\research\architectureSmells\repos\lachesis_scallion\scallion\KernelGenerator.cs,GenerateExpLoadingCode,The following statement contains a magic number: uint mask1 = 0xFFFFFFFF >> (8 * offset);
Magic Number,scallion,KernelGenerator,D:\research\architectureSmells\repos\lachesis_scallion\scallion\KernelGenerator.cs,GenerateExpLoadingCode,The following statement contains a magic number: builder.AppendFormat("W[{0}] |= exp >> {1} & 0x{2:x}u; // OR in the first part of the exp\n"' firstWord' (8*offset)' mask1);
Magic Number,scallion,KernelGenerator,D:\research\architectureSmells\repos\lachesis_scallion\scallion\KernelGenerator.cs,GenerateExpLoadingCode,The following statement contains a magic number: builder.AppendFormat("W[{0}] |= exp << {1} & 0x{2:x}u; // OR in the second part of the exp\n"' firstWord + 1' (32 - 8*offset)' ~mask1);
Magic Number,scallion,KernelGenerator,D:\research\architectureSmells\repos\lachesis_scallion\scallion\KernelGenerator.cs,GenerateExpLoadingCode,The following statement contains a magic number: builder.AppendFormat("W[{0}] |= exp << {1} & 0x{2:x}u; // OR in the second part of the exp\n"' firstWord + 1' (32 - 8*offset)' ~mask1);
Magic Number,scallion,SingleRegexPattern,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RegexPattern.cs,GeneratePatternsForGpu,The following statement contains a magic number: var charClasses = _parsedRegex.Enumerate().OrderBy(i => i.Value[0] == '.' ? 666 : i.Value.Length).ToArray();
Magic Number,scallion,Program,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Program.cs,Main,The following statement contains a magic number: switch (parms.ProgramMode)              {                  case Mode.Help:                      Help(p);                      break;                  case Mode.ListDevices:                      ListDevices();                      break;                  case Mode.Normal:  		        case Mode.NonOptimized:  		            {  		                // If no Work Group Size provided' then query the selected device for preferred' if not found set to 32.  		                if (parms.WorkGroupSize == 0)  		                {  		                    ulong preferredWorkGroupSize = 32;  		                    uint deviceId = 0;  		                    foreach (CLDeviceInfo device in CLRuntime.GetDevices())  		                    {  		                        if (!device.CompilerAvailable) continue;  		                        if (deviceId == parms.DeviceId)  		                        {  		                            preferredWorkGroupSize = getPreferredWorkGroupSize(device.DeviceId);  		                            break;  		                        }  		                        deviceId++;  		                    }    		                    parms.WorkGroupSize = (uint)preferredWorkGroupSize;  		                }  						  		                Console.CancelKeyPress += new ConsoleCancelEventHandler(Console_CancelKeyPress);  						try {  		                	_runtime.Run(ProgramParameters.Instance);  						}                          catch (ApplicationException e) {                              // these are handled and printed out                              Console.Error.WriteLine(e.Message);                              Environment.Exit(1);                          }  						finally {  							Shutdown();  						}  		            }              break;              }
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,GenerateKey,The following statement contains a magic number: GenerateKey(size'3);
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,GenerateKey,The following statement contains a magic number: Timestamp = (uint)(DateTime.UtcNow - new DateTime(1970'1'1'0'0'0)).TotalSeconds;
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,BigNumberToMPI,The following statement contains a magic number: byte[] mpi = new byte[num.Bytes + 2];
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,BigNumberToMPI,The following statement contains a magic number: mpi[0] = (byte)((num.Bits >> 8) & 0xFFu);
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,BigNumberToMPI,The following statement contains a magic number: Array.Copy(buf' 0' mpi' 2' num.Bytes);
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,GPG_v4Packet,The following statement contains a magic number: byte[] v4pkt = new byte[3 + buf.Length];
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,GPG_v4Packet,The following statement contains a magic number: v4pkt[idx] = (byte)((buf.Length >> 8) & 0xFFu);
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,GPG_pubkey_packet,The following statement contains a magic number: byte[] v4pkt = new byte[6 + 2*2 + Rsa.PublicModulus.Bytes + Rsa.PublicExponent.Bytes];
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,GPG_pubkey_packet,The following statement contains a magic number: byte[] v4pkt = new byte[6 + 2*2 + Rsa.PublicModulus.Bytes + Rsa.PublicExponent.Bytes];
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,GPG_pubkey_packet,The following statement contains a magic number: byte[] v4pkt = new byte[6 + 2*2 + Rsa.PublicModulus.Bytes + Rsa.PublicExponent.Bytes];
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,GPG_pubkey_packet,The following statement contains a magic number: buf = new byte[4];
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,GPG_pubkey_packet,The following statement contains a magic number: exp_index = idx + 2;
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,GPG_privkey_packet,The following statement contains a magic number: int len = 6 + 2*2 + Rsa.PublicModulus.Bytes + Rsa.PublicExponent.Bytes +  					  3 + 2*4 + Rsa.PrivateExponent.Bytes + Rsa.SecretPrimeFactorP.Bytes + Rsa.SecretPrimeFactorQ.Bytes + IPmodQ.Bytes;
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,GPG_privkey_packet,The following statement contains a magic number: int len = 6 + 2*2 + Rsa.PublicModulus.Bytes + Rsa.PublicExponent.Bytes +  					  3 + 2*4 + Rsa.PrivateExponent.Bytes + Rsa.SecretPrimeFactorP.Bytes + Rsa.SecretPrimeFactorQ.Bytes + IPmodQ.Bytes;
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,GPG_privkey_packet,The following statement contains a magic number: int len = 6 + 2*2 + Rsa.PublicModulus.Bytes + Rsa.PublicExponent.Bytes +  					  3 + 2*4 + Rsa.PrivateExponent.Bytes + Rsa.SecretPrimeFactorP.Bytes + Rsa.SecretPrimeFactorQ.Bytes + IPmodQ.Bytes;
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,GPG_privkey_packet,The following statement contains a magic number: int len = 6 + 2*2 + Rsa.PublicModulus.Bytes + Rsa.PublicExponent.Bytes +  					  3 + 2*4 + Rsa.PrivateExponent.Bytes + Rsa.SecretPrimeFactorP.Bytes + Rsa.SecretPrimeFactorQ.Bytes + IPmodQ.Bytes;
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,GPG_privkey_packet,The following statement contains a magic number: int len = 6 + 2*2 + Rsa.PublicModulus.Bytes + Rsa.PublicExponent.Bytes +  					  3 + 2*4 + Rsa.PrivateExponent.Bytes + Rsa.SecretPrimeFactorP.Bytes + Rsa.SecretPrimeFactorQ.Bytes + IPmodQ.Bytes;
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,GPG_privkey_packet,The following statement contains a magic number: int len = 6 + 2*2 + Rsa.PublicModulus.Bytes + Rsa.PublicExponent.Bytes +  					  3 + 2*4 + Rsa.PrivateExponent.Bytes + Rsa.SecretPrimeFactorP.Bytes + Rsa.SecretPrimeFactorQ.Bytes + IPmodQ.Bytes;
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,GPG_privkey_packet,The following statement contains a magic number: buf = new byte[4];
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,GPG_privkey_packet,The following statement contains a magic number: Array.Copy(buf' 0' v4pkt' idx' 4);
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,GPG_privkey_packet,The following statement contains a magic number: idx += 4;
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,GPG_privkey_packet,The following statement contains a magic number: sum = sum % 65536;
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,GPG_privkey_packet,The following statement contains a magic number: buf = new byte[2];
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,Packetize,The following statement contains a magic number: switch (lenlen) {  				case 1:  					length_type = 0;  					break;  				case 2:  					length_type = 1;  					break;  				case 3:  					// Zero-pad length  					byte[] temp = new byte[4];  					Array.Copy(buf' 0' temp' 1' 3);  					temp[0] = 0;  					buf = temp;  					length_type = 2;  					break;  				case 4:  					length_type = 2;  					break;  				default:  					throw new Exception("Invalid length.");  			}
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,Packetize,The following statement contains a magic number: switch (lenlen) {  				case 1:  					length_type = 0;  					break;  				case 2:  					length_type = 1;  					break;  				case 3:  					// Zero-pad length  					byte[] temp = new byte[4];  					Array.Copy(buf' 0' temp' 1' 3);  					temp[0] = 0;  					buf = temp;  					length_type = 2;  					break;  				case 4:  					length_type = 2;  					break;  				default:  					throw new Exception("Invalid length.");  			}
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,Packetize,The following statement contains a magic number: switch (lenlen) {  				case 1:  					length_type = 0;  					break;  				case 2:  					length_type = 1;  					break;  				case 3:  					// Zero-pad length  					byte[] temp = new byte[4];  					Array.Copy(buf' 0' temp' 1' 3);  					temp[0] = 0;  					buf = temp;  					length_type = 2;  					break;  				case 4:  					length_type = 2;  					break;  				default:  					throw new Exception("Invalid length.");  			}
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,Packetize,The following statement contains a magic number: switch (lenlen) {  				case 1:  					length_type = 0;  					break;  				case 2:  					length_type = 1;  					break;  				case 3:  					// Zero-pad length  					byte[] temp = new byte[4];  					Array.Copy(buf' 0' temp' 1' 3);  					temp[0] = 0;  					buf = temp;  					length_type = 2;  					break;  				case 4:  					length_type = 2;  					break;  				default:  					throw new Exception("Invalid length.");  			}
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,Packetize,The following statement contains a magic number: switch (lenlen) {  				case 1:  					length_type = 0;  					break;  				case 2:  					length_type = 1;  					break;  				case 3:  					// Zero-pad length  					byte[] temp = new byte[4];  					Array.Copy(buf' 0' temp' 1' 3);  					temp[0] = 0;  					buf = temp;  					length_type = 2;  					break;  				case 4:  					length_type = 2;  					break;  				default:  					throw new Exception("Invalid length.");  			}
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,Packetize,The following statement contains a magic number: switch (lenlen) {  				case 1:  					length_type = 0;  					break;  				case 2:  					length_type = 1;  					break;  				case 3:  					// Zero-pad length  					byte[] temp = new byte[4];  					Array.Copy(buf' 0' temp' 1' 3);  					temp[0] = 0;  					buf = temp;  					length_type = 2;  					break;  				case 4:  					length_type = 2;  					break;  				default:  					throw new Exception("Invalid length.");  			}
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,Packetize,The following statement contains a magic number: switch (lenlen) {  				case 1:  					length_type = 0;  					break;  				case 2:  					length_type = 1;  					break;  				case 3:  					// Zero-pad length  					byte[] temp = new byte[4];  					Array.Copy(buf' 0' temp' 1' 3);  					temp[0] = 0;  					buf = temp;  					length_type = 2;  					break;  				case 4:  					length_type = 2;  					break;  				default:  					throw new Exception("Invalid length.");  			}
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,Packetize,The following statement contains a magic number: byte header = (byte)(0x80 | ((tag << 2) & 0x3C) | (length_type & 0x03));
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,ascii_armor,The following statement contains a magic number: ChunksUpto(Convert.ToBase64String(input) + "====="' 78)
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,tobase32str,The following statement contains a magic number: int nbits = len * 8;
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,tobase32str,The following statement contains a magic number: v = ((byte)src[bit/8]) << 8;
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,tobase32str,The following statement contains a magic number: v = ((byte)src[bit/8]) << 8;
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,tobase32str,The following statement contains a magic number: v += (byte)src[(bit/8)+1];
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,tobase32str,The following statement contains a magic number: bit+5<nbits
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,tobase32str,The following statement contains a magic number: u = (v >> (11-(bit%8))) & 0x1F;
Magic Number,scallion,RSAWrapper,D:\research\architectureSmells\repos\lachesis_scallion\scallion\RSAWrapper.cs,tobase32str,The following statement contains a magic number: u = (v >> (11-(bit%8))) & 0x1F;
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,pad_data,The following statement contains a magic number: int midlength = 64-data.Length%64-9;
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,pad_data,The following statement contains a magic number: int midlength = 64-data.Length%64-9;
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,pad_data,The following statement contains a magic number: int midlength = 64-data.Length%64-9;
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,pad_data,The following statement contains a magic number: return (new byte[][] { data' new byte[] {0x80}' new byte[midlength]' Mono.DataConverter.Pack("^L"'new object[] { data.Length*8 }) }).SelectMany(i=>i).ToArray();
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: uint[] W = new uint[80];
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: int j = chunk*64 + k*4;
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: int j = chunk*64 + k*4;
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: W[k] = (uint)(data[j+0]<<24 | data[j+1]<<16 | data[j+2]<<8 | data[j+3]);
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: W[k] = (uint)(data[j+0]<<24 | data[j+1]<<16 | data[j+2]<<8 | data[j+3]);
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: W[k] = (uint)(data[j+0]<<24 | data[j+1]<<16 | data[j+2]<<8 | data[j+3]);
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: W[k] = (uint)(data[j+0]<<24 | data[j+1]<<16 | data[j+2]<<8 | data[j+3]);
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: W[k] = (uint)(data[j+0]<<24 | data[j+1]<<16 | data[j+2]<<8 | data[j+3]);
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: k < 16
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: chunk < data.Length/64
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,rotateLeft,The following statement contains a magic number: return  (x << n) | (x >> (32-n));
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: C = H[2];
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: D = H[3];
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: E = H[4];
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: W[i] = rotateLeft(W[i-3] ^ W[i-8] ^ W[i-14] ^ W[i-16]' 1);
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: W[i] = rotateLeft(W[i-3] ^ W[i-8] ^ W[i-14] ^ W[i-16]' 1);
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: W[i] = rotateLeft(W[i-3] ^ W[i-8] ^ W[i-14] ^ W[i-16]' 1);
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: W[i] = rotateLeft(W[i-3] ^ W[i-8] ^ W[i-14] ^ W[i-16]' 1);
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: i < 80
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: temp = rotateLeft(A'5) + ((B & C) | ((~ B) & D)) + E + W[i] + K0;
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: C = rotateLeft(B' 30);
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: i < 20
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: temp = rotateLeft(A' 5) + (B ^ C ^ D) + E + W[i] + K1;
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: C = rotateLeft(B' 30);
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: i < 40
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: temp = rotateLeft(A' 5) + ((B & C) | (B & D) | (C & D)) + E + W[i] + K2;
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: C = rotateLeft(B' 30);
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: i < 60
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: temp = rotateLeft(A' 5) + (B ^ C ^ D)  + E + W[i] + K3;
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: C = rotateLeft(B' 30);
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: i < 80
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: H[2] = (H[2] + C);
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: H[2] = (H[2] + C);
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: H[3] = (H[3] + D);
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: H[3] = (H[3] + D);
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: H[4] = (H[4] + E);
Magic Number,scallion,SHA1,D:\research\architectureSmells\repos\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: H[4] = (H[4] + E);
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,ToUIntArray,The following statement contains a magic number: byte[] padded = new byte[(int)Math.Ceiling(byteArray.Length / 4f) * 4];
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,ToUIntArray,The following statement contains a magic number: byte[] padded = new byte[(int)Math.Ceiling(byteArray.Length / 4f) * 4];
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,ToUIntArray,The following statement contains a magic number: uint[] ret = new uint[(int)Math.Ceiling(padded.Length / 4f)];
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,ToUIntArray,The following statement contains a magic number: ret[i / 4] = (uint)(padded[i] << 24) | (uint)(padded[i + 1] << 16) | (uint)(padded[i + 2] << 8) | (uint)(padded[i + 3] << 0);
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,ToUIntArray,The following statement contains a magic number: ret[i / 4] = (uint)(padded[i] << 24) | (uint)(padded[i + 1] << 16) | (uint)(padded[i + 2] << 8) | (uint)(padded[i + 3] << 0);
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,ToUIntArray,The following statement contains a magic number: ret[i / 4] = (uint)(padded[i] << 24) | (uint)(padded[i + 1] << 16) | (uint)(padded[i + 2] << 8) | (uint)(padded[i + 3] << 0);
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,ToUIntArray,The following statement contains a magic number: ret[i / 4] = (uint)(padded[i] << 24) | (uint)(padded[i + 1] << 16) | (uint)(padded[i + 2] << 8) | (uint)(padded[i + 3] << 0);
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,ToUIntArray,The following statement contains a magic number: ret[i / 4] = (uint)(padded[i] << 24) | (uint)(padded[i + 1] << 16) | (uint)(padded[i + 2] << 8) | (uint)(padded[i + 3] << 0);
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,ToUIntArray,The following statement contains a magic number: ret[i / 4] = (uint)(padded[i] << 24) | (uint)(padded[i + 1] << 16) | (uint)(padded[i + 2] << 8) | (uint)(padded[i + 3] << 0);
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: int nbits = src.Length * 5;
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: nbits % 8 != 0
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: byte[] dest = new byte[srclen * 5 / 8];
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: byte[] dest = new byte[srclen * 5 / 8];
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40)  				{  					case 0:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 3) +  								  (((byte)tmp[(bit / 5) + 1]) >> 2));  						break;  					case 8:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 6) +  								  (((byte)tmp[(bit / 5) + 1]) << 1) +  								  (((byte)tmp[(bit / 5) + 2]) >> 4));  						break;  					case 16:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 4) +  								  (((byte)tmp[(bit / 5) + 1]) >> 1));  						break;  					case 24:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 7) +  								  (((byte)tmp[(bit / 5) + 1]) << 2) +  								  (((byte)tmp[(bit / 5) + 2]) >> 3));  						break;  					case 32:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 5) +  								  ((byte)tmp[(bit / 5) + 1]));  						break;  				}
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40)  				{  					case 0:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 3) +  								  (((byte)tmp[(bit / 5) + 1]) >> 2));  						break;  					case 8:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 6) +  								  (((byte)tmp[(bit / 5) + 1]) << 1) +  								  (((byte)tmp[(bit / 5) + 2]) >> 4));  						break;  					case 16:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 4) +  								  (((byte)tmp[(bit / 5) + 1]) >> 1));  						break;  					case 24:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 7) +  								  (((byte)tmp[(bit / 5) + 1]) << 2) +  								  (((byte)tmp[(bit / 5) + 2]) >> 3));  						break;  					case 32:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 5) +  								  ((byte)tmp[(bit / 5) + 1]));  						break;  				}
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40)  				{  					case 0:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 3) +  								  (((byte)tmp[(bit / 5) + 1]) >> 2));  						break;  					case 8:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 6) +  								  (((byte)tmp[(bit / 5) + 1]) << 1) +  								  (((byte)tmp[(bit / 5) + 2]) >> 4));  						break;  					case 16:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 4) +  								  (((byte)tmp[(bit / 5) + 1]) >> 1));  						break;  					case 24:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 7) +  								  (((byte)tmp[(bit / 5) + 1]) << 2) +  								  (((byte)tmp[(bit / 5) + 2]) >> 3));  						break;  					case 32:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 5) +  								  ((byte)tmp[(bit / 5) + 1]));  						break;  				}
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40)  				{  					case 0:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 3) +  								  (((byte)tmp[(bit / 5) + 1]) >> 2));  						break;  					case 8:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 6) +  								  (((byte)tmp[(bit / 5) + 1]) << 1) +  								  (((byte)tmp[(bit / 5) + 2]) >> 4));  						break;  					case 16:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 4) +  								  (((byte)tmp[(bit / 5) + 1]) >> 1));  						break;  					case 24:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 7) +  								  (((byte)tmp[(bit / 5) + 1]) << 2) +  								  (((byte)tmp[(bit / 5) + 2]) >> 3));  						break;  					case 32:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 5) +  								  ((byte)tmp[(bit / 5) + 1]));  						break;  				}
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40)  				{  					case 0:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 3) +  								  (((byte)tmp[(bit / 5) + 1]) >> 2));  						break;  					case 8:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 6) +  								  (((byte)tmp[(bit / 5) + 1]) << 1) +  								  (((byte)tmp[(bit / 5) + 2]) >> 4));  						break;  					case 16:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 4) +  								  (((byte)tmp[(bit / 5) + 1]) >> 1));  						break;  					case 24:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 7) +  								  (((byte)tmp[(bit / 5) + 1]) << 2) +  								  (((byte)tmp[(bit / 5) + 2]) >> 3));  						break;  					case 32:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 5) +  								  ((byte)tmp[(bit / 5) + 1]));  						break;  				}
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40)  				{  					case 0:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 3) +  								  (((byte)tmp[(bit / 5) + 1]) >> 2));  						break;  					case 8:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 6) +  								  (((byte)tmp[(bit / 5) + 1]) << 1) +  								  (((byte)tmp[(bit / 5) + 2]) >> 4));  						break;  					case 16:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 4) +  								  (((byte)tmp[(bit / 5) + 1]) >> 1));  						break;  					case 24:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 7) +  								  (((byte)tmp[(bit / 5) + 1]) << 2) +  								  (((byte)tmp[(bit / 5) + 2]) >> 3));  						break;  					case 32:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 5) +  								  ((byte)tmp[(bit / 5) + 1]));  						break;  				}
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40)  				{  					case 0:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 3) +  								  (((byte)tmp[(bit / 5) + 1]) >> 2));  						break;  					case 8:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 6) +  								  (((byte)tmp[(bit / 5) + 1]) << 1) +  								  (((byte)tmp[(bit / 5) + 2]) >> 4));  						break;  					case 16:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 4) +  								  (((byte)tmp[(bit / 5) + 1]) >> 1));  						break;  					case 24:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 7) +  								  (((byte)tmp[(bit / 5) + 1]) << 2) +  								  (((byte)tmp[(bit / 5) + 2]) >> 3));  						break;  					case 32:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 5) +  								  ((byte)tmp[(bit / 5) + 1]));  						break;  				}
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40)  				{  					case 0:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 3) +  								  (((byte)tmp[(bit / 5) + 1]) >> 2));  						break;  					case 8:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 6) +  								  (((byte)tmp[(bit / 5) + 1]) << 1) +  								  (((byte)tmp[(bit / 5) + 2]) >> 4));  						break;  					case 16:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 4) +  								  (((byte)tmp[(bit / 5) + 1]) >> 1));  						break;  					case 24:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 7) +  								  (((byte)tmp[(bit / 5) + 1]) << 2) +  								  (((byte)tmp[(bit / 5) + 2]) >> 3));  						break;  					case 32:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 5) +  								  ((byte)tmp[(bit / 5) + 1]));  						break;  				}
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40)  				{  					case 0:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 3) +  								  (((byte)tmp[(bit / 5) + 1]) >> 2));  						break;  					case 8:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 6) +  								  (((byte)tmp[(bit / 5) + 1]) << 1) +  								  (((byte)tmp[(bit / 5) + 2]) >> 4));  						break;  					case 16:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 4) +  								  (((byte)tmp[(bit / 5) + 1]) >> 1));  						break;  					case 24:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 7) +  								  (((byte)tmp[(bit / 5) + 1]) << 2) +  								  (((byte)tmp[(bit / 5) + 2]) >> 3));  						break;  					case 32:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 5) +  								  ((byte)tmp[(bit / 5) + 1]));  						break;  				}
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40)  				{  					case 0:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 3) +  								  (((byte)tmp[(bit / 5) + 1]) >> 2));  						break;  					case 8:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 6) +  								  (((byte)tmp[(bit / 5) + 1]) << 1) +  								  (((byte)tmp[(bit / 5) + 2]) >> 4));  						break;  					case 16:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 4) +  								  (((byte)tmp[(bit / 5) + 1]) >> 1));  						break;  					case 24:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 7) +  								  (((byte)tmp[(bit / 5) + 1]) << 2) +  								  (((byte)tmp[(bit / 5) + 2]) >> 3));  						break;  					case 32:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 5) +  								  ((byte)tmp[(bit / 5) + 1]));  						break;  				}
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40)  				{  					case 0:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 3) +  								  (((byte)tmp[(bit / 5) + 1]) >> 2));  						break;  					case 8:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 6) +  								  (((byte)tmp[(bit / 5) + 1]) << 1) +  								  (((byte)tmp[(bit / 5) + 2]) >> 4));  						break;  					case 16:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 4) +  								  (((byte)tmp[(bit / 5) + 1]) >> 1));  						break;  					case 24:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 7) +  								  (((byte)tmp[(bit / 5) + 1]) << 2) +  								  (((byte)tmp[(bit / 5) + 2]) >> 3));  						break;  					case 32:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 5) +  								  ((byte)tmp[(bit / 5) + 1]));  						break;  				}
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40)  				{  					case 0:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 3) +  								  (((byte)tmp[(bit / 5) + 1]) >> 2));  						break;  					case 8:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 6) +  								  (((byte)tmp[(bit / 5) + 1]) << 1) +  								  (((byte)tmp[(bit / 5) + 2]) >> 4));  						break;  					case 16:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 4) +  								  (((byte)tmp[(bit / 5) + 1]) >> 1));  						break;  					case 24:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 7) +  								  (((byte)tmp[(bit / 5) + 1]) << 2) +  								  (((byte)tmp[(bit / 5) + 2]) >> 3));  						break;  					case 32:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 5) +  								  ((byte)tmp[(bit / 5) + 1]));  						break;  				}
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40)  				{  					case 0:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 3) +  								  (((byte)tmp[(bit / 5) + 1]) >> 2));  						break;  					case 8:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 6) +  								  (((byte)tmp[(bit / 5) + 1]) << 1) +  								  (((byte)tmp[(bit / 5) + 2]) >> 4));  						break;  					case 16:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 4) +  								  (((byte)tmp[(bit / 5) + 1]) >> 1));  						break;  					case 24:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 7) +  								  (((byte)tmp[(bit / 5) + 1]) << 2) +  								  (((byte)tmp[(bit / 5) + 2]) >> 3));  						break;  					case 32:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 5) +  								  ((byte)tmp[(bit / 5) + 1]));  						break;  				}
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40)  				{  					case 0:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 3) +  								  (((byte)tmp[(bit / 5) + 1]) >> 2));  						break;  					case 8:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 6) +  								  (((byte)tmp[(bit / 5) + 1]) << 1) +  								  (((byte)tmp[(bit / 5) + 2]) >> 4));  						break;  					case 16:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 4) +  								  (((byte)tmp[(bit / 5) + 1]) >> 1));  						break;  					case 24:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 7) +  								  (((byte)tmp[(bit / 5) + 1]) << 2) +  								  (((byte)tmp[(bit / 5) + 2]) >> 3));  						break;  					case 32:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 5) +  								  ((byte)tmp[(bit / 5) + 1]));  						break;  				}
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40)  				{  					case 0:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 3) +  								  (((byte)tmp[(bit / 5) + 1]) >> 2));  						break;  					case 8:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 6) +  								  (((byte)tmp[(bit / 5) + 1]) << 1) +  								  (((byte)tmp[(bit / 5) + 2]) >> 4));  						break;  					case 16:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 4) +  								  (((byte)tmp[(bit / 5) + 1]) >> 1));  						break;  					case 24:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 7) +  								  (((byte)tmp[(bit / 5) + 1]) << 2) +  								  (((byte)tmp[(bit / 5) + 2]) >> 3));  						break;  					case 32:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 5) +  								  ((byte)tmp[(bit / 5) + 1]));  						break;  				}
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40)  				{  					case 0:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 3) +  								  (((byte)tmp[(bit / 5) + 1]) >> 2));  						break;  					case 8:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 6) +  								  (((byte)tmp[(bit / 5) + 1]) << 1) +  								  (((byte)tmp[(bit / 5) + 2]) >> 4));  						break;  					case 16:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 4) +  								  (((byte)tmp[(bit / 5) + 1]) >> 1));  						break;  					case 24:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 7) +  								  (((byte)tmp[(bit / 5) + 1]) << 2) +  								  (((byte)tmp[(bit / 5) + 2]) >> 3));  						break;  					case 32:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 5) +  								  ((byte)tmp[(bit / 5) + 1]));  						break;  				}
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40)  				{  					case 0:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 3) +  								  (((byte)tmp[(bit / 5) + 1]) >> 2));  						break;  					case 8:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 6) +  								  (((byte)tmp[(bit / 5) + 1]) << 1) +  								  (((byte)tmp[(bit / 5) + 2]) >> 4));  						break;  					case 16:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 4) +  								  (((byte)tmp[(bit / 5) + 1]) >> 1));  						break;  					case 24:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 7) +  								  (((byte)tmp[(bit / 5) + 1]) << 2) +  								  (((byte)tmp[(bit / 5) + 2]) >> 3));  						break;  					case 32:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 5) +  								  ((byte)tmp[(bit / 5) + 1]));  						break;  				}
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40)  				{  					case 0:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 3) +  								  (((byte)tmp[(bit / 5) + 1]) >> 2));  						break;  					case 8:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 6) +  								  (((byte)tmp[(bit / 5) + 1]) << 1) +  								  (((byte)tmp[(bit / 5) + 2]) >> 4));  						break;  					case 16:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 4) +  								  (((byte)tmp[(bit / 5) + 1]) >> 1));  						break;  					case 24:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 7) +  								  (((byte)tmp[(bit / 5) + 1]) << 2) +  								  (((byte)tmp[(bit / 5) + 2]) >> 3));  						break;  					case 32:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 5) +  								  ((byte)tmp[(bit / 5) + 1]));  						break;  				}
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40)  				{  					case 0:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 3) +  								  (((byte)tmp[(bit / 5) + 1]) >> 2));  						break;  					case 8:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 6) +  								  (((byte)tmp[(bit / 5) + 1]) << 1) +  								  (((byte)tmp[(bit / 5) + 2]) >> 4));  						break;  					case 16:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 4) +  								  (((byte)tmp[(bit / 5) + 1]) >> 1));  						break;  					case 24:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 7) +  								  (((byte)tmp[(bit / 5) + 1]) << 2) +  								  (((byte)tmp[(bit / 5) + 2]) >> 3));  						break;  					case 32:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 5) +  								  ((byte)tmp[(bit / 5) + 1]));  						break;  				}
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40)  				{  					case 0:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 3) +  								  (((byte)tmp[(bit / 5) + 1]) >> 2));  						break;  					case 8:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 6) +  								  (((byte)tmp[(bit / 5) + 1]) << 1) +  								  (((byte)tmp[(bit / 5) + 2]) >> 4));  						break;  					case 16:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 4) +  								  (((byte)tmp[(bit / 5) + 1]) >> 1));  						break;  					case 24:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 7) +  								  (((byte)tmp[(bit / 5) + 1]) << 2) +  								  (((byte)tmp[(bit / 5) + 2]) >> 3));  						break;  					case 32:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 5) +  								  ((byte)tmp[(bit / 5) + 1]));  						break;  				}
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40)  				{  					case 0:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 3) +  								  (((byte)tmp[(bit / 5) + 1]) >> 2));  						break;  					case 8:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 6) +  								  (((byte)tmp[(bit / 5) + 1]) << 1) +  								  (((byte)tmp[(bit / 5) + 2]) >> 4));  						break;  					case 16:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 4) +  								  (((byte)tmp[(bit / 5) + 1]) >> 1));  						break;  					case 24:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 7) +  								  (((byte)tmp[(bit / 5) + 1]) << 2) +  								  (((byte)tmp[(bit / 5) + 2]) >> 3));  						break;  					case 32:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 5) +  								  ((byte)tmp[(bit / 5) + 1]));  						break;  				}
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40)  				{  					case 0:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 3) +  								  (((byte)tmp[(bit / 5) + 1]) >> 2));  						break;  					case 8:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 6) +  								  (((byte)tmp[(bit / 5) + 1]) << 1) +  								  (((byte)tmp[(bit / 5) + 2]) >> 4));  						break;  					case 16:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 4) +  								  (((byte)tmp[(bit / 5) + 1]) >> 1));  						break;  					case 24:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 7) +  								  (((byte)tmp[(bit / 5) + 1]) << 2) +  								  (((byte)tmp[(bit / 5) + 2]) >> 3));  						break;  					case 32:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 5) +  								  ((byte)tmp[(bit / 5) + 1]));  						break;  				}
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40)  				{  					case 0:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 3) +  								  (((byte)tmp[(bit / 5) + 1]) >> 2));  						break;  					case 8:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 6) +  								  (((byte)tmp[(bit / 5) + 1]) << 1) +  								  (((byte)tmp[(bit / 5) + 2]) >> 4));  						break;  					case 16:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 4) +  								  (((byte)tmp[(bit / 5) + 1]) >> 1));  						break;  					case 24:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 7) +  								  (((byte)tmp[(bit / 5) + 1]) << 2) +  								  (((byte)tmp[(bit / 5) + 2]) >> 3));  						break;  					case 32:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 5) +  								  ((byte)tmp[(bit / 5) + 1]));  						break;  				}
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40)  				{  					case 0:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 3) +  								  (((byte)tmp[(bit / 5) + 1]) >> 2));  						break;  					case 8:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 6) +  								  (((byte)tmp[(bit / 5) + 1]) << 1) +  								  (((byte)tmp[(bit / 5) + 2]) >> 4));  						break;  					case 16:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 4) +  								  (((byte)tmp[(bit / 5) + 1]) >> 1));  						break;  					case 24:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 7) +  								  (((byte)tmp[(bit / 5) + 1]) << 2) +  								  (((byte)tmp[(bit / 5) + 2]) >> 3));  						break;  					case 32:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 5) +  								  ((byte)tmp[(bit / 5) + 1]));  						break;  				}
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40)  				{  					case 0:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 3) +  								  (((byte)tmp[(bit / 5) + 1]) >> 2));  						break;  					case 8:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 6) +  								  (((byte)tmp[(bit / 5) + 1]) << 1) +  								  (((byte)tmp[(bit / 5) + 2]) >> 4));  						break;  					case 16:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 4) +  								  (((byte)tmp[(bit / 5) + 1]) >> 1));  						break;  					case 24:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 7) +  								  (((byte)tmp[(bit / 5) + 1]) << 2) +  								  (((byte)tmp[(bit / 5) + 2]) >> 3));  						break;  					case 32:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 5) +  								  ((byte)tmp[(bit / 5) + 1]));  						break;  				}
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40)  				{  					case 0:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 3) +  								  (((byte)tmp[(bit / 5) + 1]) >> 2));  						break;  					case 8:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 6) +  								  (((byte)tmp[(bit / 5) + 1]) << 1) +  								  (((byte)tmp[(bit / 5) + 2]) >> 4));  						break;  					case 16:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 4) +  								  (((byte)tmp[(bit / 5) + 1]) >> 1));  						break;  					case 24:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 7) +  								  (((byte)tmp[(bit / 5) + 1]) << 2) +  								  (((byte)tmp[(bit / 5) + 2]) >> 3));  						break;  					case 32:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 5) +  								  ((byte)tmp[(bit / 5) + 1]));  						break;  				}
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40)  				{  					case 0:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 3) +  								  (((byte)tmp[(bit / 5) + 1]) >> 2));  						break;  					case 8:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 6) +  								  (((byte)tmp[(bit / 5) + 1]) << 1) +  								  (((byte)tmp[(bit / 5) + 2]) >> 4));  						break;  					case 16:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 4) +  								  (((byte)tmp[(bit / 5) + 1]) >> 1));  						break;  					case 24:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 7) +  								  (((byte)tmp[(bit / 5) + 1]) << 2) +  								  (((byte)tmp[(bit / 5) + 2]) >> 3));  						break;  					case 32:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 5) +  								  ((byte)tmp[(bit / 5) + 1]));  						break;  				}
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40)  				{  					case 0:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 3) +  								  (((byte)tmp[(bit / 5) + 1]) >> 2));  						break;  					case 8:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 6) +  								  (((byte)tmp[(bit / 5) + 1]) << 1) +  								  (((byte)tmp[(bit / 5) + 2]) >> 4));  						break;  					case 16:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 4) +  								  (((byte)tmp[(bit / 5) + 1]) >> 1));  						break;  					case 24:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 7) +  								  (((byte)tmp[(bit / 5) + 1]) << 2) +  								  (((byte)tmp[(bit / 5) + 2]) >> 3));  						break;  					case 32:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 5) +  								  ((byte)tmp[(bit / 5) + 1]));  						break;  				}
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,ToBase32Str,The following statement contains a magic number: int nbits = src.Length * 8;
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,ToBase32Str,The following statement contains a magic number: nbits % 5 != 0
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,ToBase32Str,The following statement contains a magic number: v = ((byte)src[bit / 8]) << 8;
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,ToBase32Str,The following statement contains a magic number: v = ((byte)src[bit / 8]) << 8;
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,ToBase32Str,The following statement contains a magic number: v += (byte)src[(bit / 8) + 1];
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,ToBase32Str,The following statement contains a magic number: bit + 5 < nbits
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,ToBase32Str,The following statement contains a magic number: u = (v >> (11 - (bit % 8))) & 0x1F;
Magic Number,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,ToBase32Str,The following statement contains a magic number: u = (v >> (11 - (bit % 8))) & 0x1F;
Magic Number,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,The following statement contains a magic number: inputQueueIsLow = _kernelInput.Count < 300;
Magic Number,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,The following statement contains a magic number: exp_index %= 64;
Magic Number,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,The following statement contains a magic number: Ws.Last().Take(16).ToArray().CopyTo(input.LastWs' 0);
Magic Number,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,The following statement contains a magic number: parms.ToolConfig.MinimumExponent + workSize * 2 * i >= parms.ToolConfig.MaximumExponent
Magic Number,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,The following statement contains a magic number: inputs.Add(new KernelInput(input' parms.ToolConfig.MinimumExponent + workSize * 2 * i));
Magic Number,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,The following statement contains a magic number: i < (parms.ToolConfig.MaximumExponent - parms.ToolConfig.MinimumExponent) / 2 / workSize - 1
Magic Number,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,The following statement contains a magic number: Thread.Sleep(50);
Magic Number,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: CLBuffer<uint> bufSuccess = context.CreateBuffer(OpenTK.Compute.CL10.MemFlags.MemReadWrite | OpenTK.Compute.CL10.MemFlags.MemCopyHostPtr' new uint[5]);
Magic Number,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: StringBuilder cpuhex = new StringBuilder(cpuhash.Length * 2);
Magic Number,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: String gpuhex = String.Format("{0:x8}{1:x8}{2:x8}{3:x8}{4:x8}"' bufSuccess.Data[0]' bufSuccess.Data[1]' bufSuccess.Data[2]' bufSuccess.Data[3]' bufSuccess.Data[4]);
Magic Number,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: String gpuhex = String.Format("{0:x8}{1:x8}{2:x8}{3:x8}{4:x8}"' bufSuccess.Data[0]' bufSuccess.Data[1]' bufSuccess.Data[2]' bufSuccess.Data[3]' bufSuccess.Data[4]);
Magic Number,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: String gpuhex = String.Format("{0:x8}{1:x8}{2:x8}{3:x8}{4:x8}"' bufSuccess.Data[0]' bufSuccess.Data[1]' bufSuccess.Data[2]' bufSuccess.Data[3]' bufSuccess.Data[4]);
Magic Number,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: uint[] LastWs = new uint[num_exps * 16];
Magic Number,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: uint[] Midstates = new uint[num_exps * 5];
Magic Number,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: uint[] Results = new uint[128];
Magic Number,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: kernel.SetKernelArg(2' bufResults);
Magic Number,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: kernel.SetKernelArg(3' (uint)parms.ToolConfig.MinimumExponent);
Magic Number,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: kernel.SetKernelArg(4' (byte)parms.ExponentIndex);
Magic Number,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: kernel.SetKernelArg(5' bufExpIndexes);
Magic Number,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: kernel.SetKernelArg(6' bufBitmasks);
Magic Number,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: kernel.SetKernelArg(7' bufHashTable);
Magic Number,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: kernel.SetKernelArg(8' bufDataArray);
Magic Number,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: Thread.Sleep(3000);
Magic Number,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: Thread.Sleep(2500);
Magic Number,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: kernel.SetKernelArg(3' input.BaseExp);
Magic Number,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: Console.Write("LoopIteration:{0}  HashCount:{1:0.00}MH  Speed:{2:0.0}MH/s  Runtime:{3}  Predicted:{4}  "'   				              loop' hashes / 1000000.0d' hashes/gpu_runtime_sw.ElapsedMilliseconds/1000.0d'   				              gpu_runtime_sw.Elapsed.ToString().Split('.')[0]'   				              parms.ToolConfig.PredictRuntime(hashes * 1000/gpu_runtime_sw.ElapsedMilliseconds));
Magic Number,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: Console.Write("LoopIteration:{0}  HashCount:{1:0.00}MH  Speed:{2:0.0}MH/s  Runtime:{3}  Predicted:{4}  "'   				              loop' hashes / 1000000.0d' hashes/gpu_runtime_sw.ElapsedMilliseconds/1000.0d'   				              gpu_runtime_sw.Elapsed.ToString().Split('.')[0]'   				              parms.ToolConfig.PredictRuntime(hashes * 1000/gpu_runtime_sw.ElapsedMilliseconds));
Magic Number,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: Console.Write("LoopIteration:{0}  HashCount:{1:0.00}MH  Speed:{2:0.0}MH/s  Runtime:{3}  Predicted:{4}  "'   				              loop' hashes / 1000000.0d' hashes/gpu_runtime_sw.ElapsedMilliseconds/1000.0d'   				              gpu_runtime_sw.Elapsed.ToString().Split('.')[0]'   				              parms.ToolConfig.PredictRuntime(hashes * 1000/gpu_runtime_sw.ElapsedMilliseconds));
Magic Number,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: Console.WriteLine("{0:0.00} million hashes per second"' ((long)loop * (long)workSize * (long)1000) / (double)profiler.GetTotalMS("total without init") / (double)1000000);
Magic Number,scallion,CLRuntime,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: Console.WriteLine("{0:0.00} million hashes per second"' ((long)loop * (long)workSize * (long)1000) / (double)profiler.GetTotalMS("total without init") / (double)1000000);
Magic Number,scallion,KernelInput,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,KernelInput,The following statement contains a magic number: LastWs = new uint[num_exps * 16];
Magic Number,scallion,KernelInput,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,KernelInput,The following statement contains a magic number: Midstates = new uint[num_exps * 5];
Magic Number,scallion,KernelInput,D:\research\architectureSmells\repos\lachesis_scallion\scallion\CLRuntime.cs,KernelInput,The following statement contains a magic number: Results = new uint[128];
Magic Number,scallion,Profiler,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Profiler.cs,GetSummaryString,The following statement contains a magic number: double rate = total_ms != 0 ? count * 1000 / (double)total_ms : 0;
Magic Number,scallion,Util,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Util.cs,ExecExternalCommand,The following statement contains a magic number: string[] commandParts = command.Split(new char[] { ' ' }' 2);
Magic Number,scallion,Util,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Util.cs,Rotate5,The following statement contains a magic number: return (a << 5) | (a >> 27);
Magic Number,scallion,Util,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Util.cs,Rotate5,The following statement contains a magic number: return (a << 5) | (a >> 27);
Magic Number,scallion,Util,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Util.cs,FNV10,The following statement contains a magic number: return (ushort)(((f >> 10) ^ f) & (uint)1023);
Magic Number,scallion,Util,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Util.cs,FNV10,The following statement contains a magic number: return (ushort)(((f >> 10) ^ f) & (uint)1023);
Magic Number,scallion,Util,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Util.cs,GetDerLen,The following statement contains a magic number: tmp >>= 8;
Magic Number,scallion,Util,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Util.cs,GetDerLen,The following statement contains a magic number: ((val >> 8*(len-1)) & 0x80) == 0x80
Magic Number,scallion,ToolConfig,D:\research\architectureSmells\repos\lachesis_scallion\scallion\ToolConfig.cs,CreateHashTableAndPackPatterns,The following statement contains a magic number: hashTable = new ushort[1024];
Magic Number,scallion,ToolConfig,D:\research\architectureSmells\repos\lachesis_scallion\scallion\ToolConfig.cs,PredictRuntime,The following statement contains a magic number: return TimeSpan.FromSeconds(Math.Min(TimeSpan.MaxValue.TotalSeconds * 0.99' PredictRuntimeInSeconds(hashRate)));
Magic Number,scallion,GpgToolConfig,D:\research\architectureSmells\repos\lachesis_scallion\scallion\GpgToolConfig.cs,PredictRuntimeInSeconds,The following statement contains a magic number: var hashes_per_win = _regex.GenerateAllPatternsForRegex().Select(t=>Math.Pow(2'4*t.Count(q=>q!='.') - 1)).Sum();
Magic Number,scallion,GpgToolConfig,D:\research\architectureSmells\repos\lachesis_scallion\scallion\GpgToolConfig.cs,PredictRuntimeInSeconds,The following statement contains a magic number: var hashes_per_win = _regex.GenerateAllPatternsForRegex().Select(t=>Math.Pow(2'4*t.Count(q=>q!='.') - 1)).Sum();
Magic Number,scallion,GpgToolConfig,D:\research\architectureSmells\repos\lachesis_scallion\scallion\GpgToolConfig.cs,CreateRegexPattern,The following statement contains a magic number: return new RegexPattern(pattern' 40' "0123456789abcdef");
Magic Number,scallion,GpgToolConfig,D:\research\architectureSmells\repos\lachesis_scallion\scallion\GpgToolConfig.cs,GenerateBitmaskPatterns,The following statement contains a magic number: Func<string' byte[]> hexToBytes = (hex) => {  				return Enumerable.Range(0' hex.Length)  					      .Where(x => x % 2 == 0)  						  .Select(x => Convert.ToByte(hex.Substring(x' 2)' 16))  						  .ToArray();  			};
Magic Number,scallion,GpgToolConfig,D:\research\architectureSmells\repos\lachesis_scallion\scallion\GpgToolConfig.cs,GenerateBitmaskPatterns,The following statement contains a magic number: Func<string' byte[]> hexToBytes = (hex) => {  				return Enumerable.Range(0' hex.Length)  					      .Where(x => x % 2 == 0)  						  .Select(x => Convert.ToByte(hex.Substring(x' 2)' 16))  						  .ToArray();  			};
Magic Number,scallion,GpgToolConfig,D:\research\architectureSmells\repos\lachesis_scallion\scallion\GpgToolConfig.cs,GenerateBitmaskPatterns,The following statement contains a magic number: Func<string' byte[]> hexToBytes = (hex) => {  				return Enumerable.Range(0' hex.Length)  					      .Where(x => x % 2 == 0)  						  .Select(x => Convert.ToByte(hex.Substring(x' 2)' 16))  						  .ToArray();  			};
Magic Number,scallion,GpgToolConfig,D:\research\architectureSmells\repos\lachesis_scallion\scallion\GpgToolConfig.cs,GenerateBitmaskPatterns,The following statement contains a magic number: return _regex.GeneratePatternsForGpu(9)  					.GroupBy(i => _regex.ConvertPatternToBitmask(i))  					.Select(i => {  						uint[] bitmask = TorBase32.ToUIntArray(hexToBytes(                              Regex.Replace(i.Key.ToLower()' "[^.]"' "f").Replace("."' "0")  						).PadLeft(20)); // 20 bytes = 40 hex chars = 160 bits                            return new BitmaskPatternsTuple(                              bitmask'                              i.Select(j => TorBase32.ToUIntArray(hexToBytes(j.Replace('.'' '0')).PadLeft(20)))                          );                      })  					.ToList();
Magic Number,scallion,GpgToolConfig,D:\research\architectureSmells\repos\lachesis_scallion\scallion\GpgToolConfig.cs,GenerateBitmaskPatterns,The following statement contains a magic number: return _regex.GeneratePatternsForGpu(9)  					.GroupBy(i => _regex.ConvertPatternToBitmask(i))  					.Select(i => {  						uint[] bitmask = TorBase32.ToUIntArray(hexToBytes(                              Regex.Replace(i.Key.ToLower()' "[^.]"' "f").Replace("."' "0")  						).PadLeft(20)); // 20 bytes = 40 hex chars = 160 bits                            return new BitmaskPatternsTuple(                              bitmask'                              i.Select(j => TorBase32.ToUIntArray(hexToBytes(j.Replace('.'' '0')).PadLeft(20)))                          );                      })  					.ToList();
Magic Number,scallion,GpgToolConfig,D:\research\architectureSmells\repos\lachesis_scallion\scallion\GpgToolConfig.cs,GenerateBitmaskPatterns,The following statement contains a magic number: return _regex.GeneratePatternsForGpu(9)  					.GroupBy(i => _regex.ConvertPatternToBitmask(i))  					.Select(i => {  						uint[] bitmask = TorBase32.ToUIntArray(hexToBytes(                              Regex.Replace(i.Key.ToLower()' "[^.]"' "f").Replace("."' "0")  						).PadLeft(20)); // 20 bytes = 40 hex chars = 160 bits                            return new BitmaskPatternsTuple(                              bitmask'                              i.Select(j => TorBase32.ToUIntArray(hexToBytes(j.Replace('.'' '0')).PadLeft(20)))                          );                      })  					.ToList();
Magic Number,scallion,OnionToolConfig,D:\research\architectureSmells\repos\lachesis_scallion\scallion\OnionToolConfig.cs,PredictRuntimeInSeconds,The following statement contains a magic number: var hashes_per_win = _regex.GenerateAllPatternsForRegex().Select(t=>Math.Pow(2'5*t.Count(q=>q!='.') - 1)).Sum();
Magic Number,scallion,OnionToolConfig,D:\research\architectureSmells\repos\lachesis_scallion\scallion\OnionToolConfig.cs,PredictRuntimeInSeconds,The following statement contains a magic number: var hashes_per_win = _regex.GenerateAllPatternsForRegex().Select(t=>Math.Pow(2'5*t.Count(q=>q!='.') - 1)).Sum();
Magic Number,scallion,OnionToolConfig,D:\research\architectureSmells\repos\lachesis_scallion\scallion\OnionToolConfig.cs,CreateRegexPattern,The following statement contains a magic number: return new RegexPattern(pattern' 16' "abcdefghijklmnopqrstuvwxyz234567");
Magic Number,scallion,OnionToolConfig,D:\research\architectureSmells\repos\lachesis_scallion\scallion\OnionToolConfig.cs,GenerateBitmaskPatterns,The following statement contains a magic number: return _regex.GeneratePatternsForGpu(7)                  .GroupBy(i => _regex.ConvertPatternToBitmask(i))                  .Select(i => new BitmaskPatternsTuple(                      TorBase32.ToUIntArray(TorBase32.CreateBase32Mask(i.Key))'                      i.Select(j => TorBase32.ToUIntArray(TorBase32.FromBase32Str(j.Replace('.'' 'a'))))                  ))                  .ToList();
Magic Number,Mono.Options,OptionSet,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Options.cs,Add,The following statement contains a magic number: Option p = new ActionOption (prototype' description' 2'   					delegate (OptionValueCollection v) {action (v [0]' v [1]);});
Magic Number,Mono.Options,OptionSet,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: WriteDescription (o' p.Description' ""' 80' 80);
Magic Number,Mono.Options,OptionSet,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: WriteDescription (o' p.Description' ""' 80' 80);
Magic Number,Mono.Options,OptionSet,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: WriteDescription (o' p.Description' new string (' '' OptionWidth+2)'  						Description_FirstWidth' Description_RemWidth);
Magic Number,Mono.Options,OptionSet,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: WriteDescription (o' s.Description' new string (' '' OptionWidth+2)'  						Description_FirstWidth' Description_RemWidth);
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetBytes,The following statement contains a magic number: byte [] ret = new byte [8];
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetBytes,The following statement contains a magic number: byte [] ret = new byte [4];
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetBytes,The following statement contains a magic number: byte [] ret = new byte [4];
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetBytes,The following statement contains a magic number: byte [] ret = new byte [8];
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetBytes,The following statement contains a magic number: byte [] ret = new byte [2];
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetBytes,The following statement contains a magic number: byte [] ret = new byte [2];
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetBytes,The following statement contains a magic number: byte [] ret = new byte [4];
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetBytes,The following statement contains a magic number: byte [] ret = new byte [8];
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]){  			case '^':  				b.conv = BigEndian;  				return false;  			case '_':  				b.conv = LittleEndian;  				return false;  			case '%':  				b.conv = Native;  				return false;    			case '!':  				b.align = -1;  				return false;  				  			case 'x':  				b.Add (new byte [] { 0 });  				return false;  				  				// Type Conversions  			case 'i':  				b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  				break;  				  			case 'I':  				b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  				break;  				  			case 's':  				b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  				break;  				  			case 'S':  				b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  				break;  				  			case 'l':  				b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  				break;  				  			case 'L':  				b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  				break;  				  			case 'f':  				b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  				break;  				  			case 'd':  				b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  				break;  				  			case 'b':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    			case 'c':  				b.Add (new byte [] { (byte) (Convert.ToSByte (oarg)) });  				break;    			case 'C':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    				// Repeat acount;  			case '1': case '2': case '3': case '4': case '5':  			case '6': case '7': case '8': case '9':  				b.repeat = ((short) b.description [b.i]) - ((short) '0');  				return false;    			case '*':  				b.repeat = Int32.MaxValue;  				return false;  				  			case '[':  				int count = -1' j;  				  				for (j = b.i+1; j < b.description.Length; j++){  					if (b.description [j] == ']')  						break;  					n = ((short) b.description [j]) - ((short) '0');  					if (n >= 0 && n <= 9){  						if (count == -1)  							count = n;  						else  							count = count * 10 + n;  					}  				}  				if (count == -1)  					throw new ArgumentException ("invalid size specification");  				b.i = j;  				b.repeat = count;  				return false;  				  			case '$': case 'z':  				bool add_null = b.description [b.i] == 'z';  				b.i++;  				if (b.i >= b.description.Length)  					throw new ArgumentException ("$ description needs a type specified"' "description");  				char d = b.description [b.i];  				Encoding e;  				  				switch (d){  				case '8':  					e = Encoding.UTF8;  					n = 1;  					break;  				case '6':  					e = Encoding.Unicode;  					n = 2;  					break;  				case '7':  					e = Encoding.UTF7;  					n = 1;  					break;  				case 'b':  					e = Encoding.BigEndianUnicode;  					n = 2;  					break;  				case '3':  					e = Encoding.GetEncoding (12000);  					n = 4;  					break;  				case '4':  					e = Encoding.GetEncoding (12001);  					n = 4;  					break;  					  				default:  					throw new ArgumentException ("Invalid format for $ specifier"' "description");  				}  				if (b.align == -1)  					b.align = 4;  				b.Add (e.GetBytes (Convert.ToString (oarg)));  				if (add_null)  					b.Add (new byte [n]);  				break;  			default:  				throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  									    b.description [b.i]));  			}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]){  			case '^':  				b.conv = BigEndian;  				return false;  			case '_':  				b.conv = LittleEndian;  				return false;  			case '%':  				b.conv = Native;  				return false;    			case '!':  				b.align = -1;  				return false;  				  			case 'x':  				b.Add (new byte [] { 0 });  				return false;  				  				// Type Conversions  			case 'i':  				b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  				break;  				  			case 'I':  				b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  				break;  				  			case 's':  				b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  				break;  				  			case 'S':  				b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  				break;  				  			case 'l':  				b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  				break;  				  			case 'L':  				b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  				break;  				  			case 'f':  				b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  				break;  				  			case 'd':  				b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  				break;  				  			case 'b':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    			case 'c':  				b.Add (new byte [] { (byte) (Convert.ToSByte (oarg)) });  				break;    			case 'C':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    				// Repeat acount;  			case '1': case '2': case '3': case '4': case '5':  			case '6': case '7': case '8': case '9':  				b.repeat = ((short) b.description [b.i]) - ((short) '0');  				return false;    			case '*':  				b.repeat = Int32.MaxValue;  				return false;  				  			case '[':  				int count = -1' j;  				  				for (j = b.i+1; j < b.description.Length; j++){  					if (b.description [j] == ']')  						break;  					n = ((short) b.description [j]) - ((short) '0');  					if (n >= 0 && n <= 9){  						if (count == -1)  							count = n;  						else  							count = count * 10 + n;  					}  				}  				if (count == -1)  					throw new ArgumentException ("invalid size specification");  				b.i = j;  				b.repeat = count;  				return false;  				  			case '$': case 'z':  				bool add_null = b.description [b.i] == 'z';  				b.i++;  				if (b.i >= b.description.Length)  					throw new ArgumentException ("$ description needs a type specified"' "description");  				char d = b.description [b.i];  				Encoding e;  				  				switch (d){  				case '8':  					e = Encoding.UTF8;  					n = 1;  					break;  				case '6':  					e = Encoding.Unicode;  					n = 2;  					break;  				case '7':  					e = Encoding.UTF7;  					n = 1;  					break;  				case 'b':  					e = Encoding.BigEndianUnicode;  					n = 2;  					break;  				case '3':  					e = Encoding.GetEncoding (12000);  					n = 4;  					break;  				case '4':  					e = Encoding.GetEncoding (12001);  					n = 4;  					break;  					  				default:  					throw new ArgumentException ("Invalid format for $ specifier"' "description");  				}  				if (b.align == -1)  					b.align = 4;  				b.Add (e.GetBytes (Convert.ToString (oarg)));  				if (add_null)  					b.Add (new byte [n]);  				break;  			default:  				throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  									    b.description [b.i]));  			}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]){  			case '^':  				b.conv = BigEndian;  				return false;  			case '_':  				b.conv = LittleEndian;  				return false;  			case '%':  				b.conv = Native;  				return false;    			case '!':  				b.align = -1;  				return false;  				  			case 'x':  				b.Add (new byte [] { 0 });  				return false;  				  				// Type Conversions  			case 'i':  				b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  				break;  				  			case 'I':  				b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  				break;  				  			case 's':  				b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  				break;  				  			case 'S':  				b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  				break;  				  			case 'l':  				b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  				break;  				  			case 'L':  				b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  				break;  				  			case 'f':  				b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  				break;  				  			case 'd':  				b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  				break;  				  			case 'b':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    			case 'c':  				b.Add (new byte [] { (byte) (Convert.ToSByte (oarg)) });  				break;    			case 'C':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    				// Repeat acount;  			case '1': case '2': case '3': case '4': case '5':  			case '6': case '7': case '8': case '9':  				b.repeat = ((short) b.description [b.i]) - ((short) '0');  				return false;    			case '*':  				b.repeat = Int32.MaxValue;  				return false;  				  			case '[':  				int count = -1' j;  				  				for (j = b.i+1; j < b.description.Length; j++){  					if (b.description [j] == ']')  						break;  					n = ((short) b.description [j]) - ((short) '0');  					if (n >= 0 && n <= 9){  						if (count == -1)  							count = n;  						else  							count = count * 10 + n;  					}  				}  				if (count == -1)  					throw new ArgumentException ("invalid size specification");  				b.i = j;  				b.repeat = count;  				return false;  				  			case '$': case 'z':  				bool add_null = b.description [b.i] == 'z';  				b.i++;  				if (b.i >= b.description.Length)  					throw new ArgumentException ("$ description needs a type specified"' "description");  				char d = b.description [b.i];  				Encoding e;  				  				switch (d){  				case '8':  					e = Encoding.UTF8;  					n = 1;  					break;  				case '6':  					e = Encoding.Unicode;  					n = 2;  					break;  				case '7':  					e = Encoding.UTF7;  					n = 1;  					break;  				case 'b':  					e = Encoding.BigEndianUnicode;  					n = 2;  					break;  				case '3':  					e = Encoding.GetEncoding (12000);  					n = 4;  					break;  				case '4':  					e = Encoding.GetEncoding (12001);  					n = 4;  					break;  					  				default:  					throw new ArgumentException ("Invalid format for $ specifier"' "description");  				}  				if (b.align == -1)  					b.align = 4;  				b.Add (e.GetBytes (Convert.ToString (oarg)));  				if (add_null)  					b.Add (new byte [n]);  				break;  			default:  				throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  									    b.description [b.i]));  			}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]){  			case '^':  				b.conv = BigEndian;  				return false;  			case '_':  				b.conv = LittleEndian;  				return false;  			case '%':  				b.conv = Native;  				return false;    			case '!':  				b.align = -1;  				return false;  				  			case 'x':  				b.Add (new byte [] { 0 });  				return false;  				  				// Type Conversions  			case 'i':  				b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  				break;  				  			case 'I':  				b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  				break;  				  			case 's':  				b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  				break;  				  			case 'S':  				b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  				break;  				  			case 'l':  				b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  				break;  				  			case 'L':  				b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  				break;  				  			case 'f':  				b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  				break;  				  			case 'd':  				b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  				break;  				  			case 'b':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    			case 'c':  				b.Add (new byte [] { (byte) (Convert.ToSByte (oarg)) });  				break;    			case 'C':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    				// Repeat acount;  			case '1': case '2': case '3': case '4': case '5':  			case '6': case '7': case '8': case '9':  				b.repeat = ((short) b.description [b.i]) - ((short) '0');  				return false;    			case '*':  				b.repeat = Int32.MaxValue;  				return false;  				  			case '[':  				int count = -1' j;  				  				for (j = b.i+1; j < b.description.Length; j++){  					if (b.description [j] == ']')  						break;  					n = ((short) b.description [j]) - ((short) '0');  					if (n >= 0 && n <= 9){  						if (count == -1)  							count = n;  						else  							count = count * 10 + n;  					}  				}  				if (count == -1)  					throw new ArgumentException ("invalid size specification");  				b.i = j;  				b.repeat = count;  				return false;  				  			case '$': case 'z':  				bool add_null = b.description [b.i] == 'z';  				b.i++;  				if (b.i >= b.description.Length)  					throw new ArgumentException ("$ description needs a type specified"' "description");  				char d = b.description [b.i];  				Encoding e;  				  				switch (d){  				case '8':  					e = Encoding.UTF8;  					n = 1;  					break;  				case '6':  					e = Encoding.Unicode;  					n = 2;  					break;  				case '7':  					e = Encoding.UTF7;  					n = 1;  					break;  				case 'b':  					e = Encoding.BigEndianUnicode;  					n = 2;  					break;  				case '3':  					e = Encoding.GetEncoding (12000);  					n = 4;  					break;  				case '4':  					e = Encoding.GetEncoding (12001);  					n = 4;  					break;  					  				default:  					throw new ArgumentException ("Invalid format for $ specifier"' "description");  				}  				if (b.align == -1)  					b.align = 4;  				b.Add (e.GetBytes (Convert.ToString (oarg)));  				if (add_null)  					b.Add (new byte [n]);  				break;  			default:  				throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  									    b.description [b.i]));  			}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]){  			case '^':  				b.conv = BigEndian;  				return false;  			case '_':  				b.conv = LittleEndian;  				return false;  			case '%':  				b.conv = Native;  				return false;    			case '!':  				b.align = -1;  				return false;  				  			case 'x':  				b.Add (new byte [] { 0 });  				return false;  				  				// Type Conversions  			case 'i':  				b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  				break;  				  			case 'I':  				b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  				break;  				  			case 's':  				b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  				break;  				  			case 'S':  				b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  				break;  				  			case 'l':  				b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  				break;  				  			case 'L':  				b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  				break;  				  			case 'f':  				b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  				break;  				  			case 'd':  				b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  				break;  				  			case 'b':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    			case 'c':  				b.Add (new byte [] { (byte) (Convert.ToSByte (oarg)) });  				break;    			case 'C':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    				// Repeat acount;  			case '1': case '2': case '3': case '4': case '5':  			case '6': case '7': case '8': case '9':  				b.repeat = ((short) b.description [b.i]) - ((short) '0');  				return false;    			case '*':  				b.repeat = Int32.MaxValue;  				return false;  				  			case '[':  				int count = -1' j;  				  				for (j = b.i+1; j < b.description.Length; j++){  					if (b.description [j] == ']')  						break;  					n = ((short) b.description [j]) - ((short) '0');  					if (n >= 0 && n <= 9){  						if (count == -1)  							count = n;  						else  							count = count * 10 + n;  					}  				}  				if (count == -1)  					throw new ArgumentException ("invalid size specification");  				b.i = j;  				b.repeat = count;  				return false;  				  			case '$': case 'z':  				bool add_null = b.description [b.i] == 'z';  				b.i++;  				if (b.i >= b.description.Length)  					throw new ArgumentException ("$ description needs a type specified"' "description");  				char d = b.description [b.i];  				Encoding e;  				  				switch (d){  				case '8':  					e = Encoding.UTF8;  					n = 1;  					break;  				case '6':  					e = Encoding.Unicode;  					n = 2;  					break;  				case '7':  					e = Encoding.UTF7;  					n = 1;  					break;  				case 'b':  					e = Encoding.BigEndianUnicode;  					n = 2;  					break;  				case '3':  					e = Encoding.GetEncoding (12000);  					n = 4;  					break;  				case '4':  					e = Encoding.GetEncoding (12001);  					n = 4;  					break;  					  				default:  					throw new ArgumentException ("Invalid format for $ specifier"' "description");  				}  				if (b.align == -1)  					b.align = 4;  				b.Add (e.GetBytes (Convert.ToString (oarg)));  				if (add_null)  					b.Add (new byte [n]);  				break;  			default:  				throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  									    b.description [b.i]));  			}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]){  			case '^':  				b.conv = BigEndian;  				return false;  			case '_':  				b.conv = LittleEndian;  				return false;  			case '%':  				b.conv = Native;  				return false;    			case '!':  				b.align = -1;  				return false;  				  			case 'x':  				b.Add (new byte [] { 0 });  				return false;  				  				// Type Conversions  			case 'i':  				b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  				break;  				  			case 'I':  				b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  				break;  				  			case 's':  				b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  				break;  				  			case 'S':  				b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  				break;  				  			case 'l':  				b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  				break;  				  			case 'L':  				b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  				break;  				  			case 'f':  				b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  				break;  				  			case 'd':  				b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  				break;  				  			case 'b':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    			case 'c':  				b.Add (new byte [] { (byte) (Convert.ToSByte (oarg)) });  				break;    			case 'C':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    				// Repeat acount;  			case '1': case '2': case '3': case '4': case '5':  			case '6': case '7': case '8': case '9':  				b.repeat = ((short) b.description [b.i]) - ((short) '0');  				return false;    			case '*':  				b.repeat = Int32.MaxValue;  				return false;  				  			case '[':  				int count = -1' j;  				  				for (j = b.i+1; j < b.description.Length; j++){  					if (b.description [j] == ']')  						break;  					n = ((short) b.description [j]) - ((short) '0');  					if (n >= 0 && n <= 9){  						if (count == -1)  							count = n;  						else  							count = count * 10 + n;  					}  				}  				if (count == -1)  					throw new ArgumentException ("invalid size specification");  				b.i = j;  				b.repeat = count;  				return false;  				  			case '$': case 'z':  				bool add_null = b.description [b.i] == 'z';  				b.i++;  				if (b.i >= b.description.Length)  					throw new ArgumentException ("$ description needs a type specified"' "description");  				char d = b.description [b.i];  				Encoding e;  				  				switch (d){  				case '8':  					e = Encoding.UTF8;  					n = 1;  					break;  				case '6':  					e = Encoding.Unicode;  					n = 2;  					break;  				case '7':  					e = Encoding.UTF7;  					n = 1;  					break;  				case 'b':  					e = Encoding.BigEndianUnicode;  					n = 2;  					break;  				case '3':  					e = Encoding.GetEncoding (12000);  					n = 4;  					break;  				case '4':  					e = Encoding.GetEncoding (12001);  					n = 4;  					break;  					  				default:  					throw new ArgumentException ("Invalid format for $ specifier"' "description");  				}  				if (b.align == -1)  					b.align = 4;  				b.Add (e.GetBytes (Convert.ToString (oarg)));  				if (add_null)  					b.Add (new byte [n]);  				break;  			default:  				throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  									    b.description [b.i]));  			}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]){  			case '^':  				b.conv = BigEndian;  				return false;  			case '_':  				b.conv = LittleEndian;  				return false;  			case '%':  				b.conv = Native;  				return false;    			case '!':  				b.align = -1;  				return false;  				  			case 'x':  				b.Add (new byte [] { 0 });  				return false;  				  				// Type Conversions  			case 'i':  				b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  				break;  				  			case 'I':  				b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  				break;  				  			case 's':  				b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  				break;  				  			case 'S':  				b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  				break;  				  			case 'l':  				b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  				break;  				  			case 'L':  				b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  				break;  				  			case 'f':  				b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  				break;  				  			case 'd':  				b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  				break;  				  			case 'b':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    			case 'c':  				b.Add (new byte [] { (byte) (Convert.ToSByte (oarg)) });  				break;    			case 'C':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    				// Repeat acount;  			case '1': case '2': case '3': case '4': case '5':  			case '6': case '7': case '8': case '9':  				b.repeat = ((short) b.description [b.i]) - ((short) '0');  				return false;    			case '*':  				b.repeat = Int32.MaxValue;  				return false;  				  			case '[':  				int count = -1' j;  				  				for (j = b.i+1; j < b.description.Length; j++){  					if (b.description [j] == ']')  						break;  					n = ((short) b.description [j]) - ((short) '0');  					if (n >= 0 && n <= 9){  						if (count == -1)  							count = n;  						else  							count = count * 10 + n;  					}  				}  				if (count == -1)  					throw new ArgumentException ("invalid size specification");  				b.i = j;  				b.repeat = count;  				return false;  				  			case '$': case 'z':  				bool add_null = b.description [b.i] == 'z';  				b.i++;  				if (b.i >= b.description.Length)  					throw new ArgumentException ("$ description needs a type specified"' "description");  				char d = b.description [b.i];  				Encoding e;  				  				switch (d){  				case '8':  					e = Encoding.UTF8;  					n = 1;  					break;  				case '6':  					e = Encoding.Unicode;  					n = 2;  					break;  				case '7':  					e = Encoding.UTF7;  					n = 1;  					break;  				case 'b':  					e = Encoding.BigEndianUnicode;  					n = 2;  					break;  				case '3':  					e = Encoding.GetEncoding (12000);  					n = 4;  					break;  				case '4':  					e = Encoding.GetEncoding (12001);  					n = 4;  					break;  					  				default:  					throw new ArgumentException ("Invalid format for $ specifier"' "description");  				}  				if (b.align == -1)  					b.align = 4;  				b.Add (e.GetBytes (Convert.ToString (oarg)));  				if (add_null)  					b.Add (new byte [n]);  				break;  			default:  				throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  									    b.description [b.i]));  			}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]){  			case '^':  				b.conv = BigEndian;  				return false;  			case '_':  				b.conv = LittleEndian;  				return false;  			case '%':  				b.conv = Native;  				return false;    			case '!':  				b.align = -1;  				return false;  				  			case 'x':  				b.Add (new byte [] { 0 });  				return false;  				  				// Type Conversions  			case 'i':  				b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  				break;  				  			case 'I':  				b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  				break;  				  			case 's':  				b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  				break;  				  			case 'S':  				b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  				break;  				  			case 'l':  				b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  				break;  				  			case 'L':  				b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  				break;  				  			case 'f':  				b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  				break;  				  			case 'd':  				b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  				break;  				  			case 'b':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    			case 'c':  				b.Add (new byte [] { (byte) (Convert.ToSByte (oarg)) });  				break;    			case 'C':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    				// Repeat acount;  			case '1': case '2': case '3': case '4': case '5':  			case '6': case '7': case '8': case '9':  				b.repeat = ((short) b.description [b.i]) - ((short) '0');  				return false;    			case '*':  				b.repeat = Int32.MaxValue;  				return false;  				  			case '[':  				int count = -1' j;  				  				for (j = b.i+1; j < b.description.Length; j++){  					if (b.description [j] == ']')  						break;  					n = ((short) b.description [j]) - ((short) '0');  					if (n >= 0 && n <= 9){  						if (count == -1)  							count = n;  						else  							count = count * 10 + n;  					}  				}  				if (count == -1)  					throw new ArgumentException ("invalid size specification");  				b.i = j;  				b.repeat = count;  				return false;  				  			case '$': case 'z':  				bool add_null = b.description [b.i] == 'z';  				b.i++;  				if (b.i >= b.description.Length)  					throw new ArgumentException ("$ description needs a type specified"' "description");  				char d = b.description [b.i];  				Encoding e;  				  				switch (d){  				case '8':  					e = Encoding.UTF8;  					n = 1;  					break;  				case '6':  					e = Encoding.Unicode;  					n = 2;  					break;  				case '7':  					e = Encoding.UTF7;  					n = 1;  					break;  				case 'b':  					e = Encoding.BigEndianUnicode;  					n = 2;  					break;  				case '3':  					e = Encoding.GetEncoding (12000);  					n = 4;  					break;  				case '4':  					e = Encoding.GetEncoding (12001);  					n = 4;  					break;  					  				default:  					throw new ArgumentException ("Invalid format for $ specifier"' "description");  				}  				if (b.align == -1)  					b.align = 4;  				b.Add (e.GetBytes (Convert.ToString (oarg)));  				if (add_null)  					b.Add (new byte [n]);  				break;  			default:  				throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  									    b.description [b.i]));  			}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]){  			case '^':  				b.conv = BigEndian;  				return false;  			case '_':  				b.conv = LittleEndian;  				return false;  			case '%':  				b.conv = Native;  				return false;    			case '!':  				b.align = -1;  				return false;  				  			case 'x':  				b.Add (new byte [] { 0 });  				return false;  				  				// Type Conversions  			case 'i':  				b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  				break;  				  			case 'I':  				b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  				break;  				  			case 's':  				b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  				break;  				  			case 'S':  				b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  				break;  				  			case 'l':  				b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  				break;  				  			case 'L':  				b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  				break;  				  			case 'f':  				b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  				break;  				  			case 'd':  				b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  				break;  				  			case 'b':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    			case 'c':  				b.Add (new byte [] { (byte) (Convert.ToSByte (oarg)) });  				break;    			case 'C':  				b.Add (new byte [] { Convert.ToByte (oarg) });  				break;    				// Repeat acount;  			case '1': case '2': case '3': case '4': case '5':  			case '6': case '7': case '8': case '9':  				b.repeat = ((short) b.description [b.i]) - ((short) '0');  				return false;    			case '*':  				b.repeat = Int32.MaxValue;  				return false;  				  			case '[':  				int count = -1' j;  				  				for (j = b.i+1; j < b.description.Length; j++){  					if (b.description [j] == ']')  						break;  					n = ((short) b.description [j]) - ((short) '0');  					if (n >= 0 && n <= 9){  						if (count == -1)  							count = n;  						else  							count = count * 10 + n;  					}  				}  				if (count == -1)  					throw new ArgumentException ("invalid size specification");  				b.i = j;  				b.repeat = count;  				return false;  				  			case '$': case 'z':  				bool add_null = b.description [b.i] == 'z';  				b.i++;  				if (b.i >= b.description.Length)  					throw new ArgumentException ("$ description needs a type specified"' "description");  				char d = b.description [b.i];  				Encoding e;  				  				switch (d){  				case '8':  					e = Encoding.UTF8;  					n = 1;  					break;  				case '6':  					e = Encoding.Unicode;  					n = 2;  					break;  				case '7':  					e = Encoding.UTF7;  					n = 1;  					break;  				case 'b':  					e = Encoding.BigEndianUnicode;  					n = 2;  					break;  				case '3':  					e = Encoding.GetEncoding (12000);  					n = 4;  					break;  				case '4':  					e = Encoding.GetEncoding (12001);  					n = 4;  					break;  					  				default:  					throw new ArgumentException ("Invalid format for $ specifier"' "description");  				}  				if (b.align == -1)  					b.align = 4;  				b.Add (e.GetBytes (Convert.ToString (oarg)));  				if (add_null)  					b.Add (new byte [n]);  				break;  			default:  				throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  									    b.description [b.i]));  			}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]){  				case '^':  					conv = BigEndian;  					break;  				case '_':  					conv = LittleEndian;  					break;  				case '%':  					conv = Native;  					break;  				case 'x':  					idx++;  					break;    				case '!':  					align = true;  					break;    					// Type Conversions  				case 'i':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetInt32 (buffer' idx));  						idx += 4;  					}   					break;  				  				case 'I':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetUInt32 (buffer' idx));  						idx += 4;  					}  					break;  				  				case 's':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'S':  					if (Prepare (buffer' ref idx' 2' ref align)){  						result.Add (conv.GetUInt16 (buffer' idx));  						idx += 2;  					}  					break;  				  				case 'l':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'L':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetUInt64 (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'f':  					if (Prepare (buffer' ref idx' 4' ref align)){  						result.Add (conv.GetFloat (buffer' idx));  						idx += 4;  					}  					break;  				  				case 'd':  					if (Prepare (buffer' ref idx' 8' ref align)){  						result.Add (conv.GetDouble (buffer' idx));  						idx += 8;  					}  					break;  				  				case 'b':  					if (Prepare (buffer' ref idx' 1' ref align)){  						result.Add (buffer [idx]);  						idx++;  					}  					break;    				case 'c': case 'C':  					if (Prepare (buffer' ref idx' 1' ref align)){  						char c;  						  						if (description [i] == 'c')  							c = ((char) ((sbyte)buffer [idx]));  						else  							c = ((char) ((byte)buffer [idx]));  						  						result.Add (c);  						idx++;  					}  					break;  					  					// Repeat acount;  				case '1': case '2': case '3': case '4': case '5':  				case '6': case '7': case '8': case '9':  					repeat = ((short) description [i]) - ((short) '0');  					save = i + 1;  					break;    				case '*':  					repeat = Int32.MaxValue;  					break;  				  				case '[':  					int count = -1' j;  				  					for (j = i+1; j < description.Length; j++){  						if (description [j] == ']')  							break;  						n = ((short) description [j]) - ((short) '0');  						if (n >= 0 && n <= 9){  							if (count == -1)  								count = n;  							else  								count = count * 10 + n;  						}  					}  					if (count == -1)  						throw new ArgumentException ("invalid size specification");  					i = j;  					save = i + 1;  					repeat = count;  					break;  				  				case '$': case 'z':  					// bool with_null = description [i] == 'z';  					i++;  					if (i >= description.Length)  						throw new ArgumentException ("$ description needs a type specified"' "description");  					char d = description [i];  					Encoding e;  					if (align){  						idx = Align (idx' 4);  						align = false;  					}  					if (idx >= buffer.Length)  						break;  				  					switch (d){  					case '8':  						e = Encoding.UTF8;  						n = 1;  						break;  					case '6':  						e = Encoding.Unicode;  						n = 2;  						break;  					case '7':  						e = Encoding.UTF7;  						n = 1;  						break;  					case 'b':  						e = Encoding.BigEndianUnicode;  						n = 2;  						break;  					case '3':  						e = Encoding.GetEncoding (12000);  						n = 4;  						break;  					case '4':  						e = Encoding.GetEncoding (12001);  						n = 4;  						break;  					  					default:  						throw new ArgumentException ("Invalid format for $ specifier"' "description");  					}  					int k = idx;  					switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}  					break;  				default:  					throw new ArgumentException (String.Format ("invalid format specified `{0}'"'  										    description [i]));  				}
Magic Number,Mono,PackContext,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Add,The following statement contains a magic number: byte [] nb = new byte [System.Math.Max (next' 16) * 2 + group.Length];
Magic Number,Mono,PackContext,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Add,The following statement contains a magic number: byte [] nb = new byte [System.Math.Max (next' 16) * 2 + group.Length];
Magic Number,Mono,CopyConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetDouble,The following statement contains a magic number: data.Length - index < 8
Magic Number,Mono,CopyConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetDouble,The following statement contains a magic number: i < 8
Magic Number,Mono,CopyConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetUInt64,The following statement contains a magic number: data.Length - index < 8
Magic Number,Mono,CopyConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetUInt64,The following statement contains a magic number: i < 8
Magic Number,Mono,CopyConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetInt64,The following statement contains a magic number: data.Length - index < 8
Magic Number,Mono,CopyConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetInt64,The following statement contains a magic number: i < 8
Magic Number,Mono,CopyConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetFloat,The following statement contains a magic number: data.Length - index < 4
Magic Number,Mono,CopyConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetFloat,The following statement contains a magic number: i < 4
Magic Number,Mono,CopyConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetInt32,The following statement contains a magic number: data.Length - index < 4
Magic Number,Mono,CopyConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetInt32,The following statement contains a magic number: i < 4
Magic Number,Mono,CopyConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetUInt32,The following statement contains a magic number: data.Length - index < 4
Magic Number,Mono,CopyConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetUInt32,The following statement contains a magic number: i < 4
Magic Number,Mono,CopyConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetInt16,The following statement contains a magic number: data.Length - index < 2
Magic Number,Mono,CopyConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetInt16,The following statement contains a magic number: i < 2
Magic Number,Mono,CopyConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetUInt16,The following statement contains a magic number: data.Length - index < 2
Magic Number,Mono,CopyConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetUInt16,The following statement contains a magic number: i < 2
Magic Number,Mono,CopyConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 8);
Magic Number,Mono,CopyConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 4);
Magic Number,Mono,CopyConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 4);
Magic Number,Mono,CopyConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 4);
Magic Number,Mono,CopyConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 8);
Magic Number,Mono,CopyConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 8);
Magic Number,Mono,CopyConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 2);
Magic Number,Mono,CopyConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 2);
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetDouble,The following statement contains a magic number: data.Length - index < 8
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetDouble,The following statement contains a magic number: b [7-i] = data [index+i];
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetDouble,The following statement contains a magic number: i < 8
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetUInt64,The following statement contains a magic number: data.Length - index < 8
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetUInt64,The following statement contains a magic number: b [7-i] = data [index+i];
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetUInt64,The following statement contains a magic number: i < 8
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetInt64,The following statement contains a magic number: data.Length - index < 8
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetInt64,The following statement contains a magic number: b [7-i] = data [index+i];
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetInt64,The following statement contains a magic number: i < 8
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetFloat,The following statement contains a magic number: data.Length - index < 4
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetFloat,The following statement contains a magic number: b [3-i] = data [index+i];
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetFloat,The following statement contains a magic number: i < 4
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetInt32,The following statement contains a magic number: data.Length - index < 4
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetInt32,The following statement contains a magic number: b [3-i] = data [index+i];
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetInt32,The following statement contains a magic number: i < 4
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetUInt32,The following statement contains a magic number: data.Length - index < 4
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetUInt32,The following statement contains a magic number: b [3-i] = data [index+i];
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetUInt32,The following statement contains a magic number: i < 4
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetInt16,The following statement contains a magic number: data.Length - index < 2
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetInt16,The following statement contains a magic number: i < 2
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetUInt16,The following statement contains a magic number: data.Length - index < 2
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,GetUInt16,The following statement contains a magic number: i < 2
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 8);
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PutBytes,The following statement contains a magic number: target [i] = source [7-i];
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PutBytes,The following statement contains a magic number: i < 8
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 4);
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PutBytes,The following statement contains a magic number: target [i] = source [3-i];
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PutBytes,The following statement contains a magic number: i < 4
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 4);
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PutBytes,The following statement contains a magic number: target [i] = source [3-i];
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PutBytes,The following statement contains a magic number: i < 4
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 4);
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PutBytes,The following statement contains a magic number: target [i] = source [3-i];
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PutBytes,The following statement contains a magic number: i < 4
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 8);
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PutBytes,The following statement contains a magic number: target [i] = source [7-i];
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PutBytes,The following statement contains a magic number: i < 8
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 8);
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PutBytes,The following statement contains a magic number: target [i] = source [7-i];
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PutBytes,The following statement contains a magic number: i < 8
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 2);
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PutBytes,The following statement contains a magic number: i < 2
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PutBytes,The following statement contains a magic number: Check (dest' destIdx' 2);
Magic Number,Mono,SwapConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,PutBytes,The following statement contains a magic number: i < 2
Missing Default,scallion,Program,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Program.cs,Main,The following switch statement is missing a default case: switch (parms.ProgramMode)              {                  case Mode.Help:                      Help(p);                      break;                  case Mode.ListDevices:                      ListDevices();                      break;                  case Mode.Normal:  		        case Mode.NonOptimized:  		            {  		                // If no Work Group Size provided' then query the selected device for preferred' if not found set to 32.  		                if (parms.WorkGroupSize == 0)  		                {  		                    ulong preferredWorkGroupSize = 32;  		                    uint deviceId = 0;  		                    foreach (CLDeviceInfo device in CLRuntime.GetDevices())  		                    {  		                        if (!device.CompilerAvailable) continue;  		                        if (deviceId == parms.DeviceId)  		                        {  		                            preferredWorkGroupSize = getPreferredWorkGroupSize(device.DeviceId);  		                            break;  		                        }  		                        deviceId++;  		                    }    		                    parms.WorkGroupSize = (uint)preferredWorkGroupSize;  		                }  						  		                Console.CancelKeyPress += new ConsoleCancelEventHandler(Console_CancelKeyPress);  						try {  		                	_runtime.Run(ProgramParameters.Instance);  						}                          catch (ApplicationException e) {                              // these are handled and printed out                              Console.Error.WriteLine(e.Message);                              Environment.Exit(1);                          }  						finally {  							Shutdown();  						}  		            }              break;              }
Missing Default,scallion,TorBase32,D:\research\architectureSmells\repos\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following switch statement is missing a default case: switch (bit % 40)  				{  					case 0:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 3) +  								  (((byte)tmp[(bit / 5) + 1]) >> 2));  						break;  					case 8:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 6) +  								  (((byte)tmp[(bit / 5) + 1]) << 1) +  								  (((byte)tmp[(bit / 5) + 2]) >> 4));  						break;  					case 16:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 4) +  								  (((byte)tmp[(bit / 5) + 1]) >> 1));  						break;  					case 24:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 7) +  								  (((byte)tmp[(bit / 5) + 1]) << 2) +  								  (((byte)tmp[(bit / 5) + 2]) >> 3));  						break;  					case 32:  						dest[i] = (byte)((((byte)tmp[(bit / 5)]) << 5) +  								  ((byte)tmp[(bit / 5) + 1]));  						break;  				}
Missing Default,Mono.Options,OptionSet,D:\research\architectureSmells\repos\lachesis_scallion\scallion\Options.cs,Parse,The following switch statement is missing a default case: switch (p.OptionValueType) {  					case OptionValueType.None:  						c.OptionValues.Add (n);  						c.Option.Invoke (c);  						break;  					case OptionValueType.Optional:  					case OptionValueType.Required:   						ParseValue (v' c);  						break;  				}
Missing Default,Mono,DataConverter,D:\research\architectureSmells\repos\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following switch statement is missing a default case: switch (n){  					case 1:  						for (; k < buffer.Length && buffer [k] != 0; k++)  							;  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+1;  						break;  						  					case 2:  						for (; k < buffer.Length; k++){  							if (k+1 == buffer.Length){  								k++;  								break;  							}  							if (buffer [k] == 0 && buffer [k+1] == 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+2;  						break;  						  					case 4:  						for (; k < buffer.Length; k++){  							if (k+3 >= buffer.Length){  								k = buffer.Length;  								break;  							}  							if (buffer[k]==0 && buffer[k+1] == 0 && buffer[k+2] == 0 && buffer[k+3]== 0)  								break;  						}  						result.Add (e.GetChars (buffer' idx' k-idx));  						if (k == buffer.Length)  							idx = k;  						else  							idx = k+4;  						break;  					}
