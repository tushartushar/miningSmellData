Implementation smell,Namespace,Class,File,Method,Description
Long Method,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The method has 243 lines of code.
Long Method,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,The method has 140 lines of code.
Long Method,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The method has 222 lines of code.
Complex Method,scallion,Program,F:\newReposMay17\lachesis_scallion\scallion\Program.cs,Main,Cyclomatic complexity of the method is 17
Complex Method,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,Packetize,Cyclomatic complexity of the method is 18
Complex Method,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,Cyclomatic complexity of the method is 21
Complex Method,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,Cyclomatic complexity of the method is 8
Complex Method,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,Cyclomatic complexity of the method is 34
Complex Method,Mono.Options,StringCoda,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,CreateWrappedLinesIterator,Cyclomatic complexity of the method is 8
Complex Method,Mono.Options,Option,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,ParsePrototype,Cyclomatic complexity of the method is 9
Complex Method,Mono.Options,Option,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,AddSeparators,Cyclomatic complexity of the method is 17
Complex Method,Mono.Options,ArgumentSource,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,GetArguments,Cyclomatic complexity of the method is 9
Complex Method,Mono.Options,OptionSet,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,Parse,Cyclomatic complexity of the method is 8
Complex Method,Mono.Options,OptionSet,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,Parse,Cyclomatic complexity of the method is 10
Complex Method,Mono.Options,OptionSet,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,ParseBundledValue,Cyclomatic complexity of the method is 10
Complex Method,Mono.Options,OptionSet,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,WriteOptionDescriptions,Cyclomatic complexity of the method is 9
Complex Method,Mono.Options,OptionSet,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,GetDescription,Cyclomatic complexity of the method is 20
Complex Method,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,Cyclomatic complexity of the method is 83
Complex Method,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,Cyclomatic complexity of the method is 105
Long Parameter List,scallion,CLKernel,F:\newReposMay17\lachesis_scallion\scallion\CLContext.cs,CLKernel,The method has 5 parameters.
Long Parameter List,Mono.Options,OptionSet,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,GetOptionParts,The method has 5 parameters.
Long Parameter List,Mono.Options,OptionSet,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,WriteDescription,The method has 5 parameters.
Long Statement,scallion,CLContext,F:\newReposMay17\lachesis_scallion\scallion\CLContext.cs,CreateAndCompileProgram,The length of the statement  "		CL.GetProgramBuildInfo (programId' DeviceId' ProgramBuildInfo.ProgramBuildLog' IntPtr.Zero' IntPtr.Zero' (IntPtr*)&parmSize); " is 125.
Long Statement,scallion,CLContext,F:\newReposMay17\lachesis_scallion\scallion\CLContext.cs,CreateAndCompileProgram,The length of the statement  "			error = (ErrorCode)CL.GetProgramBuildInfo (programId' DeviceId' ProgramBuildInfo.ProgramBuildLog' new IntPtr (&parmSize)' new IntPtr (valuePtr)' (IntPtr*)IntPtr.Zero.ToPointer ()); " is 180.
Long Statement,scallion,CLBuffer,F:\newReposMay17\lachesis_scallion\scallion\CLContext.cs,EnqueueWrite,The length of the statement  "	error = (ErrorCode)CL.EnqueueWriteBuffer (CommandQueueId' BufferId' !async' new IntPtr (0)' new IntPtr (BufferSize)' Handle.AddrOfPinnedObject ()' 0' (IntPtr*)IntPtr.Zero.ToPointer ()' (IntPtr*)IntPtr.Zero.ToPointer ()); " is 220.
Long Statement,scallion,CLBuffer,F:\newReposMay17\lachesis_scallion\scallion\CLContext.cs,EnqueueRead,The length of the statement  "	error = (ErrorCode)CL.EnqueueReadBuffer (CommandQueueId' BufferId' !async' new IntPtr (0)' new IntPtr (BufferSize)' Handle.AddrOfPinnedObject ()' 0' (IntPtr*)IntPtr.Zero.ToPointer ()' (IntPtr*)IntPtr.Zero.ToPointer ()); " is 219.
Long Statement,scallion,CLKernel,F:\newReposMay17\lachesis_scallion\scallion\CLContext.cs,EnqueueNDRangeKernel,The length of the statement  "	error = (ErrorCode)CL.EnqueueNDRangeKernel (CommandQueueId' KernelId' 1' null' &pglobalWorkSize' &plocalWorkSize' 0' null' null); " is 129.
Long Statement,scallion,KernelGenerator,F:\newReposMay17\lachesis_scallion\scallion\KernelGenerator.cs,GenerateKernel,The length of the statement  "	string kernelFile = Path.GetDirectoryName (Assembly.GetExecutingAssembly ().Location) + Path.DirectorySeparatorChar + "kernel.cl"; " is 130.
Long Statement,scallion,KernelGenerator,F:\newReposMay17\lachesis_scallion\scallion\KernelGenerator.cs,GenerateExpLoadingCode,The length of the statement  "	builder.AppendFormat ("W[{0}] |= exp >> {1} & 0x{2:x}u; // OR in the first part of the exp\n"' firstWord' (8 * offset)' mask1); " is 127.
Long Statement,scallion,KernelGenerator,F:\newReposMay17\lachesis_scallion\scallion\KernelGenerator.cs,GenerateExpLoadingCode,The length of the statement  "	builder.AppendFormat ("W[{0}] |= exp << {1} & 0x{2:x}u; // OR in the second part of the exp\n"' firstWord + 1' (32 - 8 * offset)' ~mask1); " is 138.
Long Statement,scallion,KernelGenerator,F:\newReposMay17\lachesis_scallion\scallion\KernelGenerator.cs,GenerateCheckingCode,The length of the statement  "			builder.Append (Util.Range (toolConfig.NumberOfWords).Select (i => String.Format ("(H[{0}] & BitmaskArray[{2}*{1}+{0}])"' i' toolConfig.NumberOfWords' m)).ToDelimitedString ("'")); " is 180.
Long Statement,scallion,KernelGenerator,F:\newReposMay17\lachesis_scallion\scallion\KernelGenerator.cs,GenerateCheckingCode,The length of the statement  "			builder.AppendLines (Util.Range (toolConfig.MaxKeyCollisions).Select (i => string.Format ("    if(DataArray[dataaddr + {0}] == fnv) Results[get_local_id(0) % ResultsArraySize] = exp;"' i))); " is 190.
Long Statement,scallion,ProgramParameters,F:\newReposMay17\lachesis_scallion\scallion\Program.cs,CreateDefinesString,The length of the statement  "	var fields = this.GetType ().GetFields (BindingFlags.Public | BindingFlags.Instance).Cast<object> ().Concat (this.GetType ().GetProperties (BindingFlags.Public | BindingFlags.Instance).Cast<object> ()); " is 202.
Long Statement,scallion,Program,F:\newReposMay17\lachesis_scallion\scallion\Program.cs,ListDevices,The length of the statement  "		Console.WriteLine ("    PreferredGroupSizeMultiple:{0} ComputeUnits:{1} ClockFrequency:{2}"' preferredWorkGroupSize' device.MaxComputeUnits' device.MaxClockFrequency); " is 167.
Long Statement,scallion,Program,F:\newReposMay17\lachesis_scallion\scallion\Program.cs,ListDevices,The length of the statement  "		Console.WriteLine ("    MaxConstantBufferSize:{0} MaxConstantArgs:{1} MaxMemAllocSize:{2}"' device.MaxConstantBufferSize' device.MaxConstantArgs' device.MaxMemAllocSize); " is 170.
Long Statement,scallion,Program,F:\newReposMay17\lachesis_scallion\scallion\Program.cs,Main,The length of the statement  "			r.Rsa.PublicModulus = BigNumber.FromHexString("00E2FC646FF48AFC8C2A7DDF1B99CECD21A0AEC603DBAAA1A7ADF6836A6CED82BAE694AC5A4ACBD7FC1D36B2C677BE25E400330D295D044C9F6AFAEA45A8CF370F59E398F853FFCED03395D297CEED47C0E9EF2C358C05399E1F8A878E6E044F1AB7D82A162C77EE956B0A9B54C910000EF7122CC8BBB1746872968F05E7CFD563");" is 308.
Long Statement,scallion,Program,F:\newReposMay17\lachesis_scallion\scallion\Program.cs,Main,The length of the statement  "			Console.WriteLine("GPG Fingerprint: {0}"' r.GPG_fingerprint_string);*/ProgramParameters parms = ProgramParameters.Instance; " is 123.
Long Statement,scallion,Program,F:\newReposMay17\lachesis_scallion\scallion\Program.cs,Main,The length of the statement  "	OptionSet p = new OptionSet ().Add<uint> ("k|keysize="' "Specifies keysize for the RSA key"' i => parms.KeySize = i).Add ("n|nonoptimized"' "Runs non-optimized kernel"' parseMode (Mode.NonOptimized)).Add ("l|listdevices"' "Lists the devices that can be used."' parseMode (Mode.ListDevices)).Add ("h|?|help"' "Displays command line usage help."' parseMode (Mode.Help)).Add ("gpg"' "GPG vanitygen mode."' i => { " is 409.
Long Statement,scallion,Program,F:\newReposMay17\lachesis_scallion\scallion\Program.cs,Main,The length of the statement  "	}).Add<uint> ("d|device="' "Specifies the opencl device that should be used."' i => parms.DeviceId = i).Add<uint> ("g|groupsize="' "Specifies the number of threads in a workgroup."' i => parms.WorkGroupSize = i).Add<uint> ("w|worksize="' "Specifies the number of hashes preformed at one time."' i => parms.WorkSize = i).Add<uint> ("t|cputhreads="' "Specifies the number of CPU threads to use when creating work. (EXPERIMENTAL - OpenSSL not thread-safe)"' i => parms.CpuThreads = i).Add<string> ("p|save-kernel="' "Saves the generated kernel to this path."' i => parms.SaveGeneratedKernelPath = i).Add<string> ("o|output="' "Saves the generated key(s) and address(es) to this path."' i => parms.KeyOutputPath = i).Add ("skip-sha-test"' "Skip the SHA-1 test at startup."' i => { " is 776.
Long Statement,scallion,Program,F:\newReposMay17\lachesis_scallion\scallion\Program.cs,Main,The length of the statement  "	}).Add<uint> ("quit-after="' "Quit after this many keys have been found."' i => parms.QuitAfterXKeysFound = i).Add<uint> ("timestamp="' "Use this value as a timestamp for the RSA key."' i => parms.UnixTs = i).Add ("c|continue"' "Continue to search for keys rather than exiting when a key is found."' i => { " is 306.
Long Statement,scallion,Program,F:\newReposMay17\lachesis_scallion\scallion\Program.cs,Main,The length of the statement  "	}).Add<string> ("command="' "When a match is found specified external program is called with key passed to stdin.\nExample: \"--command 'tee example.txt'\" would save the key to example.txt\nIf the command returns with a non-zero exit code' the program will return the same code."' i => parms.Command = i); " is 306.
Long Statement,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,GPG_privkey_packet,The length of the statement  "	int len = 6 + 2 * 2 + Rsa.PublicModulus.Bytes + Rsa.PublicExponent.Bytes + 3 + 2 * 4 + Rsa.PrivateExponent.Bytes + Rsa.SecretPrimeFactorP.Bytes + Rsa.SecretPrimeFactorQ.Bytes + IPmodQ.Bytes; " is 190.
Long Statement,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToUIntArray,The length of the statement  "		ret [i / 4] = (uint)(padded [i] << 24) | (uint)(padded [i + 1] << 16) | (uint)(padded [i + 2] << 8) | (uint)(padded [i + 3] << 0); " is 130.
Long Statement,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The length of the statement  "			dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4)); " is 124.
Long Statement,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The length of the statement  "			dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3)); " is 124.
Long Statement,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,OutputKey,The length of the statement  "		System.IO.File.AppendAllText (parms.KeyOutputPath' "Public Modulus: " + rsa.Rsa.PublicModulus.ToDecimalString () + "\n"); " is 121.
Long Statement,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,OutputKey,The length of the statement  "		System.IO.File.AppendAllText (parms.KeyOutputPath' "Public Exponent: " + rsa.Rsa.PublicExponent.ToDecimalString () + "\n"); " is 123.
Long Statement,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The length of the statement  "	//string kernel_text = KernelGenerator.GenerateKernel(parms'gpu_bitmasks.Length/3'max_items_per_key'gpu_bitmasks.Take(3).ToArray()'all_patterns[0]'all_patterns.Length'parms.ExponentIndex); " is 188.
Long Statement,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The length of the statement  "		CLBuffer<uint> bufSuccess = context.CreateBuffer (OpenTK.Compute.CL10.MemFlags.MemReadWrite | OpenTK.Compute.CL10.MemFlags.MemCopyHostPtr' new uint[5]); " is 152.
Long Statement,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The length of the statement  "		String gpuhex = String.Format ("{0:x8}{1:x8}{2:x8}{3:x8}{4:x8}"' bufSuccess.Data [0]' bufSuccess.Data [1]' bufSuccess.Data [2]' bufSuccess.Data [3]' bufSuccess.Data [4]); " is 170.
Long Statement,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The length of the statement  "		bufLastWs = context.CreateBuffer (OpenTK.Compute.CL10.MemFlags.MemReadOnly | OpenTK.Compute.CL10.MemFlags.MemCopyHostPtr' LastWs); " is 130.
Long Statement,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The length of the statement  "		bufMidstates = context.CreateBuffer (OpenTK.Compute.CL10.MemFlags.MemReadOnly | OpenTK.Compute.CL10.MemFlags.MemCopyHostPtr' Midstates); " is 136.
Long Statement,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The length of the statement  "		bufExpIndexes = context.CreateBuffer (OpenTK.Compute.CL10.MemFlags.MemReadOnly | OpenTK.Compute.CL10.MemFlags.MemCopyHostPtr' ExpIndexes); " is 138.
Long Statement,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The length of the statement  "		bufResults = context.CreateBuffer (OpenTK.Compute.CL10.MemFlags.MemReadWrite | OpenTK.Compute.CL10.MemFlags.MemCopyHostPtr' Results); " is 133.
Long Statement,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The length of the statement  "		bufHashTable = context.CreateBuffer (OpenTK.Compute.CL10.MemFlags.MemReadOnly | OpenTK.Compute.CL10.MemFlags.MemCopyHostPtr' parms.ToolConfig.HashTable); " is 153.
Long Statement,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The length of the statement  "		bufDataArray = context.CreateBuffer (OpenTK.Compute.CL10.MemFlags.MemReadOnly | OpenTK.Compute.CL10.MemFlags.MemCopyHostPtr' parms.ToolConfig.PackedPatterns); " is 158.
Long Statement,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The length of the statement  "		bufBitmasks = context.CreateBuffer (OpenTK.Compute.CL10.MemFlags.MemReadOnly | OpenTK.Compute.CL10.MemFlags.MemCopyHostPtr' parms.ToolConfig.PackedBitmasks); " is 157.
Long Statement,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The length of the statement  "		Console.Write ("LoopIteration:{0}  HashCount:{1:0.00}MH  Speed:{2:0.0}MH/s  Runtime:{3}  Predicted:{4}  "' loop' hashes / 1000000.0d' hashes / gpu_runtime_sw.ElapsedMilliseconds / 1000.0d' gpu_runtime_sw.Elapsed.ToString ().Split ('.') [0]' parms.ToolConfig.PredictRuntime (hashes * 1000 / gpu_runtime_sw.ElapsedMilliseconds)); " is 327.
Long Statement,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The length of the statement  "				String gpuhashhex = String.Format("{0:x8}{1:x8}{2:x8}{3:x8}{4:x8}"' input.Results[0]' input.Results[1]' input.Results[2]' input.Results[3]' input.Results[4]);" is 158.
Long Statement,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The length of the statement  "					//System.IO.File.WriteAllText(String.Format("/tmp/{0}.sec.asc"' input.Rsa.GPG_fingerprint_string)' input.Rsa.GPG_privkey_export); " is 129.
Long Statement,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The length of the statement  "	Console.WriteLine ("{0:0.00} million hashes per second"' ((long)loop * (long)workSize * (long)1000) / (double)profiler.GetTotalMS ("total without init") / (double)1000000); " is 172.
Long Statement,scallion,ToolConfig,F:\newReposMay17\lachesis_scallion\scallion\ToolConfig.cs,CreateHashTableAndPackPatterns,The length of the statement  "	Dictionary<ushort' List<uint[]>> patterns = BitmaskPatterns.SelectMany (i => i.Patterns).Select (i => new KeyValuePair<ushort' uint[]> (Util.FNV10 (i)' i)).GroupBy (i => i.Key).ToDictionary (i => i.Key' i => i.Select (j => j.Value).ToList ()); " is 243.
Long Statement,scallion,GpgToolConfig,F:\newReposMay17\lachesis_scallion\scallion\GpgToolConfig.cs,PredictRuntimeInSeconds,The length of the statement  "	var hashes_per_win = _regex.GenerateAllPatternsForRegex ().Select (t => Math.Pow (2' 4 * t.Count (q => q != '.') - 1)).Sum (); " is 126.
Long Statement,scallion,GpgToolConfig,F:\newReposMay17\lachesis_scallion\scallion\GpgToolConfig.cs,GenerateBitmaskPatterns,The length of the statement  "		return Enumerable.Range (0' hex.Length).Where (x => x % 2 == 0).Select (x => Convert.ToByte (hex.Substring (x' 2)' 16)).ToArray (); " is 131.
Long Statement,scallion,GpgToolConfig,F:\newReposMay17\lachesis_scallion\scallion\GpgToolConfig.cs,GenerateBitmaskPatterns,The length of the statement  "		uint[] bitmask = TorBase32.ToUIntArray (hexToBytes (Regex.Replace (i.Key.ToLower ()' "[^.]"' "f").Replace ("."' "0")).PadLeft (20)); " is 132.
Long Statement,scallion,GpgToolConfig,F:\newReposMay17\lachesis_scallion\scallion\GpgToolConfig.cs,GenerateBitmaskPatterns,The length of the statement  "		return new BitmaskPatternsTuple (bitmask' i.Select (j => TorBase32.ToUIntArray (hexToBytes (j.Replace ('.'' '0')).PadLeft (20)))); " is 130.
Long Statement,scallion,OnionToolConfig,F:\newReposMay17\lachesis_scallion\scallion\OnionToolConfig.cs,PredictRuntimeInSeconds,The length of the statement  "	var hashes_per_win = _regex.GenerateAllPatternsForRegex ().Select (t => Math.Pow (2' 5 * t.Count (q => q != '.') - 1)).Sum (); " is 126.
Long Statement,scallion,OnionToolConfig,F:\newReposMay17\lachesis_scallion\scallion\OnionToolConfig.cs,GenerateBitmaskPatterns,The length of the statement  "	return _regex.GeneratePatternsForGpu (7).GroupBy (i => _regex.ConvertPatternToBitmask (i)).Select (i => new BitmaskPatternsTuple (TorBase32.ToUIntArray (TorBase32.CreateBase32Mask (i.Key))' i.Select (j => TorBase32.ToUIntArray (TorBase32.FromBase32Str (j.Replace ('.'' 'a')))))).ToList (); " is 289.
Long Statement,Mono.Options,StringCoda,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,GetNextWidth,The length of the statement  "			throw new ArgumentOutOfRangeException ("widths"' string.Format ("Element must be >= {0}' was {1}."' minWidth.Length' curWidth)); " is 128.
Long Statement,Mono.Options,OptionValueCollection,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,AssertValid,The length of the statement  "		throw new OptionException (string.Format (c.OptionSet.MessageLocalizer ("Missing required value for option '{0}'.")' c.OptionName)' c.OptionName); " is 146.
Long Statement,Mono.Options,Option,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,Parse,The length of the statement  "	bool nullable = tt.IsValueType && tt.IsGenericType && !tt.IsGenericTypeDefinition && tt.GetGenericTypeDefinition () == typeof(Nullable<>); " is 138.
Long Statement,Mono.Options,Option,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,Parse,The length of the statement  "		throw new OptionException (string.Format (c.OptionSet.MessageLocalizer ("Could not convert string `{0}' to type {1} for option `{2}'.")' value' targetType.Name' c.OptionName)' c.OptionName' e); " is 193.
Long Statement,Mono.Options,Option,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,ParsePrototype,The length of the statement  "			throw new ArgumentException (string.Format ("Conflicting option types: '{0}' vs. '{1}'."' type' name [end])' "prototype"); " is 122.
Long Statement,Mono.Options,Option,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,ParsePrototype,The length of the statement  "		throw new ArgumentException (string.Format ("Cannot provide key/value separators for Options taking {0} value(s)."' count)' "prototype"); " is 137.
Long Statement,Mono.Options,OptionSet,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,ParseValue,The length of the statement  "		foreach (string o in c.Option.ValueSeparators != null ? option.Split (c.Option.ValueSeparators' c.Option.MaxValueCount - c.OptionValues.Count' StringSplitOptions.None) : new string[] { " is 184.
Long Statement,Mono.Options,OptionSet,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,ParseValue,The length of the statement  "		throw new OptionException (localizer (string.Format ("Error: Found {0} option values when expecting {1}."' c.OptionValues.Count' c.Option.MaxValueCount))' c.OptionName); " is 169.
Long Statement,Mono.Options,OptionSet,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,ParseBool,The length of the statement  "	if (n.Length >= 1 && (n [n.Length - 1] == '+' || n [n.Length - 1] == '-') && Contains ((rn = n.Substring (0' n.Length - 1)))) { " is 127.
Complex Conditional,Mono.Options,Option,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,Option,The conditional expression  "Array.IndexOf (names' "<>") >= 0 && ((names.Length == 1 && this.type != OptionValueType.None) || (names.Length > 1 && this.MaxValueCount > 1))"  is complex.
Complex Conditional,Mono.Options,OptionSet,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,ParseBool,The conditional expression  "n.Length >= 1 && (n [n.Length - 1] == '+' || n [n.Length - 1] == '-') && Contains ((rn = n.Substring (0' n.Length - 1)))"  is complex.
Complex Conditional,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The conditional expression  "buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0"  is complex.
Virtual Method Call from Constructor,scallion,ToolConfig,F:\newReposMay17\lachesis_scallion\scallion\ToolConfig.cs,ToolConfig,The constructor "ToolConfig" calls a virtual method "CreateRegexPattern".
Virtual Method Call from Constructor,scallion,ToolConfig,F:\newReposMay17\lachesis_scallion\scallion\ToolConfig.cs,ToolConfig,The constructor "ToolConfig" calls a virtual method "GenerateBitmaskPatterns".
Empty Catch Block,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The method has an empty catch block.
Magic Number,scallion,CLDeviceInfo,F:\newReposMay17\lachesis_scallion\scallion\CLDeviceInfo.cs,GetDeviceInfo_size_t,The following statement contains a magic number: if (AddressBits == 32)  	return (ulong)GetDeviceInfo_uint (paramName);  else  	return GetDeviceInfo_ulong (paramName);  
Magic Number,scallion,KernelGenerator,F:\newReposMay17\lachesis_scallion\scallion\KernelGenerator.cs,GenerateExpLoadingCode,The following statement contains a magic number: builder.AppendFormat ("W[{0}] |= exp >> {1} & 0x{2:x}u; // OR in the first part of the exp\n"' firstWord' (8 * offset)' mask1);  
Magic Number,scallion,KernelGenerator,F:\newReposMay17\lachesis_scallion\scallion\KernelGenerator.cs,GenerateExpLoadingCode,The following statement contains a magic number: builder.AppendFormat ("W[{0}] |= exp << {1} & 0x{2:x}u; // OR in the second part of the exp\n"' firstWord + 1' (32 - 8 * offset)' ~mask1);  
Magic Number,scallion,KernelGenerator,F:\newReposMay17\lachesis_scallion\scallion\KernelGenerator.cs,GenerateExpLoadingCode,The following statement contains a magic number: builder.AppendFormat ("W[{0}] |= exp << {1} & 0x{2:x}u; // OR in the second part of the exp\n"' firstWord + 1' (32 - 8 * offset)' ~mask1);  
Magic Number,scallion,Program,F:\newReposMay17\lachesis_scallion\scallion\Program.cs,Main,The following statement contains a magic number: switch (parms.ProgramMode) {  case Mode.Help:  	Help (p);  	break;  case Mode.ListDevices:  	ListDevices ();  	break;  case Mode.Normal:  case Mode.NonOptimized:  	{  		// If no Work Group Size provided' then query the selected device for preferred' if not found set to 32.  		if (parms.WorkGroupSize == 0) {  			ulong preferredWorkGroupSize = 32;  			uint deviceId = 0;  			foreach (CLDeviceInfo device in CLRuntime.GetDevices ()) {  				if (!device.CompilerAvailable)  					continue;  				if (deviceId == parms.DeviceId) {  					preferredWorkGroupSize = getPreferredWorkGroupSize (device.DeviceId);  					break;  				}  				deviceId++;  			}  			parms.WorkGroupSize = (uint)preferredWorkGroupSize;  		}  		Console.CancelKeyPress += new ConsoleCancelEventHandler (Console_CancelKeyPress);  		try {  			_runtime.Run (ProgramParameters.Instance);  		} catch (ApplicationException e) {  			// these are handled and printed out  			Console.Error.WriteLine (e.Message);  			Environment.Exit (1);  		} finally {  			Shutdown ();  		}  	}  	break;  }  
Magic Number,scallion,Program,F:\newReposMay17\lachesis_scallion\scallion\Program.cs,Main,The following statement contains a magic number: if (parms.WorkGroupSize == 0) {  	ulong preferredWorkGroupSize = 32;  	uint deviceId = 0;  	foreach (CLDeviceInfo device in CLRuntime.GetDevices ()) {  		if (!device.CompilerAvailable)  			continue;  		if (deviceId == parms.DeviceId) {  			preferredWorkGroupSize = getPreferredWorkGroupSize (device.DeviceId);  			break;  		}  		deviceId++;  	}  	parms.WorkGroupSize = (uint)preferredWorkGroupSize;  }  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,GenerateKey,The following statement contains a magic number: GenerateKey (size' 3);  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,GenerateKey,The following statement contains a magic number: Timestamp = (uint)(DateTime.UtcNow - new DateTime (1970' 1' 1' 0' 0' 0)).TotalSeconds;  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,BigNumberToMPI,The following statement contains a magic number: mpi [0] = (byte)((num.Bits >> 8) & 0xFFu);  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,BigNumberToMPI,The following statement contains a magic number: Array.Copy (buf' 0' mpi' 2' num.Bytes);  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,GPG_v4Packet,The following statement contains a magic number: v4pkt [idx] = (byte)((buf.Length >> 8) & 0xFFu);  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,GPG_pubkey_packet,The following statement contains a magic number: buf = new byte[4];  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,GPG_pubkey_packet,The following statement contains a magic number: exp_index = idx + 2;  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,GPG_privkey_packet,The following statement contains a magic number: buf = new byte[4];  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,GPG_privkey_packet,The following statement contains a magic number: Array.Copy (buf' 0' v4pkt' idx' 4);  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,GPG_privkey_packet,The following statement contains a magic number: idx += 4;  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,GPG_privkey_packet,The following statement contains a magic number: sum = sum % 65536;  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,GPG_privkey_packet,The following statement contains a magic number: buf = new byte[2];  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,Packetize,The following statement contains a magic number: switch (lenlen) {  case 1:  	length_type = 0;  	break;  case 2:  	length_type = 1;  	break;  case 3:  	// Zero-pad length  	byte[] temp = new byte[4];  	Array.Copy (buf' 0' temp' 1' 3);  	temp [0] = 0;  	buf = temp;  	length_type = 2;  	break;  case 4:  	length_type = 2;  	break;  default:  	throw new Exception ("Invalid length.");  }  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,Packetize,The following statement contains a magic number: switch (lenlen) {  case 1:  	length_type = 0;  	break;  case 2:  	length_type = 1;  	break;  case 3:  	// Zero-pad length  	byte[] temp = new byte[4];  	Array.Copy (buf' 0' temp' 1' 3);  	temp [0] = 0;  	buf = temp;  	length_type = 2;  	break;  case 4:  	length_type = 2;  	break;  default:  	throw new Exception ("Invalid length.");  }  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,Packetize,The following statement contains a magic number: switch (lenlen) {  case 1:  	length_type = 0;  	break;  case 2:  	length_type = 1;  	break;  case 3:  	// Zero-pad length  	byte[] temp = new byte[4];  	Array.Copy (buf' 0' temp' 1' 3);  	temp [0] = 0;  	buf = temp;  	length_type = 2;  	break;  case 4:  	length_type = 2;  	break;  default:  	throw new Exception ("Invalid length.");  }  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,Packetize,The following statement contains a magic number: switch (lenlen) {  case 1:  	length_type = 0;  	break;  case 2:  	length_type = 1;  	break;  case 3:  	// Zero-pad length  	byte[] temp = new byte[4];  	Array.Copy (buf' 0' temp' 1' 3);  	temp [0] = 0;  	buf = temp;  	length_type = 2;  	break;  case 4:  	length_type = 2;  	break;  default:  	throw new Exception ("Invalid length.");  }  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,Packetize,The following statement contains a magic number: switch (lenlen) {  case 1:  	length_type = 0;  	break;  case 2:  	length_type = 1;  	break;  case 3:  	// Zero-pad length  	byte[] temp = new byte[4];  	Array.Copy (buf' 0' temp' 1' 3);  	temp [0] = 0;  	buf = temp;  	length_type = 2;  	break;  case 4:  	length_type = 2;  	break;  default:  	throw new Exception ("Invalid length.");  }  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,Packetize,The following statement contains a magic number: switch (lenlen) {  case 1:  	length_type = 0;  	break;  case 2:  	length_type = 1;  	break;  case 3:  	// Zero-pad length  	byte[] temp = new byte[4];  	Array.Copy (buf' 0' temp' 1' 3);  	temp [0] = 0;  	buf = temp;  	length_type = 2;  	break;  case 4:  	length_type = 2;  	break;  default:  	throw new Exception ("Invalid length.");  }  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,Packetize,The following statement contains a magic number: switch (lenlen) {  case 1:  	length_type = 0;  	break;  case 2:  	length_type = 1;  	break;  case 3:  	// Zero-pad length  	byte[] temp = new byte[4];  	Array.Copy (buf' 0' temp' 1' 3);  	temp [0] = 0;  	buf = temp;  	length_type = 2;  	break;  case 4:  	length_type = 2;  	break;  default:  	throw new Exception ("Invalid length.");  }  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,Packetize,The following statement contains a magic number: Array.Copy (buf' 0' temp' 1' 3);  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,Packetize,The following statement contains a magic number: length_type = 2;  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,Packetize,The following statement contains a magic number: length_type = 2;  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,ascii_armor,The following statement contains a magic number: foreach (var str in ChunksUpto (Convert.ToBase64String (input) + "====="' 78)) {  	s.AppendLine (str);  }  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,tobase32str,The following statement contains a magic number: for (i = 0' bit = 0; bit < nbits; ++i' bit += 5) {  	/* set v to the 16-bit value starting at src[bits/8]' 0-padded. */v = ((byte)src [bit / 8]) << 8;  	if (bit + 5 < nbits)  		v += (byte)src [(bit / 8) + 1];  	/* set u to the 5-bit value at the bit'th bit of src. */u = (v >> (11 - (bit % 8))) & 0x1F;  	sb.Append (BASE32_CHARS [u]);  }  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,tobase32str,The following statement contains a magic number: for (i = 0' bit = 0; bit < nbits; ++i' bit += 5) {  	/* set v to the 16-bit value starting at src[bits/8]' 0-padded. */v = ((byte)src [bit / 8]) << 8;  	if (bit + 5 < nbits)  		v += (byte)src [(bit / 8) + 1];  	/* set u to the 5-bit value at the bit'th bit of src. */u = (v >> (11 - (bit % 8))) & 0x1F;  	sb.Append (BASE32_CHARS [u]);  }  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,tobase32str,The following statement contains a magic number: for (i = 0' bit = 0; bit < nbits; ++i' bit += 5) {  	/* set v to the 16-bit value starting at src[bits/8]' 0-padded. */v = ((byte)src [bit / 8]) << 8;  	if (bit + 5 < nbits)  		v += (byte)src [(bit / 8) + 1];  	/* set u to the 5-bit value at the bit'th bit of src. */u = (v >> (11 - (bit % 8))) & 0x1F;  	sb.Append (BASE32_CHARS [u]);  }  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,tobase32str,The following statement contains a magic number: for (i = 0' bit = 0; bit < nbits; ++i' bit += 5) {  	/* set v to the 16-bit value starting at src[bits/8]' 0-padded. */v = ((byte)src [bit / 8]) << 8;  	if (bit + 5 < nbits)  		v += (byte)src [(bit / 8) + 1];  	/* set u to the 5-bit value at the bit'th bit of src. */u = (v >> (11 - (bit % 8))) & 0x1F;  	sb.Append (BASE32_CHARS [u]);  }  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,tobase32str,The following statement contains a magic number: for (i = 0' bit = 0; bit < nbits; ++i' bit += 5) {  	/* set v to the 16-bit value starting at src[bits/8]' 0-padded. */v = ((byte)src [bit / 8]) << 8;  	if (bit + 5 < nbits)  		v += (byte)src [(bit / 8) + 1];  	/* set u to the 5-bit value at the bit'th bit of src. */u = (v >> (11 - (bit % 8))) & 0x1F;  	sb.Append (BASE32_CHARS [u]);  }  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,tobase32str,The following statement contains a magic number: for (i = 0' bit = 0; bit < nbits; ++i' bit += 5) {  	/* set v to the 16-bit value starting at src[bits/8]' 0-padded. */v = ((byte)src [bit / 8]) << 8;  	if (bit + 5 < nbits)  		v += (byte)src [(bit / 8) + 1];  	/* set u to the 5-bit value at the bit'th bit of src. */u = (v >> (11 - (bit % 8))) & 0x1F;  	sb.Append (BASE32_CHARS [u]);  }  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,tobase32str,The following statement contains a magic number: for (i = 0' bit = 0; bit < nbits; ++i' bit += 5) {  	/* set v to the 16-bit value starting at src[bits/8]' 0-padded. */v = ((byte)src [bit / 8]) << 8;  	if (bit + 5 < nbits)  		v += (byte)src [(bit / 8) + 1];  	/* set u to the 5-bit value at the bit'th bit of src. */u = (v >> (11 - (bit % 8))) & 0x1F;  	sb.Append (BASE32_CHARS [u]);  }  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,tobase32str,The following statement contains a magic number: bit += 5
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,tobase32str,The following statement contains a magic number: v = ((byte)src [bit / 8]) << 8;  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,tobase32str,The following statement contains a magic number: v = ((byte)src [bit / 8]) << 8;  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,tobase32str,The following statement contains a magic number: if (bit + 5 < nbits)  	v += (byte)src [(bit / 8) + 1];  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,tobase32str,The following statement contains a magic number: if (bit + 5 < nbits)  	v += (byte)src [(bit / 8) + 1];  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,tobase32str,The following statement contains a magic number: v += (byte)src [(bit / 8) + 1];  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,tobase32str,The following statement contains a magic number: u = (v >> (11 - (bit % 8))) & 0x1F;  
Magic Number,scallion,RSAWrapper,F:\newReposMay17\lachesis_scallion\scallion\RSAWrapper.cs,tobase32str,The following statement contains a magic number: u = (v >> (11 - (bit % 8))) & 0x1F;  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,pad_data,The following statement contains a magic number: return (new byte[][] {  	data'  	new byte[] {  		0x80  	}'  	new byte[midlength]'  	Mono.DataConverter.Pack ("^L"' new object[] {  		data.Length * 8  	})  }).SelectMany (i => i).ToArray ();  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: for (int chunk = 0; chunk < data.Length / 64; chunk++) {  	uint[] W = new uint[80];  	for (int k = 0; k < 16; k++) {  		int j = chunk * 64 + k * 4;  		W [k] = (uint)(data [j + 0] << 24 | data [j + 1] << 16 | data [j + 2] << 8 | data [j + 3]);  	}  	ret.Add (W);  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: for (int chunk = 0; chunk < data.Length / 64; chunk++) {  	uint[] W = new uint[80];  	for (int k = 0; k < 16; k++) {  		int j = chunk * 64 + k * 4;  		W [k] = (uint)(data [j + 0] << 24 | data [j + 1] << 16 | data [j + 2] << 8 | data [j + 3]);  	}  	ret.Add (W);  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: for (int chunk = 0; chunk < data.Length / 64; chunk++) {  	uint[] W = new uint[80];  	for (int k = 0; k < 16; k++) {  		int j = chunk * 64 + k * 4;  		W [k] = (uint)(data [j + 0] << 24 | data [j + 1] << 16 | data [j + 2] << 8 | data [j + 3]);  	}  	ret.Add (W);  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: for (int chunk = 0; chunk < data.Length / 64; chunk++) {  	uint[] W = new uint[80];  	for (int k = 0; k < 16; k++) {  		int j = chunk * 64 + k * 4;  		W [k] = (uint)(data [j + 0] << 24 | data [j + 1] << 16 | data [j + 2] << 8 | data [j + 3]);  	}  	ret.Add (W);  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: for (int chunk = 0; chunk < data.Length / 64; chunk++) {  	uint[] W = new uint[80];  	for (int k = 0; k < 16; k++) {  		int j = chunk * 64 + k * 4;  		W [k] = (uint)(data [j + 0] << 24 | data [j + 1] << 16 | data [j + 2] << 8 | data [j + 3]);  	}  	ret.Add (W);  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: for (int chunk = 0; chunk < data.Length / 64; chunk++) {  	uint[] W = new uint[80];  	for (int k = 0; k < 16; k++) {  		int j = chunk * 64 + k * 4;  		W [k] = (uint)(data [j + 0] << 24 | data [j + 1] << 16 | data [j + 2] << 8 | data [j + 3]);  	}  	ret.Add (W);  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: for (int chunk = 0; chunk < data.Length / 64; chunk++) {  	uint[] W = new uint[80];  	for (int k = 0; k < 16; k++) {  		int j = chunk * 64 + k * 4;  		W [k] = (uint)(data [j + 0] << 24 | data [j + 1] << 16 | data [j + 2] << 8 | data [j + 3]);  	}  	ret.Add (W);  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: for (int chunk = 0; chunk < data.Length / 64; chunk++) {  	uint[] W = new uint[80];  	for (int k = 0; k < 16; k++) {  		int j = chunk * 64 + k * 4;  		W [k] = (uint)(data [j + 0] << 24 | data [j + 1] << 16 | data [j + 2] << 8 | data [j + 3]);  	}  	ret.Add (W);  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: for (int chunk = 0; chunk < data.Length / 64; chunk++) {  	uint[] W = new uint[80];  	for (int k = 0; k < 16; k++) {  		int j = chunk * 64 + k * 4;  		W [k] = (uint)(data [j + 0] << 24 | data [j + 1] << 16 | data [j + 2] << 8 | data [j + 3]);  	}  	ret.Add (W);  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: for (int chunk = 0; chunk < data.Length / 64; chunk++) {  	uint[] W = new uint[80];  	for (int k = 0; k < 16; k++) {  		int j = chunk * 64 + k * 4;  		W [k] = (uint)(data [j + 0] << 24 | data [j + 1] << 16 | data [j + 2] << 8 | data [j + 3]);  	}  	ret.Add (W);  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: for (int k = 0; k < 16; k++) {  	int j = chunk * 64 + k * 4;  	W [k] = (uint)(data [j + 0] << 24 | data [j + 1] << 16 | data [j + 2] << 8 | data [j + 3]);  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: for (int k = 0; k < 16; k++) {  	int j = chunk * 64 + k * 4;  	W [k] = (uint)(data [j + 0] << 24 | data [j + 1] << 16 | data [j + 2] << 8 | data [j + 3]);  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: for (int k = 0; k < 16; k++) {  	int j = chunk * 64 + k * 4;  	W [k] = (uint)(data [j + 0] << 24 | data [j + 1] << 16 | data [j + 2] << 8 | data [j + 3]);  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: for (int k = 0; k < 16; k++) {  	int j = chunk * 64 + k * 4;  	W [k] = (uint)(data [j + 0] << 24 | data [j + 1] << 16 | data [j + 2] << 8 | data [j + 3]);  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: for (int k = 0; k < 16; k++) {  	int j = chunk * 64 + k * 4;  	W [k] = (uint)(data [j + 0] << 24 | data [j + 1] << 16 | data [j + 2] << 8 | data [j + 3]);  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: for (int k = 0; k < 16; k++) {  	int j = chunk * 64 + k * 4;  	W [k] = (uint)(data [j + 0] << 24 | data [j + 1] << 16 | data [j + 2] << 8 | data [j + 3]);  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: for (int k = 0; k < 16; k++) {  	int j = chunk * 64 + k * 4;  	W [k] = (uint)(data [j + 0] << 24 | data [j + 1] << 16 | data [j + 2] << 8 | data [j + 3]);  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: for (int k = 0; k < 16; k++) {  	int j = chunk * 64 + k * 4;  	W [k] = (uint)(data [j + 0] << 24 | data [j + 1] << 16 | data [j + 2] << 8 | data [j + 3]);  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: W [k] = (uint)(data [j + 0] << 24 | data [j + 1] << 16 | data [j + 2] << 8 | data [j + 3]);  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: W [k] = (uint)(data [j + 0] << 24 | data [j + 1] << 16 | data [j + 2] << 8 | data [j + 3]);  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: W [k] = (uint)(data [j + 0] << 24 | data [j + 1] << 16 | data [j + 2] << 8 | data [j + 3]);  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: W [k] = (uint)(data [j + 0] << 24 | data [j + 1] << 16 | data [j + 2] << 8 | data [j + 3]);  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,DataToPaddedBlocks,The following statement contains a magic number: W [k] = (uint)(data [j + 0] << 24 | data [j + 1] << 16 | data [j + 2] << 8 | data [j + 3]);  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,rotateLeft,The following statement contains a magic number: return (x << n) | (x >> (32 - n));  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: C = H [2];  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: D = H [3];  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: E = H [4];  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: for (i = 16; i < 80; i++) {  	W [i] = rotateLeft (W [i - 3] ^ W [i - 8] ^ W [i - 14] ^ W [i - 16]' 1);  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: for (i = 16; i < 80; i++) {  	W [i] = rotateLeft (W [i - 3] ^ W [i - 8] ^ W [i - 14] ^ W [i - 16]' 1);  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: for (i = 16; i < 80; i++) {  	W [i] = rotateLeft (W [i - 3] ^ W [i - 8] ^ W [i - 14] ^ W [i - 16]' 1);  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: for (i = 16; i < 80; i++) {  	W [i] = rotateLeft (W [i - 3] ^ W [i - 8] ^ W [i - 14] ^ W [i - 16]' 1);  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: for (i = 16; i < 80; i++) {  	W [i] = rotateLeft (W [i - 3] ^ W [i - 8] ^ W [i - 14] ^ W [i - 16]' 1);  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: for (i = 16; i < 80; i++) {  	W [i] = rotateLeft (W [i - 3] ^ W [i - 8] ^ W [i - 14] ^ W [i - 16]' 1);  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: i = 16
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: W [i] = rotateLeft (W [i - 3] ^ W [i - 8] ^ W [i - 14] ^ W [i - 16]' 1);  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: W [i] = rotateLeft (W [i - 3] ^ W [i - 8] ^ W [i - 14] ^ W [i - 16]' 1);  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: W [i] = rotateLeft (W [i - 3] ^ W [i - 8] ^ W [i - 14] ^ W [i - 16]' 1);  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: W [i] = rotateLeft (W [i - 3] ^ W [i - 8] ^ W [i - 14] ^ W [i - 16]' 1);  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: for (i = 0; i < 20; i++) {  	temp = rotateLeft (A' 5) + ((B & C) | ((~B) & D)) + E + W [i] + K0;  	E = D;  	D = C;  	C = rotateLeft (B' 30);  	B = A;  	A = temp;  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: for (i = 0; i < 20; i++) {  	temp = rotateLeft (A' 5) + ((B & C) | ((~B) & D)) + E + W [i] + K0;  	E = D;  	D = C;  	C = rotateLeft (B' 30);  	B = A;  	A = temp;  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: for (i = 0; i < 20; i++) {  	temp = rotateLeft (A' 5) + ((B & C) | ((~B) & D)) + E + W [i] + K0;  	E = D;  	D = C;  	C = rotateLeft (B' 30);  	B = A;  	A = temp;  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: temp = rotateLeft (A' 5) + ((B & C) | ((~B) & D)) + E + W [i] + K0;  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: C = rotateLeft (B' 30);  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: for (i = 20; i < 40; i++) {  	temp = rotateLeft (A' 5) + (B ^ C ^ D) + E + W [i] + K1;  	E = D;  	D = C;  	C = rotateLeft (B' 30);  	B = A;  	A = temp;  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: for (i = 20; i < 40; i++) {  	temp = rotateLeft (A' 5) + (B ^ C ^ D) + E + W [i] + K1;  	E = D;  	D = C;  	C = rotateLeft (B' 30);  	B = A;  	A = temp;  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: for (i = 20; i < 40; i++) {  	temp = rotateLeft (A' 5) + (B ^ C ^ D) + E + W [i] + K1;  	E = D;  	D = C;  	C = rotateLeft (B' 30);  	B = A;  	A = temp;  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: for (i = 20; i < 40; i++) {  	temp = rotateLeft (A' 5) + (B ^ C ^ D) + E + W [i] + K1;  	E = D;  	D = C;  	C = rotateLeft (B' 30);  	B = A;  	A = temp;  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: i = 20
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: temp = rotateLeft (A' 5) + (B ^ C ^ D) + E + W [i] + K1;  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: C = rotateLeft (B' 30);  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: for (i = 40; i < 60; i++) {  	temp = rotateLeft (A' 5) + ((B & C) | (B & D) | (C & D)) + E + W [i] + K2;  	E = D;  	D = C;  	C = rotateLeft (B' 30);  	B = A;  	A = temp;  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: for (i = 40; i < 60; i++) {  	temp = rotateLeft (A' 5) + ((B & C) | (B & D) | (C & D)) + E + W [i] + K2;  	E = D;  	D = C;  	C = rotateLeft (B' 30);  	B = A;  	A = temp;  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: for (i = 40; i < 60; i++) {  	temp = rotateLeft (A' 5) + ((B & C) | (B & D) | (C & D)) + E + W [i] + K2;  	E = D;  	D = C;  	C = rotateLeft (B' 30);  	B = A;  	A = temp;  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: for (i = 40; i < 60; i++) {  	temp = rotateLeft (A' 5) + ((B & C) | (B & D) | (C & D)) + E + W [i] + K2;  	E = D;  	D = C;  	C = rotateLeft (B' 30);  	B = A;  	A = temp;  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: i = 40
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: temp = rotateLeft (A' 5) + ((B & C) | (B & D) | (C & D)) + E + W [i] + K2;  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: C = rotateLeft (B' 30);  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: for (i = 60; i < 80; i++) {  	temp = rotateLeft (A' 5) + (B ^ C ^ D) + E + W [i] + K3;  	E = D;  	D = C;  	C = rotateLeft (B' 30);  	B = A;  	A = temp;  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: for (i = 60; i < 80; i++) {  	temp = rotateLeft (A' 5) + (B ^ C ^ D) + E + W [i] + K3;  	E = D;  	D = C;  	C = rotateLeft (B' 30);  	B = A;  	A = temp;  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: for (i = 60; i < 80; i++) {  	temp = rotateLeft (A' 5) + (B ^ C ^ D) + E + W [i] + K3;  	E = D;  	D = C;  	C = rotateLeft (B' 30);  	B = A;  	A = temp;  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: for (i = 60; i < 80; i++) {  	temp = rotateLeft (A' 5) + (B ^ C ^ D) + E + W [i] + K3;  	E = D;  	D = C;  	C = rotateLeft (B' 30);  	B = A;  	A = temp;  }  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: i = 60
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: temp = rotateLeft (A' 5) + (B ^ C ^ D) + E + W [i] + K3;  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: C = rotateLeft (B' 30);  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: H [2] = (H [2] + C);  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: H [2] = (H [2] + C);  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: H [3] = (H [3] + D);  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: H [3] = (H [3] + D);  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: H [4] = (H [4] + E);  
Magic Number,scallion,SHA1,F:\newReposMay17\lachesis_scallion\scallion\SHA1.cs,SHA1_Block,The following statement contains a magic number: H [4] = (H [4] + E);  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToUIntArray,The following statement contains a magic number: for (int i = 0; i < padded.Length; i += 4)  	ret [i / 4] = (uint)(padded [i] << 24) | (uint)(padded [i + 1] << 16) | (uint)(padded [i + 2] << 8) | (uint)(padded [i + 3] << 0);  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToUIntArray,The following statement contains a magic number: for (int i = 0; i < padded.Length; i += 4)  	ret [i / 4] = (uint)(padded [i] << 24) | (uint)(padded [i + 1] << 16) | (uint)(padded [i + 2] << 8) | (uint)(padded [i + 3] << 0);  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToUIntArray,The following statement contains a magic number: for (int i = 0; i < padded.Length; i += 4)  	ret [i / 4] = (uint)(padded [i] << 24) | (uint)(padded [i + 1] << 16) | (uint)(padded [i + 2] << 8) | (uint)(padded [i + 3] << 0);  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToUIntArray,The following statement contains a magic number: for (int i = 0; i < padded.Length; i += 4)  	ret [i / 4] = (uint)(padded [i] << 24) | (uint)(padded [i + 1] << 16) | (uint)(padded [i + 2] << 8) | (uint)(padded [i + 3] << 0);  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToUIntArray,The following statement contains a magic number: for (int i = 0; i < padded.Length; i += 4)  	ret [i / 4] = (uint)(padded [i] << 24) | (uint)(padded [i + 1] << 16) | (uint)(padded [i + 2] << 8) | (uint)(padded [i + 3] << 0);  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToUIntArray,The following statement contains a magic number: for (int i = 0; i < padded.Length; i += 4)  	ret [i / 4] = (uint)(padded [i] << 24) | (uint)(padded [i + 1] << 16) | (uint)(padded [i + 2] << 8) | (uint)(padded [i + 3] << 0);  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToUIntArray,The following statement contains a magic number: for (int i = 0; i < padded.Length; i += 4)  	ret [i / 4] = (uint)(padded [i] << 24) | (uint)(padded [i + 1] << 16) | (uint)(padded [i + 2] << 8) | (uint)(padded [i + 3] << 0);  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToUIntArray,The following statement contains a magic number: i += 4
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToUIntArray,The following statement contains a magic number: ret [i / 4] = (uint)(padded [i] << 24) | (uint)(padded [i + 1] << 16) | (uint)(padded [i + 2] << 8) | (uint)(padded [i + 3] << 0);  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToUIntArray,The following statement contains a magic number: ret [i / 4] = (uint)(padded [i] << 24) | (uint)(padded [i + 1] << 16) | (uint)(padded [i + 2] << 8) | (uint)(padded [i + 3] << 0);  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToUIntArray,The following statement contains a magic number: ret [i / 4] = (uint)(padded [i] << 24) | (uint)(padded [i + 1] << 16) | (uint)(padded [i + 2] << 8) | (uint)(padded [i + 3] << 0);  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToUIntArray,The following statement contains a magic number: ret [i / 4] = (uint)(padded [i] << 24) | (uint)(padded [i + 1] << 16) | (uint)(padded [i + 2] << 8) | (uint)(padded [i + 3] << 0);  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToUIntArray,The following statement contains a magic number: ret [i / 4] = (uint)(padded [i] << 24) | (uint)(padded [i + 1] << 16) | (uint)(padded [i + 2] << 8) | (uint)(padded [i + 3] << 0);  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToUIntArray,The following statement contains a magic number: ret [i / 4] = (uint)(padded [i] << 24) | (uint)(padded [i + 1] << 16) | (uint)(padded [i + 2] << 8) | (uint)(padded [i + 3] << 0);  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: if (nbits % 8 != 0)  	throw new System.ArgumentException ("We need an even multiple of 8 bits.");  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: for (int i = 0' bit = 0; bit < nbits; ++i' bit += 8) {  	switch (bit % 40) {  	case 0:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  		break;  	case 8:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  		break;  	case 16:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  		break;  	case 24:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  		break;  	case 32:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  		break;  	}  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: for (int i = 0' bit = 0; bit < nbits; ++i' bit += 8) {  	switch (bit % 40) {  	case 0:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  		break;  	case 8:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  		break;  	case 16:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  		break;  	case 24:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  		break;  	case 32:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  		break;  	}  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: for (int i = 0' bit = 0; bit < nbits; ++i' bit += 8) {  	switch (bit % 40) {  	case 0:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  		break;  	case 8:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  		break;  	case 16:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  		break;  	case 24:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  		break;  	case 32:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  		break;  	}  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: for (int i = 0' bit = 0; bit < nbits; ++i' bit += 8) {  	switch (bit % 40) {  	case 0:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  		break;  	case 8:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  		break;  	case 16:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  		break;  	case 24:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  		break;  	case 32:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  		break;  	}  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: for (int i = 0' bit = 0; bit < nbits; ++i' bit += 8) {  	switch (bit % 40) {  	case 0:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  		break;  	case 8:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  		break;  	case 16:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  		break;  	case 24:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  		break;  	case 32:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  		break;  	}  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: for (int i = 0' bit = 0; bit < nbits; ++i' bit += 8) {  	switch (bit % 40) {  	case 0:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  		break;  	case 8:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  		break;  	case 16:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  		break;  	case 24:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  		break;  	case 32:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  		break;  	}  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: for (int i = 0' bit = 0; bit < nbits; ++i' bit += 8) {  	switch (bit % 40) {  	case 0:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  		break;  	case 8:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  		break;  	case 16:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  		break;  	case 24:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  		break;  	case 32:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  		break;  	}  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: for (int i = 0' bit = 0; bit < nbits; ++i' bit += 8) {  	switch (bit % 40) {  	case 0:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  		break;  	case 8:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  		break;  	case 16:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  		break;  	case 24:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  		break;  	case 32:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  		break;  	}  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: for (int i = 0' bit = 0; bit < nbits; ++i' bit += 8) {  	switch (bit % 40) {  	case 0:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  		break;  	case 8:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  		break;  	case 16:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  		break;  	case 24:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  		break;  	case 32:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  		break;  	}  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: for (int i = 0' bit = 0; bit < nbits; ++i' bit += 8) {  	switch (bit % 40) {  	case 0:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  		break;  	case 8:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  		break;  	case 16:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  		break;  	case 24:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  		break;  	case 32:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  		break;  	}  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: for (int i = 0' bit = 0; bit < nbits; ++i' bit += 8) {  	switch (bit % 40) {  	case 0:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  		break;  	case 8:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  		break;  	case 16:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  		break;  	case 24:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  		break;  	case 32:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  		break;  	}  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: for (int i = 0' bit = 0; bit < nbits; ++i' bit += 8) {  	switch (bit % 40) {  	case 0:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  		break;  	case 8:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  		break;  	case 16:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  		break;  	case 24:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  		break;  	case 32:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  		break;  	}  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: for (int i = 0' bit = 0; bit < nbits; ++i' bit += 8) {  	switch (bit % 40) {  	case 0:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  		break;  	case 8:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  		break;  	case 16:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  		break;  	case 24:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  		break;  	case 32:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  		break;  	}  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: for (int i = 0' bit = 0; bit < nbits; ++i' bit += 8) {  	switch (bit % 40) {  	case 0:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  		break;  	case 8:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  		break;  	case 16:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  		break;  	case 24:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  		break;  	case 32:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  		break;  	}  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: for (int i = 0' bit = 0; bit < nbits; ++i' bit += 8) {  	switch (bit % 40) {  	case 0:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  		break;  	case 8:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  		break;  	case 16:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  		break;  	case 24:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  		break;  	case 32:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  		break;  	}  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: for (int i = 0' bit = 0; bit < nbits; ++i' bit += 8) {  	switch (bit % 40) {  	case 0:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  		break;  	case 8:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  		break;  	case 16:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  		break;  	case 24:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  		break;  	case 32:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  		break;  	}  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: for (int i = 0' bit = 0; bit < nbits; ++i' bit += 8) {  	switch (bit % 40) {  	case 0:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  		break;  	case 8:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  		break;  	case 16:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  		break;  	case 24:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  		break;  	case 32:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  		break;  	}  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: for (int i = 0' bit = 0; bit < nbits; ++i' bit += 8) {  	switch (bit % 40) {  	case 0:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  		break;  	case 8:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  		break;  	case 16:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  		break;  	case 24:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  		break;  	case 32:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  		break;  	}  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: for (int i = 0' bit = 0; bit < nbits; ++i' bit += 8) {  	switch (bit % 40) {  	case 0:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  		break;  	case 8:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  		break;  	case 16:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  		break;  	case 24:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  		break;  	case 32:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  		break;  	}  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: for (int i = 0' bit = 0; bit < nbits; ++i' bit += 8) {  	switch (bit % 40) {  	case 0:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  		break;  	case 8:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  		break;  	case 16:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  		break;  	case 24:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  		break;  	case 32:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  		break;  	}  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: for (int i = 0' bit = 0; bit < nbits; ++i' bit += 8) {  	switch (bit % 40) {  	case 0:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  		break;  	case 8:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  		break;  	case 16:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  		break;  	case 24:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  		break;  	case 32:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  		break;  	}  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: for (int i = 0' bit = 0; bit < nbits; ++i' bit += 8) {  	switch (bit % 40) {  	case 0:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  		break;  	case 8:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  		break;  	case 16:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  		break;  	case 24:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  		break;  	case 32:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  		break;  	}  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: for (int i = 0' bit = 0; bit < nbits; ++i' bit += 8) {  	switch (bit % 40) {  	case 0:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  		break;  	case 8:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  		break;  	case 16:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  		break;  	case 24:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  		break;  	case 32:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  		break;  	}  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: for (int i = 0' bit = 0; bit < nbits; ++i' bit += 8) {  	switch (bit % 40) {  	case 0:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  		break;  	case 8:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  		break;  	case 16:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  		break;  	case 24:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  		break;  	case 32:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  		break;  	}  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: for (int i = 0' bit = 0; bit < nbits; ++i' bit += 8) {  	switch (bit % 40) {  	case 0:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  		break;  	case 8:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  		break;  	case 16:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  		break;  	case 24:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  		break;  	case 32:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  		break;  	}  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: for (int i = 0' bit = 0; bit < nbits; ++i' bit += 8) {  	switch (bit % 40) {  	case 0:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  		break;  	case 8:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  		break;  	case 16:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  		break;  	case 24:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  		break;  	case 32:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  		break;  	}  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: for (int i = 0' bit = 0; bit < nbits; ++i' bit += 8) {  	switch (bit % 40) {  	case 0:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  		break;  	case 8:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  		break;  	case 16:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  		break;  	case 24:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  		break;  	case 32:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  		break;  	}  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: for (int i = 0' bit = 0; bit < nbits; ++i' bit += 8) {  	switch (bit % 40) {  	case 0:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  		break;  	case 8:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  		break;  	case 16:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  		break;  	case 24:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  		break;  	case 32:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  		break;  	}  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: for (int i = 0' bit = 0; bit < nbits; ++i' bit += 8) {  	switch (bit % 40) {  	case 0:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  		break;  	case 8:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  		break;  	case 16:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  		break;  	case 24:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  		break;  	case 32:  		dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  		break;  	}  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: bit += 8
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40) {  case 0:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  	break;  case 8:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  	break;  case 16:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  	break;  case 24:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  	break;  case 32:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  	break;  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40) {  case 0:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  	break;  case 8:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  	break;  case 16:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  	break;  case 24:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  	break;  case 32:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  	break;  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40) {  case 0:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  	break;  case 8:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  	break;  case 16:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  	break;  case 24:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  	break;  case 32:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  	break;  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40) {  case 0:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  	break;  case 8:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  	break;  case 16:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  	break;  case 24:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  	break;  case 32:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  	break;  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40) {  case 0:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  	break;  case 8:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  	break;  case 16:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  	break;  case 24:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  	break;  case 32:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  	break;  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40) {  case 0:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  	break;  case 8:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  	break;  case 16:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  	break;  case 24:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  	break;  case 32:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  	break;  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40) {  case 0:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  	break;  case 8:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  	break;  case 16:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  	break;  case 24:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  	break;  case 32:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  	break;  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40) {  case 0:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  	break;  case 8:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  	break;  case 16:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  	break;  case 24:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  	break;  case 32:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  	break;  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40) {  case 0:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  	break;  case 8:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  	break;  case 16:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  	break;  case 24:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  	break;  case 32:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  	break;  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40) {  case 0:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  	break;  case 8:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  	break;  case 16:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  	break;  case 24:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  	break;  case 32:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  	break;  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40) {  case 0:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  	break;  case 8:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  	break;  case 16:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  	break;  case 24:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  	break;  case 32:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  	break;  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40) {  case 0:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  	break;  case 8:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  	break;  case 16:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  	break;  case 24:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  	break;  case 32:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  	break;  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40) {  case 0:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  	break;  case 8:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  	break;  case 16:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  	break;  case 24:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  	break;  case 32:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  	break;  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40) {  case 0:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  	break;  case 8:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  	break;  case 16:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  	break;  case 24:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  	break;  case 32:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  	break;  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40) {  case 0:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  	break;  case 8:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  	break;  case 16:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  	break;  case 24:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  	break;  case 32:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  	break;  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40) {  case 0:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  	break;  case 8:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  	break;  case 16:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  	break;  case 24:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  	break;  case 32:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  	break;  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40) {  case 0:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  	break;  case 8:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  	break;  case 16:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  	break;  case 24:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  	break;  case 32:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  	break;  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40) {  case 0:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  	break;  case 8:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  	break;  case 16:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  	break;  case 24:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  	break;  case 32:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  	break;  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40) {  case 0:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  	break;  case 8:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  	break;  case 16:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  	break;  case 24:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  	break;  case 32:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  	break;  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40) {  case 0:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  	break;  case 8:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  	break;  case 16:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  	break;  case 24:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  	break;  case 32:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  	break;  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40) {  case 0:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  	break;  case 8:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  	break;  case 16:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  	break;  case 24:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  	break;  case 32:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  	break;  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40) {  case 0:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  	break;  case 8:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  	break;  case 16:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  	break;  case 24:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  	break;  case 32:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  	break;  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40) {  case 0:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  	break;  case 8:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  	break;  case 16:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  	break;  case 24:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  	break;  case 32:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  	break;  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40) {  case 0:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  	break;  case 8:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  	break;  case 16:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  	break;  case 24:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  	break;  case 32:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  	break;  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40) {  case 0:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  	break;  case 8:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  	break;  case 16:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  	break;  case 24:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  	break;  case 32:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  	break;  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40) {  case 0:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  	break;  case 8:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  	break;  case 16:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  	break;  case 24:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  	break;  case 32:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  	break;  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40) {  case 0:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  	break;  case 8:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  	break;  case 16:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  	break;  case 24:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  	break;  case 32:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  	break;  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: switch (bit % 40) {  case 0:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  	break;  case 8:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  	break;  case 16:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  	break;  case 24:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  	break;  case 32:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  	break;  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following statement contains a magic number: dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToBase32Str,The following statement contains a magic number: if (nbits % 5 != 0)  	throw new System.ArgumentException ("We need an even multiple of 5 bits.");  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToBase32Str,The following statement contains a magic number: for (i = 0' bit = 0; bit < nbits; ++i' bit += 5) {  	/* set v to the 16-bit value starting at src[bits/8]' 0-padded. */v = ((byte)src [bit / 8]) << 8;  	if (bit + 5 < nbits)  		v += (byte)src [(bit / 8) + 1];  	/* set u to the 5-bit value at the bit'th bit of src. */u = (v >> (11 - (bit % 8))) & 0x1F;  	sb.Append (BASE32_CHARS [u]);  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToBase32Str,The following statement contains a magic number: for (i = 0' bit = 0; bit < nbits; ++i' bit += 5) {  	/* set v to the 16-bit value starting at src[bits/8]' 0-padded. */v = ((byte)src [bit / 8]) << 8;  	if (bit + 5 < nbits)  		v += (byte)src [(bit / 8) + 1];  	/* set u to the 5-bit value at the bit'th bit of src. */u = (v >> (11 - (bit % 8))) & 0x1F;  	sb.Append (BASE32_CHARS [u]);  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToBase32Str,The following statement contains a magic number: for (i = 0' bit = 0; bit < nbits; ++i' bit += 5) {  	/* set v to the 16-bit value starting at src[bits/8]' 0-padded. */v = ((byte)src [bit / 8]) << 8;  	if (bit + 5 < nbits)  		v += (byte)src [(bit / 8) + 1];  	/* set u to the 5-bit value at the bit'th bit of src. */u = (v >> (11 - (bit % 8))) & 0x1F;  	sb.Append (BASE32_CHARS [u]);  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToBase32Str,The following statement contains a magic number: for (i = 0' bit = 0; bit < nbits; ++i' bit += 5) {  	/* set v to the 16-bit value starting at src[bits/8]' 0-padded. */v = ((byte)src [bit / 8]) << 8;  	if (bit + 5 < nbits)  		v += (byte)src [(bit / 8) + 1];  	/* set u to the 5-bit value at the bit'th bit of src. */u = (v >> (11 - (bit % 8))) & 0x1F;  	sb.Append (BASE32_CHARS [u]);  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToBase32Str,The following statement contains a magic number: for (i = 0' bit = 0; bit < nbits; ++i' bit += 5) {  	/* set v to the 16-bit value starting at src[bits/8]' 0-padded. */v = ((byte)src [bit / 8]) << 8;  	if (bit + 5 < nbits)  		v += (byte)src [(bit / 8) + 1];  	/* set u to the 5-bit value at the bit'th bit of src. */u = (v >> (11 - (bit % 8))) & 0x1F;  	sb.Append (BASE32_CHARS [u]);  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToBase32Str,The following statement contains a magic number: for (i = 0' bit = 0; bit < nbits; ++i' bit += 5) {  	/* set v to the 16-bit value starting at src[bits/8]' 0-padded. */v = ((byte)src [bit / 8]) << 8;  	if (bit + 5 < nbits)  		v += (byte)src [(bit / 8) + 1];  	/* set u to the 5-bit value at the bit'th bit of src. */u = (v >> (11 - (bit % 8))) & 0x1F;  	sb.Append (BASE32_CHARS [u]);  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToBase32Str,The following statement contains a magic number: for (i = 0' bit = 0; bit < nbits; ++i' bit += 5) {  	/* set v to the 16-bit value starting at src[bits/8]' 0-padded. */v = ((byte)src [bit / 8]) << 8;  	if (bit + 5 < nbits)  		v += (byte)src [(bit / 8) + 1];  	/* set u to the 5-bit value at the bit'th bit of src. */u = (v >> (11 - (bit % 8))) & 0x1F;  	sb.Append (BASE32_CHARS [u]);  }  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToBase32Str,The following statement contains a magic number: bit += 5
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToBase32Str,The following statement contains a magic number: v = ((byte)src [bit / 8]) << 8;  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToBase32Str,The following statement contains a magic number: v = ((byte)src [bit / 8]) << 8;  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToBase32Str,The following statement contains a magic number: if (bit + 5 < nbits)  	v += (byte)src [(bit / 8) + 1];  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToBase32Str,The following statement contains a magic number: if (bit + 5 < nbits)  	v += (byte)src [(bit / 8) + 1];  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToBase32Str,The following statement contains a magic number: v += (byte)src [(bit / 8) + 1];  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToBase32Str,The following statement contains a magic number: u = (v >> (11 - (bit % 8))) & 0x1F;  
Magic Number,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,ToBase32Str,The following statement contains a magic number: u = (v >> (11 - (bit % 8))) & 0x1F;  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,The following statement contains a magic number: while (true) {  	bool inputQueueIsLow = false;  	lock (_kernelInput) {  		inputQueueIsLow = _kernelInput.Count < 300;  	}  	if (inputQueueIsLow) {  		KernelInput input = new KernelInput (1);  		// Generate keys if the queue is low  		profiler.StartRegion ("generate key");  		input.Rsa.GenerateKey ((int)parms.KeySize);  		// Generate a key  		if (parms.UnixTs != 0) {  			input.Rsa.Timestamp = parms.UnixTs;  		}  		profiler.EndRegion ("generate key");  		// Build DERs and calculate midstates for exponents of representitive lengths  		profiler.StartRegion ("cpu precompute");  		bool skip_flag = false;  		uint exp = parms.ToolConfig.MinimumExponent;  		// Set the exponent in the RSA key  		// NO SANITY CHECK - just for building a DER/GPG v4 packet  		input.Rsa.Rsa.PublicExponent = (BigNumber)exp;  		// Get the GPG v4 packet  		int exp_index;  		byte[] data = parms.ToolConfig.GetPublicKeyData (input.Rsa' out exp_index);  		//byte[] data = input.Rsa.GPG_v4Packet(out exp_index);  		exp_index %= 64;  		// SHA-1 block size  		if (exp_index != parms.ExponentIndex) {  			Console.WriteLine ("Exponent index doesn't match - skipping key");  			skip_flag = true;  			break;  		}  		/*if(i != 4) { // exponent length assumed to be 4 in the kernel 						Console.WriteLine("Exponent length doesn't match - skipping key"); 						skip_flag = true; 						break; 					}*/// Put the v4 packet into Ws  		SHA1 Sha1 = new SHA1 ();  		List<uint[]> Ws = Sha1.DataToPaddedBlocks (data);  		// Put all but the last block through the hash  		Ws.Take (Ws.Count - 1).Select (t => {  			Sha1.SHA1_Block (t);  			return t;  		}).ToArray ();  		// Put the midstate' the last W block' and the byte index of the exponent into the CL buffers  		Sha1.H.CopyTo (input.Midstates' 0);  		Ws.Last ().Take (16).ToArray ().CopyTo (input.LastWs' 0);  		input.ExpIndexes [0] = exp_index;  		profiler.EndRegion ("cpu precompute");  		if (skip_flag)  			continue;  		// we got a bad key - don't enqueue it  		List<KernelInput> inputs = new List<KernelInput> ();  		inputs.Add (input);  		// Stretch the key for multiple exponents (if more than one kernel iteration (work group?) will be needed)  		for (uint i = 1; i < (parms.ToolConfig.MaximumExponent - parms.ToolConfig.MinimumExponent) / 2 / workSize - 1; i++) {  			//profiler.StartRegion("generate key");  			if (parms.ToolConfig.MinimumExponent + workSize * 2 * i >= parms.ToolConfig.MaximumExponent)  				throw new ArgumentException ("base_exp > EXP_MAX");  			inputs.Add (new KernelInput (input' parms.ToolConfig.MinimumExponent + workSize * 2 * i));  			//profiler.EndRegion("generate key");  		}  		// TODO: Stretch the key for multiple time stamps for GPG  		lock (_kernelInput)//put input on queue  		 {  			foreach (KernelInput i in inputs) {  				_kernelInput.Push (i);  			}  			//Console.WriteLine("[DEBUG] Input pool size: {0}"' _kernelInput.Count);  		}  		continue;  		//skip the sleep cause we might be really low  	}  	Thread.Sleep (50);  }  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,The following statement contains a magic number: while (true) {  	bool inputQueueIsLow = false;  	lock (_kernelInput) {  		inputQueueIsLow = _kernelInput.Count < 300;  	}  	if (inputQueueIsLow) {  		KernelInput input = new KernelInput (1);  		// Generate keys if the queue is low  		profiler.StartRegion ("generate key");  		input.Rsa.GenerateKey ((int)parms.KeySize);  		// Generate a key  		if (parms.UnixTs != 0) {  			input.Rsa.Timestamp = parms.UnixTs;  		}  		profiler.EndRegion ("generate key");  		// Build DERs and calculate midstates for exponents of representitive lengths  		profiler.StartRegion ("cpu precompute");  		bool skip_flag = false;  		uint exp = parms.ToolConfig.MinimumExponent;  		// Set the exponent in the RSA key  		// NO SANITY CHECK - just for building a DER/GPG v4 packet  		input.Rsa.Rsa.PublicExponent = (BigNumber)exp;  		// Get the GPG v4 packet  		int exp_index;  		byte[] data = parms.ToolConfig.GetPublicKeyData (input.Rsa' out exp_index);  		//byte[] data = input.Rsa.GPG_v4Packet(out exp_index);  		exp_index %= 64;  		// SHA-1 block size  		if (exp_index != parms.ExponentIndex) {  			Console.WriteLine ("Exponent index doesn't match - skipping key");  			skip_flag = true;  			break;  		}  		/*if(i != 4) { // exponent length assumed to be 4 in the kernel 						Console.WriteLine("Exponent length doesn't match - skipping key"); 						skip_flag = true; 						break; 					}*/// Put the v4 packet into Ws  		SHA1 Sha1 = new SHA1 ();  		List<uint[]> Ws = Sha1.DataToPaddedBlocks (data);  		// Put all but the last block through the hash  		Ws.Take (Ws.Count - 1).Select (t => {  			Sha1.SHA1_Block (t);  			return t;  		}).ToArray ();  		// Put the midstate' the last W block' and the byte index of the exponent into the CL buffers  		Sha1.H.CopyTo (input.Midstates' 0);  		Ws.Last ().Take (16).ToArray ().CopyTo (input.LastWs' 0);  		input.ExpIndexes [0] = exp_index;  		profiler.EndRegion ("cpu precompute");  		if (skip_flag)  			continue;  		// we got a bad key - don't enqueue it  		List<KernelInput> inputs = new List<KernelInput> ();  		inputs.Add (input);  		// Stretch the key for multiple exponents (if more than one kernel iteration (work group?) will be needed)  		for (uint i = 1; i < (parms.ToolConfig.MaximumExponent - parms.ToolConfig.MinimumExponent) / 2 / workSize - 1; i++) {  			//profiler.StartRegion("generate key");  			if (parms.ToolConfig.MinimumExponent + workSize * 2 * i >= parms.ToolConfig.MaximumExponent)  				throw new ArgumentException ("base_exp > EXP_MAX");  			inputs.Add (new KernelInput (input' parms.ToolConfig.MinimumExponent + workSize * 2 * i));  			//profiler.EndRegion("generate key");  		}  		// TODO: Stretch the key for multiple time stamps for GPG  		lock (_kernelInput)//put input on queue  		 {  			foreach (KernelInput i in inputs) {  				_kernelInput.Push (i);  			}  			//Console.WriteLine("[DEBUG] Input pool size: {0}"' _kernelInput.Count);  		}  		continue;  		//skip the sleep cause we might be really low  	}  	Thread.Sleep (50);  }  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,The following statement contains a magic number: while (true) {  	bool inputQueueIsLow = false;  	lock (_kernelInput) {  		inputQueueIsLow = _kernelInput.Count < 300;  	}  	if (inputQueueIsLow) {  		KernelInput input = new KernelInput (1);  		// Generate keys if the queue is low  		profiler.StartRegion ("generate key");  		input.Rsa.GenerateKey ((int)parms.KeySize);  		// Generate a key  		if (parms.UnixTs != 0) {  			input.Rsa.Timestamp = parms.UnixTs;  		}  		profiler.EndRegion ("generate key");  		// Build DERs and calculate midstates for exponents of representitive lengths  		profiler.StartRegion ("cpu precompute");  		bool skip_flag = false;  		uint exp = parms.ToolConfig.MinimumExponent;  		// Set the exponent in the RSA key  		// NO SANITY CHECK - just for building a DER/GPG v4 packet  		input.Rsa.Rsa.PublicExponent = (BigNumber)exp;  		// Get the GPG v4 packet  		int exp_index;  		byte[] data = parms.ToolConfig.GetPublicKeyData (input.Rsa' out exp_index);  		//byte[] data = input.Rsa.GPG_v4Packet(out exp_index);  		exp_index %= 64;  		// SHA-1 block size  		if (exp_index != parms.ExponentIndex) {  			Console.WriteLine ("Exponent index doesn't match - skipping key");  			skip_flag = true;  			break;  		}  		/*if(i != 4) { // exponent length assumed to be 4 in the kernel 						Console.WriteLine("Exponent length doesn't match - skipping key"); 						skip_flag = true; 						break; 					}*/// Put the v4 packet into Ws  		SHA1 Sha1 = new SHA1 ();  		List<uint[]> Ws = Sha1.DataToPaddedBlocks (data);  		// Put all but the last block through the hash  		Ws.Take (Ws.Count - 1).Select (t => {  			Sha1.SHA1_Block (t);  			return t;  		}).ToArray ();  		// Put the midstate' the last W block' and the byte index of the exponent into the CL buffers  		Sha1.H.CopyTo (input.Midstates' 0);  		Ws.Last ().Take (16).ToArray ().CopyTo (input.LastWs' 0);  		input.ExpIndexes [0] = exp_index;  		profiler.EndRegion ("cpu precompute");  		if (skip_flag)  			continue;  		// we got a bad key - don't enqueue it  		List<KernelInput> inputs = new List<KernelInput> ();  		inputs.Add (input);  		// Stretch the key for multiple exponents (if more than one kernel iteration (work group?) will be needed)  		for (uint i = 1; i < (parms.ToolConfig.MaximumExponent - parms.ToolConfig.MinimumExponent) / 2 / workSize - 1; i++) {  			//profiler.StartRegion("generate key");  			if (parms.ToolConfig.MinimumExponent + workSize * 2 * i >= parms.ToolConfig.MaximumExponent)  				throw new ArgumentException ("base_exp > EXP_MAX");  			inputs.Add (new KernelInput (input' parms.ToolConfig.MinimumExponent + workSize * 2 * i));  			//profiler.EndRegion("generate key");  		}  		// TODO: Stretch the key for multiple time stamps for GPG  		lock (_kernelInput)//put input on queue  		 {  			foreach (KernelInput i in inputs) {  				_kernelInput.Push (i);  			}  			//Console.WriteLine("[DEBUG] Input pool size: {0}"' _kernelInput.Count);  		}  		continue;  		//skip the sleep cause we might be really low  	}  	Thread.Sleep (50);  }  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,The following statement contains a magic number: while (true) {  	bool inputQueueIsLow = false;  	lock (_kernelInput) {  		inputQueueIsLow = _kernelInput.Count < 300;  	}  	if (inputQueueIsLow) {  		KernelInput input = new KernelInput (1);  		// Generate keys if the queue is low  		profiler.StartRegion ("generate key");  		input.Rsa.GenerateKey ((int)parms.KeySize);  		// Generate a key  		if (parms.UnixTs != 0) {  			input.Rsa.Timestamp = parms.UnixTs;  		}  		profiler.EndRegion ("generate key");  		// Build DERs and calculate midstates for exponents of representitive lengths  		profiler.StartRegion ("cpu precompute");  		bool skip_flag = false;  		uint exp = parms.ToolConfig.MinimumExponent;  		// Set the exponent in the RSA key  		// NO SANITY CHECK - just for building a DER/GPG v4 packet  		input.Rsa.Rsa.PublicExponent = (BigNumber)exp;  		// Get the GPG v4 packet  		int exp_index;  		byte[] data = parms.ToolConfig.GetPublicKeyData (input.Rsa' out exp_index);  		//byte[] data = input.Rsa.GPG_v4Packet(out exp_index);  		exp_index %= 64;  		// SHA-1 block size  		if (exp_index != parms.ExponentIndex) {  			Console.WriteLine ("Exponent index doesn't match - skipping key");  			skip_flag = true;  			break;  		}  		/*if(i != 4) { // exponent length assumed to be 4 in the kernel 						Console.WriteLine("Exponent length doesn't match - skipping key"); 						skip_flag = true; 						break; 					}*/// Put the v4 packet into Ws  		SHA1 Sha1 = new SHA1 ();  		List<uint[]> Ws = Sha1.DataToPaddedBlocks (data);  		// Put all but the last block through the hash  		Ws.Take (Ws.Count - 1).Select (t => {  			Sha1.SHA1_Block (t);  			return t;  		}).ToArray ();  		// Put the midstate' the last W block' and the byte index of the exponent into the CL buffers  		Sha1.H.CopyTo (input.Midstates' 0);  		Ws.Last ().Take (16).ToArray ().CopyTo (input.LastWs' 0);  		input.ExpIndexes [0] = exp_index;  		profiler.EndRegion ("cpu precompute");  		if (skip_flag)  			continue;  		// we got a bad key - don't enqueue it  		List<KernelInput> inputs = new List<KernelInput> ();  		inputs.Add (input);  		// Stretch the key for multiple exponents (if more than one kernel iteration (work group?) will be needed)  		for (uint i = 1; i < (parms.ToolConfig.MaximumExponent - parms.ToolConfig.MinimumExponent) / 2 / workSize - 1; i++) {  			//profiler.StartRegion("generate key");  			if (parms.ToolConfig.MinimumExponent + workSize * 2 * i >= parms.ToolConfig.MaximumExponent)  				throw new ArgumentException ("base_exp > EXP_MAX");  			inputs.Add (new KernelInput (input' parms.ToolConfig.MinimumExponent + workSize * 2 * i));  			//profiler.EndRegion("generate key");  		}  		// TODO: Stretch the key for multiple time stamps for GPG  		lock (_kernelInput)//put input on queue  		 {  			foreach (KernelInput i in inputs) {  				_kernelInput.Push (i);  			}  			//Console.WriteLine("[DEBUG] Input pool size: {0}"' _kernelInput.Count);  		}  		continue;  		//skip the sleep cause we might be really low  	}  	Thread.Sleep (50);  }  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,The following statement contains a magic number: while (true) {  	bool inputQueueIsLow = false;  	lock (_kernelInput) {  		inputQueueIsLow = _kernelInput.Count < 300;  	}  	if (inputQueueIsLow) {  		KernelInput input = new KernelInput (1);  		// Generate keys if the queue is low  		profiler.StartRegion ("generate key");  		input.Rsa.GenerateKey ((int)parms.KeySize);  		// Generate a key  		if (parms.UnixTs != 0) {  			input.Rsa.Timestamp = parms.UnixTs;  		}  		profiler.EndRegion ("generate key");  		// Build DERs and calculate midstates for exponents of representitive lengths  		profiler.StartRegion ("cpu precompute");  		bool skip_flag = false;  		uint exp = parms.ToolConfig.MinimumExponent;  		// Set the exponent in the RSA key  		// NO SANITY CHECK - just for building a DER/GPG v4 packet  		input.Rsa.Rsa.PublicExponent = (BigNumber)exp;  		// Get the GPG v4 packet  		int exp_index;  		byte[] data = parms.ToolConfig.GetPublicKeyData (input.Rsa' out exp_index);  		//byte[] data = input.Rsa.GPG_v4Packet(out exp_index);  		exp_index %= 64;  		// SHA-1 block size  		if (exp_index != parms.ExponentIndex) {  			Console.WriteLine ("Exponent index doesn't match - skipping key");  			skip_flag = true;  			break;  		}  		/*if(i != 4) { // exponent length assumed to be 4 in the kernel 						Console.WriteLine("Exponent length doesn't match - skipping key"); 						skip_flag = true; 						break; 					}*/// Put the v4 packet into Ws  		SHA1 Sha1 = new SHA1 ();  		List<uint[]> Ws = Sha1.DataToPaddedBlocks (data);  		// Put all but the last block through the hash  		Ws.Take (Ws.Count - 1).Select (t => {  			Sha1.SHA1_Block (t);  			return t;  		}).ToArray ();  		// Put the midstate' the last W block' and the byte index of the exponent into the CL buffers  		Sha1.H.CopyTo (input.Midstates' 0);  		Ws.Last ().Take (16).ToArray ().CopyTo (input.LastWs' 0);  		input.ExpIndexes [0] = exp_index;  		profiler.EndRegion ("cpu precompute");  		if (skip_flag)  			continue;  		// we got a bad key - don't enqueue it  		List<KernelInput> inputs = new List<KernelInput> ();  		inputs.Add (input);  		// Stretch the key for multiple exponents (if more than one kernel iteration (work group?) will be needed)  		for (uint i = 1; i < (parms.ToolConfig.MaximumExponent - parms.ToolConfig.MinimumExponent) / 2 / workSize - 1; i++) {  			//profiler.StartRegion("generate key");  			if (parms.ToolConfig.MinimumExponent + workSize * 2 * i >= parms.ToolConfig.MaximumExponent)  				throw new ArgumentException ("base_exp > EXP_MAX");  			inputs.Add (new KernelInput (input' parms.ToolConfig.MinimumExponent + workSize * 2 * i));  			//profiler.EndRegion("generate key");  		}  		// TODO: Stretch the key for multiple time stamps for GPG  		lock (_kernelInput)//put input on queue  		 {  			foreach (KernelInput i in inputs) {  				_kernelInput.Push (i);  			}  			//Console.WriteLine("[DEBUG] Input pool size: {0}"' _kernelInput.Count);  		}  		continue;  		//skip the sleep cause we might be really low  	}  	Thread.Sleep (50);  }  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,The following statement contains a magic number: while (true) {  	bool inputQueueIsLow = false;  	lock (_kernelInput) {  		inputQueueIsLow = _kernelInput.Count < 300;  	}  	if (inputQueueIsLow) {  		KernelInput input = new KernelInput (1);  		// Generate keys if the queue is low  		profiler.StartRegion ("generate key");  		input.Rsa.GenerateKey ((int)parms.KeySize);  		// Generate a key  		if (parms.UnixTs != 0) {  			input.Rsa.Timestamp = parms.UnixTs;  		}  		profiler.EndRegion ("generate key");  		// Build DERs and calculate midstates for exponents of representitive lengths  		profiler.StartRegion ("cpu precompute");  		bool skip_flag = false;  		uint exp = parms.ToolConfig.MinimumExponent;  		// Set the exponent in the RSA key  		// NO SANITY CHECK - just for building a DER/GPG v4 packet  		input.Rsa.Rsa.PublicExponent = (BigNumber)exp;  		// Get the GPG v4 packet  		int exp_index;  		byte[] data = parms.ToolConfig.GetPublicKeyData (input.Rsa' out exp_index);  		//byte[] data = input.Rsa.GPG_v4Packet(out exp_index);  		exp_index %= 64;  		// SHA-1 block size  		if (exp_index != parms.ExponentIndex) {  			Console.WriteLine ("Exponent index doesn't match - skipping key");  			skip_flag = true;  			break;  		}  		/*if(i != 4) { // exponent length assumed to be 4 in the kernel 						Console.WriteLine("Exponent length doesn't match - skipping key"); 						skip_flag = true; 						break; 					}*/// Put the v4 packet into Ws  		SHA1 Sha1 = new SHA1 ();  		List<uint[]> Ws = Sha1.DataToPaddedBlocks (data);  		// Put all but the last block through the hash  		Ws.Take (Ws.Count - 1).Select (t => {  			Sha1.SHA1_Block (t);  			return t;  		}).ToArray ();  		// Put the midstate' the last W block' and the byte index of the exponent into the CL buffers  		Sha1.H.CopyTo (input.Midstates' 0);  		Ws.Last ().Take (16).ToArray ().CopyTo (input.LastWs' 0);  		input.ExpIndexes [0] = exp_index;  		profiler.EndRegion ("cpu precompute");  		if (skip_flag)  			continue;  		// we got a bad key - don't enqueue it  		List<KernelInput> inputs = new List<KernelInput> ();  		inputs.Add (input);  		// Stretch the key for multiple exponents (if more than one kernel iteration (work group?) will be needed)  		for (uint i = 1; i < (parms.ToolConfig.MaximumExponent - parms.ToolConfig.MinimumExponent) / 2 / workSize - 1; i++) {  			//profiler.StartRegion("generate key");  			if (parms.ToolConfig.MinimumExponent + workSize * 2 * i >= parms.ToolConfig.MaximumExponent)  				throw new ArgumentException ("base_exp > EXP_MAX");  			inputs.Add (new KernelInput (input' parms.ToolConfig.MinimumExponent + workSize * 2 * i));  			//profiler.EndRegion("generate key");  		}  		// TODO: Stretch the key for multiple time stamps for GPG  		lock (_kernelInput)//put input on queue  		 {  			foreach (KernelInput i in inputs) {  				_kernelInput.Push (i);  			}  			//Console.WriteLine("[DEBUG] Input pool size: {0}"' _kernelInput.Count);  		}  		continue;  		//skip the sleep cause we might be really low  	}  	Thread.Sleep (50);  }  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,The following statement contains a magic number: while (true) {  	bool inputQueueIsLow = false;  	lock (_kernelInput) {  		inputQueueIsLow = _kernelInput.Count < 300;  	}  	if (inputQueueIsLow) {  		KernelInput input = new KernelInput (1);  		// Generate keys if the queue is low  		profiler.StartRegion ("generate key");  		input.Rsa.GenerateKey ((int)parms.KeySize);  		// Generate a key  		if (parms.UnixTs != 0) {  			input.Rsa.Timestamp = parms.UnixTs;  		}  		profiler.EndRegion ("generate key");  		// Build DERs and calculate midstates for exponents of representitive lengths  		profiler.StartRegion ("cpu precompute");  		bool skip_flag = false;  		uint exp = parms.ToolConfig.MinimumExponent;  		// Set the exponent in the RSA key  		// NO SANITY CHECK - just for building a DER/GPG v4 packet  		input.Rsa.Rsa.PublicExponent = (BigNumber)exp;  		// Get the GPG v4 packet  		int exp_index;  		byte[] data = parms.ToolConfig.GetPublicKeyData (input.Rsa' out exp_index);  		//byte[] data = input.Rsa.GPG_v4Packet(out exp_index);  		exp_index %= 64;  		// SHA-1 block size  		if (exp_index != parms.ExponentIndex) {  			Console.WriteLine ("Exponent index doesn't match - skipping key");  			skip_flag = true;  			break;  		}  		/*if(i != 4) { // exponent length assumed to be 4 in the kernel 						Console.WriteLine("Exponent length doesn't match - skipping key"); 						skip_flag = true; 						break; 					}*/// Put the v4 packet into Ws  		SHA1 Sha1 = new SHA1 ();  		List<uint[]> Ws = Sha1.DataToPaddedBlocks (data);  		// Put all but the last block through the hash  		Ws.Take (Ws.Count - 1).Select (t => {  			Sha1.SHA1_Block (t);  			return t;  		}).ToArray ();  		// Put the midstate' the last W block' and the byte index of the exponent into the CL buffers  		Sha1.H.CopyTo (input.Midstates' 0);  		Ws.Last ().Take (16).ToArray ().CopyTo (input.LastWs' 0);  		input.ExpIndexes [0] = exp_index;  		profiler.EndRegion ("cpu precompute");  		if (skip_flag)  			continue;  		// we got a bad key - don't enqueue it  		List<KernelInput> inputs = new List<KernelInput> ();  		inputs.Add (input);  		// Stretch the key for multiple exponents (if more than one kernel iteration (work group?) will be needed)  		for (uint i = 1; i < (parms.ToolConfig.MaximumExponent - parms.ToolConfig.MinimumExponent) / 2 / workSize - 1; i++) {  			//profiler.StartRegion("generate key");  			if (parms.ToolConfig.MinimumExponent + workSize * 2 * i >= parms.ToolConfig.MaximumExponent)  				throw new ArgumentException ("base_exp > EXP_MAX");  			inputs.Add (new KernelInput (input' parms.ToolConfig.MinimumExponent + workSize * 2 * i));  			//profiler.EndRegion("generate key");  		}  		// TODO: Stretch the key for multiple time stamps for GPG  		lock (_kernelInput)//put input on queue  		 {  			foreach (KernelInput i in inputs) {  				_kernelInput.Push (i);  			}  			//Console.WriteLine("[DEBUG] Input pool size: {0}"' _kernelInput.Count);  		}  		continue;  		//skip the sleep cause we might be really low  	}  	Thread.Sleep (50);  }  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,The following statement contains a magic number: lock (_kernelInput) {  	inputQueueIsLow = _kernelInput.Count < 300;  }  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,The following statement contains a magic number: inputQueueIsLow = _kernelInput.Count < 300;  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,The following statement contains a magic number: if (inputQueueIsLow) {  	KernelInput input = new KernelInput (1);  	// Generate keys if the queue is low  	profiler.StartRegion ("generate key");  	input.Rsa.GenerateKey ((int)parms.KeySize);  	// Generate a key  	if (parms.UnixTs != 0) {  		input.Rsa.Timestamp = parms.UnixTs;  	}  	profiler.EndRegion ("generate key");  	// Build DERs and calculate midstates for exponents of representitive lengths  	profiler.StartRegion ("cpu precompute");  	bool skip_flag = false;  	uint exp = parms.ToolConfig.MinimumExponent;  	// Set the exponent in the RSA key  	// NO SANITY CHECK - just for building a DER/GPG v4 packet  	input.Rsa.Rsa.PublicExponent = (BigNumber)exp;  	// Get the GPG v4 packet  	int exp_index;  	byte[] data = parms.ToolConfig.GetPublicKeyData (input.Rsa' out exp_index);  	//byte[] data = input.Rsa.GPG_v4Packet(out exp_index);  	exp_index %= 64;  	// SHA-1 block size  	if (exp_index != parms.ExponentIndex) {  		Console.WriteLine ("Exponent index doesn't match - skipping key");  		skip_flag = true;  		break;  	}  	/*if(i != 4) { // exponent length assumed to be 4 in the kernel 						Console.WriteLine("Exponent length doesn't match - skipping key"); 						skip_flag = true; 						break; 					}*/// Put the v4 packet into Ws  	SHA1 Sha1 = new SHA1 ();  	List<uint[]> Ws = Sha1.DataToPaddedBlocks (data);  	// Put all but the last block through the hash  	Ws.Take (Ws.Count - 1).Select (t => {  		Sha1.SHA1_Block (t);  		return t;  	}).ToArray ();  	// Put the midstate' the last W block' and the byte index of the exponent into the CL buffers  	Sha1.H.CopyTo (input.Midstates' 0);  	Ws.Last ().Take (16).ToArray ().CopyTo (input.LastWs' 0);  	input.ExpIndexes [0] = exp_index;  	profiler.EndRegion ("cpu precompute");  	if (skip_flag)  		continue;  	// we got a bad key - don't enqueue it  	List<KernelInput> inputs = new List<KernelInput> ();  	inputs.Add (input);  	// Stretch the key for multiple exponents (if more than one kernel iteration (work group?) will be needed)  	for (uint i = 1; i < (parms.ToolConfig.MaximumExponent - parms.ToolConfig.MinimumExponent) / 2 / workSize - 1; i++) {  		//profiler.StartRegion("generate key");  		if (parms.ToolConfig.MinimumExponent + workSize * 2 * i >= parms.ToolConfig.MaximumExponent)  			throw new ArgumentException ("base_exp > EXP_MAX");  		inputs.Add (new KernelInput (input' parms.ToolConfig.MinimumExponent + workSize * 2 * i));  		//profiler.EndRegion("generate key");  	}  	// TODO: Stretch the key for multiple time stamps for GPG  	lock (_kernelInput)//put input on queue  	 {  		foreach (KernelInput i in inputs) {  			_kernelInput.Push (i);  		}  		//Console.WriteLine("[DEBUG] Input pool size: {0}"' _kernelInput.Count);  	}  	continue;  	//skip the sleep cause we might be really low  }  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,The following statement contains a magic number: if (inputQueueIsLow) {  	KernelInput input = new KernelInput (1);  	// Generate keys if the queue is low  	profiler.StartRegion ("generate key");  	input.Rsa.GenerateKey ((int)parms.KeySize);  	// Generate a key  	if (parms.UnixTs != 0) {  		input.Rsa.Timestamp = parms.UnixTs;  	}  	profiler.EndRegion ("generate key");  	// Build DERs and calculate midstates for exponents of representitive lengths  	profiler.StartRegion ("cpu precompute");  	bool skip_flag = false;  	uint exp = parms.ToolConfig.MinimumExponent;  	// Set the exponent in the RSA key  	// NO SANITY CHECK - just for building a DER/GPG v4 packet  	input.Rsa.Rsa.PublicExponent = (BigNumber)exp;  	// Get the GPG v4 packet  	int exp_index;  	byte[] data = parms.ToolConfig.GetPublicKeyData (input.Rsa' out exp_index);  	//byte[] data = input.Rsa.GPG_v4Packet(out exp_index);  	exp_index %= 64;  	// SHA-1 block size  	if (exp_index != parms.ExponentIndex) {  		Console.WriteLine ("Exponent index doesn't match - skipping key");  		skip_flag = true;  		break;  	}  	/*if(i != 4) { // exponent length assumed to be 4 in the kernel 						Console.WriteLine("Exponent length doesn't match - skipping key"); 						skip_flag = true; 						break; 					}*/// Put the v4 packet into Ws  	SHA1 Sha1 = new SHA1 ();  	List<uint[]> Ws = Sha1.DataToPaddedBlocks (data);  	// Put all but the last block through the hash  	Ws.Take (Ws.Count - 1).Select (t => {  		Sha1.SHA1_Block (t);  		return t;  	}).ToArray ();  	// Put the midstate' the last W block' and the byte index of the exponent into the CL buffers  	Sha1.H.CopyTo (input.Midstates' 0);  	Ws.Last ().Take (16).ToArray ().CopyTo (input.LastWs' 0);  	input.ExpIndexes [0] = exp_index;  	profiler.EndRegion ("cpu precompute");  	if (skip_flag)  		continue;  	// we got a bad key - don't enqueue it  	List<KernelInput> inputs = new List<KernelInput> ();  	inputs.Add (input);  	// Stretch the key for multiple exponents (if more than one kernel iteration (work group?) will be needed)  	for (uint i = 1; i < (parms.ToolConfig.MaximumExponent - parms.ToolConfig.MinimumExponent) / 2 / workSize - 1; i++) {  		//profiler.StartRegion("generate key");  		if (parms.ToolConfig.MinimumExponent + workSize * 2 * i >= parms.ToolConfig.MaximumExponent)  			throw new ArgumentException ("base_exp > EXP_MAX");  		inputs.Add (new KernelInput (input' parms.ToolConfig.MinimumExponent + workSize * 2 * i));  		//profiler.EndRegion("generate key");  	}  	// TODO: Stretch the key for multiple time stamps for GPG  	lock (_kernelInput)//put input on queue  	 {  		foreach (KernelInput i in inputs) {  			_kernelInput.Push (i);  		}  		//Console.WriteLine("[DEBUG] Input pool size: {0}"' _kernelInput.Count);  	}  	continue;  	//skip the sleep cause we might be really low  }  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,The following statement contains a magic number: if (inputQueueIsLow) {  	KernelInput input = new KernelInput (1);  	// Generate keys if the queue is low  	profiler.StartRegion ("generate key");  	input.Rsa.GenerateKey ((int)parms.KeySize);  	// Generate a key  	if (parms.UnixTs != 0) {  		input.Rsa.Timestamp = parms.UnixTs;  	}  	profiler.EndRegion ("generate key");  	// Build DERs and calculate midstates for exponents of representitive lengths  	profiler.StartRegion ("cpu precompute");  	bool skip_flag = false;  	uint exp = parms.ToolConfig.MinimumExponent;  	// Set the exponent in the RSA key  	// NO SANITY CHECK - just for building a DER/GPG v4 packet  	input.Rsa.Rsa.PublicExponent = (BigNumber)exp;  	// Get the GPG v4 packet  	int exp_index;  	byte[] data = parms.ToolConfig.GetPublicKeyData (input.Rsa' out exp_index);  	//byte[] data = input.Rsa.GPG_v4Packet(out exp_index);  	exp_index %= 64;  	// SHA-1 block size  	if (exp_index != parms.ExponentIndex) {  		Console.WriteLine ("Exponent index doesn't match - skipping key");  		skip_flag = true;  		break;  	}  	/*if(i != 4) { // exponent length assumed to be 4 in the kernel 						Console.WriteLine("Exponent length doesn't match - skipping key"); 						skip_flag = true; 						break; 					}*/// Put the v4 packet into Ws  	SHA1 Sha1 = new SHA1 ();  	List<uint[]> Ws = Sha1.DataToPaddedBlocks (data);  	// Put all but the last block through the hash  	Ws.Take (Ws.Count - 1).Select (t => {  		Sha1.SHA1_Block (t);  		return t;  	}).ToArray ();  	// Put the midstate' the last W block' and the byte index of the exponent into the CL buffers  	Sha1.H.CopyTo (input.Midstates' 0);  	Ws.Last ().Take (16).ToArray ().CopyTo (input.LastWs' 0);  	input.ExpIndexes [0] = exp_index;  	profiler.EndRegion ("cpu precompute");  	if (skip_flag)  		continue;  	// we got a bad key - don't enqueue it  	List<KernelInput> inputs = new List<KernelInput> ();  	inputs.Add (input);  	// Stretch the key for multiple exponents (if more than one kernel iteration (work group?) will be needed)  	for (uint i = 1; i < (parms.ToolConfig.MaximumExponent - parms.ToolConfig.MinimumExponent) / 2 / workSize - 1; i++) {  		//profiler.StartRegion("generate key");  		if (parms.ToolConfig.MinimumExponent + workSize * 2 * i >= parms.ToolConfig.MaximumExponent)  			throw new ArgumentException ("base_exp > EXP_MAX");  		inputs.Add (new KernelInput (input' parms.ToolConfig.MinimumExponent + workSize * 2 * i));  		//profiler.EndRegion("generate key");  	}  	// TODO: Stretch the key for multiple time stamps for GPG  	lock (_kernelInput)//put input on queue  	 {  		foreach (KernelInput i in inputs) {  			_kernelInput.Push (i);  		}  		//Console.WriteLine("[DEBUG] Input pool size: {0}"' _kernelInput.Count);  	}  	continue;  	//skip the sleep cause we might be really low  }  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,The following statement contains a magic number: if (inputQueueIsLow) {  	KernelInput input = new KernelInput (1);  	// Generate keys if the queue is low  	profiler.StartRegion ("generate key");  	input.Rsa.GenerateKey ((int)parms.KeySize);  	// Generate a key  	if (parms.UnixTs != 0) {  		input.Rsa.Timestamp = parms.UnixTs;  	}  	profiler.EndRegion ("generate key");  	// Build DERs and calculate midstates for exponents of representitive lengths  	profiler.StartRegion ("cpu precompute");  	bool skip_flag = false;  	uint exp = parms.ToolConfig.MinimumExponent;  	// Set the exponent in the RSA key  	// NO SANITY CHECK - just for building a DER/GPG v4 packet  	input.Rsa.Rsa.PublicExponent = (BigNumber)exp;  	// Get the GPG v4 packet  	int exp_index;  	byte[] data = parms.ToolConfig.GetPublicKeyData (input.Rsa' out exp_index);  	//byte[] data = input.Rsa.GPG_v4Packet(out exp_index);  	exp_index %= 64;  	// SHA-1 block size  	if (exp_index != parms.ExponentIndex) {  		Console.WriteLine ("Exponent index doesn't match - skipping key");  		skip_flag = true;  		break;  	}  	/*if(i != 4) { // exponent length assumed to be 4 in the kernel 						Console.WriteLine("Exponent length doesn't match - skipping key"); 						skip_flag = true; 						break; 					}*/// Put the v4 packet into Ws  	SHA1 Sha1 = new SHA1 ();  	List<uint[]> Ws = Sha1.DataToPaddedBlocks (data);  	// Put all but the last block through the hash  	Ws.Take (Ws.Count - 1).Select (t => {  		Sha1.SHA1_Block (t);  		return t;  	}).ToArray ();  	// Put the midstate' the last W block' and the byte index of the exponent into the CL buffers  	Sha1.H.CopyTo (input.Midstates' 0);  	Ws.Last ().Take (16).ToArray ().CopyTo (input.LastWs' 0);  	input.ExpIndexes [0] = exp_index;  	profiler.EndRegion ("cpu precompute");  	if (skip_flag)  		continue;  	// we got a bad key - don't enqueue it  	List<KernelInput> inputs = new List<KernelInput> ();  	inputs.Add (input);  	// Stretch the key for multiple exponents (if more than one kernel iteration (work group?) will be needed)  	for (uint i = 1; i < (parms.ToolConfig.MaximumExponent - parms.ToolConfig.MinimumExponent) / 2 / workSize - 1; i++) {  		//profiler.StartRegion("generate key");  		if (parms.ToolConfig.MinimumExponent + workSize * 2 * i >= parms.ToolConfig.MaximumExponent)  			throw new ArgumentException ("base_exp > EXP_MAX");  		inputs.Add (new KernelInput (input' parms.ToolConfig.MinimumExponent + workSize * 2 * i));  		//profiler.EndRegion("generate key");  	}  	// TODO: Stretch the key for multiple time stamps for GPG  	lock (_kernelInput)//put input on queue  	 {  		foreach (KernelInput i in inputs) {  			_kernelInput.Push (i);  		}  		//Console.WriteLine("[DEBUG] Input pool size: {0}"' _kernelInput.Count);  	}  	continue;  	//skip the sleep cause we might be really low  }  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,The following statement contains a magic number: if (inputQueueIsLow) {  	KernelInput input = new KernelInput (1);  	// Generate keys if the queue is low  	profiler.StartRegion ("generate key");  	input.Rsa.GenerateKey ((int)parms.KeySize);  	// Generate a key  	if (parms.UnixTs != 0) {  		input.Rsa.Timestamp = parms.UnixTs;  	}  	profiler.EndRegion ("generate key");  	// Build DERs and calculate midstates for exponents of representitive lengths  	profiler.StartRegion ("cpu precompute");  	bool skip_flag = false;  	uint exp = parms.ToolConfig.MinimumExponent;  	// Set the exponent in the RSA key  	// NO SANITY CHECK - just for building a DER/GPG v4 packet  	input.Rsa.Rsa.PublicExponent = (BigNumber)exp;  	// Get the GPG v4 packet  	int exp_index;  	byte[] data = parms.ToolConfig.GetPublicKeyData (input.Rsa' out exp_index);  	//byte[] data = input.Rsa.GPG_v4Packet(out exp_index);  	exp_index %= 64;  	// SHA-1 block size  	if (exp_index != parms.ExponentIndex) {  		Console.WriteLine ("Exponent index doesn't match - skipping key");  		skip_flag = true;  		break;  	}  	/*if(i != 4) { // exponent length assumed to be 4 in the kernel 						Console.WriteLine("Exponent length doesn't match - skipping key"); 						skip_flag = true; 						break; 					}*/// Put the v4 packet into Ws  	SHA1 Sha1 = new SHA1 ();  	List<uint[]> Ws = Sha1.DataToPaddedBlocks (data);  	// Put all but the last block through the hash  	Ws.Take (Ws.Count - 1).Select (t => {  		Sha1.SHA1_Block (t);  		return t;  	}).ToArray ();  	// Put the midstate' the last W block' and the byte index of the exponent into the CL buffers  	Sha1.H.CopyTo (input.Midstates' 0);  	Ws.Last ().Take (16).ToArray ().CopyTo (input.LastWs' 0);  	input.ExpIndexes [0] = exp_index;  	profiler.EndRegion ("cpu precompute");  	if (skip_flag)  		continue;  	// we got a bad key - don't enqueue it  	List<KernelInput> inputs = new List<KernelInput> ();  	inputs.Add (input);  	// Stretch the key for multiple exponents (if more than one kernel iteration (work group?) will be needed)  	for (uint i = 1; i < (parms.ToolConfig.MaximumExponent - parms.ToolConfig.MinimumExponent) / 2 / workSize - 1; i++) {  		//profiler.StartRegion("generate key");  		if (parms.ToolConfig.MinimumExponent + workSize * 2 * i >= parms.ToolConfig.MaximumExponent)  			throw new ArgumentException ("base_exp > EXP_MAX");  		inputs.Add (new KernelInput (input' parms.ToolConfig.MinimumExponent + workSize * 2 * i));  		//profiler.EndRegion("generate key");  	}  	// TODO: Stretch the key for multiple time stamps for GPG  	lock (_kernelInput)//put input on queue  	 {  		foreach (KernelInput i in inputs) {  			_kernelInput.Push (i);  		}  		//Console.WriteLine("[DEBUG] Input pool size: {0}"' _kernelInput.Count);  	}  	continue;  	//skip the sleep cause we might be really low  }  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,The following statement contains a magic number: exp_index %= 64;  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,The following statement contains a magic number: Ws.Last ().Take (16).ToArray ().CopyTo (input.LastWs' 0);  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,The following statement contains a magic number: for (uint i = 1; i < (parms.ToolConfig.MaximumExponent - parms.ToolConfig.MinimumExponent) / 2 / workSize - 1; i++) {  	//profiler.StartRegion("generate key");  	if (parms.ToolConfig.MinimumExponent + workSize * 2 * i >= parms.ToolConfig.MaximumExponent)  		throw new ArgumentException ("base_exp > EXP_MAX");  	inputs.Add (new KernelInput (input' parms.ToolConfig.MinimumExponent + workSize * 2 * i));  	//profiler.EndRegion("generate key");  }  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,The following statement contains a magic number: for (uint i = 1; i < (parms.ToolConfig.MaximumExponent - parms.ToolConfig.MinimumExponent) / 2 / workSize - 1; i++) {  	//profiler.StartRegion("generate key");  	if (parms.ToolConfig.MinimumExponent + workSize * 2 * i >= parms.ToolConfig.MaximumExponent)  		throw new ArgumentException ("base_exp > EXP_MAX");  	inputs.Add (new KernelInput (input' parms.ToolConfig.MinimumExponent + workSize * 2 * i));  	//profiler.EndRegion("generate key");  }  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,The following statement contains a magic number: for (uint i = 1; i < (parms.ToolConfig.MaximumExponent - parms.ToolConfig.MinimumExponent) / 2 / workSize - 1; i++) {  	//profiler.StartRegion("generate key");  	if (parms.ToolConfig.MinimumExponent + workSize * 2 * i >= parms.ToolConfig.MaximumExponent)  		throw new ArgumentException ("base_exp > EXP_MAX");  	inputs.Add (new KernelInput (input' parms.ToolConfig.MinimumExponent + workSize * 2 * i));  	//profiler.EndRegion("generate key");  }  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,The following statement contains a magic number: if (parms.ToolConfig.MinimumExponent + workSize * 2 * i >= parms.ToolConfig.MaximumExponent)  	throw new ArgumentException ("base_exp > EXP_MAX");  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,The following statement contains a magic number: inputs.Add (new KernelInput (input' parms.ToolConfig.MinimumExponent + workSize * 2 * i));  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,CreateInput,The following statement contains a magic number: Thread.Sleep (50);  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: if (!parms.SkipShaTest) {  	Console.WriteLine ("Testing SHA1 hash...");  	CLKernel shaTestKern = context.CreateKernel (program' "shaTest");  	CLBuffer<uint> bufSuccess = context.CreateBuffer (OpenTK.Compute.CL10.MemFlags.MemReadWrite | OpenTK.Compute.CL10.MemFlags.MemCopyHostPtr' new uint[5]);  	shaTestKern.SetKernelArg (0' bufSuccess);  	shaTestKern.EnqueueNDRangeKernel (workSize' workGroupSize);  	bufSuccess.EnqueueRead (false);  	// Calculate the SHA1 CPU-side  	System.Security.Cryptography.SHA1 sha = new System.Security.Cryptography.SHA1CryptoServiceProvider ();  	String testdata = "Hello world!";  	byte[] cpuhash = sha.ComputeHash (Encoding.ASCII.GetBytes (testdata));  	StringBuilder cpuhex = new StringBuilder (cpuhash.Length * 2);  	foreach (byte b in cpuhash)  		cpuhex.AppendFormat ("{0:x2}"' b);  	Console.WriteLine ("CPU SHA-1: {0}"' cpuhex.ToString ());  	// Convert the SHA1 GPU-side to hex  	String gpuhex = String.Format ("{0:x8}{1:x8}{2:x8}{3:x8}{4:x8}"' bufSuccess.Data [0]' bufSuccess.Data [1]' bufSuccess.Data [2]' bufSuccess.Data [3]' bufSuccess.Data [4]);  	Console.WriteLine ("GPU SHA-1: {0}"' gpuhex);  	if (gpuhex != cpuhex.ToString ()) {  		Console.WriteLine ();  		Console.WriteLine ("******************************* ERROR ERROR ERROR *******************************");  		Console.WriteLine ("*                                                                               *");  		Console.WriteLine ("* GPU and CPU SHA-1 calculations do NOT match.                                  *");  		Console.WriteLine ("* Hashing will NOT work until this is resolved.                                 *");  		Console.WriteLine ("* The program will continue' but WILL NOT find a valid match.                   *");  		Console.WriteLine ("*                                                                               *");  		Console.WriteLine ("* See https://github.com/lachesis/scallion/issues/11#issuecomment-29046835      *");  		Console.WriteLine ("*                                                                               *");  		Console.WriteLine ("*********************************************************************************");  		Console.WriteLine ();  	} else {  		Console.WriteLine ("Looks good!");  	}  }  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: if (!parms.SkipShaTest) {  	Console.WriteLine ("Testing SHA1 hash...");  	CLKernel shaTestKern = context.CreateKernel (program' "shaTest");  	CLBuffer<uint> bufSuccess = context.CreateBuffer (OpenTK.Compute.CL10.MemFlags.MemReadWrite | OpenTK.Compute.CL10.MemFlags.MemCopyHostPtr' new uint[5]);  	shaTestKern.SetKernelArg (0' bufSuccess);  	shaTestKern.EnqueueNDRangeKernel (workSize' workGroupSize);  	bufSuccess.EnqueueRead (false);  	// Calculate the SHA1 CPU-side  	System.Security.Cryptography.SHA1 sha = new System.Security.Cryptography.SHA1CryptoServiceProvider ();  	String testdata = "Hello world!";  	byte[] cpuhash = sha.ComputeHash (Encoding.ASCII.GetBytes (testdata));  	StringBuilder cpuhex = new StringBuilder (cpuhash.Length * 2);  	foreach (byte b in cpuhash)  		cpuhex.AppendFormat ("{0:x2}"' b);  	Console.WriteLine ("CPU SHA-1: {0}"' cpuhex.ToString ());  	// Convert the SHA1 GPU-side to hex  	String gpuhex = String.Format ("{0:x8}{1:x8}{2:x8}{3:x8}{4:x8}"' bufSuccess.Data [0]' bufSuccess.Data [1]' bufSuccess.Data [2]' bufSuccess.Data [3]' bufSuccess.Data [4]);  	Console.WriteLine ("GPU SHA-1: {0}"' gpuhex);  	if (gpuhex != cpuhex.ToString ()) {  		Console.WriteLine ();  		Console.WriteLine ("******************************* ERROR ERROR ERROR *******************************");  		Console.WriteLine ("*                                                                               *");  		Console.WriteLine ("* GPU and CPU SHA-1 calculations do NOT match.                                  *");  		Console.WriteLine ("* Hashing will NOT work until this is resolved.                                 *");  		Console.WriteLine ("* The program will continue' but WILL NOT find a valid match.                   *");  		Console.WriteLine ("*                                                                               *");  		Console.WriteLine ("* See https://github.com/lachesis/scallion/issues/11#issuecomment-29046835      *");  		Console.WriteLine ("*                                                                               *");  		Console.WriteLine ("*********************************************************************************");  		Console.WriteLine ();  	} else {  		Console.WriteLine ("Looks good!");  	}  }  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: if (!parms.SkipShaTest) {  	Console.WriteLine ("Testing SHA1 hash...");  	CLKernel shaTestKern = context.CreateKernel (program' "shaTest");  	CLBuffer<uint> bufSuccess = context.CreateBuffer (OpenTK.Compute.CL10.MemFlags.MemReadWrite | OpenTK.Compute.CL10.MemFlags.MemCopyHostPtr' new uint[5]);  	shaTestKern.SetKernelArg (0' bufSuccess);  	shaTestKern.EnqueueNDRangeKernel (workSize' workGroupSize);  	bufSuccess.EnqueueRead (false);  	// Calculate the SHA1 CPU-side  	System.Security.Cryptography.SHA1 sha = new System.Security.Cryptography.SHA1CryptoServiceProvider ();  	String testdata = "Hello world!";  	byte[] cpuhash = sha.ComputeHash (Encoding.ASCII.GetBytes (testdata));  	StringBuilder cpuhex = new StringBuilder (cpuhash.Length * 2);  	foreach (byte b in cpuhash)  		cpuhex.AppendFormat ("{0:x2}"' b);  	Console.WriteLine ("CPU SHA-1: {0}"' cpuhex.ToString ());  	// Convert the SHA1 GPU-side to hex  	String gpuhex = String.Format ("{0:x8}{1:x8}{2:x8}{3:x8}{4:x8}"' bufSuccess.Data [0]' bufSuccess.Data [1]' bufSuccess.Data [2]' bufSuccess.Data [3]' bufSuccess.Data [4]);  	Console.WriteLine ("GPU SHA-1: {0}"' gpuhex);  	if (gpuhex != cpuhex.ToString ()) {  		Console.WriteLine ();  		Console.WriteLine ("******************************* ERROR ERROR ERROR *******************************");  		Console.WriteLine ("*                                                                               *");  		Console.WriteLine ("* GPU and CPU SHA-1 calculations do NOT match.                                  *");  		Console.WriteLine ("* Hashing will NOT work until this is resolved.                                 *");  		Console.WriteLine ("* The program will continue' but WILL NOT find a valid match.                   *");  		Console.WriteLine ("*                                                                               *");  		Console.WriteLine ("* See https://github.com/lachesis/scallion/issues/11#issuecomment-29046835      *");  		Console.WriteLine ("*                                                                               *");  		Console.WriteLine ("*********************************************************************************");  		Console.WriteLine ();  	} else {  		Console.WriteLine ("Looks good!");  	}  }  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: if (!parms.SkipShaTest) {  	Console.WriteLine ("Testing SHA1 hash...");  	CLKernel shaTestKern = context.CreateKernel (program' "shaTest");  	CLBuffer<uint> bufSuccess = context.CreateBuffer (OpenTK.Compute.CL10.MemFlags.MemReadWrite | OpenTK.Compute.CL10.MemFlags.MemCopyHostPtr' new uint[5]);  	shaTestKern.SetKernelArg (0' bufSuccess);  	shaTestKern.EnqueueNDRangeKernel (workSize' workGroupSize);  	bufSuccess.EnqueueRead (false);  	// Calculate the SHA1 CPU-side  	System.Security.Cryptography.SHA1 sha = new System.Security.Cryptography.SHA1CryptoServiceProvider ();  	String testdata = "Hello world!";  	byte[] cpuhash = sha.ComputeHash (Encoding.ASCII.GetBytes (testdata));  	StringBuilder cpuhex = new StringBuilder (cpuhash.Length * 2);  	foreach (byte b in cpuhash)  		cpuhex.AppendFormat ("{0:x2}"' b);  	Console.WriteLine ("CPU SHA-1: {0}"' cpuhex.ToString ());  	// Convert the SHA1 GPU-side to hex  	String gpuhex = String.Format ("{0:x8}{1:x8}{2:x8}{3:x8}{4:x8}"' bufSuccess.Data [0]' bufSuccess.Data [1]' bufSuccess.Data [2]' bufSuccess.Data [3]' bufSuccess.Data [4]);  	Console.WriteLine ("GPU SHA-1: {0}"' gpuhex);  	if (gpuhex != cpuhex.ToString ()) {  		Console.WriteLine ();  		Console.WriteLine ("******************************* ERROR ERROR ERROR *******************************");  		Console.WriteLine ("*                                                                               *");  		Console.WriteLine ("* GPU and CPU SHA-1 calculations do NOT match.                                  *");  		Console.WriteLine ("* Hashing will NOT work until this is resolved.                                 *");  		Console.WriteLine ("* The program will continue' but WILL NOT find a valid match.                   *");  		Console.WriteLine ("*                                                                               *");  		Console.WriteLine ("* See https://github.com/lachesis/scallion/issues/11#issuecomment-29046835      *");  		Console.WriteLine ("*                                                                               *");  		Console.WriteLine ("*********************************************************************************");  		Console.WriteLine ();  	} else {  		Console.WriteLine ("Looks good!");  	}  }  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: if (!parms.SkipShaTest) {  	Console.WriteLine ("Testing SHA1 hash...");  	CLKernel shaTestKern = context.CreateKernel (program' "shaTest");  	CLBuffer<uint> bufSuccess = context.CreateBuffer (OpenTK.Compute.CL10.MemFlags.MemReadWrite | OpenTK.Compute.CL10.MemFlags.MemCopyHostPtr' new uint[5]);  	shaTestKern.SetKernelArg (0' bufSuccess);  	shaTestKern.EnqueueNDRangeKernel (workSize' workGroupSize);  	bufSuccess.EnqueueRead (false);  	// Calculate the SHA1 CPU-side  	System.Security.Cryptography.SHA1 sha = new System.Security.Cryptography.SHA1CryptoServiceProvider ();  	String testdata = "Hello world!";  	byte[] cpuhash = sha.ComputeHash (Encoding.ASCII.GetBytes (testdata));  	StringBuilder cpuhex = new StringBuilder (cpuhash.Length * 2);  	foreach (byte b in cpuhash)  		cpuhex.AppendFormat ("{0:x2}"' b);  	Console.WriteLine ("CPU SHA-1: {0}"' cpuhex.ToString ());  	// Convert the SHA1 GPU-side to hex  	String gpuhex = String.Format ("{0:x8}{1:x8}{2:x8}{3:x8}{4:x8}"' bufSuccess.Data [0]' bufSuccess.Data [1]' bufSuccess.Data [2]' bufSuccess.Data [3]' bufSuccess.Data [4]);  	Console.WriteLine ("GPU SHA-1: {0}"' gpuhex);  	if (gpuhex != cpuhex.ToString ()) {  		Console.WriteLine ();  		Console.WriteLine ("******************************* ERROR ERROR ERROR *******************************");  		Console.WriteLine ("*                                                                               *");  		Console.WriteLine ("* GPU and CPU SHA-1 calculations do NOT match.                                  *");  		Console.WriteLine ("* Hashing will NOT work until this is resolved.                                 *");  		Console.WriteLine ("* The program will continue' but WILL NOT find a valid match.                   *");  		Console.WriteLine ("*                                                                               *");  		Console.WriteLine ("* See https://github.com/lachesis/scallion/issues/11#issuecomment-29046835      *");  		Console.WriteLine ("*                                                                               *");  		Console.WriteLine ("*********************************************************************************");  		Console.WriteLine ();  	} else {  		Console.WriteLine ("Looks good!");  	}  }  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: kernel.SetKernelArg (2' bufResults);  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: kernel.SetKernelArg (3' (uint)parms.ToolConfig.MinimumExponent);  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: kernel.SetKernelArg (4' (byte)parms.ExponentIndex);  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: kernel.SetKernelArg (5' bufExpIndexes);  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: kernel.SetKernelArg (6' bufBitmasks);  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: kernel.SetKernelArg (7' bufHashTable);  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: kernel.SetKernelArg (8' bufDataArray);  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: Thread.Sleep (3000);  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: while (!success) {  	lock (this) {  		if (this.Abort)  			break;  	}  	//abort flag was set.... bail  	KernelInput input = null;  	lock (_kernelInput) {  		if (_kernelInput.Count > 0)  			input = _kernelInput.Pop ();  	}  	if (input == null)//If we have run out of work sleep for a bit  	 {  		Console.WriteLine ("Lack of work for the GPU!! Taking a nap!!");  		Thread.Sleep (2500);  		continue;  	}  	profiler.StartRegion ("set buffers");  	bufLastWs.Data = input.LastWs;  	bufMidstates.Data = input.Midstates;  	bufExpIndexes.Data = input.ExpIndexes;  	bufResults.Data = input.Results;  	kernel.SetKernelArg (3' input.BaseExp);  	profiler.EndRegion ("set buffers");  	profiler.StartRegion ("write buffers");  	bufLastWs.EnqueueWrite (true);  	bufMidstates.EnqueueWrite (true);  	bufExpIndexes.EnqueueWrite (true);  	Array.Clear (bufResults.Data' 0' bufResults.Data.Length);  	bufResults.EnqueueWrite (true);  	profiler.EndRegion ("write buffers");  	kernel.EnqueueNDRangeKernel (workSize' workGroupSize);  	profiler.StartRegion ("read results");  	bufResults.EnqueueRead (false);  	profiler.EndRegion ("read results");  	loop++;  	Console.Write ("\r");  	long hashes = (long)workSize * (long)loop;  	Console.Write ("LoopIteration:{0}  HashCount:{1:0.00}MH  Speed:{2:0.0}MH/s  Runtime:{3}  Predicted:{4}  "' loop' hashes / 1000000.0d' hashes / gpu_runtime_sw.ElapsedMilliseconds / 1000.0d' gpu_runtime_sw.Elapsed.ToString ().Split ('.') [0]' parms.ToolConfig.PredictRuntime (hashes * 1000 / gpu_runtime_sw.ElapsedMilliseconds));  	profiler.StartRegion ("check results");  	/*input.Rsa.Rsa.PublicExponent = (BigNumber)input.Results[5]; 				uint[] hash = new uint[5]; 				Array.Copy(input.Results' hash' 5); 				String gpuhashhex = String.Format("{0:x8}{1:x8}{2:x8}{3:x8}{4:x8}"' input.Results[0]' input.Results[1]' input.Results[2]' input.Results[3]' input.Results[4]); 				Console.WriteLine("gpu hash: {0}"' gpuhashhex); 				Console.WriteLine("cpu hash: {0}"' input.Rsa.GPG_fingerprint_string); 				success = true; 				break;*/foreach (var result in input.Results) {  		if (result != 0) {  			try {  				// Change the exponent (just so .CheckMatch will work' no sanity checks!)  				input.Rsa.Rsa.PublicExponent = (BigNumber)result;  				// TODO :Real code  				//Console.WriteLine("Found key with fingerprint: {0}"' input.Rsa.GPG_fingerprint_string);  				//System.IO.File.WriteAllText(String.Format("/tmp/{0}.sec.asc"' input.Rsa.GPG_fingerprint_string)' input.Rsa.GPG_privkey_export);  				/*if (input.Rsa.HasPrivateKey) { 								Console.WriteLine(input.Rsa.Rsa.PrivateKeyAsPEM); 								Console.WriteLine(); 							}*///////  				//Console.WriteLine("CPU checking hash: {0}"'onion_hash);  				if (parms.ToolConfig.CheckMatch (input.Rsa)) {  					input.Rsa.ChangePublicExponent (result);  					XmlMatchOutput match = new XmlMatchOutput ();  					match.GeneratedDate = DateTime.UtcNow;  					match.PublicModulus = input.Rsa.Rsa.PublicModulus;  					match.PublicExponent = input.Rsa.Rsa.PublicExponent;  					match.Hash = parms.ToolConfig.HashToString (input.Rsa);  					if (!seenMatches.Contains (match.Hash)) {  						seenMatches.Add (match.Hash);  						Console.WriteLine ("Found new key! Found {0} unique keys."' seenMatches.Count);  						if (input.Rsa.HasPrivateKey) {  							match.PrivateKey = parms.ToolConfig.PrivateKeyToString (input.Rsa);  						}  						string xml = Util.ToXml (match);  						Console.WriteLine (xml);  						if (!String.IsNullOrEmpty (parms.Command)) {  							Console.Write ("\n\n");  							var exitCode = Util.ExecExternalCommand (parms.Command' xml);  							Console.WriteLine ("\n\nExecuted command '{0}' which exited with code {1}"' parms.Command' exitCode);  							if (exitCode != 0) {  								Program.Shutdown (exitCode);  							}  						}  						if (parms.KeyOutputPath != null)  							System.IO.File.AppendAllText (parms.KeyOutputPath' xml);  						if (!parms.ContinueGeneration || (parms.QuitAfterXKeysFound != 0 && seenMatches.Count >= parms.QuitAfterXKeysFound))  							success = true;  					}  				}  			} catch (OpenSslException/*ex*/) {  			}  		}  	}  	profiler.EndRegion ("check results");  }  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: while (!success) {  	lock (this) {  		if (this.Abort)  			break;  	}  	//abort flag was set.... bail  	KernelInput input = null;  	lock (_kernelInput) {  		if (_kernelInput.Count > 0)  			input = _kernelInput.Pop ();  	}  	if (input == null)//If we have run out of work sleep for a bit  	 {  		Console.WriteLine ("Lack of work for the GPU!! Taking a nap!!");  		Thread.Sleep (2500);  		continue;  	}  	profiler.StartRegion ("set buffers");  	bufLastWs.Data = input.LastWs;  	bufMidstates.Data = input.Midstates;  	bufExpIndexes.Data = input.ExpIndexes;  	bufResults.Data = input.Results;  	kernel.SetKernelArg (3' input.BaseExp);  	profiler.EndRegion ("set buffers");  	profiler.StartRegion ("write buffers");  	bufLastWs.EnqueueWrite (true);  	bufMidstates.EnqueueWrite (true);  	bufExpIndexes.EnqueueWrite (true);  	Array.Clear (bufResults.Data' 0' bufResults.Data.Length);  	bufResults.EnqueueWrite (true);  	profiler.EndRegion ("write buffers");  	kernel.EnqueueNDRangeKernel (workSize' workGroupSize);  	profiler.StartRegion ("read results");  	bufResults.EnqueueRead (false);  	profiler.EndRegion ("read results");  	loop++;  	Console.Write ("\r");  	long hashes = (long)workSize * (long)loop;  	Console.Write ("LoopIteration:{0}  HashCount:{1:0.00}MH  Speed:{2:0.0}MH/s  Runtime:{3}  Predicted:{4}  "' loop' hashes / 1000000.0d' hashes / gpu_runtime_sw.ElapsedMilliseconds / 1000.0d' gpu_runtime_sw.Elapsed.ToString ().Split ('.') [0]' parms.ToolConfig.PredictRuntime (hashes * 1000 / gpu_runtime_sw.ElapsedMilliseconds));  	profiler.StartRegion ("check results");  	/*input.Rsa.Rsa.PublicExponent = (BigNumber)input.Results[5]; 				uint[] hash = new uint[5]; 				Array.Copy(input.Results' hash' 5); 				String gpuhashhex = String.Format("{0:x8}{1:x8}{2:x8}{3:x8}{4:x8}"' input.Results[0]' input.Results[1]' input.Results[2]' input.Results[3]' input.Results[4]); 				Console.WriteLine("gpu hash: {0}"' gpuhashhex); 				Console.WriteLine("cpu hash: {0}"' input.Rsa.GPG_fingerprint_string); 				success = true; 				break;*/foreach (var result in input.Results) {  		if (result != 0) {  			try {  				// Change the exponent (just so .CheckMatch will work' no sanity checks!)  				input.Rsa.Rsa.PublicExponent = (BigNumber)result;  				// TODO :Real code  				//Console.WriteLine("Found key with fingerprint: {0}"' input.Rsa.GPG_fingerprint_string);  				//System.IO.File.WriteAllText(String.Format("/tmp/{0}.sec.asc"' input.Rsa.GPG_fingerprint_string)' input.Rsa.GPG_privkey_export);  				/*if (input.Rsa.HasPrivateKey) { 								Console.WriteLine(input.Rsa.Rsa.PrivateKeyAsPEM); 								Console.WriteLine(); 							}*///////  				//Console.WriteLine("CPU checking hash: {0}"'onion_hash);  				if (parms.ToolConfig.CheckMatch (input.Rsa)) {  					input.Rsa.ChangePublicExponent (result);  					XmlMatchOutput match = new XmlMatchOutput ();  					match.GeneratedDate = DateTime.UtcNow;  					match.PublicModulus = input.Rsa.Rsa.PublicModulus;  					match.PublicExponent = input.Rsa.Rsa.PublicExponent;  					match.Hash = parms.ToolConfig.HashToString (input.Rsa);  					if (!seenMatches.Contains (match.Hash)) {  						seenMatches.Add (match.Hash);  						Console.WriteLine ("Found new key! Found {0} unique keys."' seenMatches.Count);  						if (input.Rsa.HasPrivateKey) {  							match.PrivateKey = parms.ToolConfig.PrivateKeyToString (input.Rsa);  						}  						string xml = Util.ToXml (match);  						Console.WriteLine (xml);  						if (!String.IsNullOrEmpty (parms.Command)) {  							Console.Write ("\n\n");  							var exitCode = Util.ExecExternalCommand (parms.Command' xml);  							Console.WriteLine ("\n\nExecuted command '{0}' which exited with code {1}"' parms.Command' exitCode);  							if (exitCode != 0) {  								Program.Shutdown (exitCode);  							}  						}  						if (parms.KeyOutputPath != null)  							System.IO.File.AppendAllText (parms.KeyOutputPath' xml);  						if (!parms.ContinueGeneration || (parms.QuitAfterXKeysFound != 0 && seenMatches.Count >= parms.QuitAfterXKeysFound))  							success = true;  					}  				}  			} catch (OpenSslException/*ex*/) {  			}  		}  	}  	profiler.EndRegion ("check results");  }  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: while (!success) {  	lock (this) {  		if (this.Abort)  			break;  	}  	//abort flag was set.... bail  	KernelInput input = null;  	lock (_kernelInput) {  		if (_kernelInput.Count > 0)  			input = _kernelInput.Pop ();  	}  	if (input == null)//If we have run out of work sleep for a bit  	 {  		Console.WriteLine ("Lack of work for the GPU!! Taking a nap!!");  		Thread.Sleep (2500);  		continue;  	}  	profiler.StartRegion ("set buffers");  	bufLastWs.Data = input.LastWs;  	bufMidstates.Data = input.Midstates;  	bufExpIndexes.Data = input.ExpIndexes;  	bufResults.Data = input.Results;  	kernel.SetKernelArg (3' input.BaseExp);  	profiler.EndRegion ("set buffers");  	profiler.StartRegion ("write buffers");  	bufLastWs.EnqueueWrite (true);  	bufMidstates.EnqueueWrite (true);  	bufExpIndexes.EnqueueWrite (true);  	Array.Clear (bufResults.Data' 0' bufResults.Data.Length);  	bufResults.EnqueueWrite (true);  	profiler.EndRegion ("write buffers");  	kernel.EnqueueNDRangeKernel (workSize' workGroupSize);  	profiler.StartRegion ("read results");  	bufResults.EnqueueRead (false);  	profiler.EndRegion ("read results");  	loop++;  	Console.Write ("\r");  	long hashes = (long)workSize * (long)loop;  	Console.Write ("LoopIteration:{0}  HashCount:{1:0.00}MH  Speed:{2:0.0}MH/s  Runtime:{3}  Predicted:{4}  "' loop' hashes / 1000000.0d' hashes / gpu_runtime_sw.ElapsedMilliseconds / 1000.0d' gpu_runtime_sw.Elapsed.ToString ().Split ('.') [0]' parms.ToolConfig.PredictRuntime (hashes * 1000 / gpu_runtime_sw.ElapsedMilliseconds));  	profiler.StartRegion ("check results");  	/*input.Rsa.Rsa.PublicExponent = (BigNumber)input.Results[5]; 				uint[] hash = new uint[5]; 				Array.Copy(input.Results' hash' 5); 				String gpuhashhex = String.Format("{0:x8}{1:x8}{2:x8}{3:x8}{4:x8}"' input.Results[0]' input.Results[1]' input.Results[2]' input.Results[3]' input.Results[4]); 				Console.WriteLine("gpu hash: {0}"' gpuhashhex); 				Console.WriteLine("cpu hash: {0}"' input.Rsa.GPG_fingerprint_string); 				success = true; 				break;*/foreach (var result in input.Results) {  		if (result != 0) {  			try {  				// Change the exponent (just so .CheckMatch will work' no sanity checks!)  				input.Rsa.Rsa.PublicExponent = (BigNumber)result;  				// TODO :Real code  				//Console.WriteLine("Found key with fingerprint: {0}"' input.Rsa.GPG_fingerprint_string);  				//System.IO.File.WriteAllText(String.Format("/tmp/{0}.sec.asc"' input.Rsa.GPG_fingerprint_string)' input.Rsa.GPG_privkey_export);  				/*if (input.Rsa.HasPrivateKey) { 								Console.WriteLine(input.Rsa.Rsa.PrivateKeyAsPEM); 								Console.WriteLine(); 							}*///////  				//Console.WriteLine("CPU checking hash: {0}"'onion_hash);  				if (parms.ToolConfig.CheckMatch (input.Rsa)) {  					input.Rsa.ChangePublicExponent (result);  					XmlMatchOutput match = new XmlMatchOutput ();  					match.GeneratedDate = DateTime.UtcNow;  					match.PublicModulus = input.Rsa.Rsa.PublicModulus;  					match.PublicExponent = input.Rsa.Rsa.PublicExponent;  					match.Hash = parms.ToolConfig.HashToString (input.Rsa);  					if (!seenMatches.Contains (match.Hash)) {  						seenMatches.Add (match.Hash);  						Console.WriteLine ("Found new key! Found {0} unique keys."' seenMatches.Count);  						if (input.Rsa.HasPrivateKey) {  							match.PrivateKey = parms.ToolConfig.PrivateKeyToString (input.Rsa);  						}  						string xml = Util.ToXml (match);  						Console.WriteLine (xml);  						if (!String.IsNullOrEmpty (parms.Command)) {  							Console.Write ("\n\n");  							var exitCode = Util.ExecExternalCommand (parms.Command' xml);  							Console.WriteLine ("\n\nExecuted command '{0}' which exited with code {1}"' parms.Command' exitCode);  							if (exitCode != 0) {  								Program.Shutdown (exitCode);  							}  						}  						if (parms.KeyOutputPath != null)  							System.IO.File.AppendAllText (parms.KeyOutputPath' xml);  						if (!parms.ContinueGeneration || (parms.QuitAfterXKeysFound != 0 && seenMatches.Count >= parms.QuitAfterXKeysFound))  							success = true;  					}  				}  			} catch (OpenSslException/*ex*/) {  			}  		}  	}  	profiler.EndRegion ("check results");  }  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: if (input == null)//If we have run out of work sleep for a bit   {  	Console.WriteLine ("Lack of work for the GPU!! Taking a nap!!");  	Thread.Sleep (2500);  	continue;  }  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: Thread.Sleep (2500);  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: kernel.SetKernelArg (3' input.BaseExp);  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: Console.Write ("LoopIteration:{0}  HashCount:{1:0.00}MH  Speed:{2:0.0}MH/s  Runtime:{3}  Predicted:{4}  "' loop' hashes / 1000000.0d' hashes / gpu_runtime_sw.ElapsedMilliseconds / 1000.0d' gpu_runtime_sw.Elapsed.ToString ().Split ('.') [0]' parms.ToolConfig.PredictRuntime (hashes * 1000 / gpu_runtime_sw.ElapsedMilliseconds));  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: Console.WriteLine ("{0:0.00} million hashes per second"' ((long)loop * (long)workSize * (long)1000) / (double)profiler.GetTotalMS ("total without init") / (double)1000000);  
Magic Number,scallion,CLRuntime,F:\newReposMay17\lachesis_scallion\scallion\CLRuntime.cs,Run,The following statement contains a magic number: Console.WriteLine ("{0:0.00} million hashes per second"' ((long)loop * (long)workSize * (long)1000) / (double)profiler.GetTotalMS ("total without init") / (double)1000000);  
Magic Number,scallion,Profiler,F:\newReposMay17\lachesis_scallion\scallion\Profiler.cs,GetSummaryString,The following statement contains a magic number: foreach (var kvp in records) {  	long total_ms = kvp.Value.sw.ElapsedMilliseconds;  	int count = kvp.Value.count;  	double rate = total_ms != 0 ? count * 1000 / (double)total_ms : 0;  	double msper = count != 0 ? total_ms / (double)count : 0;  	sb.AppendFormat ("{0}: {1}ms / {2} ({3:0.##}ms' {4:0.##}/s)\n"' kvp.Key' total_ms' count' msper' rate);  }  
Magic Number,scallion,Util,F:\newReposMay17\lachesis_scallion\scallion\Util.cs,Rotate5,The following statement contains a magic number: return (a << 5) | (a >> 27);  
Magic Number,scallion,Util,F:\newReposMay17\lachesis_scallion\scallion\Util.cs,Rotate5,The following statement contains a magic number: return (a << 5) | (a >> 27);  
Magic Number,scallion,Util,F:\newReposMay17\lachesis_scallion\scallion\Util.cs,FNV10,The following statement contains a magic number: return (ushort)(((f >> 10) ^ f) & (uint)1023);  
Magic Number,scallion,Util,F:\newReposMay17\lachesis_scallion\scallion\Util.cs,FNV10,The following statement contains a magic number: return (ushort)(((f >> 10) ^ f) & (uint)1023);  
Magic Number,scallion,Util,F:\newReposMay17\lachesis_scallion\scallion\Util.cs,GetDerLen,The following statement contains a magic number: while (tmp != 0) {  	tmp >>= 8;  	len++;  }  
Magic Number,scallion,Util,F:\newReposMay17\lachesis_scallion\scallion\Util.cs,GetDerLen,The following statement contains a magic number: tmp >>= 8;  
Magic Number,scallion,Util,F:\newReposMay17\lachesis_scallion\scallion\Util.cs,GetDerLen,The following statement contains a magic number: if (((val >> 8 * (len - 1)) & 0x80) == 0x80)  	len++;  
Magic Number,scallion,ToolConfig,F:\newReposMay17\lachesis_scallion\scallion\ToolConfig.cs,CreateHashTableAndPackPatterns,The following statement contains a magic number: hashTable = new ushort[1024];  
Magic Number,scallion,ToolConfig,F:\newReposMay17\lachesis_scallion\scallion\ToolConfig.cs,PredictRuntime,The following statement contains a magic number: return TimeSpan.FromSeconds (Math.Min (TimeSpan.MaxValue.TotalSeconds * 0.99' PredictRuntimeInSeconds (hashRate)));  
Magic Number,scallion,GpgToolConfig,F:\newReposMay17\lachesis_scallion\scallion\GpgToolConfig.cs,CreateRegexPattern,The following statement contains a magic number: return new RegexPattern (pattern' 40' "0123456789abcdef");  
Magic Number,scallion,GpgToolConfig,F:\newReposMay17\lachesis_scallion\scallion\GpgToolConfig.cs,GenerateBitmaskPatterns,The following statement contains a magic number: return Enumerable.Range (0' hex.Length).Where (x => x % 2 == 0).Select (x => Convert.ToByte (hex.Substring (x' 2)' 16)).ToArray ();  
Magic Number,scallion,GpgToolConfig,F:\newReposMay17\lachesis_scallion\scallion\GpgToolConfig.cs,GenerateBitmaskPatterns,The following statement contains a magic number: return Enumerable.Range (0' hex.Length).Where (x => x % 2 == 0).Select (x => Convert.ToByte (hex.Substring (x' 2)' 16)).ToArray ();  
Magic Number,scallion,GpgToolConfig,F:\newReposMay17\lachesis_scallion\scallion\GpgToolConfig.cs,GenerateBitmaskPatterns,The following statement contains a magic number: return Enumerable.Range (0' hex.Length).Where (x => x % 2 == 0).Select (x => Convert.ToByte (hex.Substring (x' 2)' 16)).ToArray ();  
Magic Number,scallion,GpgToolConfig,F:\newReposMay17\lachesis_scallion\scallion\GpgToolConfig.cs,GenerateBitmaskPatterns,The following statement contains a magic number: return _regex.GeneratePatternsForGpu (9).GroupBy (i => _regex.ConvertPatternToBitmask (i)).Select (i => {  	uint[] bitmask = TorBase32.ToUIntArray (hexToBytes (Regex.Replace (i.Key.ToLower ()' "[^.]"' "f").Replace ("."' "0")).PadLeft (20));  	// 20 bytes = 40 hex chars = 160 bits  	return new BitmaskPatternsTuple (bitmask' i.Select (j => TorBase32.ToUIntArray (hexToBytes (j.Replace ('.'' '0')).PadLeft (20))));  }).ToList ();  
Magic Number,scallion,GpgToolConfig,F:\newReposMay17\lachesis_scallion\scallion\GpgToolConfig.cs,GenerateBitmaskPatterns,The following statement contains a magic number: return _regex.GeneratePatternsForGpu (9).GroupBy (i => _regex.ConvertPatternToBitmask (i)).Select (i => {  	uint[] bitmask = TorBase32.ToUIntArray (hexToBytes (Regex.Replace (i.Key.ToLower ()' "[^.]"' "f").Replace ("."' "0")).PadLeft (20));  	// 20 bytes = 40 hex chars = 160 bits  	return new BitmaskPatternsTuple (bitmask' i.Select (j => TorBase32.ToUIntArray (hexToBytes (j.Replace ('.'' '0')).PadLeft (20))));  }).ToList ();  
Magic Number,scallion,GpgToolConfig,F:\newReposMay17\lachesis_scallion\scallion\GpgToolConfig.cs,GenerateBitmaskPatterns,The following statement contains a magic number: return _regex.GeneratePatternsForGpu (9).GroupBy (i => _regex.ConvertPatternToBitmask (i)).Select (i => {  	uint[] bitmask = TorBase32.ToUIntArray (hexToBytes (Regex.Replace (i.Key.ToLower ()' "[^.]"' "f").Replace ("."' "0")).PadLeft (20));  	// 20 bytes = 40 hex chars = 160 bits  	return new BitmaskPatternsTuple (bitmask' i.Select (j => TorBase32.ToUIntArray (hexToBytes (j.Replace ('.'' '0')).PadLeft (20))));  }).ToList ();  
Magic Number,scallion,GpgToolConfig,F:\newReposMay17\lachesis_scallion\scallion\GpgToolConfig.cs,GenerateBitmaskPatterns,The following statement contains a magic number: return new BitmaskPatternsTuple (bitmask' i.Select (j => TorBase32.ToUIntArray (hexToBytes (j.Replace ('.'' '0')).PadLeft (20))));  
Magic Number,scallion,OnionToolConfig,F:\newReposMay17\lachesis_scallion\scallion\OnionToolConfig.cs,CreateRegexPattern,The following statement contains a magic number: return new RegexPattern (pattern' 16' "abcdefghijklmnopqrstuvwxyz234567");  
Magic Number,scallion,OnionToolConfig,F:\newReposMay17\lachesis_scallion\scallion\OnionToolConfig.cs,GenerateBitmaskPatterns,The following statement contains a magic number: return _regex.GeneratePatternsForGpu (7).GroupBy (i => _regex.ConvertPatternToBitmask (i)).Select (i => new BitmaskPatternsTuple (TorBase32.ToUIntArray (TorBase32.CreateBase32Mask (i.Key))' i.Select (j => TorBase32.ToUIntArray (TorBase32.FromBase32Str (j.Replace ('.'' 'a')))))).ToList ();  
Magic Number,Mono.Options,OptionSet,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: foreach (Option p in this) {  	int written = 0;  	Category c = p as Category;  	if (c != null) {  		WriteDescription (o' p.Description' ""' 80' 80);  		continue;  	}  	if (!WriteOptionPrototype (o' p' ref written))  		continue;  	if (written < OptionWidth)  		o.Write (new string (' '' OptionWidth - written));  	else {  		o.WriteLine ();  		o.Write (new string (' '' OptionWidth));  	}  	WriteDescription (o' p.Description' new string (' '' OptionWidth + 2)' Description_FirstWidth' Description_RemWidth);  }  
Magic Number,Mono.Options,OptionSet,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: foreach (Option p in this) {  	int written = 0;  	Category c = p as Category;  	if (c != null) {  		WriteDescription (o' p.Description' ""' 80' 80);  		continue;  	}  	if (!WriteOptionPrototype (o' p' ref written))  		continue;  	if (written < OptionWidth)  		o.Write (new string (' '' OptionWidth - written));  	else {  		o.WriteLine ();  		o.Write (new string (' '' OptionWidth));  	}  	WriteDescription (o' p.Description' new string (' '' OptionWidth + 2)' Description_FirstWidth' Description_RemWidth);  }  
Magic Number,Mono.Options,OptionSet,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: foreach (Option p in this) {  	int written = 0;  	Category c = p as Category;  	if (c != null) {  		WriteDescription (o' p.Description' ""' 80' 80);  		continue;  	}  	if (!WriteOptionPrototype (o' p' ref written))  		continue;  	if (written < OptionWidth)  		o.Write (new string (' '' OptionWidth - written));  	else {  		o.WriteLine ();  		o.Write (new string (' '' OptionWidth));  	}  	WriteDescription (o' p.Description' new string (' '' OptionWidth + 2)' Description_FirstWidth' Description_RemWidth);  }  
Magic Number,Mono.Options,OptionSet,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: if (c != null) {  	WriteDescription (o' p.Description' ""' 80' 80);  	continue;  }  
Magic Number,Mono.Options,OptionSet,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: if (c != null) {  	WriteDescription (o' p.Description' ""' 80' 80);  	continue;  }  
Magic Number,Mono.Options,OptionSet,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: WriteDescription (o' p.Description' ""' 80' 80);  
Magic Number,Mono.Options,OptionSet,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: WriteDescription (o' p.Description' ""' 80' 80);  
Magic Number,Mono.Options,OptionSet,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: WriteDescription (o' p.Description' new string (' '' OptionWidth + 2)' Description_FirstWidth' Description_RemWidth);  
Magic Number,Mono.Options,OptionSet,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: foreach (ArgumentSource s in sources) {  	string[] names = s.GetNames ();  	if (names == null || names.Length == 0)  		continue;  	int written = 0;  	Write (o' ref written' "  ");  	Write (o' ref written' names [0]);  	for (int i = 1; i < names.Length; ++i) {  		Write (o' ref written' "' ");  		Write (o' ref written' names [i]);  	}  	if (written < OptionWidth)  		o.Write (new string (' '' OptionWidth - written));  	else {  		o.WriteLine ();  		o.Write (new string (' '' OptionWidth));  	}  	WriteDescription (o' s.Description' new string (' '' OptionWidth + 2)' Description_FirstWidth' Description_RemWidth);  }  
Magic Number,Mono.Options,OptionSet,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,WriteOptionDescriptions,The following statement contains a magic number: WriteDescription (o' s.Description' new string (' '' OptionWidth + 2)' Description_FirstWidth' Description_RemWidth);  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]) {  case '^':  	b.conv = BigEndian;  	return false;  case '_':  	b.conv = LittleEndian;  	return false;  case '%':  	b.conv = Native;  	return false;  case '!':  	b.align = -1;  	return false;  case 'x':  	b.Add (new byte[] {  		0  	});  	return false;  // Type Conversions  case 'i':  	b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  	break;  case 'I':  	b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  	break;  case 's':  	b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  	break;  case 'S':  	b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  	break;  case 'l':  	b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  	break;  case 'L':  	b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  	break;  case 'f':  	b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  	break;  case 'd':  	b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  	break;  case 'b':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  case 'c':  	b.Add (new byte[] {  		(byte)(Convert.ToSByte (oarg))  	});  	break;  case 'C':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b.repeat = ((short)b.description [b.i]) - ((short)'0');  	return false;  case '*':  	b.repeat = Int32.MaxValue;  	return false;  case '[':  	int count = -1' j;  	for (j = b.i + 1; j < b.description.Length; j++) {  		if (b.description [j] == ']')  			break;  		n = ((short)b.description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	b.i = j;  	b.repeat = count;  	return false;  case '$':  case 'z':  	bool add_null = b.description [b.i] == 'z';  	b.i++;  	if (b.i >= b.description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = b.description [b.i];  	Encoding e;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	if (b.align == -1)  		b.align = 4;  	b.Add (e.GetBytes (Convert.ToString (oarg)));  	if (add_null)  		b.Add (new byte[n]);  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' b.description [b.i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]) {  case '^':  	b.conv = BigEndian;  	return false;  case '_':  	b.conv = LittleEndian;  	return false;  case '%':  	b.conv = Native;  	return false;  case '!':  	b.align = -1;  	return false;  case 'x':  	b.Add (new byte[] {  		0  	});  	return false;  // Type Conversions  case 'i':  	b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  	break;  case 'I':  	b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  	break;  case 's':  	b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  	break;  case 'S':  	b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  	break;  case 'l':  	b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  	break;  case 'L':  	b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  	break;  case 'f':  	b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  	break;  case 'd':  	b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  	break;  case 'b':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  case 'c':  	b.Add (new byte[] {  		(byte)(Convert.ToSByte (oarg))  	});  	break;  case 'C':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b.repeat = ((short)b.description [b.i]) - ((short)'0');  	return false;  case '*':  	b.repeat = Int32.MaxValue;  	return false;  case '[':  	int count = -1' j;  	for (j = b.i + 1; j < b.description.Length; j++) {  		if (b.description [j] == ']')  			break;  		n = ((short)b.description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	b.i = j;  	b.repeat = count;  	return false;  case '$':  case 'z':  	bool add_null = b.description [b.i] == 'z';  	b.i++;  	if (b.i >= b.description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = b.description [b.i];  	Encoding e;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	if (b.align == -1)  		b.align = 4;  	b.Add (e.GetBytes (Convert.ToString (oarg)));  	if (add_null)  		b.Add (new byte[n]);  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' b.description [b.i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]) {  case '^':  	b.conv = BigEndian;  	return false;  case '_':  	b.conv = LittleEndian;  	return false;  case '%':  	b.conv = Native;  	return false;  case '!':  	b.align = -1;  	return false;  case 'x':  	b.Add (new byte[] {  		0  	});  	return false;  // Type Conversions  case 'i':  	b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  	break;  case 'I':  	b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  	break;  case 's':  	b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  	break;  case 'S':  	b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  	break;  case 'l':  	b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  	break;  case 'L':  	b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  	break;  case 'f':  	b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  	break;  case 'd':  	b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  	break;  case 'b':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  case 'c':  	b.Add (new byte[] {  		(byte)(Convert.ToSByte (oarg))  	});  	break;  case 'C':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b.repeat = ((short)b.description [b.i]) - ((short)'0');  	return false;  case '*':  	b.repeat = Int32.MaxValue;  	return false;  case '[':  	int count = -1' j;  	for (j = b.i + 1; j < b.description.Length; j++) {  		if (b.description [j] == ']')  			break;  		n = ((short)b.description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	b.i = j;  	b.repeat = count;  	return false;  case '$':  case 'z':  	bool add_null = b.description [b.i] == 'z';  	b.i++;  	if (b.i >= b.description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = b.description [b.i];  	Encoding e;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	if (b.align == -1)  		b.align = 4;  	b.Add (e.GetBytes (Convert.ToString (oarg)));  	if (add_null)  		b.Add (new byte[n]);  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' b.description [b.i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]) {  case '^':  	b.conv = BigEndian;  	return false;  case '_':  	b.conv = LittleEndian;  	return false;  case '%':  	b.conv = Native;  	return false;  case '!':  	b.align = -1;  	return false;  case 'x':  	b.Add (new byte[] {  		0  	});  	return false;  // Type Conversions  case 'i':  	b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  	break;  case 'I':  	b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  	break;  case 's':  	b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  	break;  case 'S':  	b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  	break;  case 'l':  	b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  	break;  case 'L':  	b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  	break;  case 'f':  	b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  	break;  case 'd':  	b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  	break;  case 'b':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  case 'c':  	b.Add (new byte[] {  		(byte)(Convert.ToSByte (oarg))  	});  	break;  case 'C':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b.repeat = ((short)b.description [b.i]) - ((short)'0');  	return false;  case '*':  	b.repeat = Int32.MaxValue;  	return false;  case '[':  	int count = -1' j;  	for (j = b.i + 1; j < b.description.Length; j++) {  		if (b.description [j] == ']')  			break;  		n = ((short)b.description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	b.i = j;  	b.repeat = count;  	return false;  case '$':  case 'z':  	bool add_null = b.description [b.i] == 'z';  	b.i++;  	if (b.i >= b.description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = b.description [b.i];  	Encoding e;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	if (b.align == -1)  		b.align = 4;  	b.Add (e.GetBytes (Convert.ToString (oarg)));  	if (add_null)  		b.Add (new byte[n]);  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' b.description [b.i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]) {  case '^':  	b.conv = BigEndian;  	return false;  case '_':  	b.conv = LittleEndian;  	return false;  case '%':  	b.conv = Native;  	return false;  case '!':  	b.align = -1;  	return false;  case 'x':  	b.Add (new byte[] {  		0  	});  	return false;  // Type Conversions  case 'i':  	b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  	break;  case 'I':  	b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  	break;  case 's':  	b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  	break;  case 'S':  	b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  	break;  case 'l':  	b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  	break;  case 'L':  	b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  	break;  case 'f':  	b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  	break;  case 'd':  	b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  	break;  case 'b':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  case 'c':  	b.Add (new byte[] {  		(byte)(Convert.ToSByte (oarg))  	});  	break;  case 'C':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b.repeat = ((short)b.description [b.i]) - ((short)'0');  	return false;  case '*':  	b.repeat = Int32.MaxValue;  	return false;  case '[':  	int count = -1' j;  	for (j = b.i + 1; j < b.description.Length; j++) {  		if (b.description [j] == ']')  			break;  		n = ((short)b.description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	b.i = j;  	b.repeat = count;  	return false;  case '$':  case 'z':  	bool add_null = b.description [b.i] == 'z';  	b.i++;  	if (b.i >= b.description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = b.description [b.i];  	Encoding e;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	if (b.align == -1)  		b.align = 4;  	b.Add (e.GetBytes (Convert.ToString (oarg)));  	if (add_null)  		b.Add (new byte[n]);  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' b.description [b.i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]) {  case '^':  	b.conv = BigEndian;  	return false;  case '_':  	b.conv = LittleEndian;  	return false;  case '%':  	b.conv = Native;  	return false;  case '!':  	b.align = -1;  	return false;  case 'x':  	b.Add (new byte[] {  		0  	});  	return false;  // Type Conversions  case 'i':  	b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  	break;  case 'I':  	b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  	break;  case 's':  	b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  	break;  case 'S':  	b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  	break;  case 'l':  	b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  	break;  case 'L':  	b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  	break;  case 'f':  	b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  	break;  case 'd':  	b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  	break;  case 'b':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  case 'c':  	b.Add (new byte[] {  		(byte)(Convert.ToSByte (oarg))  	});  	break;  case 'C':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b.repeat = ((short)b.description [b.i]) - ((short)'0');  	return false;  case '*':  	b.repeat = Int32.MaxValue;  	return false;  case '[':  	int count = -1' j;  	for (j = b.i + 1; j < b.description.Length; j++) {  		if (b.description [j] == ']')  			break;  		n = ((short)b.description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	b.i = j;  	b.repeat = count;  	return false;  case '$':  case 'z':  	bool add_null = b.description [b.i] == 'z';  	b.i++;  	if (b.i >= b.description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = b.description [b.i];  	Encoding e;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	if (b.align == -1)  		b.align = 4;  	b.Add (e.GetBytes (Convert.ToString (oarg)));  	if (add_null)  		b.Add (new byte[n]);  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' b.description [b.i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]) {  case '^':  	b.conv = BigEndian;  	return false;  case '_':  	b.conv = LittleEndian;  	return false;  case '%':  	b.conv = Native;  	return false;  case '!':  	b.align = -1;  	return false;  case 'x':  	b.Add (new byte[] {  		0  	});  	return false;  // Type Conversions  case 'i':  	b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  	break;  case 'I':  	b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  	break;  case 's':  	b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  	break;  case 'S':  	b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  	break;  case 'l':  	b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  	break;  case 'L':  	b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  	break;  case 'f':  	b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  	break;  case 'd':  	b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  	break;  case 'b':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  case 'c':  	b.Add (new byte[] {  		(byte)(Convert.ToSByte (oarg))  	});  	break;  case 'C':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b.repeat = ((short)b.description [b.i]) - ((short)'0');  	return false;  case '*':  	b.repeat = Int32.MaxValue;  	return false;  case '[':  	int count = -1' j;  	for (j = b.i + 1; j < b.description.Length; j++) {  		if (b.description [j] == ']')  			break;  		n = ((short)b.description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	b.i = j;  	b.repeat = count;  	return false;  case '$':  case 'z':  	bool add_null = b.description [b.i] == 'z';  	b.i++;  	if (b.i >= b.description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = b.description [b.i];  	Encoding e;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	if (b.align == -1)  		b.align = 4;  	b.Add (e.GetBytes (Convert.ToString (oarg)));  	if (add_null)  		b.Add (new byte[n]);  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' b.description [b.i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]) {  case '^':  	b.conv = BigEndian;  	return false;  case '_':  	b.conv = LittleEndian;  	return false;  case '%':  	b.conv = Native;  	return false;  case '!':  	b.align = -1;  	return false;  case 'x':  	b.Add (new byte[] {  		0  	});  	return false;  // Type Conversions  case 'i':  	b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  	break;  case 'I':  	b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  	break;  case 's':  	b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  	break;  case 'S':  	b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  	break;  case 'l':  	b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  	break;  case 'L':  	b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  	break;  case 'f':  	b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  	break;  case 'd':  	b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  	break;  case 'b':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  case 'c':  	b.Add (new byte[] {  		(byte)(Convert.ToSByte (oarg))  	});  	break;  case 'C':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b.repeat = ((short)b.description [b.i]) - ((short)'0');  	return false;  case '*':  	b.repeat = Int32.MaxValue;  	return false;  case '[':  	int count = -1' j;  	for (j = b.i + 1; j < b.description.Length; j++) {  		if (b.description [j] == ']')  			break;  		n = ((short)b.description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	b.i = j;  	b.repeat = count;  	return false;  case '$':  case 'z':  	bool add_null = b.description [b.i] == 'z';  	b.i++;  	if (b.i >= b.description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = b.description [b.i];  	Encoding e;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	if (b.align == -1)  		b.align = 4;  	b.Add (e.GetBytes (Convert.ToString (oarg)));  	if (add_null)  		b.Add (new byte[n]);  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' b.description [b.i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]) {  case '^':  	b.conv = BigEndian;  	return false;  case '_':  	b.conv = LittleEndian;  	return false;  case '%':  	b.conv = Native;  	return false;  case '!':  	b.align = -1;  	return false;  case 'x':  	b.Add (new byte[] {  		0  	});  	return false;  // Type Conversions  case 'i':  	b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  	break;  case 'I':  	b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  	break;  case 's':  	b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  	break;  case 'S':  	b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  	break;  case 'l':  	b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  	break;  case 'L':  	b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  	break;  case 'f':  	b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  	break;  case 'd':  	b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  	break;  case 'b':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  case 'c':  	b.Add (new byte[] {  		(byte)(Convert.ToSByte (oarg))  	});  	break;  case 'C':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b.repeat = ((short)b.description [b.i]) - ((short)'0');  	return false;  case '*':  	b.repeat = Int32.MaxValue;  	return false;  case '[':  	int count = -1' j;  	for (j = b.i + 1; j < b.description.Length; j++) {  		if (b.description [j] == ']')  			break;  		n = ((short)b.description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	b.i = j;  	b.repeat = count;  	return false;  case '$':  case 'z':  	bool add_null = b.description [b.i] == 'z';  	b.i++;  	if (b.i >= b.description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = b.description [b.i];  	Encoding e;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	if (b.align == -1)  		b.align = 4;  	b.Add (e.GetBytes (Convert.ToString (oarg)));  	if (add_null)  		b.Add (new byte[n]);  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' b.description [b.i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: for (j = b.i + 1; j < b.description.Length; j++) {  	if (b.description [j] == ']')  		break;  	n = ((short)b.description [j]) - ((short)'0');  	if (n >= 0 && n <= 9) {  		if (count == -1)  			count = n;  		else  			count = count * 10 + n;  	}  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: for (j = b.i + 1; j < b.description.Length; j++) {  	if (b.description [j] == ']')  		break;  	n = ((short)b.description [j]) - ((short)'0');  	if (n >= 0 && n <= 9) {  		if (count == -1)  			count = n;  		else  			count = count * 10 + n;  	}  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: if (n >= 0 && n <= 9) {  	if (count == -1)  		count = n;  	else  		count = count * 10 + n;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: if (n >= 0 && n <= 9) {  	if (count == -1)  		count = n;  	else  		count = count * 10 + n;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: if (count == -1)  	count = n;  else  	count = count * 10 + n;  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: count = count * 10 + n;  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: n = 2;  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: n = 2;  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: e = Encoding.GetEncoding (12000);  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: n = 4;  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: e = Encoding.GetEncoding (12001);  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: n = 4;  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: if (b.align == -1)  	b.align = 4;  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,PackOne,The following statement contains a magic number: b.align = 4;  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetFloat (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	} else  		i++;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetFloat (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 4' ref align)) {  	result.Add (conv.GetInt32 (buffer' idx));  	idx += 4;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 4' ref align)) {  	result.Add (conv.GetInt32 (buffer' idx));  	idx += 4;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: idx += 4;  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 4' ref align)) {  	result.Add (conv.GetUInt32 (buffer' idx));  	idx += 4;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 4' ref align)) {  	result.Add (conv.GetUInt32 (buffer' idx));  	idx += 4;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: idx += 4;  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 2' ref align)) {  	result.Add (conv.GetInt16 (buffer' idx));  	idx += 2;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 2' ref align)) {  	result.Add (conv.GetInt16 (buffer' idx));  	idx += 2;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: idx += 2;  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 2' ref align)) {  	result.Add (conv.GetUInt16 (buffer' idx));  	idx += 2;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 2' ref align)) {  	result.Add (conv.GetUInt16 (buffer' idx));  	idx += 2;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: idx += 2;  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 8' ref align)) {  	result.Add (conv.GetInt64 (buffer' idx));  	idx += 8;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 8' ref align)) {  	result.Add (conv.GetInt64 (buffer' idx));  	idx += 8;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: idx += 8;  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 8' ref align)) {  	result.Add (conv.GetUInt64 (buffer' idx));  	idx += 8;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 8' ref align)) {  	result.Add (conv.GetUInt64 (buffer' idx));  	idx += 8;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: idx += 8;  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 4' ref align)) {  	result.Add (conv.GetFloat (buffer' idx));  	idx += 4;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 4' ref align)) {  	result.Add (conv.GetFloat (buffer' idx));  	idx += 4;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: idx += 4;  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 8' ref align)) {  	result.Add (conv.GetDouble (buffer' idx));  	idx += 8;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 8' ref align)) {  	result.Add (conv.GetDouble (buffer' idx));  	idx += 8;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: idx += 8;  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (j = i + 1; j < description.Length; j++) {  	if (description [j] == ']')  		break;  	n = ((short)description [j]) - ((short)'0');  	if (n >= 0 && n <= 9) {  		if (count == -1)  			count = n;  		else  			count = count * 10 + n;  	}  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (j = i + 1; j < description.Length; j++) {  	if (description [j] == ']')  		break;  	n = ((short)description [j]) - ((short)'0');  	if (n >= 0 && n <= 9) {  		if (count == -1)  			count = n;  		else  			count = count * 10 + n;  	}  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: if (n >= 0 && n <= 9) {  	if (count == -1)  		count = n;  	else  		count = count * 10 + n;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: if (n >= 0 && n <= 9) {  	if (count == -1)  		count = n;  	else  		count = count * 10 + n;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: if (count == -1)  	count = n;  else  	count = count * 10 + n;  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: count = count * 10 + n;  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: if (align) {  	idx = Align (idx' 4);  	align = false;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: idx = Align (idx' 4);  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: n = 2;  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: n = 2;  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: e = Encoding.GetEncoding (12000);  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: n = 4;  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: e = Encoding.GetEncoding (12001);  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: n = 4;  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (n) {  case 1:  	for (; k < buffer.Length && buffer [k] != 0; k++)  		;  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 1;  	break;  case 2:  	for (; k < buffer.Length; k++) {  		if (k + 1 == buffer.Length) {  			k++;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 2;  	break;  case 4:  	for (; k < buffer.Length; k++) {  		if (k + 3 >= buffer.Length) {  			k = buffer.Length;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 4;  	break;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (n) {  case 1:  	for (; k < buffer.Length && buffer [k] != 0; k++)  		;  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 1;  	break;  case 2:  	for (; k < buffer.Length; k++) {  		if (k + 1 == buffer.Length) {  			k++;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 2;  	break;  case 4:  	for (; k < buffer.Length; k++) {  		if (k + 3 >= buffer.Length) {  			k = buffer.Length;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 4;  	break;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (n) {  case 1:  	for (; k < buffer.Length && buffer [k] != 0; k++)  		;  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 1;  	break;  case 2:  	for (; k < buffer.Length; k++) {  		if (k + 1 == buffer.Length) {  			k++;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 2;  	break;  case 4:  	for (; k < buffer.Length; k++) {  		if (k + 3 >= buffer.Length) {  			k = buffer.Length;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 4;  	break;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (n) {  case 1:  	for (; k < buffer.Length && buffer [k] != 0; k++)  		;  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 1;  	break;  case 2:  	for (; k < buffer.Length; k++) {  		if (k + 1 == buffer.Length) {  			k++;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 2;  	break;  case 4:  	for (; k < buffer.Length; k++) {  		if (k + 3 >= buffer.Length) {  			k = buffer.Length;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 4;  	break;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (n) {  case 1:  	for (; k < buffer.Length && buffer [k] != 0; k++)  		;  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 1;  	break;  case 2:  	for (; k < buffer.Length; k++) {  		if (k + 1 == buffer.Length) {  			k++;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 2;  	break;  case 4:  	for (; k < buffer.Length; k++) {  		if (k + 3 >= buffer.Length) {  			k = buffer.Length;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 4;  	break;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (n) {  case 1:  	for (; k < buffer.Length && buffer [k] != 0; k++)  		;  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 1;  	break;  case 2:  	for (; k < buffer.Length; k++) {  		if (k + 1 == buffer.Length) {  			k++;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 2;  	break;  case 4:  	for (; k < buffer.Length; k++) {  		if (k + 3 >= buffer.Length) {  			k = buffer.Length;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 4;  	break;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: switch (n) {  case 1:  	for (; k < buffer.Length && buffer [k] != 0; k++)  		;  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 1;  	break;  case 2:  	for (; k < buffer.Length; k++) {  		if (k + 1 == buffer.Length) {  			k++;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 2;  	break;  case 4:  	for (; k < buffer.Length; k++) {  		if (k + 3 >= buffer.Length) {  			k = buffer.Length;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 4;  	break;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: if (k == buffer.Length)  	idx = k;  else  	idx = k + 2;  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: idx = k + 2;  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (; k < buffer.Length; k++) {  	if (k + 3 >= buffer.Length) {  		k = buffer.Length;  		break;  	}  	if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  		break;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (; k < buffer.Length; k++) {  	if (k + 3 >= buffer.Length) {  		k = buffer.Length;  		break;  	}  	if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  		break;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: for (; k < buffer.Length; k++) {  	if (k + 3 >= buffer.Length) {  		k = buffer.Length;  		break;  	}  	if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  		break;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: if (k + 3 >= buffer.Length) {  	k = buffer.Length;  	break;  }  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  	break;  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  	break;  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: if (k == buffer.Length)  	idx = k;  else  	idx = k + 4;  
Magic Number,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following statement contains a magic number: idx = k + 4;  
Missing Default,scallion,Program,F:\newReposMay17\lachesis_scallion\scallion\Program.cs,Main,The following switch statement is missing a default case: switch (parms.ProgramMode) {  case Mode.Help:  	Help (p);  	break;  case Mode.ListDevices:  	ListDevices ();  	break;  case Mode.Normal:  case Mode.NonOptimized:  	{  		// If no Work Group Size provided' then query the selected device for preferred' if not found set to 32.  		if (parms.WorkGroupSize == 0) {  			ulong preferredWorkGroupSize = 32;  			uint deviceId = 0;  			foreach (CLDeviceInfo device in CLRuntime.GetDevices ()) {  				if (!device.CompilerAvailable)  					continue;  				if (deviceId == parms.DeviceId) {  					preferredWorkGroupSize = getPreferredWorkGroupSize (device.DeviceId);  					break;  				}  				deviceId++;  			}  			parms.WorkGroupSize = (uint)preferredWorkGroupSize;  		}  		Console.CancelKeyPress += new ConsoleCancelEventHandler (Console_CancelKeyPress);  		try {  			_runtime.Run (ProgramParameters.Instance);  		} catch (ApplicationException e) {  			// these are handled and printed out  			Console.Error.WriteLine (e.Message);  			Environment.Exit (1);  		} finally {  			Shutdown ();  		}  	}  	break;  }  
Missing Default,scallion,TorBase32,F:\newReposMay17\lachesis_scallion\scallion\TorBase32.cs,FromBase32Str,The following switch statement is missing a default case: switch (bit % 40) {  case 0:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 3) + (((byte)tmp [(bit / 5) + 1]) >> 2));  	break;  case 8:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 6) + (((byte)tmp [(bit / 5) + 1]) << 1) + (((byte)tmp [(bit / 5) + 2]) >> 4));  	break;  case 16:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 4) + (((byte)tmp [(bit / 5) + 1]) >> 1));  	break;  case 24:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 7) + (((byte)tmp [(bit / 5) + 1]) << 2) + (((byte)tmp [(bit / 5) + 2]) >> 3));  	break;  case 32:  	dest [i] = (byte)((((byte)tmp [(bit / 5)]) << 5) + ((byte)tmp [(bit / 5) + 1]));  	break;  }  
Missing Default,Mono.Options,OptionSet,F:\newReposMay17\lachesis_scallion\scallion\Options.cs,Parse,The following switch statement is missing a default case: switch (p.OptionValueType) {  case OptionValueType.None:  	c.OptionValues.Add (n);  	c.Option.Invoke (c);  	break;  case OptionValueType.Optional:  case OptionValueType.Required:  	ParseValue (v' c);  	break;  }  
Missing Default,Mono,DataConverter,F:\newReposMay17\lachesis_scallion\scallion\DataConvert.cs,Unpack,The following switch statement is missing a default case: switch (n) {  case 1:  	for (; k < buffer.Length && buffer [k] != 0; k++)  		;  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 1;  	break;  case 2:  	for (; k < buffer.Length; k++) {  		if (k + 1 == buffer.Length) {  			k++;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 2;  	break;  case 4:  	for (; k < buffer.Length; k++) {  		if (k + 3 >= buffer.Length) {  			k = buffer.Length;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 4;  	break;  }  
