Implementation smell,Namespace,Class,File,Method,Description
Long Method,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The method has 264 lines of code.
Long Method,Examples,VectorAdd,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenCL\VectorAdd.cs,Main,The method has 109 lines of code.
Long Method,Examples,TestApp,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\Test\TestAudioContext.cs,AlcUnitTestFunc,The method has 144 lines of code.
Long Method,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The method has 233 lines of code.
Long Method,Examples.Tutorial,GLDiagnostics,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\OpenGLDiagnostics.cs,OnLoad,The method has 139 lines of code.
Long Method,Examples.Tutorial,SimpleFBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\FramebufferObject.cs,OnLoad,The method has 134 lines of code.
Long Method,Examples.Tutorial,SimpleGeometryShader,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShader.cs,OnLoad,The method has 102 lines of code.
Long Method,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,initShaderProgramCubemap,The method has 128 lines of code.
Long Method,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,initTextureCube,The method has 123 lines of code.
Long Method,Examples.TextureLoaders,ImageGDI,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderGDI.cs,LoadFromDisk,The method has 108 lines of code.
Long Method,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The method has 326 lines of code.
Long Method,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The method has 236 lines of code.
Long Method,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The method has 127 lines of code.
Long Method,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The method has 246 lines of code.
Long Method,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The method has 185 lines of code.
Long Method,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The method has 593 lines of code.
Complex Method,Examples.Tutorial,T02_Vertex_Arrays,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VertexArrays.cs,OnUpdateFrame,Cyclomatic complexity of the method is 10
Complex Method,Examples.Tutorial,T12_GLSL_Parallax,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\SwizzledParallax.cs,OnUpdateFrame,Cyclomatic complexity of the method is 9
Complex Method,Examples.TextureLoaders,ImageGDI,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderGDI.cs,LoadFromDisk,Cyclomatic complexity of the method is 9
Complex Method,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,Cyclomatic complexity of the method is 25
Complex Method,Examples.Shapes,TorusKnot,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\TorusKnot.cs,TorusKnot,Cyclomatic complexity of the method is 10
Complex Method,Examples.Tests,TestGraphicsModes,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\TestGraphicsModes.cs,Main,Cyclomatic complexity of the method is 8
Long Parameter List,Examples,ExampleAttribute,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleAttribute.cs,ExampleAttribute,The method has 5 parameters. Parameters: title' category' subcategory' difficulty' visible
Long Parameter List,Examples.Tutorial,T10_GLSL_Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\SimpleGLSL.cs,CreateShaders,The method has 5 parameters. Parameters: vs' fs' vertexObject' fragmentObject' program
Long Parameter List,Examples.Shapes,TorusKnot,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\TorusKnot.cs,TorusKnot,The method has 7 parameters. Parameters: pathsteps' shapevertices' radius' p' q' TexCount' useDL
Long Parameter List,Examples.Shapes,KochTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\KochTetrahedron.cs,KochTetrahedron,The method has 5 parameters. Parameters: scale' extrusionHeight' extrusionMultiplier' subdivs' useDL
Long Parameter List,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The method has 6 parameters. Parameters: Width' Height' Length' subdivs' radius' useDL
Long Parameter List,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The method has 6 parameters. Parameters: side' subdivs' scale' offset1' offset2' useDL
Long Parameter List,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,SlicedSphere,The method has 5 parameters. Parameters: radius' offset' subdivs' sides' useDL
Long Parameter List,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,GetDefaultVertices,The method has 5 parameters. Parameters: s' scale' first' second' third
Long Parameter List,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The method has 5 parameters. Parameters: Scale' first' second' third' c
Long Parameter List,Examples.Shapes,IsoSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\IsoSphere.cs,IsoSphere,The method has 5 parameters. Parameters: s_steps' t_steps' x_scale' y_scale' z_scale
Long Parameter List,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,FindNormal,The method has 5 parameters. Parameters: A' B' C' D' result
Long Parameter List,Examples.Shapes,TetrahedronFace,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\TetrahedronFace.cs,TetrahedronFace,The method has 8 parameters. Parameters: apos' atc' bpos' btc' cpos' ctc' dpos' normal
Long Parameter List,Examples.Shapes,TetrahedronFace,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\TetrahedronFace.cs,SubdivideKoch,The method has 7 parameters. Parameters: height' first' second' third' fourth' fifth' sixth
Long Parameter List,Examples.WinForms,Function,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,Function,The method has 5 parameters. Parameters: name' category' entryPoint' version' extension
Long Identifier,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,,The length of the parameter viewDescriptionToolStripMenuItem is 32.
Long Identifier,Examples.Tutorial,T12_GLSL_Parallax,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\SwizzledParallax.cs,,The length of the parameter MaterialScaleAndBiasAndShininess is 32.
Long Statement,Examples,Program,C:\repos\lachesis_scallion\opentk\Source\Examples\Main.cs,Main,The length of the statement  "                MessageBox.Show("The Example Launcher failed to start' due to insufficient permissions. This may happen if you execute the application from a network share."' "OpenTK Example Launcher failed to start."' " is 202.
Long Statement,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,OnShown,The length of the statement  "                //MessageBox.Show("The new Sample Browser is not complete. Please report any issues at http://www.opentk.com/project/issues."' " is 126.
Long Statement,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,RunSample,The length of the statement  "                MessageBox.Show("The selected example does not define a Main method"' "Entry point not found"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 145.
Long Statement,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The length of the statement  "            this.treeViewSamples.NodeMouseDoubleClick += new System.Windows.Forms.TreeNodeMouseClickEventHandler(this.treeViewSamples_NodeMouseDoubleClick); " is 144.
Long Statement,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The length of the statement  "            this.contextMenuStripSamples.ItemClicked += new System.Windows.Forms.ToolStripItemClickedEventHandler(this.contextMenuStripSamples_ItemClicked); " is 144.
Long Statement,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The length of the statement  "            this.richTextBoxDescription.MouseDown += new System.Windows.Forms.MouseEventHandler(this.richTextBoxDescription_MouseDown); " is 123.
Long Statement,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The length of the statement  "            this.contextMenuStripDescription.ItemClicked += new System.Windows.Forms.ToolStripItemClickedEventHandler(this.contextMenuStripDescription_ItemClicked); " is 152.
Long Statement,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The length of the statement  "            this.richTextBoxSource.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(216))))' ((int)(((byte)(242))))' ((int)(((byte)(240))))); " is 137.
Long Statement,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The length of the statement  "            this.contextMenuStripSource.ItemClicked += new System.Windows.Forms.ToolStripItemClickedEventHandler(this.contextMenuStripSource_ItemClicked); " is 142.
Long Statement,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The length of the statement  "            this.textBoxOutput.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(216))))' ((int)(((byte)(242))))' ((int)(((byte)(240))))); " is 133.
Long Statement,Examples,VectorAdd,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenCL\VectorAdd.cs,Main,The length of the statement  "            unsafe { hContext = CL.CreateContextFromType((ContextProperties*)null' DeviceTypeFlags.DeviceTypeDefault' IntPtr.Zero' IntPtr.Zero' &error); } " is 142.
Long Statement,Examples,TestApp,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\Test\TestAudioContext.cs,AlcUnitTestFunc,The length of the statement  "                    Alc.ProcessContext( MyContext ); // enable context. The default state of a context created by alcCreateContext is that it is processing. " is 136.
Long Statement,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,StartRecording,The length of the statement  "                MessageBox.Show("Fatal: Cannot continue without a playback device.\nException caught when opening playback device.\n" + ae.Message); " is 132.
Long Statement,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,StartRecording,The length of the statement  "            int buffer_length_samples = (int)((double)numericUpDown_BufferLength.Value * sampling_rate * 0.001 / BlittableValueType.StrideOf(buffer)); " is 138.
Long Statement,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,UpdateSamples,The length of the statement  "                AL.BufferData(buf' ALFormat.Mono16' buffer' (int)(available_samples * BlittableValueType.StrideOf(buffer))' audio_capture.SampleFrequency); " is 139.
Long Statement,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The length of the statement  "            this.comboBox_RecorderSelection.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) " is 159.
Long Statement,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The length of the statement  "            this.groupBox_RecorderParameters.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) " is 163.
Long Statement,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The length of the statement  "            this.numericUpDown_PlaybackGain.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 162.
Long Statement,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The length of the statement  "            this.label_MONO16BIT.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 151.
Long Statement,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The length of the statement  "            this.numericUpDown_BufferLength.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 162.
Long Statement,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The length of the statement  "            this.numericUpDown_Frequency.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 159.
Long Statement,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The length of the statement  "            this.groupBox_RecordingControls.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) " is 162.
Long Statement,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The length of the statement  "            this.button_Start.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) " is 145.
Long Statement,Examples.Tutorial,Anaglyph,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\Anaglyph.cs,SetupCamera,The length of the statement  "            double widthdiv2 = camera.NearPlane * Math.Tan( MathHelper.DegreesToRadians( (float)( camera.Aperture / 2.0 ) ) ); // aperture in radians " is 137.
Long Statement,Examples.Tutorial,Anaglyph,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\Anaglyph.cs,SetupCamera,The length of the statement  "                    new Vector3( camera.Position.X + Right.X + camera.Direction.X' camera.Position.Y + Right.Y + camera.Direction.Y' camera.Position.Z + Right.Z + camera.Direction.Z )' " is 164.
Long Statement,Examples.Tutorial,Anaglyph,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\Anaglyph.cs,SetupCamera,The length of the statement  "                    new Vector3( camera.Position.X - Right.X + camera.Direction.X' camera.Position.Y - Right.Y + camera.Direction.Y' camera.Position.Z - Right.Z + camera.Direction.Z )' " is 164.
Long Statement,Examples.Tutorial,StencilCSG,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\StencilCSG.cs,OnLoad,The length of the statement  "            WindowTitle = "Cube-Sphere Stencil CSG  " + GL.GetString(StringName.Renderer) + " (GL " + GL.GetString(StringName.Version) + ")"; " is 129.
Long Statement,Examples.Tutorial,StencilCSG,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\StencilCSG.cs,OnLoad,The length of the statement  "            BitmapData data = bitmap.LockBits(new System.Drawing.Rectangle(0' 0' bitmap.Width' bitmap.Height)' ImageLockMode.ReadOnly' System.Drawing.Imaging.PixelFormat.Format32bppArgb); " is 175.
Long Statement,Examples.Tutorial,StencilCSG,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\StencilCSG.cs,OnLoad,The length of the statement  "            GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgba' data.Width' data.Height' 0' OpenTK.Graphics.OpenGL.PixelFormat.Bgra' PixelType.UnsignedByte' data.Scan0); " is 173.
Long Statement,Examples.Tutorial,T02_Vertex_Arrays,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VertexArrays.cs,OnResize,The length of the statement  "            OpenTK.Matrix4 perspective = OpenTK.Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4' (float)aspect_ratio' 1' 64); " is 121.
Long Statement,Examples.Tutorial,T09_VBO_Dynamic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VBODynamic.cs,OnRenderFrame,The length of the statement  "            GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(VertexC4ubV3f.SizeInBytes * MaxParticleCount)' IntPtr.Zero' BufferUsageHint.StreamDraw); " is 137.
Long Statement,Examples.Tutorial,T09_VBO_Dynamic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VBODynamic.cs,OnRenderFrame,The length of the statement  "            GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(VertexC4ubV3f.SizeInBytes * MaxParticleCount)' VBO' BufferUsageHint.StreamDraw); " is 129.
Long Statement,Examples.Tutorial,SimpleFBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\FramebufferObject.cs,OnLoad,The length of the statement  "            GL.TexImage2D(TextureTarget.Texture2D' 0' PixelInternalFormat.Rgba8' TextureSize' TextureSize' 0' PixelFormat.Rgba' PixelType.UnsignedByte' IntPtr.Zero); " is 153.
Long Statement,Examples.Tutorial,SimpleFBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\FramebufferObject.cs,OnLoad,The length of the statement  "            GL.TexImage2D(TextureTarget.Texture2D' 0' (PixelInternalFormat)All.DepthComponent32' TextureSize' TextureSize' 0' PixelFormat.DepthComponent' PixelType.UnsignedInt' IntPtr.Zero); " is 178.
Long Statement,Examples.Tutorial,SimpleFBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\FramebufferObject.cs,OnLoad,The length of the statement  "            GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt' FramebufferAttachment.ColorAttachment0Ext' TextureTarget.Texture2D' ColorTexture' 0); " is 147.
Long Statement,Examples.Tutorial,SimpleFBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\FramebufferObject.cs,OnLoad,The length of the statement  "            GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt' FramebufferAttachment.DepthAttachmentExt' TextureTarget.Texture2D' DepthTexture' 0); " is 146.
Long Statement,Examples.Tutorial,SimpleFBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\FramebufferObject.cs,OnLoad,The length of the statement  "                        Console.WriteLine("FBO: One or more attachment points are not framebuffer attachment complete. This could mean there’s no texture attached or the format isn’t renderable. For color textures this means the base format must be RGB or RGBA and for depth textures it must be a DEPTH_COMPONENT format. Other causes of this error are that the width or height is zero or the z-offset is out of range in case of render to volume."); " is 424.
Long Statement,Examples.Tutorial,SimpleFBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\FramebufferObject.cs,OnLoad,The length of the statement  "                        Console.WriteLine("FBO: The color attachments have different format. All color attachments must have the same format."); " is 120.
Long Statement,Examples.Tutorial,SimpleFBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\FramebufferObject.cs,OnLoad,The length of the statement  "            Console.WriteLine("max. ColorBuffers: " + queryinfo[0] + " max. AuxBuffers: " + queryinfo[1] + " max. DrawBuffers: " + queryinfo[2] + " is 133.
Long Statement,Examples.Tutorial,SimpleFBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\FramebufferObject.cs,OnLoad,The length of the statement  "                OpenTK.Matrix4 perspective = OpenTK.Matrix4.CreatePerspectiveFieldOfView( MathHelper.PiOver4' TextureSize / (float)TextureSize' 2.5f' 6f ); " is 139.
Long Statement,Examples.Tutorial,SimpleFBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\FramebufferObject.cs,OnResize,The length of the statement  "            OpenTK.Matrix4 perspective = OpenTK.Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4' (float)aspect_ratio' 1' 64); " is 121.
Long Statement,Examples.Tutorial,T03_Immediate_Mode_Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\ImmediateMode.cs,OnResize,The length of the statement  "            OpenTK.Matrix4 perspective = OpenTK.Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4' (float)aspect_ratio' 1' 64); " is 121.
Long Statement,Examples.Tutorial,TextureMatrix,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\TextureMatrix.cs,LoadTexture,The length of the statement  "            BitmapData data = bitmap.LockBits(new System.Drawing.Rectangle(0' 0' bitmap.Width' bitmap.Height)' ImageLockMode.ReadOnly' System.Drawing.Imaging.PixelFormat.Format32bppArgb); " is 175.
Long Statement,Examples.Tutorial,TextureMatrix,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\TextureMatrix.cs,LoadTexture,The length of the statement  "            GL.TexImage2D(Target' 0' PixelInternalFormat.Rgba' data.Width' data.Height' 0' OpenTK.Graphics.OpenGL.PixelFormat.Bgra' PixelType.UnsignedByte' data.Scan0); " is 156.
Long Statement,Examples.Tutorial,Picking,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\Picking.cs,OnLoad,The length of the statement  "            GL.BufferData<Vertex>(BufferTarget.ArrayBuffer' (IntPtr)(VBO_Array.Length * Vertex.SizeInBytes)' VBO_Array' BufferUsageHint.StaticDraw); " is 136.
Long Statement,Examples.Tutorial,Picking,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\Picking.cs,OnResize,The length of the statement  "            Matrix4 projection = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4' this.Width / (float)this.Height' 0.1f' 10.0f); " is 124.
Long Statement,Examples.Tutorial,Picking,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\Picking.cs,Main,The length of the statement  "                example.Title = String.Format("OpenTK | {0} {1}: {2} (use the mouse to pick)"' info.Category' info.Difficulty' info.Title); " is 123.
Long Statement,Examples.Tutorial,SimpleGeometryShader,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShader.cs,OnLoad,The length of the statement  "            // the primitive type given to GL.Begin. If the types do not match a GL error will occur (todo: verify GL_INVALID_ENUM' on glBegin) " is 131.
Long Statement,Examples.Tutorial,T13_GLSL_Earth,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\DDSCubeMap.cs,OnLoad,The length of the statement  "            sphere = new SlicedSphere(1.5f' Vector3d.Zero' SlicedSphere.eSubdivisions.Four' new SlicedSphere.eDir[] { SlicedSphere.eDir.All }' true); " is 137.
Long Statement,Examples.Tutorial,T12_GLSL_Parallax,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\SwizzledParallax.cs,OnRenderFrame,The length of the statement  "            GL.Uniform3( GL.GetUniformLocation( ProgramObject' "Material_ScaleBiasShininess" )' MaterialScaleAndBiasAndShininess.X' MaterialScaleAndBiasAndShininess.Y' MaterialScaleAndBiasAndShininess.Z ); " is 193.
Long Statement,Examples.Tutorial,T12_GLSL_Parallax,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\SwizzledParallax.cs,OnRenderFrame,The length of the statement  "            GL.Uniform3( GL.GetUniformLocation( ProgramObject' "Light_Position" )' LightPosition.X' LightPosition.Y' LightPosition.Z ); " is 123.
Long Statement,Examples.Tutorial,T12_GLSL_Parallax,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\SwizzledParallax.cs,OnRenderFrame,The length of the statement  "            GL.Uniform3( GL.GetUniformLocation( ProgramObject' "Light_DiffuseColor" )' LightDiffuse.X' LightDiffuse.Y' LightDiffuse.Z ); " is 124.
Long Statement,Examples.Tutorial,T12_GLSL_Parallax,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\SwizzledParallax.cs,OnRenderFrame,The length of the statement  "            GL.Uniform3( GL.GetUniformLocation( ProgramObject' "Light_SpecularColor" )' LightSpecular.X' LightSpecular.Y' LightSpecular.Z ); " is 128.
Long Statement,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,initTextureCube,The length of the statement  "                GL.TexImage2D(target' 0' PixelInternalFormat.Rgba8' 512' 512' 0' PixelFormat.Rgba' PixelType.UnsignedByte' IntPtr.Zero); " is 120.
Long Statement,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,initTextureCube,The length of the statement  "                GL.TexImage2D(target' 0' (PixelInternalFormat)All.DepthComponent32' 512' 512' 0' PixelFormat.DepthComponent' PixelType.UnsignedInt' IntPtr.Zero); " is 145.
Long Statement,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,initTextureCube,The length of the statement  "            GL.Ext.FramebufferTexture(FramebufferTarget.FramebufferExt' FramebufferAttachment.ColorAttachment0Ext' textureCubeColor' 0); " is 124.
Long Statement,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,initTextureCube,The length of the statement  "            //GL.Ext.FramebufferRenderbuffer(FramebufferTarget.FramebufferExt' FramebufferAttachment.DepthAttachmentExt' RenderbufferTarget.RenderbufferExt' textureCubeDepth); " is 163.
Long Statement,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,initTextureCube,The length of the statement  "                        Console.WriteLine("FBO: One or more attachment points are not framebuffer attachment complete. This could mean there’s no texture attached or the format isn’t renderable. For color textures this means the base format must be RGB or RGBA and for depth textures it must be a DEPTH_COMPONENT format. Other causes of this error are that the width or height is zero or the z-offset is out of range in case of render to volume."); " is 424.
Long Statement,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,initTextureCube,The length of the statement  "                        Console.WriteLine("FBO: The color attachments have different format. All color attachments must have the same format."); " is 120.
Long Statement,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,initTextureCube,The length of the statement  "            Console.WriteLine("max. ColorBuffers: " + queryinfo[0] + " max. AuxBuffers: " + queryinfo[1] + " max. DrawBuffers: " + queryinfo[2] + " is 133.
Long Statement,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,initVBOCube,The length of the statement  "            GL.BufferData(BufferTarget.ArrayBuffer' new IntPtr(cubeData.Length * vboCubeStride)' cubeData' BufferUsageHint.StaticDraw); " is 123.
Long Statement,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,initVBOSpere,The length of the statement  "            GL.BufferData(BufferTarget.ArrayBuffer' new IntPtr(BlittableValueType.StrideOf(sphereVertices) * sphereVertices.Length)' sphereVertices' BufferUsageHint.StaticDraw); " is 165.
Long Statement,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,initVBOSpere,The length of the statement  "            GL.BufferData(BufferTarget.ElementArrayBuffer' new IntPtr(BlittableValueType.StrideOf(sphereElements) * sphereElements.Length)' sphereElements' BufferUsageHint.StaticDraw); " is 172.
Long Statement,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,renderSphereVBO,The length of the statement  "            GL.TexCoordPointer(2' TexCoordPointerType.Float' vboSphereStride' new IntPtr(Vector3.SizeInBytes + Vector3.SizeInBytes)); " is 121.
Long Statement,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,renderCubemap,The length of the statement  "                    GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt' FramebufferAttachment.ColorAttachment0' TextureTarget.TextureCubeMapPositiveX + i' textureCubeColor' 0); " is 166.
Long Statement,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,renderCubemap,The length of the statement  "                GL.Ext.FramebufferTexture(FramebufferTarget.FramebufferExt' FramebufferAttachment.ColorAttachment0' textureCubeColor' 0); " is 121.
Long Statement,Examples.Tutorial,JuliaSetFractal,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\JuliaSetFractal.cs,OnLoad,The length of the statement  "                BitmapData data = bitmap.LockBits(new System.Drawing.Rectangle(0' 0' bitmap.Width' bitmap.Height)' ImageLockMode.ReadOnly' " is 122.
Long Statement,Examples.Tutorial,JuliaSetFractal,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\JuliaSetFractal.cs,OnLoad,The length of the statement  "                GL.TexImage1D(TextureTarget.Texture1D' 0' PixelInternalFormat.Rgb8' data.Width' 0' OpenTK.Graphics.OpenGL.PixelFormat.Bgr' " is 122.
Long Statement,Examples.Tutorial,SimpleES11Window,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGLES\1.1\SimpleWindow.cs,OnResize,The length of the statement  "            OpenTK.Matrix4 perspective = OpenTK.Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4' (float)aspect_ratio' 1' 64); " is 121.
Long Statement,Examples.TextureLoaders,ImageGDI,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderGDI.cs,LoadFromDisk,The length of the statement  "                BitmapData Data = CurrentBitmap.LockBits( new System.Drawing.Rectangle( 0' 0' CurrentBitmap.Width' CurrentBitmap.Height )' ImageLockMode.ReadOnly' CurrentBitmap.PixelFormat ); " is 175.
Long Statement,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool ..... " is 121.
Long Statement,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                    throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." ); " is 142.
Long Statement,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                        int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5 " is 160.
Long Statement,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                                            GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) ); " is 130.
Long Statement,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                                            GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) ); " is 130.
Long Statement,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                                            throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." ); " is 140.
Long Statement,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                                GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width ); " is 126.
Long Statement,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                                GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height ); " is 128.
Long Statement,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                                GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat ); " is 144.
Long Statement,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                                GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed ); " is 136.
Long Statement,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                                Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height ); " is 207.
Long Statement,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                                throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) ); " is 130.
Long Statement,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                        Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) ); " is 177.
Long Statement,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The length of the statement  "                throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) ); " is 154.
Long Statement,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,GetUInt32,The length of the statement  "            return (uint) ( ( ( input[offset + 3] * 256 + input[offset + 2] ) * 256 + input[offset + 1] ) * 256 + input[offset + 0] ); " is 122.
Long Statement,Examples.Shapes,KochTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\KochTetrahedron.cs,SubdivideKoch,The length of the statement  "                input[i].SubdivideKoch(height' out output[counter + 0]' out output[counter + 1]' out output[counter + 2]' out output[counter + 3]' out output[counter + 4]' out output[counter + 5] ); " is 182.
Long Statement,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,SubdivideTetrahedron,The length of the statement  "                source[i].SubdivideSierpinski( out output[counter + 0]' out output[counter + 1]' out output[counter + 2]' out output[counter + 3] ); " is 132.
Long Statement,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The length of the statement  "                cubes[0] = new MengerCube( new Vector3d( Center.X - six' Center.Y + six' Center.Z + six )' NewLength' new eSides[] { eSides.Front' eSides.Left' eSides.Top }' this.VisibilityToInherit ); " is 185.
Long Statement,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The length of the statement  "                cubes[1] = new MengerCube( new Vector3d( Center.X + 0.0' Center.Y + six' Center.Z + six )' NewLength' new eSides[] { eSides.Front' eSides.Bottom' eSides.Back' eSides.Top }' this.VisibilityToInherit ); " is 200.
Long Statement,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The length of the statement  "                cubes[2] = new MengerCube( new Vector3d( Center.X + six' Center.Y + six' Center.Z + six )' NewLength' new eSides[] { eSides.Front' eSides.Right' eSides.Top }' this.VisibilityToInherit ); " is 186.
Long Statement,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The length of the statement  "                cubes[3] = new MengerCube( new Vector3d( Center.X - six' Center.Y + 0.0' Center.Z + six )' NewLength' new eSides[] { eSides.Front' eSides.Right' eSides.Back' eSides.Left }' this.VisibilityToInherit ); " is 200.
Long Statement,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The length of the statement  "                cubes[4] = new MengerCube( new Vector3d( Center.X + six' Center.Y + 0.0' Center.Z + six )' NewLength' new eSides[] { eSides.Front' eSides.Right' eSides.Back' eSides.Left }' this.VisibilityToInherit ); " is 200.
Long Statement,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The length of the statement  "                cubes[5] = new MengerCube( new Vector3d( Center.X - six' Center.Y - six' Center.Z + six )' NewLength' new eSides[] { eSides.Front' eSides.Left' eSides.Bottom } ' this.VisibilityToInherit ); " is 189.
Long Statement,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The length of the statement  "                cubes[6] = new MengerCube( new Vector3d( Center.X + 0.0' Center.Y - six' Center.Z + six )' NewLength' new eSides[] { eSides.Front' eSides.Top' eSides.Back' eSides.Bottom }' this.VisibilityToInherit ); " is 200.
Long Statement,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The length of the statement  "                cubes[7] = new MengerCube( new Vector3d( Center.X + six' Center.Y - six' Center.Z + six )' NewLength' new eSides[] { eSides.Front' eSides.Right' eSides.Bottom }' this.VisibilityToInherit ); " is 189.
Long Statement,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The length of the statement  "                cubes[8] = new MengerCube( new Vector3d( Center.X - six' Center.Y + six' Center.Z + 0.0 )' NewLength' new eSides[] { eSides.Top' eSides.Right' eSides.Bottom' eSides.Left }' this.VisibilityToInherit ); " is 200.
Long Statement,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The length of the statement  "                cubes[9] = new MengerCube( new Vector3d( Center.X + six' Center.Y + six' Center.Z + 0.0 )' NewLength' new eSides[] { eSides.Top' eSides.Right' eSides.Bottom' eSides.Left }' this.VisibilityToInherit ); " is 200.
Long Statement,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The length of the statement  "                cubes[10] = new MengerCube( new Vector3d( Center.X - six' Center.Y - six' Center.Z + 0.0 )' NewLength' new eSides[] { eSides.Top' eSides.Right' eSides.Bottom' eSides.Left }' this.VisibilityToInherit ); " is 201.
Long Statement,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The length of the statement  "                cubes[11] = new MengerCube( new Vector3d( Center.X + six' Center.Y - six' Center.Z + 0.0 )' NewLength' new eSides[] { eSides.Top' eSides.Right' eSides.Bottom' eSides.Left }' this.VisibilityToInherit ); " is 201.
Long Statement,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The length of the statement  "                cubes[12] = new MengerCube( new Vector3d( Center.X - six' Center.Y + six' Center.Z - six )' NewLength' new eSides[] { eSides.Top' eSides.Back' eSides.Left }' this.VisibilityToInherit ); " is 185.
Long Statement,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The length of the statement  "                cubes[13] = new MengerCube( new Vector3d( Center.X + 0.0' Center.Y + six' Center.Z - six )' NewLength' new eSides[] { eSides.Top' eSides.Back' eSides.Bottom' eSides.Front }' this.VisibilityToInherit ); " is 201.
Long Statement,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The length of the statement  "                cubes[14] = new MengerCube( new Vector3d( Center.X + six' Center.Y + six' Center.Z - six )' NewLength' new eSides[] { eSides.Top' eSides.Back' eSides.Right }' this.VisibilityToInherit ); " is 186.
Long Statement,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The length of the statement  "                cubes[15] = new MengerCube( new Vector3d( Center.X - six' Center.Y + 0.0' Center.Z - six )' NewLength' new eSides[] { eSides.Front' eSides.Right' eSides.Back' eSides.Left } ' this.VisibilityToInherit ); " is 202.
Long Statement,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The length of the statement  "                cubes[16] = new MengerCube( new Vector3d( Center.X + six' Center.Y + 0.0' Center.Z - six )' NewLength' new eSides[] { eSides.Front' eSides.Right' eSides.Back' eSides.Left } ' this.VisibilityToInherit ); " is 202.
Long Statement,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The length of the statement  "                cubes[17] = new MengerCube( new Vector3d( Center.X - six' Center.Y - six' Center.Z - six )' NewLength' new eSides[] { eSides.Back' eSides.Bottom' eSides.Left } ' this.VisibilityToInherit ); " is 189.
Long Statement,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The length of the statement  "                cubes[18] = new MengerCube( new Vector3d( Center.X + 0.0' Center.Y - six' Center.Z - six )' NewLength' new eSides[] { eSides.Top' eSides.Back' eSides.Bottom' eSides.Front }' this.VisibilityToInherit ); " is 201.
Long Statement,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The length of the statement  "                cubes[19] = new MengerCube( new Vector3d( Center.X + six' Center.Y - six' Center.Z - six )' NewLength' new eSides[] { eSides.Back' eSides.Bottom' eSides.Right }' this.VisibilityToInherit ); " is 189.
Long Statement,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The length of the statement  "                Vector3d.Lerp( ref Layer2.Vertices[1].Position' ref Layer2.Vertices[6].Position' _Three' out Layer2.Vertices[2].Position ); " is 123.
Long Statement,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The length of the statement  "                Vector3d.Lerp( ref Layer2.Vertices[1].Position' ref Layer2.Vertices[6].Position' _Six' out Layer2.Vertices[5].Position ); " is 121.
Long Statement,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The length of the statement  "                Vector3d.Lerp( ref Layer2.Vertices[7].Position' ref Layer2.Vertices[0].Position' _Three' out Layer2.Vertices[8].Position ); " is 123.
Long Statement,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The length of the statement  "                Vector3d.Lerp( ref Layer2.Vertices[7].Position' ref Layer2.Vertices[0].Position' _Six' out Layer2.Vertices[11].Position ); " is 122.
Long Statement,Examples.WinForms,FontRenderingBasic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Fonts\FontRenderingBasic.cs,InitializeComponent,The length of the statement  "            this.glControl1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) " is 146.
Long Statement,Examples.WinForms,FontRenderingBasic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Fonts\FontRenderingBasic.cs,InitializeComponent,The length of the statement  "            this.changeFont.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 146.
Long Statement,Examples.WinForms,FontRenderingBasic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Fonts\FontRenderingBasic.cs,InitializeComponent,The length of the statement  "            this.textBox1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) " is 141.
Long Statement,Examples.WinForms,SimpleForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\GLControlSimple.cs,InitializeComponent,The length of the statement  "            this.redButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 145.
Long Statement,Examples.WinForms,SimpleForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\GLControlSimple.cs,InitializeComponent,The length of the statement  "            this.greenButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 147.
Long Statement,Examples.WinForms,SimpleForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\GLControlSimple.cs,InitializeComponent,The length of the statement  "            this.blueButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 146.
Long Statement,Examples.WinForms,MultipleGLControlsForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\MultipleGLControls.cs,InitializeComponent,The length of the statement  "            this.derivedGLControl2.ClearColor = System.Drawing.Color.FromArgb(((int)(((byte)(255))))' ((int)(((byte)(255))))' ((int)(((byte)(192))))); " is 138.
Long Statement,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,StartAsync,The length of the statement  "            using (IGraphicsContext context = new GraphicsContext(GraphicsMode.Default' window.WindowInfo' 3' 0' GraphicsContextFlags.Default)) " is 131.
Long Statement,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The length of the statement  "            this.backgroundWorker1.RunWorkerCompleted += new System.ComponentModel.RunWorkerCompletedEventHandler(this.backgroundWorker1_RunWorkerCompleted); " is 145.
Long Statement,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The length of the statement  "            this.dataGridView1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) " is 149.
Long Statement,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The length of the statement  "            this.TextBoxVendor.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) " is 146.
Long Statement,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The length of the statement  "            this.TextBoxRenderer.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) " is 148.
Long Statement,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The length of the statement  "            this.TextBoxVersion.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) " is 147.
Long Statement,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The length of the statement  "            this.TextBoxSupport.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) " is 147.
Long Statement,Examples.Tests,MathSpeed,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\MathSpeed.cs,Main,The length of the statement  "            Trace.WriteLine(String.format("Vector3.Add(ref a' ref b' out res)\t{0}ns"' (watch.Elapsed.TotalSeconds / 10.0).ToString())); " is 124.
Long Statement,Examples.Tests,GameWindowStates,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\GameWindowStates.cs,OnUpdateFrame,The length of the statement  "                    DrawString(gfx' String.Format("Mouse position (relative): {0}"' new Vector3(mouse.X' mouse.Y' mouse.WheelPrecise))' line++); " is 124.
Long Statement,Examples.Tests,TestGraphicsModes,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\TestGraphicsModes.cs,Main,The length of the statement  "                Trace.WriteLine(String.Format("{0}' {1:00}' {2:00}' {3:00}' {4}"' mode.ColorFormat' mode.Depth' mode.Stencil' mode.Samples' mode.Stereo)); " is 138.
Long Statement,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The length of the statement  "            this.MouseButtonsBox.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) " is 151.
Long Statement,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The length of the statement  "            this.ChooseMouse.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) " is 144.
Long Statement,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The length of the statement  "            this.comboBoxActiveJoystick.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) " is 155.
Long Statement,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The length of the statement  "            this.JoystickButtonsBox.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) " is 154.
Complex Conditional,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The conditional expression  "idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )"  is complex.
Complex Conditional,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The conditional expression  "TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes"  is complex.
Complex Conditional,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The conditional expression  "GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0"  is complex.
Virtual Method Call from Constructor,Examples.Tutorial,StencilCSG,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\StencilCSG.cs,StencilCSG,The constructor "StencilCSG" calls a virtual method "Exit".
Virtual Method Call from Constructor,Examples.Tutorial,ThreadedRendering,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GameWindow\GameWindowThreaded.cs,ThreadedRendering,The constructor "ThreadedRendering" calls a virtual method "Exit".
Empty Catch Block,Examples.Tests,TestGraphicsModes,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\TestGraphicsModes.cs,Main,The method has an empty catch block.
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,ExampleBrowser,The following statement contains a magic number: if (System.Environment.OSVersion.Platform == PlatformID.Win32NT &&                  System.Environment.OSVersion.Version.Major >= 6)              {                  textBoxOutput.Font = richTextBoxSource.Font = new Font("Consolas"' 10.0f' FontStyle.Regular);              }              else              {                  textBoxOutput.Font = richTextBoxSource.Font =                      new Font(FontFamily.GenericMonospace' 10.0f' FontStyle.Regular);              }
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,FindSourcePath,The following statement contains a magic number: for (int i = 0; i < 3; i++)              {                  DirectoryInfo dir = Directory.GetParent(guess);                  if (dir == null || !dir.Exists)                      break;                  guess = dir.FullName;              }
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer1.Size = new System.Drawing.Size(784' 564);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer1.Size = new System.Drawing.Size(784' 564);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.splitContainer1.SplitterDistance = 261;
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.treeViewSamples.Indent = 32;
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.treeViewSamples.Size = new System.Drawing.Size(261' 564);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.treeViewSamples.Size = new System.Drawing.Size(261' 564);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.contextMenuStripSamples.Size = new System.Drawing.Size(170' 76);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.contextMenuStripSamples.Size = new System.Drawing.Size(170' 76);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.runSampleToolStripMenuItem.Size = new System.Drawing.Size(169' 22);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.runSampleToolStripMenuItem.Size = new System.Drawing.Size(169' 22);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.toolStripMenuItem1.Size = new System.Drawing.Size(166' 6);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.toolStripMenuItem1.Size = new System.Drawing.Size(166' 6);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.viewDescriptionToolStripMenuItem.Size = new System.Drawing.Size(169' 22);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.viewDescriptionToolStripMenuItem.Size = new System.Drawing.Size(169' 22);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.viewSourceToolStripMenuItem.Size = new System.Drawing.Size(169' 22);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.viewSourceToolStripMenuItem.Size = new System.Drawing.Size(169' 22);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.imageListSampleCategories.ImageSize = new System.Drawing.Size(35' 35);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.imageListSampleCategories.ImageSize = new System.Drawing.Size(35' 35);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.tabControlSample.Size = new System.Drawing.Size(519' 564);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.tabControlSample.Size = new System.Drawing.Size(519' 564);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.tabDescription.Location = new System.Drawing.Point(4' 22);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.tabDescription.Location = new System.Drawing.Point(4' 22);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.tabDescription.Padding = new System.Windows.Forms.Padding(3);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.tabDescription.Size = new System.Drawing.Size(511' 538);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.tabDescription.Size = new System.Drawing.Size(511' 538);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.richTextBoxDescription.Location = new System.Drawing.Point(3' 3);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.richTextBoxDescription.Location = new System.Drawing.Point(3' 3);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.richTextBoxDescription.Size = new System.Drawing.Size(505' 532);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.richTextBoxDescription.Size = new System.Drawing.Size(505' 532);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.contextMenuStripDescription.Size = new System.Drawing.Size(103' 26);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.contextMenuStripDescription.Size = new System.Drawing.Size(103' 26);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.copyToolStripMenuItem.Size = new System.Drawing.Size(102' 22);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.copyToolStripMenuItem.Size = new System.Drawing.Size(102' 22);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.tabSource.Location = new System.Drawing.Point(4' 22);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.tabSource.Location = new System.Drawing.Point(4' 22);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.tabSource.Padding = new System.Windows.Forms.Padding(3);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.tabSource.Size = new System.Drawing.Size(511' 538);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.tabSource.Size = new System.Drawing.Size(511' 538);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.richTextBoxSource.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(216))))' ((int)(((byte)(242))))' ((int)(((byte)(240)))));
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.richTextBoxSource.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(216))))' ((int)(((byte)(242))))' ((int)(((byte)(240)))));
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.richTextBoxSource.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(216))))' ((int)(((byte)(242))))' ((int)(((byte)(240)))));
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.richTextBoxSource.Location = new System.Drawing.Point(3' 3);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.richTextBoxSource.Location = new System.Drawing.Point(3' 3);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.richTextBoxSource.Size = new System.Drawing.Size(505' 532);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.richTextBoxSource.Size = new System.Drawing.Size(505' 532);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.contextMenuStripSource.Size = new System.Drawing.Size(103' 26);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.contextMenuStripSource.Size = new System.Drawing.Size(103' 26);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.copyToolStripMenuItem1.Size = new System.Drawing.Size(102' 22);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.copyToolStripMenuItem1.Size = new System.Drawing.Size(102' 22);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.tabPageOutput.Location = new System.Drawing.Point(4' 22);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.tabPageOutput.Location = new System.Drawing.Point(4' 22);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.tabPageOutput.Padding = new System.Windows.Forms.Padding(3);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.tabPageOutput.Size = new System.Drawing.Size(511' 538);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.tabPageOutput.Size = new System.Drawing.Size(511' 538);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.tabPageOutput.TabIndex = 2;
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.textBoxOutput.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(216))))' ((int)(((byte)(242))))' ((int)(((byte)(240)))));
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.textBoxOutput.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(216))))' ((int)(((byte)(242))))' ((int)(((byte)(240)))));
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.textBoxOutput.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(216))))' ((int)(((byte)(242))))' ((int)(((byte)(240)))));
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.textBoxOutput.Location = new System.Drawing.Point(3' 3);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.textBoxOutput.Location = new System.Drawing.Point(3' 3);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.textBoxOutput.MaxLength = 1048576;
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.textBoxOutput.Size = new System.Drawing.Size(505' 532);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.textBoxOutput.Size = new System.Drawing.Size(505' 532);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.contextMenuStripOutput.Size = new System.Drawing.Size(103' 26);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.contextMenuStripOutput.Size = new System.Drawing.Size(103' 26);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.copyToolStripMenuItem2.Size = new System.Drawing.Size(102' 22);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.copyToolStripMenuItem2.Size = new System.Drawing.Size(102' 22);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(784' 564);
Magic Number,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(784' 564);
Magic Number,Examples,Utilities,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities.cs,ColorToRgba32,The following statement contains a magic number: return (int)((c.A << 24) | (c.B << 16) | (c.G << 8) | c.R);
Magic Number,Examples,Utilities,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities.cs,ColorToRgba32,The following statement contains a magic number: return (int)((c.A << 24) | (c.B << 16) | (c.G << 8) | c.R);
Magic Number,Examples,Utilities,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities.cs,ColorToRgba32,The following statement contains a magic number: return (int)((c.A << 24) | (c.B << 16) | (c.G << 8) | c.R);
Magic Number,Examples,VectorAdd,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenCL\VectorAdd.cs,Main,The following statement contains a magic number: const int cnBlockSize = 4;
Magic Number,Examples,VectorAdd,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenCL\VectorAdd.cs,Main,The following statement contains a magic number: const int cnBlocks    = 3;
Magic Number,Examples,VectorAdd,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenCL\VectorAdd.cs,Main,The following statement contains a magic number: for (int i = 0; i < A.Length; i++)              {                  A[i] = rand.Next() % 256;                  B[i] = rand.Next() % 256;              }
Magic Number,Examples,VectorAdd,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenCL\VectorAdd.cs,Main,The following statement contains a magic number: for (int i = 0; i < A.Length; i++)              {                  A[i] = rand.Next() % 256;                  B[i] = rand.Next() % 256;              }
Magic Number,Examples,VectorAdd,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenCL\VectorAdd.cs,Main,The following statement contains a magic number: unsafe              {                  fixed (float* pA = A)                  fixed (float* pB = B)                  fixed (float* pC = C)                  {                      cl_mem hDeviceMemA' hDeviceMemB' hDeviceMemC;                      hDeviceMemA = CL.CreateBuffer(hContext'                          MemFlags.MemReadOnly | MemFlags.MemCopyHostPtr'                          new IntPtr(cnDimension.ToInt32() * sizeof(float))'                          new IntPtr(pA)'                          out error);                      hDeviceMemB = CL.CreateBuffer(hContext'                         MemFlags.MemReadOnly | MemFlags.MemCopyHostPtr'                         new IntPtr(cnDimension.ToInt32() * sizeof(float))'                         new IntPtr(pA)'                         out error);                      hDeviceMemC = CL.CreateBuffer(hContext'                          MemFlags.MemWriteOnly'                          new IntPtr(cnDimension.ToInt32() * sizeof(float))'                          IntPtr.Zero'                          out error);                        // setup parameter values                      CL.SetKernelArg(hKernel' 0' new IntPtr(sizeof(cl_mem))' new IntPtr(&hDeviceMemA));                      CL.SetKernelArg(hKernel' 1' new IntPtr(sizeof(cl_mem))' new IntPtr(&hDeviceMemB));                      CL.SetKernelArg(hKernel' 2' new IntPtr(sizeof(cl_mem))' new IntPtr(&hDeviceMemC));                        // write data from host to device                      CL.EnqueueWriteBuffer(hCmdQueue' hDeviceMemA' true' IntPtr.Zero'                          new IntPtr(cnDimension.ToInt32() * sizeof(float))'                          new IntPtr(pA)' 0' null' (IntPtr[])null);                      CL.EnqueueWriteBuffer(hCmdQueue' hDeviceMemB' true' IntPtr.Zero'                          new IntPtr(cnDimension.ToInt32() * sizeof(float))'                          new IntPtr(pB)' 0' null' (IntPtr[])null);                        // execute kernel                      error = (ErrorCode)CL.EnqueueNDRangeKernel(hCmdQueue' hKernel' 1' null' &cnDimension' null' 0' null' null);                      if (error != ErrorCode.Success)                          throw new Exception(error.ToString());                        // copy results from device back to host                      IntPtr event_handle = IntPtr.Zero;                      error = (ErrorCode)CL.EnqueueReadBuffer(hCmdQueue' hDeviceMemC' true' IntPtr.Zero'                           new IntPtr(cnDimension.ToInt32() * sizeof(float))'                           new IntPtr(pC)' 0' null' (IntPtr[])null);                      if (error != ErrorCode.Success)                          throw new Exception(error.ToString());                        CL.Finish(hCmdQueue);                        CL.ReleaseMemObject(hDeviceMemA);                      CL.ReleaseMemObject(hDeviceMemB);                      CL.ReleaseMemObject(hDeviceMemC);                  }              }
Magic Number,Examples,ReverbExample,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\EFX\EFXReverb.cs,Main,The following statement contains a magic number: using (AudioContext context = new AudioContext())              {                  Trace.WriteLine("Testing WaveReader({0}).ReadToEnd()"' filename);                    EffectsExtension efx = new EffectsExtension();                    int buffer = AL.GenBuffer();                  int source = AL.GenSource();                  int state;                    int effect = efx.GenEffect();                  int slot = efx.GenAuxiliaryEffectSlot();                    efx.BindEffect(effect' EfxEffectType.Reverb);                  efx.Effect(effect' EfxEffectf.ReverbDecayTime' 3.0f);                  efx.Effect(effect' EfxEffectf.ReverbDecayHFRatio' 0.91f);                  efx.Effect(effect' EfxEffectf.ReverbDensity' 0.7f);                  efx.Effect(effect' EfxEffectf.ReverbDiffusion' 0.9f);                  efx.Effect(effect' EfxEffectf.ReverbRoomRolloffFactor' 3.1f);                  efx.Effect(effect' EfxEffectf.ReverbReflectionsGain' 0.723f);                  efx.Effect(effect' EfxEffectf.ReverbReflectionsDelay' 0.03f);                  efx.Effect(effect' EfxEffectf.ReverbGain' 0.23f);                    efx.AuxiliaryEffectSlot(slot' EfxAuxiliaryi.EffectslotEffect' effect);                    int channels' bits' rate;                  byte[] data = Playback.LoadWave(File.Open(filename' FileMode.Open)' out channels' out bits' out rate);                  AL.BufferData(buffer' Playback.GetSoundFormat(channels' bits)' data' data.Length' rate);                    AL.Source(source' ALSourcef.ConeOuterGain' 1.0f);                  AL.Source(source' ALSourcei.Buffer' buffer);                  AL.SourcePlay(source);                    Trace.Write("Playing");                    // Query the source to find out when it stops playing.                  do                  {                      Thread.Sleep(250);                      Trace.Write(".");                      AL.GetSource(source' ALGetSourcei.SourceState' out state);                  }                  while ((ALSourceState)state == ALSourceState.Playing);                    Trace.WriteLine("");                    AL.SourceStop(source);                  AL.DeleteSource(source);                  AL.DeleteBuffer(buffer);                  efx.DeleteEffect(effect);                  efx.DeleteAuxiliaryEffectSlot(slot);              }
Magic Number,Examples,OpenALDiagnostics,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\Test\OpenALDiagnostics.cs,Main,The following statement contains a magic number: Trace.WriteLine("This application is currently running as " + (IntPtr.Size == 4 ? "x86" : "x64"));
Magic Number,Examples,RecorderDiagnostic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\Test\OpenALDiagnostics.cs,RecorderDiagnostic,The following statement contains a magic number: try              {                  r = new AudioCapture(AudioCapture.DefaultDevice' 16000' ALFormat.Mono16' 4096);              }              catch (AudioDeviceException ade)              {                  Trace.WriteLine("AudioCapture Exception caught: " + ade.Message);                  return;              }
Magic Number,Examples,RecorderDiagnostic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\Test\OpenALDiagnostics.cs,RecorderDiagnostic,The following statement contains a magic number: try              {                  r = new AudioCapture(AudioCapture.DefaultDevice' 16000' ALFormat.Mono16' 4096);              }              catch (AudioDeviceException ade)              {                  Trace.WriteLine("AudioCapture Exception caught: " + ade.Message);                  return;              }
Magic Number,Examples,RecorderDiagnostic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\Test\OpenALDiagnostics.cs,RecorderDiagnostic,The following statement contains a magic number: Thread.Sleep(100);
Magic Number,Examples,RecorderDiagnostic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\Test\OpenALDiagnostics.cs,RecorderDiagnostic,The following statement contains a magic number: byte[] Buffer = new byte[8192];
Magic Number,Examples,RecorderDiagnostic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\Test\OpenALDiagnostics.cs,RecorderDiagnostic,The following statement contains a magic number: Thread.Sleep(10);
Magic Number,Examples,RecorderDiagnostic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\Test\OpenALDiagnostics.cs,RecorderDiagnostic,The following statement contains a magic number: r.ReadSamples(Buffer' (SamplesBefore > 4096 ? 4096 : SamplesBefore));
Magic Number,Examples,RecorderDiagnostic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\Test\OpenALDiagnostics.cs,RecorderDiagnostic,The following statement contains a magic number: r.ReadSamples(Buffer' (SamplesBefore > 4096 ? 4096 : SamplesBefore));
Magic Number,Examples,RecorderDiagnostic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\Test\OpenALDiagnostics.cs,RecorderDiagnostic,The following statement contains a magic number: for (int i = 0; i < SamplesCaptured * 2; i++)              {                  if (Buffer[i] == 0)                      ZeroCounter++;              }
Magic Number,Examples,RecorderDiagnostic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\Test\OpenALDiagnostics.cs,RecorderDiagnostic,The following statement contains a magic number: for (int i = 0; i < SamplesCaptured; i++)              {                  short sample = BitConverter.ToInt16(Buffer' i * 2);                  if (sample > MaxSample)                      MaxSample = sample;                  if (sample < MinSample)                      MinSample = sample;              }
Magic Number,Examples,RecorderDiagnostic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\Test\OpenALDiagnostics.cs,RecorderDiagnostic,The following statement contains a magic number: if (ZeroCounter < SamplesCaptured * 2 && SamplesCaptured > 0)                  BufferContentsAllZero = false;              else                  BufferContentsAllZero = true;
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,Parrot,The following statement contains a magic number: this.Text = "OpenAL Parrot (" + (IntPtr.Size == 4 ? "x86" : "x64") + ")";
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,StartRecording,The following statement contains a magic number: int buffer_length_samples = (int)((double)numericUpDown_BufferLength.Value * sampling_rate * 0.001 / BlittableValueType.StrideOf(buffer));
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,StartRecording,The following statement contains a magic number: timer_GetSamples.Interval = (int)(buffer_length_ms / 2 + 0.5);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,StartRecording,The following statement contains a magic number: timer_GetSamples.Interval = (int)(buffer_length_ms / 2 + 0.5);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,UpdateSamples,The following statement contains a magic number: if (available_samples * SampleToByte > buffer.Length * BlittableValueType.StrideOf(buffer))              {                  buffer = new short[MathHelper.NextPowerOfTwo(                      (int)(available_samples * SampleToByte / (double)BlittableValueType.StrideOf(buffer) + 0.5))];              }
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.comboBox_RecorderSelection.Location = new System.Drawing.Point(6' 19);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.comboBox_RecorderSelection.Location = new System.Drawing.Point(6' 19);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.comboBox_RecorderSelection.Size = new System.Drawing.Size(216' 21);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.comboBox_RecorderSelection.Size = new System.Drawing.Size(216' 21);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.groupBox_RecorderParameters.Location = new System.Drawing.Point(12' 12);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.groupBox_RecorderParameters.Location = new System.Drawing.Point(12' 12);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.groupBox_RecorderParameters.Size = new System.Drawing.Size(228' 168);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.groupBox_RecorderParameters.Size = new System.Drawing.Size(228' 168);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.groupBox_RecorderParameters.TabIndex = 2;
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(6' 132);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(6' 132);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(74' 13);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(74' 13);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 105;
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(6' 102);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(6' 102);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(96' 13);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(96' 13);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.label1.TabIndex = 104;
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.numericUpDown_PlaybackGain.Location = new System.Drawing.Point(145' 100);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.numericUpDown_PlaybackGain.Location = new System.Drawing.Point(145' 100);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.numericUpDown_PlaybackGain.Maximum = new decimal(new int[] {              64'              0'              0'              0});
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.numericUpDown_PlaybackGain.Minimum = new decimal(new int[] {              1'              0'              0'              65536});
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.numericUpDown_PlaybackGain.Size = new System.Drawing.Size(76' 20);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.numericUpDown_PlaybackGain.Size = new System.Drawing.Size(76' 20);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.numericUpDown_PlaybackGain.TabIndex = 103;
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.numericUpDown_PlaybackGain.Value = new decimal(new int[] {              4'              0'              0'              0});
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.label_MONO16BIT.Location = new System.Drawing.Point(142' 132);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.label_MONO16BIT.Location = new System.Drawing.Point(142' 132);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.label_MONO16BIT.Size = new System.Drawing.Size(64' 13);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.label_MONO16BIT.Size = new System.Drawing.Size(64' 13);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.label_MONO16BIT.TabIndex = 102;
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.label_RINGBUFFER.Location = new System.Drawing.Point(6' 76);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.label_RINGBUFFER.Location = new System.Drawing.Point(6' 76);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.label_RINGBUFFER.Size = new System.Drawing.Size(89' 13);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.label_RINGBUFFER.Size = new System.Drawing.Size(89' 13);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.label_RINGBUFFER.TabIndex = 101;
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.label_FREQUENCY.Location = new System.Drawing.Point(6' 50);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.label_FREQUENCY.Location = new System.Drawing.Point(6' 50);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.label_FREQUENCY.Size = new System.Drawing.Size(85' 13);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.label_FREQUENCY.Size = new System.Drawing.Size(85' 13);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.label_FREQUENCY.TabIndex = 100;
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.numericUpDown_BufferLength.Location = new System.Drawing.Point(145' 74);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.numericUpDown_BufferLength.Location = new System.Drawing.Point(145' 74);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.numericUpDown_BufferLength.Maximum = new decimal(new int[] {              1000'              0'              0'              0});
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.numericUpDown_BufferLength.Size = new System.Drawing.Size(76' 20);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.numericUpDown_BufferLength.Size = new System.Drawing.Size(76' 20);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.numericUpDown_BufferLength.TabIndex = 2;
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.numericUpDown_BufferLength.Value = new decimal(new int[] {              50'              0'              0'              0});
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.numericUpDown_Frequency.Location = new System.Drawing.Point(145' 48);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.numericUpDown_Frequency.Location = new System.Drawing.Point(145' 48);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.numericUpDown_Frequency.Maximum = new decimal(new int[] {              100000'              0'              0'              0});
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.numericUpDown_Frequency.Size = new System.Drawing.Size(76' 20);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.numericUpDown_Frequency.Size = new System.Drawing.Size(76' 20);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.numericUpDown_Frequency.Value = new decimal(new int[] {              16000'              0'              0'              0});
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.groupBox_RecordingControls.Location = new System.Drawing.Point(12' 186);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.groupBox_RecordingControls.Location = new System.Drawing.Point(12' 186);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.groupBox_RecordingControls.Size = new System.Drawing.Size(228' 78);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.groupBox_RecordingControls.Size = new System.Drawing.Size(228' 78);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.groupBox_RecordingControls.TabIndex = 3;
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.label_SamplesConsumed.Location = new System.Drawing.Point(6' 52);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.label_SamplesConsumed.Location = new System.Drawing.Point(6' 52);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.label_SamplesConsumed.Size = new System.Drawing.Size(108' 13);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.label_SamplesConsumed.Size = new System.Drawing.Size(108' 13);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.label_SamplesConsumed.TabIndex = 103;
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.button_Start.Location = new System.Drawing.Point(35' 19);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.button_Start.Location = new System.Drawing.Point(35' 19);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.button_Start.Size = new System.Drawing.Size(159' 24);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.button_Start.Size = new System.Drawing.Size(159' 24);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.button_Start.TabIndex = 3;
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(252' 276);
Magic Number,Examples,Parrot,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Parrot.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(252' 276);
Magic Number,Examples,Playback,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Playback.cs,LoadWave,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader(stream))              {                  // RIFF header                  string signature = new string(reader.ReadChars(4));                  if (signature != "RIFF")                      throw new NotSupportedException("Specified stream is not a wave file.");                    int riff_chunck_size = reader.ReadInt32();                    string format = new string(reader.ReadChars(4));                  if (format != "WAVE")                      throw new NotSupportedException("Specified stream is not a wave file.");                    // WAVE header                  string format_signature = new string(reader.ReadChars(4));                  if (format_signature != "fmt ")                      throw new NotSupportedException("Specified wave file is not supported.");                    int format_chunk_size = reader.ReadInt32();                  int audio_format = reader.ReadInt16();                  int num_channels = reader.ReadInt16();                  int sample_rate = reader.ReadInt32();                  int byte_rate = reader.ReadInt32();                  int block_align = reader.ReadInt16();                  int bits_per_sample = reader.ReadInt16();                    string data_signature = new string(reader.ReadChars(4));                  if (data_signature != "data")                      throw new NotSupportedException("Specified wave file is not supported.");                    int data_chunk_size = reader.ReadInt32();                    channels = num_channels;                  bits = bits_per_sample;                  rate = sample_rate;                    return reader.ReadBytes((int)reader.BaseStream.Length);              }
Magic Number,Examples,Playback,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Playback.cs,LoadWave,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader(stream))              {                  // RIFF header                  string signature = new string(reader.ReadChars(4));                  if (signature != "RIFF")                      throw new NotSupportedException("Specified stream is not a wave file.");                    int riff_chunck_size = reader.ReadInt32();                    string format = new string(reader.ReadChars(4));                  if (format != "WAVE")                      throw new NotSupportedException("Specified stream is not a wave file.");                    // WAVE header                  string format_signature = new string(reader.ReadChars(4));                  if (format_signature != "fmt ")                      throw new NotSupportedException("Specified wave file is not supported.");                    int format_chunk_size = reader.ReadInt32();                  int audio_format = reader.ReadInt16();                  int num_channels = reader.ReadInt16();                  int sample_rate = reader.ReadInt32();                  int byte_rate = reader.ReadInt32();                  int block_align = reader.ReadInt16();                  int bits_per_sample = reader.ReadInt16();                    string data_signature = new string(reader.ReadChars(4));                  if (data_signature != "data")                      throw new NotSupportedException("Specified wave file is not supported.");                    int data_chunk_size = reader.ReadInt32();                    channels = num_channels;                  bits = bits_per_sample;                  rate = sample_rate;                    return reader.ReadBytes((int)reader.BaseStream.Length);              }
Magic Number,Examples,Playback,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Playback.cs,LoadWave,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader(stream))              {                  // RIFF header                  string signature = new string(reader.ReadChars(4));                  if (signature != "RIFF")                      throw new NotSupportedException("Specified stream is not a wave file.");                    int riff_chunck_size = reader.ReadInt32();                    string format = new string(reader.ReadChars(4));                  if (format != "WAVE")                      throw new NotSupportedException("Specified stream is not a wave file.");                    // WAVE header                  string format_signature = new string(reader.ReadChars(4));                  if (format_signature != "fmt ")                      throw new NotSupportedException("Specified wave file is not supported.");                    int format_chunk_size = reader.ReadInt32();                  int audio_format = reader.ReadInt16();                  int num_channels = reader.ReadInt16();                  int sample_rate = reader.ReadInt32();                  int byte_rate = reader.ReadInt32();                  int block_align = reader.ReadInt16();                  int bits_per_sample = reader.ReadInt16();                    string data_signature = new string(reader.ReadChars(4));                  if (data_signature != "data")                      throw new NotSupportedException("Specified wave file is not supported.");                    int data_chunk_size = reader.ReadInt32();                    channels = num_channels;                  bits = bits_per_sample;                  rate = sample_rate;                    return reader.ReadBytes((int)reader.BaseStream.Length);              }
Magic Number,Examples,Playback,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Playback.cs,LoadWave,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader(stream))              {                  // RIFF header                  string signature = new string(reader.ReadChars(4));                  if (signature != "RIFF")                      throw new NotSupportedException("Specified stream is not a wave file.");                    int riff_chunck_size = reader.ReadInt32();                    string format = new string(reader.ReadChars(4));                  if (format != "WAVE")                      throw new NotSupportedException("Specified stream is not a wave file.");                    // WAVE header                  string format_signature = new string(reader.ReadChars(4));                  if (format_signature != "fmt ")                      throw new NotSupportedException("Specified wave file is not supported.");                    int format_chunk_size = reader.ReadInt32();                  int audio_format = reader.ReadInt16();                  int num_channels = reader.ReadInt16();                  int sample_rate = reader.ReadInt32();                  int byte_rate = reader.ReadInt32();                  int block_align = reader.ReadInt16();                  int bits_per_sample = reader.ReadInt16();                    string data_signature = new string(reader.ReadChars(4));                  if (data_signature != "data")                      throw new NotSupportedException("Specified wave file is not supported.");                    int data_chunk_size = reader.ReadInt32();                    channels = num_channels;                  bits = bits_per_sample;                  rate = sample_rate;                    return reader.ReadBytes((int)reader.BaseStream.Length);              }
Magic Number,Examples,Playback,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Playback.cs,GetSoundFormat,The following statement contains a magic number: switch (channels)              {                  case 1: return bits == 8 ? ALFormat.Mono8 : ALFormat.Mono16;                  case 2: return bits == 8 ? ALFormat.Stereo8 : ALFormat.Stereo16;                  default: throw new NotSupportedException("The specified sound format is not supported.");              }
Magic Number,Examples,Playback,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Playback.cs,GetSoundFormat,The following statement contains a magic number: switch (channels)              {                  case 1: return bits == 8 ? ALFormat.Mono8 : ALFormat.Mono16;                  case 2: return bits == 8 ? ALFormat.Stereo8 : ALFormat.Stereo16;                  default: throw new NotSupportedException("The specified sound format is not supported.");              }
Magic Number,Examples,Playback,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Playback.cs,GetSoundFormat,The following statement contains a magic number: switch (channels)              {                  case 1: return bits == 8 ? ALFormat.Mono8 : ALFormat.Mono16;                  case 2: return bits == 8 ? ALFormat.Stereo8 : ALFormat.Stereo16;                  default: throw new NotSupportedException("The specified sound format is not supported.");              }
Magic Number,Examples,Playback,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenAL\1.1\Playback.cs,Main,The following statement contains a magic number: using (AudioContext context = new AudioContext())              {                  int buffer = AL.GenBuffer();                  int source = AL.GenSource();                  int state;                    int channels' bits_per_sample' sample_rate;                  byte[] sound_data = LoadWave(File.Open(filename' FileMode.Open)' out channels' out bits_per_sample' out sample_rate);                  AL.BufferData(buffer' GetSoundFormat(channels' bits_per_sample)' sound_data' sound_data.Length' sample_rate);                    AL.Source(source' ALSourcei.Buffer' buffer);                  AL.SourcePlay(source);                    Trace.Write("Playing");                    // Query the source to find out when it stops playing.                  do                  {                      Thread.Sleep(250);                      Trace.Write(".");                      AL.GetSource(source' ALGetSourcei.SourceState' out state);                  }                  while ((ALSourceState)state == ALSourceState.Playing);                    Trace.WriteLine("");                    AL.SourceStop(source);                  AL.DeleteSource(source);                  AL.DeleteBuffer(buffer);              }
Magic Number,Examples,FullscreenAntialias,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GameWindow\GameWindowMsaa.cs,OnResize,The following statement contains a magic number: GL.Ortho(-1.0' 1.0' -1.0' 1.0' 0.0' 4.0);
Magic Number,Examples,FullscreenAntialias,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GameWindow\GameWindowMsaa.cs,Main,The following statement contains a magic number: using (FullscreenAntialias example = new FullscreenAntialias())              {                  // Get the title and category  of this example using reflection.                  Utilities.SetWindowTitle(example);                  example.Run(30.0' 0.0);              }
Magic Number,Examples.Tutorial,Anaglyph,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\Anaglyph.cs,SetupCamera,The following statement contains a magic number: camera.FarPlane = 5.0;
Magic Number,Examples.Tutorial,Anaglyph,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\Anaglyph.cs,SetupCamera,The following statement contains a magic number: camera.FocalLength = 2.0;
Magic Number,Examples.Tutorial,Anaglyph,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\Anaglyph.cs,SetupCamera,The following statement contains a magic number: camera.EyeSeparation = camera.FocalLength / 30.0;
Magic Number,Examples.Tutorial,Anaglyph,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\Anaglyph.cs,SetupCamera,The following statement contains a magic number: camera.Aperture = 75.0;
Magic Number,Examples.Tutorial,Anaglyph,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\Anaglyph.cs,SetupCamera,The following statement contains a magic number: double widthdiv2 = camera.NearPlane * Math.Tan( MathHelper.DegreesToRadians( (float)( camera.Aperture / 2.0 ) ) );
Magic Number,Examples.Tutorial,Anaglyph,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\Anaglyph.cs,SetupCamera,The following statement contains a magic number: double precalc2 = 0.5 * camera.EyeSeparation * camera.NearPlane / camera.FocalLength;
Magic Number,Examples.Tutorial,Anaglyph,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\Anaglyph.cs,SetupCamera,The following statement contains a magic number: Right.X *= (float)( camera.EyeSeparation / 2.0 );
Magic Number,Examples.Tutorial,Anaglyph,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\Anaglyph.cs,SetupCamera,The following statement contains a magic number: Right.Y *= (float)( camera.EyeSeparation / 2.0 );
Magic Number,Examples.Tutorial,Anaglyph,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\Anaglyph.cs,SetupCamera,The following statement contains a magic number: Right.Z *= (float)( camera.EyeSeparation / 2.0 );
Magic Number,Examples.Tutorial,Anaglyph,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\Anaglyph.cs,OnRenderFrame,The following statement contains a magic number: Angle += (float)(e.Time *20.0);
Magic Number,Examples.Tutorial,Anaglyph,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\Anaglyph.cs,Main,The following statement contains a magic number: using (Anaglyph game = new Anaglyph())              {                  game.Run(10.0);              }
Magic Number,Examples.Tutorial,GLDiagnostics,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\OpenGLDiagnostics.cs,Analyze,The following statement contains a magic number: int[] result2i = new int[2];
Magic Number,Examples.Tutorial,GLDiagnostics,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\OpenGLDiagnostics.cs,Analyze,The following statement contains a magic number: int[] result4i = new int[4];
Magic Number,Examples.Tutorial,GLDiagnostics,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\OpenGLDiagnostics.cs,Analyze,The following statement contains a magic number: switch (type)              {                  case eType.Boolean:                      GL.GetBoolean(pname' out result1b);                      output = pname + ": " + result1b;                      break;                  case eType.Int:                      GL.GetInteger(pname' out result1i);                      output = pname + ": " + result1i;                      break;                  case eType.IntEnum:                      GL.GetInteger(pname' out result1i);                      output = pname + ": " + (All)result1i;                      break;                  case eType.IntArray2:                      GL.GetInteger(pname' result2i);                      output = pname + ": ( " + result2i[0] + "' " + result2i[1] + " )";                      break;                  case eType.IntArray4:                      GL.GetInteger(pname' result4i);                      output = pname + ": ( " + result4i[0] + "' " + result4i[1] + " ) ( " + result4i[2] + "' " + result4i[3] + " )";                      break;                  case eType.Float:                      GL.GetFloat(pname' out result1f);                      output = pname + ": " + result1f;                      break;                  case eType.FloatArray2:                      GL.GetFloat(pname' out result2f);                      output = pname + ": ( " + result2f.X + "' " + result2f.Y + " )";                      break;                  case eType.FloatArray4:                      GL.GetFloat(pname' out result4f);                      output = pname + ": ( " + result4f.X + "' " + result4f.Y + "' " + result4f.Z + "' " + result4f.W + " )";                      break;                  default: throw new NotImplementedException();              }
Magic Number,Examples.Tutorial,GLDiagnostics,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\OpenGLDiagnostics.cs,Analyze,The following statement contains a magic number: switch (type)              {                  case eType.Boolean:                      GL.GetBoolean(pname' out result1b);                      output = pname + ": " + result1b;                      break;                  case eType.Int:                      GL.GetInteger(pname' out result1i);                      output = pname + ": " + result1i;                      break;                  case eType.IntEnum:                      GL.GetInteger(pname' out result1i);                      output = pname + ": " + (All)result1i;                      break;                  case eType.IntArray2:                      GL.GetInteger(pname' result2i);                      output = pname + ": ( " + result2i[0] + "' " + result2i[1] + " )";                      break;                  case eType.IntArray4:                      GL.GetInteger(pname' result4i);                      output = pname + ": ( " + result4i[0] + "' " + result4i[1] + " ) ( " + result4i[2] + "' " + result4i[3] + " )";                      break;                  case eType.Float:                      GL.GetFloat(pname' out result1f);                      output = pname + ": " + result1f;                      break;                  case eType.FloatArray2:                      GL.GetFloat(pname' out result2f);                      output = pname + ": ( " + result2f.X + "' " + result2f.Y + " )";                      break;                  case eType.FloatArray4:                      GL.GetFloat(pname' out result4f);                      output = pname + ": ( " + result4f.X + "' " + result4f.Y + "' " + result4f.Z + "' " + result4f.W + " )";                      break;                  default: throw new NotImplementedException();              }
Magic Number,Examples.Tutorial,GLDiagnostics,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\OpenGLDiagnostics.cs,OnLoad,The following statement contains a magic number: foreach (TexFormat t in TextureFormats)              {                  GL.GenTextures(1' out DummyTexture);                  GL.BindTexture(TextureTarget.Texture2D' DummyTexture);                  GL.TexImage2D(TextureTarget.Texture2D' 0' t.pif' 4' 4' 0' t.pf' t.pt' IntPtr.Zero);                  if (GL.GetError() == ErrorCode.NoError)                      Supported.Enqueue(t);                  else                      Unsupported.Enqueue(t);                  GL.DeleteTextures(1' ref DummyTexture);              }
Magic Number,Examples.Tutorial,GLDiagnostics,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\OpenGLDiagnostics.cs,OnLoad,The following statement contains a magic number: foreach (TexFormat t in TextureFormats)              {                  GL.GenTextures(1' out DummyTexture);                  GL.BindTexture(TextureTarget.Texture2D' DummyTexture);                  GL.TexImage2D(TextureTarget.Texture2D' 0' t.pif' 4' 4' 0' t.pf' t.pt' IntPtr.Zero);                  if (GL.GetError() == ErrorCode.NoError)                      Supported.Enqueue(t);                  else                      Unsupported.Enqueue(t);                  GL.DeleteTextures(1' ref DummyTexture);              }
Magic Number,Examples.Tutorial,GLDiagnostics,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\OpenGLDiagnostics.cs,Main,The following statement contains a magic number: using (GLDiagnostics game = new GLDiagnostics())              {                  game.Run(10.0);              }
Magic Number,Examples.Tutorial,TextRendering,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\TextRendering.cs,OnResize,The following statement contains a magic number: GL.Ortho(-1.0' 1.0' -1.0' 1.0' 0.0' 4.0);
Magic Number,Examples.Tutorial,TextRendering,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\TextRendering.cs,Main,The following statement contains a magic number: using (TextRendering example = new TextRendering())              {                  Utilities.SetWindowTitle(example);                  example.Run(30.0);              }
Magic Number,Examples.Tutorial,T07_Display_Lists_Flower,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\DisplayLists.cs,OnLoad,The following statement contains a magic number: for (int i = 0; i < num_lists; i++)              {                  lists[i] = first_list + i;                  GL.NewList(first_list + i' ListMode.Compile);                    GL.Color3(0.3 + 0.7 * c * c' 0.3 + 1.4 * c * c' 0.7 - 0.7 * c * c);                  c += 1 / (float)num_lists;                    GL.PushMatrix();                    GL.Rotate(c * 360.0f' 0.0' 0.0' 1.0);                  GL.Translate(5.0' 0.0' 0.0);                    GL.Begin(BeginMode.Quads);                    GL.Vertex3(-1.0f' -1.0f' 1.0f);                  GL.Vertex3(1.0f' -1.0f' 1.0f);                  GL.Vertex3(1.0f' 1.0f' 1.0f);                  GL.Vertex3(-1.0f' 1.0f' 1.0f);                    GL.End();                    GL.PopMatrix();                    GL.EndList();              }
Magic Number,Examples.Tutorial,T07_Display_Lists_Flower,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\DisplayLists.cs,OnLoad,The following statement contains a magic number: for (int i = 0; i < num_lists; i++)              {                  lists[i] = first_list + i;                  GL.NewList(first_list + i' ListMode.Compile);                    GL.Color3(0.3 + 0.7 * c * c' 0.3 + 1.4 * c * c' 0.7 - 0.7 * c * c);                  c += 1 / (float)num_lists;                    GL.PushMatrix();                    GL.Rotate(c * 360.0f' 0.0' 0.0' 1.0);                  GL.Translate(5.0' 0.0' 0.0);                    GL.Begin(BeginMode.Quads);                    GL.Vertex3(-1.0f' -1.0f' 1.0f);                  GL.Vertex3(1.0f' -1.0f' 1.0f);                  GL.Vertex3(1.0f' 1.0f' 1.0f);                  GL.Vertex3(-1.0f' 1.0f' 1.0f);                    GL.End();                    GL.PopMatrix();                    GL.EndList();              }
Magic Number,Examples.Tutorial,T07_Display_Lists_Flower,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\DisplayLists.cs,OnLoad,The following statement contains a magic number: for (int i = 0; i < num_lists; i++)              {                  lists[i] = first_list + i;                  GL.NewList(first_list + i' ListMode.Compile);                    GL.Color3(0.3 + 0.7 * c * c' 0.3 + 1.4 * c * c' 0.7 - 0.7 * c * c);                  c += 1 / (float)num_lists;                    GL.PushMatrix();                    GL.Rotate(c * 360.0f' 0.0' 0.0' 1.0);                  GL.Translate(5.0' 0.0' 0.0);                    GL.Begin(BeginMode.Quads);                    GL.Vertex3(-1.0f' -1.0f' 1.0f);                  GL.Vertex3(1.0f' -1.0f' 1.0f);                  GL.Vertex3(1.0f' 1.0f' 1.0f);                  GL.Vertex3(-1.0f' 1.0f' 1.0f);                    GL.End();                    GL.PopMatrix();                    GL.EndList();              }
Magic Number,Examples.Tutorial,T07_Display_Lists_Flower,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\DisplayLists.cs,OnLoad,The following statement contains a magic number: for (int i = 0; i < num_lists; i++)              {                  lists[i] = first_list + i;                  GL.NewList(first_list + i' ListMode.Compile);                    GL.Color3(0.3 + 0.7 * c * c' 0.3 + 1.4 * c * c' 0.7 - 0.7 * c * c);                  c += 1 / (float)num_lists;                    GL.PushMatrix();                    GL.Rotate(c * 360.0f' 0.0' 0.0' 1.0);                  GL.Translate(5.0' 0.0' 0.0);                    GL.Begin(BeginMode.Quads);                    GL.Vertex3(-1.0f' -1.0f' 1.0f);                  GL.Vertex3(1.0f' -1.0f' 1.0f);                  GL.Vertex3(1.0f' 1.0f' 1.0f);                  GL.Vertex3(-1.0f' 1.0f' 1.0f);                    GL.End();                    GL.PopMatrix();                    GL.EndList();              }
Magic Number,Examples.Tutorial,T07_Display_Lists_Flower,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\DisplayLists.cs,OnLoad,The following statement contains a magic number: for (int i = 0; i < num_lists; i++)              {                  lists[i] = first_list + i;                  GL.NewList(first_list + i' ListMode.Compile);                    GL.Color3(0.3 + 0.7 * c * c' 0.3 + 1.4 * c * c' 0.7 - 0.7 * c * c);                  c += 1 / (float)num_lists;                    GL.PushMatrix();                    GL.Rotate(c * 360.0f' 0.0' 0.0' 1.0);                  GL.Translate(5.0' 0.0' 0.0);                    GL.Begin(BeginMode.Quads);                    GL.Vertex3(-1.0f' -1.0f' 1.0f);                  GL.Vertex3(1.0f' -1.0f' 1.0f);                  GL.Vertex3(1.0f' 1.0f' 1.0f);                  GL.Vertex3(-1.0f' 1.0f' 1.0f);                    GL.End();                    GL.PopMatrix();                    GL.EndList();              }
Magic Number,Examples.Tutorial,T07_Display_Lists_Flower,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\DisplayLists.cs,OnLoad,The following statement contains a magic number: for (int i = 0; i < num_lists; i++)              {                  lists[i] = first_list + i;                  GL.NewList(first_list + i' ListMode.Compile);                    GL.Color3(0.3 + 0.7 * c * c' 0.3 + 1.4 * c * c' 0.7 - 0.7 * c * c);                  c += 1 / (float)num_lists;                    GL.PushMatrix();                    GL.Rotate(c * 360.0f' 0.0' 0.0' 1.0);                  GL.Translate(5.0' 0.0' 0.0);                    GL.Begin(BeginMode.Quads);                    GL.Vertex3(-1.0f' -1.0f' 1.0f);                  GL.Vertex3(1.0f' -1.0f' 1.0f);                  GL.Vertex3(1.0f' 1.0f' 1.0f);                  GL.Vertex3(-1.0f' 1.0f' 1.0f);                    GL.End();                    GL.PopMatrix();                    GL.EndList();              }
Magic Number,Examples.Tutorial,T07_Display_Lists_Flower,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\DisplayLists.cs,OnLoad,The following statement contains a magic number: for (int i = 0; i < num_lists; i++)              {                  lists[i] = first_list + i;                  GL.NewList(first_list + i' ListMode.Compile);                    GL.Color3(0.3 + 0.7 * c * c' 0.3 + 1.4 * c * c' 0.7 - 0.7 * c * c);                  c += 1 / (float)num_lists;                    GL.PushMatrix();                    GL.Rotate(c * 360.0f' 0.0' 0.0' 1.0);                  GL.Translate(5.0' 0.0' 0.0);                    GL.Begin(BeginMode.Quads);                    GL.Vertex3(-1.0f' -1.0f' 1.0f);                  GL.Vertex3(1.0f' -1.0f' 1.0f);                  GL.Vertex3(1.0f' 1.0f' 1.0f);                  GL.Vertex3(-1.0f' 1.0f' 1.0f);                    GL.End();                    GL.PopMatrix();                    GL.EndList();              }
Magic Number,Examples.Tutorial,T07_Display_Lists_Flower,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\DisplayLists.cs,OnResize,The following statement contains a magic number: Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4' aspect' 1' 64' out projection_matrix);
Magic Number,Examples.Tutorial,T07_Display_Lists_Flower,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\DisplayLists.cs,OnResize,The following statement contains a magic number: Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4' aspect' 1' 64' out projection_matrix);
Magic Number,Examples.Tutorial,T07_Display_Lists_Flower,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\DisplayLists.cs,OnRenderFrame,The following statement contains a magic number: Matrix4 lookat = Matrix4.LookAt(0' 0' 16' 0' 0' 0' 0' 1' 0);
Magic Number,Examples.Tutorial,T07_Display_Lists_Flower,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\DisplayLists.cs,Main,The following statement contains a magic number: using (T07_Display_Lists_Flower example = new T07_Display_Lists_Flower())              {                  Utilities.SetWindowTitle(example);                  example.Run(30.0' 0.0);              }
Magic Number,Examples.Tutorial,StencilCSG,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\StencilCSG.cs,OnLoad,The following statement contains a magic number: OperandA = new ChamferCube(1.5' 2.0' 2.5' ChamferCube.SubDivs.Four' 0.42' true);
Magic Number,Examples.Tutorial,StencilCSG,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\StencilCSG.cs,OnLoad,The following statement contains a magic number: OperandA = new ChamferCube(1.5' 2.0' 2.5' ChamferCube.SubDivs.Four' 0.42' true);
Magic Number,Examples.Tutorial,StencilCSG,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\StencilCSG.cs,OnLoad,The following statement contains a magic number: OperandA = new ChamferCube(1.5' 2.0' 2.5' ChamferCube.SubDivs.Four' 0.42' true);
Magic Number,Examples.Tutorial,StencilCSG,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\StencilCSG.cs,OnLoad,The following statement contains a magic number: OperandA = new ChamferCube(1.5' 2.0' 2.5' ChamferCube.SubDivs.Four' 0.42' true);
Magic Number,Examples.Tutorial,StencilCSG,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\StencilCSG.cs,OnRenderFrame,The following statement contains a magic number: MySphereZOffset += (float)(e.Time * 3.1);
Magic Number,Examples.Tutorial,StencilCSG,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\StencilCSG.cs,OnRenderFrame,The following statement contains a magic number: MySphereXOffset += (float)(e.Time * 4.2);
Magic Number,Examples.Tutorial,StencilCSG,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\StencilCSG.cs,Main,The following statement contains a magic number: using (StencilCSG example = new StencilCSG())              {                  Utilities.SetWindowTitle(example);                  example.Run(30.0' 0.0);              }
Magic Number,Examples.Tutorial,T02_Vertex_Arrays,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VertexArrays.cs,OnLoad,The following statement contains a magic number: GL.VertexPointer(3' VertexPointerType.Float' 0' shape.Vertices);
Magic Number,Examples.Tutorial,T02_Vertex_Arrays,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VertexArrays.cs,OnResize,The following statement contains a magic number: OpenTK.Matrix4 perspective = OpenTK.Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4' (float)aspect_ratio' 1' 64);
Magic Number,Examples.Tutorial,T02_Vertex_Arrays,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VertexArrays.cs,OnRenderFrame,The following statement contains a magic number: Matrix4 lookat = Matrix4.LookAt(0' 5' 5' 0' 0' 0' 0' 1' 0);
Magic Number,Examples.Tutorial,T02_Vertex_Arrays,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VertexArrays.cs,OnRenderFrame,The following statement contains a magic number: Matrix4 lookat = Matrix4.LookAt(0' 5' 5' 0' 0' 0' 0' 1' 0);
Magic Number,Examples.Tutorial,T02_Vertex_Arrays,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VertexArrays.cs,Launch,The following statement contains a magic number: Run(30.0' 85.0);
Magic Number,Examples.Tutorial,T02_Vertex_Arrays,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VertexArrays.cs,Launch,The following statement contains a magic number: Run(30.0' 85.0);
Magic Number,Examples.Tutorial,T04_Vertex_Lighting,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VertexLighting.cs,OnLoad,The following statement contains a magic number: GL.VertexPointer(3' VertexPointerType.Float' 0' shape.Vertices);
Magic Number,Examples.Tutorial,T04_Vertex_Lighting,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VertexLighting.cs,OnResize,The following statement contains a magic number: Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4' aspect_ratio' 1' 64);
Magic Number,Examples.Tutorial,T04_Vertex_Lighting,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VertexLighting.cs,Main,The following statement contains a magic number: using (T04_Vertex_Lighting example = new T04_Vertex_Lighting())              {                  Utilities.SetWindowTitle(example);                  example.Run(30.0' 0.0);              }
Magic Number,Examples.Tutorial,Textures,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\Textures.cs,OnResize,The following statement contains a magic number: GL.Ortho(-1.0' 1.0' -1.0' 1.0' 0.0' 4.0);
Magic Number,Examples.Tutorial,Textures,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\Textures.cs,Main,The following statement contains a magic number: using (Textures example = new Textures())              {                  // Get the title and category  of this example using reflection.                  ExampleAttribute info = ((ExampleAttribute)typeof(Textures).GetCustomAttributes(false)[0]);                  example.Title = String.Format("OpenTK | {0} {1}: {2}"' info.Category' info.Difficulty' info.Title);                  example.Run(30.0' 0.0);              }
Magic Number,Examples.Tutorial,T09_VBO_Dynamic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VBODynamic.cs,OnLoad,The following statement contains a magic number: Version version = new Version(GL.GetString(StringName.Version).Substring(0' 3));
Magic Number,Examples.Tutorial,T09_VBO_Dynamic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VBODynamic.cs,OnLoad,The following statement contains a magic number: Version target = new Version(1' 5);
Magic Number,Examples.Tutorial,T09_VBO_Dynamic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VBODynamic.cs,OnLoad,The following statement contains a magic number: GL.ColorPointer(4' ColorPointerType.UnsignedByte' VertexC4ubV3f.SizeInBytes' (IntPtr)0);
Magic Number,Examples.Tutorial,T09_VBO_Dynamic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VBODynamic.cs,OnLoad,The following statement contains a magic number: GL.VertexPointer(3' VertexPointerType.Float' VertexC4ubV3f.SizeInBytes' (IntPtr)(4 * sizeof(byte)));
Magic Number,Examples.Tutorial,T09_VBO_Dynamic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VBODynamic.cs,OnLoad,The following statement contains a magic number: GL.VertexPointer(3' VertexPointerType.Float' VertexC4ubV3f.SizeInBytes' (IntPtr)(4 * sizeof(byte)));
Magic Number,Examples.Tutorial,T09_VBO_Dynamic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VBODynamic.cs,OnLoad,The following statement contains a magic number: for (uint i = 0; i < MaxParticleCount; i++)              {                  VBO[i].R = (byte)rnd.Next(0' 256);                  VBO[i].G = (byte)rnd.Next(0' 256);                  VBO[i].B = (byte)rnd.Next(0' 256);                  VBO[i].A = (byte)rnd.Next(0' 256); // isn't actually used                  VBO[i].Position = Vector3.Zero; // all particles are born at the origin                    // generate direction vector in the range [-0.25f...+0.25f]                   // that's slow enough so you can see particles 'disappear' when they are respawned                  temp.X = (float)((rnd.NextDouble() - 0.5) * 0.5f);                  temp.Y = (float)((rnd.NextDouble() - 0.5) * 0.5f);                  temp.Z = (float)((rnd.NextDouble() - 0.5) * 0.5f);                  ParticleAttributes[i].Direction = temp; // copy                   ParticleAttributes[i].Age = 0;              }
Magic Number,Examples.Tutorial,T09_VBO_Dynamic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VBODynamic.cs,OnLoad,The following statement contains a magic number: for (uint i = 0; i < MaxParticleCount; i++)              {                  VBO[i].R = (byte)rnd.Next(0' 256);                  VBO[i].G = (byte)rnd.Next(0' 256);                  VBO[i].B = (byte)rnd.Next(0' 256);                  VBO[i].A = (byte)rnd.Next(0' 256); // isn't actually used                  VBO[i].Position = Vector3.Zero; // all particles are born at the origin                    // generate direction vector in the range [-0.25f...+0.25f]                   // that's slow enough so you can see particles 'disappear' when they are respawned                  temp.X = (float)((rnd.NextDouble() - 0.5) * 0.5f);                  temp.Y = (float)((rnd.NextDouble() - 0.5) * 0.5f);                  temp.Z = (float)((rnd.NextDouble() - 0.5) * 0.5f);                  ParticleAttributes[i].Direction = temp; // copy                   ParticleAttributes[i].Age = 0;              }
Magic Number,Examples.Tutorial,T09_VBO_Dynamic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VBODynamic.cs,OnLoad,The following statement contains a magic number: for (uint i = 0; i < MaxParticleCount; i++)              {                  VBO[i].R = (byte)rnd.Next(0' 256);                  VBO[i].G = (byte)rnd.Next(0' 256);                  VBO[i].B = (byte)rnd.Next(0' 256);                  VBO[i].A = (byte)rnd.Next(0' 256); // isn't actually used                  VBO[i].Position = Vector3.Zero; // all particles are born at the origin                    // generate direction vector in the range [-0.25f...+0.25f]                   // that's slow enough so you can see particles 'disappear' when they are respawned                  temp.X = (float)((rnd.NextDouble() - 0.5) * 0.5f);                  temp.Y = (float)((rnd.NextDouble() - 0.5) * 0.5f);                  temp.Z = (float)((rnd.NextDouble() - 0.5) * 0.5f);                  ParticleAttributes[i].Direction = temp; // copy                   ParticleAttributes[i].Age = 0;              }
Magic Number,Examples.Tutorial,T09_VBO_Dynamic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VBODynamic.cs,OnLoad,The following statement contains a magic number: for (uint i = 0; i < MaxParticleCount; i++)              {                  VBO[i].R = (byte)rnd.Next(0' 256);                  VBO[i].G = (byte)rnd.Next(0' 256);                  VBO[i].B = (byte)rnd.Next(0' 256);                  VBO[i].A = (byte)rnd.Next(0' 256); // isn't actually used                  VBO[i].Position = Vector3.Zero; // all particles are born at the origin                    // generate direction vector in the range [-0.25f...+0.25f]                   // that's slow enough so you can see particles 'disappear' when they are respawned                  temp.X = (float)((rnd.NextDouble() - 0.5) * 0.5f);                  temp.Y = (float)((rnd.NextDouble() - 0.5) * 0.5f);                  temp.Z = (float)((rnd.NextDouble() - 0.5) * 0.5f);                  ParticleAttributes[i].Direction = temp; // copy                   ParticleAttributes[i].Age = 0;              }
Magic Number,Examples.Tutorial,T09_VBO_Dynamic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VBODynamic.cs,OnLoad,The following statement contains a magic number: for (uint i = 0; i < MaxParticleCount; i++)              {                  VBO[i].R = (byte)rnd.Next(0' 256);                  VBO[i].G = (byte)rnd.Next(0' 256);                  VBO[i].B = (byte)rnd.Next(0' 256);                  VBO[i].A = (byte)rnd.Next(0' 256); // isn't actually used                  VBO[i].Position = Vector3.Zero; // all particles are born at the origin                    // generate direction vector in the range [-0.25f...+0.25f]                   // that's slow enough so you can see particles 'disappear' when they are respawned                  temp.X = (float)((rnd.NextDouble() - 0.5) * 0.5f);                  temp.Y = (float)((rnd.NextDouble() - 0.5) * 0.5f);                  temp.Z = (float)((rnd.NextDouble() - 0.5) * 0.5f);                  ParticleAttributes[i].Direction = temp; // copy                   ParticleAttributes[i].Age = 0;              }
Magic Number,Examples.Tutorial,T09_VBO_Dynamic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VBODynamic.cs,OnLoad,The following statement contains a magic number: for (uint i = 0; i < MaxParticleCount; i++)              {                  VBO[i].R = (byte)rnd.Next(0' 256);                  VBO[i].G = (byte)rnd.Next(0' 256);                  VBO[i].B = (byte)rnd.Next(0' 256);                  VBO[i].A = (byte)rnd.Next(0' 256); // isn't actually used                  VBO[i].Position = Vector3.Zero; // all particles are born at the origin                    // generate direction vector in the range [-0.25f...+0.25f]                   // that's slow enough so you can see particles 'disappear' when they are respawned                  temp.X = (float)((rnd.NextDouble() - 0.5) * 0.5f);                  temp.Y = (float)((rnd.NextDouble() - 0.5) * 0.5f);                  temp.Z = (float)((rnd.NextDouble() - 0.5) * 0.5f);                  ParticleAttributes[i].Direction = temp; // copy                   ParticleAttributes[i].Age = 0;              }
Magic Number,Examples.Tutorial,T09_VBO_Dynamic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VBODynamic.cs,OnLoad,The following statement contains a magic number: for (uint i = 0; i < MaxParticleCount; i++)              {                  VBO[i].R = (byte)rnd.Next(0' 256);                  VBO[i].G = (byte)rnd.Next(0' 256);                  VBO[i].B = (byte)rnd.Next(0' 256);                  VBO[i].A = (byte)rnd.Next(0' 256); // isn't actually used                  VBO[i].Position = Vector3.Zero; // all particles are born at the origin                    // generate direction vector in the range [-0.25f...+0.25f]                   // that's slow enough so you can see particles 'disappear' when they are respawned                  temp.X = (float)((rnd.NextDouble() - 0.5) * 0.5f);                  temp.Y = (float)((rnd.NextDouble() - 0.5) * 0.5f);                  temp.Z = (float)((rnd.NextDouble() - 0.5) * 0.5f);                  ParticleAttributes[i].Direction = temp; // copy                   ParticleAttributes[i].Age = 0;              }
Magic Number,Examples.Tutorial,T09_VBO_Dynamic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VBODynamic.cs,OnUpdateFrame,The following statement contains a magic number: for (int i = MaxParticleCount - VisibleParticleCount; i < MaxParticleCount; i++)              {                  if (ParticleAttributes[i].Age >= MaxParticleCount)                  {                      // reset particle                      ParticleAttributes[i].Age = 0;                      VBO[i].Position = Vector3.Zero;                  }                  else                  {                      ParticleAttributes[i].Age += (uint)Math.Max(ParticleAttributes[i].Direction.LengthFast * 10' 1);                      Vector3.Multiply(ref ParticleAttributes[i].Direction' (float)e.Time' out temp);                      Vector3.Add(ref VBO[i].Position' ref temp' out VBO[i].Position);                  }              }
Magic Number,Examples.Tutorial,T09_VBO_Dynamic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VBODynamic.cs,Main,The following statement contains a magic number: using (T09_VBO_Dynamic example = new T09_VBO_Dynamic())              {                  Utilities.SetWindowTitle(example);                  example.Run(60.0' 0.0);              }
Magic Number,Examples.Tutorial,SimpleFBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\FramebufferObject.cs,OnLoad,The following statement contains a magic number: Object = new Shapes.TorusKnot(256' 16' 0.2' 7'8' 1' true);
Magic Number,Examples.Tutorial,SimpleFBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\FramebufferObject.cs,OnLoad,The following statement contains a magic number: Object = new Shapes.TorusKnot(256' 16' 0.2' 7'8' 1' true);
Magic Number,Examples.Tutorial,SimpleFBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\FramebufferObject.cs,OnLoad,The following statement contains a magic number: Object = new Shapes.TorusKnot(256' 16' 0.2' 7'8' 1' true);
Magic Number,Examples.Tutorial,SimpleFBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\FramebufferObject.cs,OnLoad,The following statement contains a magic number: Object = new Shapes.TorusKnot(256' 16' 0.2' 7'8' 1' true);
Magic Number,Examples.Tutorial,SimpleFBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\FramebufferObject.cs,OnLoad,The following statement contains a magic number: Object = new Shapes.TorusKnot(256' 16' 0.2' 7'8' 1' true);
Magic Number,Examples.Tutorial,SimpleFBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\FramebufferObject.cs,OnLoad,The following statement contains a magic number: int[] queryinfo = new int[6];
Magic Number,Examples.Tutorial,SimpleFBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\FramebufferObject.cs,OnLoad,The following statement contains a magic number: GL.GetInteger(GetPName.MaxDrawBuffers' out queryinfo[2]);
Magic Number,Examples.Tutorial,SimpleFBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\FramebufferObject.cs,OnLoad,The following statement contains a magic number: GL.GetInteger(GetPName.Stereo' out queryinfo[3]);
Magic Number,Examples.Tutorial,SimpleFBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\FramebufferObject.cs,OnLoad,The following statement contains a magic number: GL.GetInteger(GetPName.Samples' out queryinfo[4]);
Magic Number,Examples.Tutorial,SimpleFBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\FramebufferObject.cs,OnLoad,The following statement contains a magic number: GL.GetInteger(GetPName.Doublebuffer' out queryinfo[5]);
Magic Number,Examples.Tutorial,SimpleFBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\FramebufferObject.cs,OnLoad,The following statement contains a magic number: Console.WriteLine("max. ColorBuffers: " + queryinfo[0] + " max. AuxBuffers: " + queryinfo[1] + " max. DrawBuffers: " + queryinfo[2] +                                 "\nStereo: " + queryinfo[3] + " Samples: " + queryinfo[4] + " DoubleBuffer: " + queryinfo[5]);
Magic Number,Examples.Tutorial,SimpleFBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\FramebufferObject.cs,OnLoad,The following statement contains a magic number: Console.WriteLine("max. ColorBuffers: " + queryinfo[0] + " max. AuxBuffers: " + queryinfo[1] + " max. DrawBuffers: " + queryinfo[2] +                                 "\nStereo: " + queryinfo[3] + " Samples: " + queryinfo[4] + " DoubleBuffer: " + queryinfo[5]);
Magic Number,Examples.Tutorial,SimpleFBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\FramebufferObject.cs,OnLoad,The following statement contains a magic number: Console.WriteLine("max. ColorBuffers: " + queryinfo[0] + " max. AuxBuffers: " + queryinfo[1] + " max. DrawBuffers: " + queryinfo[2] +                                 "\nStereo: " + queryinfo[3] + " Samples: " + queryinfo[4] + " DoubleBuffer: " + queryinfo[5]);
Magic Number,Examples.Tutorial,SimpleFBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\FramebufferObject.cs,OnLoad,The following statement contains a magic number: Console.WriteLine("max. ColorBuffers: " + queryinfo[0] + " max. AuxBuffers: " + queryinfo[1] + " max. DrawBuffers: " + queryinfo[2] +                                 "\nStereo: " + queryinfo[3] + " Samples: " + queryinfo[4] + " DoubleBuffer: " + queryinfo[5]);
Magic Number,Examples.Tutorial,SimpleFBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\FramebufferObject.cs,OnResize,The following statement contains a magic number: OpenTK.Matrix4 perspective = OpenTK.Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4' (float)aspect_ratio' 1' 64);
Magic Number,Examples.Tutorial,SimpleFBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\FramebufferObject.cs,OnResize,The following statement contains a magic number: Matrix4 lookat = Matrix4.LookAt(0' 0' 3' 0' 0' 0' 0' 1' 0);
Magic Number,Examples.Tutorial,SimpleFBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\FramebufferObject.cs,Main,The following statement contains a magic number: using (SimpleFBO example = new SimpleFBO())              {                  Utilities.SetWindowTitle(example);                  example.Run(30.0' 0.0);              }
Magic Number,Examples.Tutorial,T03_Immediate_Mode_Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\ImmediateMode.cs,OnResize,The following statement contains a magic number: OpenTK.Matrix4 perspective = OpenTK.Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4' (float)aspect_ratio' 1' 64);
Magic Number,Examples.Tutorial,T03_Immediate_Mode_Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\ImmediateMode.cs,OnRenderFrame,The following statement contains a magic number: Matrix4 lookat = Matrix4.LookAt(0' 5' 5' 0' 0' 0' 0' 1' 0);
Magic Number,Examples.Tutorial,T03_Immediate_Mode_Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\ImmediateMode.cs,OnRenderFrame,The following statement contains a magic number: Matrix4 lookat = Matrix4.LookAt(0' 5' 5' 0' 0' 0' 0' 1' 0);
Magic Number,Examples.Tutorial,T03_Immediate_Mode_Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\ImmediateMode.cs,Main,The following statement contains a magic number: using (T03_Immediate_Mode_Cube example = new T03_Immediate_Mode_Cube())              {                  Utilities.SetWindowTitle(example);                  example.Run(30.0' 0.0);              }
Magic Number,Examples.Tutorial,T08_VBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VBOStatic.cs,OnLoad,The following statement contains a magic number: Version version = new Version(GL.GetString(StringName.Version).Substring(0' 3));
Magic Number,Examples.Tutorial,T08_VBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VBOStatic.cs,OnLoad,The following statement contains a magic number: Version target = new Version(1' 5);
Magic Number,Examples.Tutorial,T08_VBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VBOStatic.cs,OnResize,The following statement contains a magic number: Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4' aspect_ratio' 1' 64);
Magic Number,Examples.Tutorial,T08_VBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VBOStatic.cs,OnRenderFrame,The following statement contains a magic number: Matrix4 lookat = Matrix4.LookAt(0' 5' 5' 0' 0' 0' 0' 1' 0);
Magic Number,Examples.Tutorial,T08_VBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VBOStatic.cs,OnRenderFrame,The following statement contains a magic number: Matrix4 lookat = Matrix4.LookAt(0' 5' 5' 0' 0' 0' 0' 1' 0);
Magic Number,Examples.Tutorial,T08_VBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VBOStatic.cs,Draw,The following statement contains a magic number: GL.VertexPointer(3' VertexPointerType.Float' BlittableValueType.StrideOf(CubeVertices)' new IntPtr(0));
Magic Number,Examples.Tutorial,T08_VBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VBOStatic.cs,Draw,The following statement contains a magic number: GL.ColorPointer(4' ColorPointerType.UnsignedByte' BlittableValueType.StrideOf(CubeVertices)' new IntPtr(12));
Magic Number,Examples.Tutorial,T08_VBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VBOStatic.cs,Draw,The following statement contains a magic number: GL.ColorPointer(4' ColorPointerType.UnsignedByte' BlittableValueType.StrideOf(CubeVertices)' new IntPtr(12));
Magic Number,Examples.Tutorial,T08_VBO,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\VBOStatic.cs,Main,The following statement contains a magic number: using (T08_VBO example = new T08_VBO())              {                  Utilities.SetWindowTitle(example);                  example.Run(30.0' 0.0);              }
Magic Number,Examples.Tutorial,TextureMatrix,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\TextureMatrix.cs,OnLoad,The following statement contains a magic number: {                  const int slices = 32;                  const float distance = 0.25f;                    GL.Begin(BeginMode.Quads);                    for (float scale = 0.26f; scale < 5f; scale += distance)                      for (int i = 0; i < slices; i++)                      {                          Vector3 MiddleCenter = new Vector3((float)(Math.Sin((double)i / slices * 2 * Math.PI) * scale)'                                                             (float)(Math.Cos((double)i / slices * 2 * Math.PI) * scale)'                                                             (float)(1f / scale));                          Vector3 MiddleRight = new Vector3((float)(Math.Sin((double)(i + 1) / slices * 2 * Math.PI) * scale)'                                                            (float)(Math.Cos((double)(i + 1) / slices * 2 * Math.PI) * scale)'                                                            (float)(1f / scale));                          Vector3 BottomRight = new Vector3((float)(Math.Sin((double)(i + 1) / slices * 2 * Math.PI) * (scale - distance))'                                                            (float)(Math.Cos((double)(i + 1) / slices * 2 * Math.PI) * (scale - distance))'                                                            (float)(1f / (scale - distance)));                          Vector3 BottomCenter = new Vector3((float)(Math.Sin((double)i / slices * 2 * Math.PI) * (scale - distance))'                                                             (float)(Math.Cos((double)i / slices * 2 * Math.PI) * (scale - distance))'                                                             (float)(1f / (scale - distance)));                            GL.TexCoord2(1f' 0f);                          GL.Vertex3(MiddleCenter);                          GL.TexCoord2(0f' 0f);                          GL.Vertex3(MiddleRight);                          GL.TexCoord2(0f' 1f);                          GL.Vertex3(BottomRight);                          GL.TexCoord2(1f' 1f);                          GL.Vertex3(BottomCenter);                      }                    GL.End();              }
Magic Number,Examples.Tutorial,TextureMatrix,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\TextureMatrix.cs,OnLoad,The following statement contains a magic number: {                  const int slices = 32;                  const float distance = 0.25f;                    GL.Begin(BeginMode.Quads);                    for (float scale = 0.26f; scale < 5f; scale += distance)                      for (int i = 0; i < slices; i++)                      {                          Vector3 MiddleCenter = new Vector3((float)(Math.Sin((double)i / slices * 2 * Math.PI) * scale)'                                                             (float)(Math.Cos((double)i / slices * 2 * Math.PI) * scale)'                                                             (float)(1f / scale));                          Vector3 MiddleRight = new Vector3((float)(Math.Sin((double)(i + 1) / slices * 2 * Math.PI) * scale)'                                                            (float)(Math.Cos((double)(i + 1) / slices * 2 * Math.PI) * scale)'                                                            (float)(1f / scale));                          Vector3 BottomRight = new Vector3((float)(Math.Sin((double)(i + 1) / slices * 2 * Math.PI) * (scale - distance))'                                                            (float)(Math.Cos((double)(i + 1) / slices * 2 * Math.PI) * (scale - distance))'                                                            (float)(1f / (scale - distance)));                          Vector3 BottomCenter = new Vector3((float)(Math.Sin((double)i / slices * 2 * Math.PI) * (scale - distance))'                                                             (float)(Math.Cos((double)i / slices * 2 * Math.PI) * (scale - distance))'                                                             (float)(1f / (scale - distance)));                            GL.TexCoord2(1f' 0f);                          GL.Vertex3(MiddleCenter);                          GL.TexCoord2(0f' 0f);                          GL.Vertex3(MiddleRight);                          GL.TexCoord2(0f' 1f);                          GL.Vertex3(BottomRight);                          GL.TexCoord2(1f' 1f);                          GL.Vertex3(BottomCenter);                      }                    GL.End();              }
Magic Number,Examples.Tutorial,TextureMatrix,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\TextureMatrix.cs,OnLoad,The following statement contains a magic number: {                  const int slices = 32;                  const float distance = 0.25f;                    GL.Begin(BeginMode.Quads);                    for (float scale = 0.26f; scale < 5f; scale += distance)                      for (int i = 0; i < slices; i++)                      {                          Vector3 MiddleCenter = new Vector3((float)(Math.Sin((double)i / slices * 2 * Math.PI) * scale)'                                                             (float)(Math.Cos((double)i / slices * 2 * Math.PI) * scale)'                                                             (float)(1f / scale));                          Vector3 MiddleRight = new Vector3((float)(Math.Sin((double)(i + 1) / slices * 2 * Math.PI) * scale)'                                                            (float)(Math.Cos((double)(i + 1) / slices * 2 * Math.PI) * scale)'                                                            (float)(1f / scale));                          Vector3 BottomRight = new Vector3((float)(Math.Sin((double)(i + 1) / slices * 2 * Math.PI) * (scale - distance))'                                                            (float)(Math.Cos((double)(i + 1) / slices * 2 * Math.PI) * (scale - distance))'                                                            (float)(1f / (scale - distance)));                          Vector3 BottomCenter = new Vector3((float)(Math.Sin((double)i / slices * 2 * Math.PI) * (scale - distance))'                                                             (float)(Math.Cos((double)i / slices * 2 * Math.PI) * (scale - distance))'                                                             (float)(1f / (scale - distance)));                            GL.TexCoord2(1f' 0f);                          GL.Vertex3(MiddleCenter);                          GL.TexCoord2(0f' 0f);                          GL.Vertex3(MiddleRight);                          GL.TexCoord2(0f' 1f);                          GL.Vertex3(BottomRight);                          GL.TexCoord2(1f' 1f);                          GL.Vertex3(BottomCenter);                      }                    GL.End();              }
Magic Number,Examples.Tutorial,TextureMatrix,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\TextureMatrix.cs,OnLoad,The following statement contains a magic number: {                  const int slices = 32;                  const float distance = 0.25f;                    GL.Begin(BeginMode.Quads);                    for (float scale = 0.26f; scale < 5f; scale += distance)                      for (int i = 0; i < slices; i++)                      {                          Vector3 MiddleCenter = new Vector3((float)(Math.Sin((double)i / slices * 2 * Math.PI) * scale)'                                                             (float)(Math.Cos((double)i / slices * 2 * Math.PI) * scale)'                                                             (float)(1f / scale));                          Vector3 MiddleRight = new Vector3((float)(Math.Sin((double)(i + 1) / slices * 2 * Math.PI) * scale)'                                                            (float)(Math.Cos((double)(i + 1) / slices * 2 * Math.PI) * scale)'                                                            (float)(1f / scale));                          Vector3 BottomRight = new Vector3((float)(Math.Sin((double)(i + 1) / slices * 2 * Math.PI) * (scale - distance))'                                                            (float)(Math.Cos((double)(i + 1) / slices * 2 * Math.PI) * (scale - distance))'                                                            (float)(1f / (scale - distance)));                          Vector3 BottomCenter = new Vector3((float)(Math.Sin((double)i / slices * 2 * Math.PI) * (scale - distance))'                                                             (float)(Math.Cos((double)i / slices * 2 * Math.PI) * (scale - distance))'                                                             (float)(1f / (scale - distance)));                            GL.TexCoord2(1f' 0f);                          GL.Vertex3(MiddleCenter);                          GL.TexCoord2(0f' 0f);                          GL.Vertex3(MiddleRight);                          GL.TexCoord2(0f' 1f);                          GL.Vertex3(BottomRight);                          GL.TexCoord2(1f' 1f);                          GL.Vertex3(BottomCenter);                      }                    GL.End();              }
Magic Number,Examples.Tutorial,TextureMatrix,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\TextureMatrix.cs,OnLoad,The following statement contains a magic number: {                  const int slices = 32;                  const float distance = 0.25f;                    GL.Begin(BeginMode.Quads);                    for (float scale = 0.26f; scale < 5f; scale += distance)                      for (int i = 0; i < slices; i++)                      {                          Vector3 MiddleCenter = new Vector3((float)(Math.Sin((double)i / slices * 2 * Math.PI) * scale)'                                                             (float)(Math.Cos((double)i / slices * 2 * Math.PI) * scale)'                                                             (float)(1f / scale));                          Vector3 MiddleRight = new Vector3((float)(Math.Sin((double)(i + 1) / slices * 2 * Math.PI) * scale)'                                                            (float)(Math.Cos((double)(i + 1) / slices * 2 * Math.PI) * scale)'                                                            (float)(1f / scale));                          Vector3 BottomRight = new Vector3((float)(Math.Sin((double)(i + 1) / slices * 2 * Math.PI) * (scale - distance))'                                                            (float)(Math.Cos((double)(i + 1) / slices * 2 * Math.PI) * (scale - distance))'                                                            (float)(1f / (scale - distance)));                          Vector3 BottomCenter = new Vector3((float)(Math.Sin((double)i / slices * 2 * Math.PI) * (scale - distance))'                                                             (float)(Math.Cos((double)i / slices * 2 * Math.PI) * (scale - distance))'                                                             (float)(1f / (scale - distance)));                            GL.TexCoord2(1f' 0f);                          GL.Vertex3(MiddleCenter);                          GL.TexCoord2(0f' 0f);                          GL.Vertex3(MiddleRight);                          GL.TexCoord2(0f' 1f);                          GL.Vertex3(BottomRight);                          GL.TexCoord2(1f' 1f);                          GL.Vertex3(BottomCenter);                      }                    GL.End();              }
Magic Number,Examples.Tutorial,TextureMatrix,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\TextureMatrix.cs,OnLoad,The following statement contains a magic number: {                  const int slices = 32;                  const float distance = 0.25f;                    GL.Begin(BeginMode.Quads);                    for (float scale = 0.26f; scale < 5f; scale += distance)                      for (int i = 0; i < slices; i++)                      {                          Vector3 MiddleCenter = new Vector3((float)(Math.Sin((double)i / slices * 2 * Math.PI) * scale)'                                                             (float)(Math.Cos((double)i / slices * 2 * Math.PI) * scale)'                                                             (float)(1f / scale));                          Vector3 MiddleRight = new Vector3((float)(Math.Sin((double)(i + 1) / slices * 2 * Math.PI) * scale)'                                                            (float)(Math.Cos((double)(i + 1) / slices * 2 * Math.PI) * scale)'                                                            (float)(1f / scale));                          Vector3 BottomRight = new Vector3((float)(Math.Sin((double)(i + 1) / slices * 2 * Math.PI) * (scale - distance))'                                                            (float)(Math.Cos((double)(i + 1) / slices * 2 * Math.PI) * (scale - distance))'                                                            (float)(1f / (scale - distance)));                          Vector3 BottomCenter = new Vector3((float)(Math.Sin((double)i / slices * 2 * Math.PI) * (scale - distance))'                                                             (float)(Math.Cos((double)i / slices * 2 * Math.PI) * (scale - distance))'                                                             (float)(1f / (scale - distance)));                            GL.TexCoord2(1f' 0f);                          GL.Vertex3(MiddleCenter);                          GL.TexCoord2(0f' 0f);                          GL.Vertex3(MiddleRight);                          GL.TexCoord2(0f' 1f);                          GL.Vertex3(BottomRight);                          GL.TexCoord2(1f' 1f);                          GL.Vertex3(BottomCenter);                      }                    GL.End();              }
Magic Number,Examples.Tutorial,TextureMatrix,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\TextureMatrix.cs,OnLoad,The following statement contains a magic number: {                  const int slices = 32;                  const float distance = 0.25f;                    GL.Begin(BeginMode.Quads);                    for (float scale = 0.26f; scale < 5f; scale += distance)                      for (int i = 0; i < slices; i++)                      {                          Vector3 MiddleCenter = new Vector3((float)(Math.Sin((double)i / slices * 2 * Math.PI) * scale)'                                                             (float)(Math.Cos((double)i / slices * 2 * Math.PI) * scale)'                                                             (float)(1f / scale));                          Vector3 MiddleRight = new Vector3((float)(Math.Sin((double)(i + 1) / slices * 2 * Math.PI) * scale)'                                                            (float)(Math.Cos((double)(i + 1) / slices * 2 * Math.PI) * scale)'                                                            (float)(1f / scale));                          Vector3 BottomRight = new Vector3((float)(Math.Sin((double)(i + 1) / slices * 2 * Math.PI) * (scale - distance))'                                                            (float)(Math.Cos((double)(i + 1) / slices * 2 * Math.PI) * (scale - distance))'                                                            (float)(1f / (scale - distance)));                          Vector3 BottomCenter = new Vector3((float)(Math.Sin((double)i / slices * 2 * Math.PI) * (scale - distance))'                                                             (float)(Math.Cos((double)i / slices * 2 * Math.PI) * (scale - distance))'                                                             (float)(1f / (scale - distance)));                            GL.TexCoord2(1f' 0f);                          GL.Vertex3(MiddleCenter);                          GL.TexCoord2(0f' 0f);                          GL.Vertex3(MiddleRight);                          GL.TexCoord2(0f' 1f);                          GL.Vertex3(BottomRight);                          GL.TexCoord2(1f' 1f);                          GL.Vertex3(BottomCenter);                      }                    GL.End();              }
Magic Number,Examples.Tutorial,TextureMatrix,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\TextureMatrix.cs,OnLoad,The following statement contains a magic number: {                  const int slices = 32;                  const float distance = 0.25f;                    GL.Begin(BeginMode.Quads);                    for (float scale = 0.26f; scale < 5f; scale += distance)                      for (int i = 0; i < slices; i++)                      {                          Vector3 MiddleCenter = new Vector3((float)(Math.Sin((double)i / slices * 2 * Math.PI) * scale)'                                                             (float)(Math.Cos((double)i / slices * 2 * Math.PI) * scale)'                                                             (float)(1f / scale));                          Vector3 MiddleRight = new Vector3((float)(Math.Sin((double)(i + 1) / slices * 2 * Math.PI) * scale)'                                                            (float)(Math.Cos((double)(i + 1) / slices * 2 * Math.PI) * scale)'                                                            (float)(1f / scale));                          Vector3 BottomRight = new Vector3((float)(Math.Sin((double)(i + 1) / slices * 2 * Math.PI) * (scale - distance))'                                                            (float)(Math.Cos((double)(i + 1) / slices * 2 * Math.PI) * (scale - distance))'                                                            (float)(1f / (scale - distance)));                          Vector3 BottomCenter = new Vector3((float)(Math.Sin((double)i / slices * 2 * Math.PI) * (scale - distance))'                                                             (float)(Math.Cos((double)i / slices * 2 * Math.PI) * (scale - distance))'                                                             (float)(1f / (scale - distance)));                            GL.TexCoord2(1f' 0f);                          GL.Vertex3(MiddleCenter);                          GL.TexCoord2(0f' 0f);                          GL.Vertex3(MiddleRight);                          GL.TexCoord2(0f' 1f);                          GL.Vertex3(BottomRight);                          GL.TexCoord2(1f' 1f);                          GL.Vertex3(BottomCenter);                      }                    GL.End();              }
Magic Number,Examples.Tutorial,TextureMatrix,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\TextureMatrix.cs,OnLoad,The following statement contains a magic number: {                  const int slices = 32;                  const float distance = 0.25f;                    GL.Begin(BeginMode.Quads);                    for (float scale = 0.26f; scale < 5f; scale += distance)                      for (int i = 0; i < slices; i++)                      {                          Vector3 MiddleCenter = new Vector3((float)(Math.Sin((double)i / slices * 2 * Math.PI) * scale)'                                                             (float)(Math.Cos((double)i / slices * 2 * Math.PI) * scale)'                                                             (float)(1f / scale));                          Vector3 MiddleRight = new Vector3((float)(Math.Sin((double)(i + 1) / slices * 2 * Math.PI) * scale)'                                                            (float)(Math.Cos((double)(i + 1) / slices * 2 * Math.PI) * scale)'                                                            (float)(1f / scale));                          Vector3 BottomRight = new Vector3((float)(Math.Sin((double)(i + 1) / slices * 2 * Math.PI) * (scale - distance))'                                                            (float)(Math.Cos((double)(i + 1) / slices * 2 * Math.PI) * (scale - distance))'                                                            (float)(1f / (scale - distance)));                          Vector3 BottomCenter = new Vector3((float)(Math.Sin((double)i / slices * 2 * Math.PI) * (scale - distance))'                                                             (float)(Math.Cos((double)i / slices * 2 * Math.PI) * (scale - distance))'                                                             (float)(1f / (scale - distance)));                            GL.TexCoord2(1f' 0f);                          GL.Vertex3(MiddleCenter);                          GL.TexCoord2(0f' 0f);                          GL.Vertex3(MiddleRight);                          GL.TexCoord2(0f' 1f);                          GL.Vertex3(BottomRight);                          GL.TexCoord2(1f' 1f);                          GL.Vertex3(BottomCenter);                      }                    GL.End();              }
Magic Number,Examples.Tutorial,TextureMatrix,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\TextureMatrix.cs,OnRenderFrame,The following statement contains a magic number: GL.Translate(e.Time / 2' -e.Time' 0f);
Magic Number,Examples.Tutorial,TextureMatrix,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\TextureMatrix.cs,LoadTexture,The following statement contains a magic number: Version version = new Version(GL.GetString(StringName.Version).Substring(0' 3));
Magic Number,Examples.Tutorial,TextureMatrix,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\TextureMatrix.cs,LoadTexture,The following statement contains a magic number: Version target = new Version(1' 4);
Magic Number,Examples.Tutorial,TextureMatrix,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\TextureMatrix.cs,Main,The following statement contains a magic number: using (TextureMatrix example = new TextureMatrix())              {                  // Get the title and category  of this example using reflection.                  ExampleAttribute info = ((ExampleAttribute)example.GetType().GetCustomAttributes(false)[0]);                  example.Title = String.Format("OpenTK | {0} {1}: {2}"' info.Category' info.Difficulty' info.Title);                  example.Run(30.0' 0.0);              }
Magic Number,Examples.Tutorial,Picking,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\Picking.cs,OnLoad,The following statement contains a magic number: for (int i = 0; i < temp_VBO.Length; i++)              {                  // Position                  VBO_Array[i].Position = temp_VBO[i].Position;                    // Index                  if (i % 3 == 0)                      TriangleCounter++;                  VBO_Array[i].Color = new Byte4(BitConverter.GetBytes(TriangleCounter));              }
Magic Number,Examples.Tutorial,Picking,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\Picking.cs,OnRenderFrame,The following statement contains a magic number: if (SelectedTriangle != uint.MaxValue)              {                  GL.Disable(EnableCap.DepthTest);                  GL.Color3(Color.Green);                  GL.DrawArrays(VBO_PrimMode' (int)SelectedTriangle * 3' 3);                  GL.Enable(EnableCap.DepthTest);              }
Magic Number,Examples.Tutorial,Picking,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\Picking.cs,OnRenderFrame,The following statement contains a magic number: if (SelectedTriangle != uint.MaxValue)              {                  GL.Disable(EnableCap.DepthTest);                  GL.Color3(Color.Green);                  GL.DrawArrays(VBO_PrimMode' (int)SelectedTriangle * 3' 3);                  GL.Enable(EnableCap.DepthTest);              }
Magic Number,Examples.Tutorial,Picking,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\Picking.cs,Main,The following statement contains a magic number: using (Picking example = new Picking())              {                  // Get the title and category  of this example using reflection.                  ExampleAttribute info = ((ExampleAttribute)example.GetType().GetCustomAttributes(false)[0]);                  example.Title = String.Format("OpenTK | {0} {1}: {2} (use the mouse to pick)"' info.Category' info.Difficulty' info.Title);                  example.Run(30.0);              }
Magic Number,Examples.Tutorial,Byte4,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\Picking.cs,Byte4,The following statement contains a magic number: B = input[2];
Magic Number,Examples.Tutorial,Byte4,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\Picking.cs,Byte4,The following statement contains a magic number: A = input[3];
Magic Number,Examples.Tutorial,T10_GLSL_Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\SimpleGLSL.cs,OnLoad,The following statement contains a magic number: Version version = new Version(GL.GetString(StringName.Version).Substring(0' 3));
Magic Number,Examples.Tutorial,T10_GLSL_Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\SimpleGLSL.cs,OnLoad,The following statement contains a magic number: Version target = new Version(2' 0);
Magic Number,Examples.Tutorial,T10_GLSL_Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\SimpleGLSL.cs,CreateVBO,The following statement contains a magic number: GL.BufferData(BufferTarget.ArrayBuffer' (IntPtr)(shape.Vertices.Length * 3 * sizeof(float))' shape.Vertices'                  BufferUsageHint.StaticDraw);
Magic Number,Examples.Tutorial,T10_GLSL_Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\SimpleGLSL.cs,CreateVBO,The following statement contains a magic number: if (size != shape.Vertices.Length * 3 * sizeof(Single))                  throw new ApplicationException(String.Format(                      "Problem uploading vertex buffer to VBO (vertices). Tried to upload {0} bytes' uploaded {1}."'                      shape.Vertices.Length * 3 * sizeof(Single)' size));
Magic Number,Examples.Tutorial,T10_GLSL_Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\SimpleGLSL.cs,CreateVBO,The following statement contains a magic number: if (size != shape.Vertices.Length * 3 * sizeof(Single))                  throw new ApplicationException(String.Format(                      "Problem uploading vertex buffer to VBO (vertices). Tried to upload {0} bytes' uploaded {1}."'                      shape.Vertices.Length * 3 * sizeof(Single)' size));
Magic Number,Examples.Tutorial,T10_GLSL_Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\SimpleGLSL.cs,OnResize,The following statement contains a magic number: Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4' aspect_ratio' 1' 64);
Magic Number,Examples.Tutorial,T10_GLSL_Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\SimpleGLSL.cs,OnRenderFrame,The following statement contains a magic number: Matrix4 lookat = Matrix4.LookAt(0' 5' 5' 0' 0' 0' 0' 1' 0);
Magic Number,Examples.Tutorial,T10_GLSL_Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\SimpleGLSL.cs,OnRenderFrame,The following statement contains a magic number: Matrix4 lookat = Matrix4.LookAt(0' 5' 5' 0' 0' 0' 0' 1' 0);
Magic Number,Examples.Tutorial,T10_GLSL_Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\SimpleGLSL.cs,OnRenderFrame,The following statement contains a magic number: GL.VertexPointer(3' VertexPointerType.Float' 0' IntPtr.Zero);
Magic Number,Examples.Tutorial,T10_GLSL_Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\SimpleGLSL.cs,OnRenderFrame,The following statement contains a magic number: GL.ColorPointer(4' ColorPointerType.UnsignedByte' 0' IntPtr.Zero);
Magic Number,Examples.Tutorial,T10_GLSL_Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\SimpleGLSL.cs,Main,The following statement contains a magic number: using (T10_GLSL_Cube example = new T10_GLSL_Cube())              {                  // Get the title and category  of this example using reflection.                  ExampleAttribute info = ((ExampleAttribute)example.GetType().GetCustomAttributes(false)[0]);                  example.Title = String.Format("OpenTK | {0} {1}: {2}"' info.Category' info.Difficulty' info.Title);                  example.Run(30.0' 0.0);              }
Magic Number,Examples.Tutorial,SimpleGeometryShader,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShader.cs,OnLoad,The following statement contains a magic number: GL.Ext.ProgramParameter(shaderProgram' ExtGeometryShader4.GeometryVerticesOutExt' 50);
Magic Number,Examples.Tutorial,SimpleGeometryShader,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShader.cs,Main,The following statement contains a magic number: using (SimpleGeometryShader example = new SimpleGeometryShader())              {                  Utilities.SetWindowTitle(example);                  example.Run(30.0' 0.0);              }
Magic Number,Examples.Tutorial,T13_GLSL_Earth,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\DDSCubeMap.cs,OnLoad,The following statement contains a magic number: if (!GL.GetString(StringName.Extensions).Contains("GL_ARB_shading_language"))              {                  throw new NotSupportedException(String.Format("This example requires OpenGL 2.0. Found {0}. Aborting."'                      GL.GetString(StringName.Version).Substring(0' 3)));              }
Magic Number,Examples.Tutorial,T13_GLSL_Earth,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\DDSCubeMap.cs,Main,The following statement contains a magic number: using ( T13_GLSL_Earth example = new T13_GLSL_Earth( ) )              {                  Utilities.SetWindowTitle(example);                  example.Run( 30.0' 0.0 );              }
Magic Number,Examples.Tutorial,T12_GLSL_Parallax,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\SwizzledParallax.cs,OnLoad,The following statement contains a magic number: if ( !GL.GetString(StringName.Extensions).Contains("GL_ARB_shading_language"))              {                  throw new NotSupportedException(String.Format("This example requires OpenGL 2.0. Found {0}. Aborting."'                      GL.GetString(StringName.Version).Substring(0' 3)));              }
Magic Number,Examples.Tutorial,T12_GLSL_Parallax,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\SwizzledParallax.cs,OnUpdateFrame,The following statement contains a magic number: LightPosition.X = ( -( this.Width / 2 ) + Mouse.X ) / 100f;
Magic Number,Examples.Tutorial,T12_GLSL_Parallax,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\SwizzledParallax.cs,OnUpdateFrame,The following statement contains a magic number: LightPosition.Y = ( ( this.Height / 2 ) - Mouse.Y ) / 100f;
Magic Number,Examples.Tutorial,T12_GLSL_Parallax,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\SwizzledParallax.cs,Main,The following statement contains a magic number: using ( T12_GLSL_Parallax example = new T12_GLSL_Parallax( ) )              {                  Utilities.SetWindowTitle( example );                  example.Run( 30.0' 0.0 );              }
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,initShaderProgramCubemap,The following statement contains a magic number: GL.Ext.ProgramParameter(shaderProgramCubemap' ExtGeometryShader4.GeometryVerticesOutExt' 18);
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,initTextureCube,The following statement contains a magic number: foreach (TextureTarget target in new TextureTarget[] {                  TextureTarget.TextureCubeMapPositiveX'                  TextureTarget.TextureCubeMapNegativeX'                  TextureTarget.TextureCubeMapPositiveY'                  TextureTarget.TextureCubeMapNegativeY'                  TextureTarget.TextureCubeMapPositiveZ'                  TextureTarget.TextureCubeMapNegativeZ'              })              {                  GL.TexImage2D(target' 0' PixelInternalFormat.Rgba8' 512' 512' 0' PixelFormat.Rgba' PixelType.UnsignedByte' IntPtr.Zero);              }
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,initTextureCube,The following statement contains a magic number: foreach (TextureTarget target in new TextureTarget[] {                  TextureTarget.TextureCubeMapPositiveX'                  TextureTarget.TextureCubeMapNegativeX'                  TextureTarget.TextureCubeMapPositiveY'                  TextureTarget.TextureCubeMapNegativeY'                  TextureTarget.TextureCubeMapPositiveZ'                  TextureTarget.TextureCubeMapNegativeZ'              })              {                  GL.TexImage2D(target' 0' PixelInternalFormat.Rgba8' 512' 512' 0' PixelFormat.Rgba' PixelType.UnsignedByte' IntPtr.Zero);              }
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,initTextureCube,The following statement contains a magic number: int[] queryinfo = new int[6];
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,initTextureCube,The following statement contains a magic number: GL.GetInteger(GetPName.MaxDrawBuffers' out queryinfo[2]);
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,initTextureCube,The following statement contains a magic number: GL.GetInteger(GetPName.Stereo' out queryinfo[3]);
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,initTextureCube,The following statement contains a magic number: GL.GetInteger(GetPName.Samples' out queryinfo[4]);
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,initTextureCube,The following statement contains a magic number: GL.GetInteger(GetPName.Doublebuffer' out queryinfo[5]);
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,initTextureCube,The following statement contains a magic number: Console.WriteLine("max. ColorBuffers: " + queryinfo[0] + " max. AuxBuffers: " + queryinfo[1] + " max. DrawBuffers: " + queryinfo[2] +                                 "\nStereo: " + queryinfo[3] + " Samples: " + queryinfo[4] + " DoubleBuffer: " + queryinfo[5]);
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,initTextureCube,The following statement contains a magic number: Console.WriteLine("max. ColorBuffers: " + queryinfo[0] + " max. AuxBuffers: " + queryinfo[1] + " max. DrawBuffers: " + queryinfo[2] +                                 "\nStereo: " + queryinfo[3] + " Samples: " + queryinfo[4] + " DoubleBuffer: " + queryinfo[5]);
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,initTextureCube,The following statement contains a magic number: Console.WriteLine("max. ColorBuffers: " + queryinfo[0] + " max. AuxBuffers: " + queryinfo[1] + " max. DrawBuffers: " + queryinfo[2] +                                 "\nStereo: " + queryinfo[3] + " Samples: " + queryinfo[4] + " DoubleBuffer: " + queryinfo[5]);
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,initTextureCube,The following statement contains a magic number: Console.WriteLine("max. ColorBuffers: " + queryinfo[0] + " max. AuxBuffers: " + queryinfo[1] + " max. DrawBuffers: " + queryinfo[2] +                                 "\nStereo: " + queryinfo[3] + " Samples: " + queryinfo[4] + " DoubleBuffer: " + queryinfo[5]);
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,initVBOCube,The following statement contains a magic number: vboCubeStride = 32;
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,initVBOSpere,The following statement contains a magic number: VertexPositionNormalTexture[] sphereVertices = CalculateSphereVertices(1' 1' 16' 16);
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,initVBOSpere,The following statement contains a magic number: VertexPositionNormalTexture[] sphereVertices = CalculateSphereVertices(1' 1' 16' 16);
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,initVBOSpere,The following statement contains a magic number: ushort[] sphereElements = CalculateSphereElements(1' 1' 16' 16);
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,initVBOSpere,The following statement contains a magic number: ushort[] sphereElements = CalculateSphereElements(1' 1' 16' 16);
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,renderCubeVBO,The following statement contains a magic number: GL.VertexPointer(3' VertexPointerType.Float' vboCubeStride' new IntPtr(0));
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,renderCubeVBO,The following statement contains a magic number: GL.TexCoordPointer(2' TexCoordPointerType.Float' vboCubeStride' new IntPtr(Vector3.SizeInBytes + Vector3.SizeInBytes));
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,renderSphereVBO,The following statement contains a magic number: GL.VertexPointer(3' VertexPointerType.Float' vboSphereStride' new IntPtr(0));
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,renderSphereVBO,The following statement contains a magic number: GL.TexCoordPointer(2' TexCoordPointerType.Float' vboSphereStride' new IntPtr(Vector3.SizeInBytes + Vector3.SizeInBytes));
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,renderSphereVBO,The following statement contains a magic number: GL.DrawElements(BeginMode.Triangles' 16 * 16 * 6' DrawElementsType.UnsignedShort' IntPtr.Zero);
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,renderSphereVBO,The following statement contains a magic number: GL.DrawElements(BeginMode.Triangles' 16 * 16 * 6' DrawElementsType.UnsignedShort' IntPtr.Zero);
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,renderSphereVBO,The following statement contains a magic number: GL.DrawElements(BeginMode.Triangles' 16 * 16 * 6' DrawElementsType.UnsignedShort' IntPtr.Zero);
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,renderCubemap,The following statement contains a magic number: {                  GL.Viewport(0' 0' 512' 512);                    // clear all cubemap faces to blue                  GL.ClearColor(0f' 0f' 1f' 0f);                  for (int i = 0; i < 6; i++)                  {                      GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt' FramebufferAttachment.ColorAttachment0' TextureTarget.TextureCubeMapPositiveX + i' textureCubeColor' 0);                      //todo select depth renderbuffer face and trun depth_test on again                      GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);                  }                  GL.Ext.FramebufferTexture(FramebufferTarget.FramebufferExt' FramebufferAttachment.ColorAttachment0' textureCubeColor' 0);                  // Create 6 ModelViewProjection matrices' one to look in each direction                  // proj with 90 degrees (1/2 pi) fov                  // translate negative to place cam insize sphere                  Matrix4 model = Matrix4.Scale(-1) * Matrix4.CreateTranslation(spherePos);                  Matrix4 proj = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver2' 1' 0.1f' 100f);                    Matrix4[] m = new Matrix4[6];                    m[0] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitX' -Vector3.UnitY) * proj;                  m[1] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitX' -Vector3.UnitY) * proj;                  m[2] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitY' Vector3.UnitZ) * proj;                  m[3] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitY' -Vector3.UnitZ) * proj;                  m[4] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitZ' -Vector3.UnitY) * proj;                  m[5] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitZ' -Vector3.UnitY) * proj;                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPX")' false' ref m[0]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNX")' false' ref m[1]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPY")' false' ref m[2]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNY")' false' ref m[3]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPZ")' false' ref m[4]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNZ")' false' ref m[5]);                      renderCubeVBO();              }
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,renderCubemap,The following statement contains a magic number: {                  GL.Viewport(0' 0' 512' 512);                    // clear all cubemap faces to blue                  GL.ClearColor(0f' 0f' 1f' 0f);                  for (int i = 0; i < 6; i++)                  {                      GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt' FramebufferAttachment.ColorAttachment0' TextureTarget.TextureCubeMapPositiveX + i' textureCubeColor' 0);                      //todo select depth renderbuffer face and trun depth_test on again                      GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);                  }                  GL.Ext.FramebufferTexture(FramebufferTarget.FramebufferExt' FramebufferAttachment.ColorAttachment0' textureCubeColor' 0);                  // Create 6 ModelViewProjection matrices' one to look in each direction                  // proj with 90 degrees (1/2 pi) fov                  // translate negative to place cam insize sphere                  Matrix4 model = Matrix4.Scale(-1) * Matrix4.CreateTranslation(spherePos);                  Matrix4 proj = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver2' 1' 0.1f' 100f);                    Matrix4[] m = new Matrix4[6];                    m[0] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitX' -Vector3.UnitY) * proj;                  m[1] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitX' -Vector3.UnitY) * proj;                  m[2] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitY' Vector3.UnitZ) * proj;                  m[3] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitY' -Vector3.UnitZ) * proj;                  m[4] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitZ' -Vector3.UnitY) * proj;                  m[5] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitZ' -Vector3.UnitY) * proj;                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPX")' false' ref m[0]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNX")' false' ref m[1]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPY")' false' ref m[2]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNY")' false' ref m[3]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPZ")' false' ref m[4]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNZ")' false' ref m[5]);                      renderCubeVBO();              }
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,renderCubemap,The following statement contains a magic number: {                  GL.Viewport(0' 0' 512' 512);                    // clear all cubemap faces to blue                  GL.ClearColor(0f' 0f' 1f' 0f);                  for (int i = 0; i < 6; i++)                  {                      GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt' FramebufferAttachment.ColorAttachment0' TextureTarget.TextureCubeMapPositiveX + i' textureCubeColor' 0);                      //todo select depth renderbuffer face and trun depth_test on again                      GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);                  }                  GL.Ext.FramebufferTexture(FramebufferTarget.FramebufferExt' FramebufferAttachment.ColorAttachment0' textureCubeColor' 0);                  // Create 6 ModelViewProjection matrices' one to look in each direction                  // proj with 90 degrees (1/2 pi) fov                  // translate negative to place cam insize sphere                  Matrix4 model = Matrix4.Scale(-1) * Matrix4.CreateTranslation(spherePos);                  Matrix4 proj = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver2' 1' 0.1f' 100f);                    Matrix4[] m = new Matrix4[6];                    m[0] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitX' -Vector3.UnitY) * proj;                  m[1] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitX' -Vector3.UnitY) * proj;                  m[2] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitY' Vector3.UnitZ) * proj;                  m[3] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitY' -Vector3.UnitZ) * proj;                  m[4] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitZ' -Vector3.UnitY) * proj;                  m[5] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitZ' -Vector3.UnitY) * proj;                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPX")' false' ref m[0]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNX")' false' ref m[1]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPY")' false' ref m[2]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNY")' false' ref m[3]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPZ")' false' ref m[4]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNZ")' false' ref m[5]);                      renderCubeVBO();              }
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,renderCubemap,The following statement contains a magic number: {                  GL.Viewport(0' 0' 512' 512);                    // clear all cubemap faces to blue                  GL.ClearColor(0f' 0f' 1f' 0f);                  for (int i = 0; i < 6; i++)                  {                      GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt' FramebufferAttachment.ColorAttachment0' TextureTarget.TextureCubeMapPositiveX + i' textureCubeColor' 0);                      //todo select depth renderbuffer face and trun depth_test on again                      GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);                  }                  GL.Ext.FramebufferTexture(FramebufferTarget.FramebufferExt' FramebufferAttachment.ColorAttachment0' textureCubeColor' 0);                  // Create 6 ModelViewProjection matrices' one to look in each direction                  // proj with 90 degrees (1/2 pi) fov                  // translate negative to place cam insize sphere                  Matrix4 model = Matrix4.Scale(-1) * Matrix4.CreateTranslation(spherePos);                  Matrix4 proj = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver2' 1' 0.1f' 100f);                    Matrix4[] m = new Matrix4[6];                    m[0] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitX' -Vector3.UnitY) * proj;                  m[1] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitX' -Vector3.UnitY) * proj;                  m[2] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitY' Vector3.UnitZ) * proj;                  m[3] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitY' -Vector3.UnitZ) * proj;                  m[4] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitZ' -Vector3.UnitY) * proj;                  m[5] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitZ' -Vector3.UnitY) * proj;                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPX")' false' ref m[0]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNX")' false' ref m[1]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPY")' false' ref m[2]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNY")' false' ref m[3]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPZ")' false' ref m[4]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNZ")' false' ref m[5]);                      renderCubeVBO();              }
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,renderCubemap,The following statement contains a magic number: {                  GL.Viewport(0' 0' 512' 512);                    // clear all cubemap faces to blue                  GL.ClearColor(0f' 0f' 1f' 0f);                  for (int i = 0; i < 6; i++)                  {                      GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt' FramebufferAttachment.ColorAttachment0' TextureTarget.TextureCubeMapPositiveX + i' textureCubeColor' 0);                      //todo select depth renderbuffer face and trun depth_test on again                      GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);                  }                  GL.Ext.FramebufferTexture(FramebufferTarget.FramebufferExt' FramebufferAttachment.ColorAttachment0' textureCubeColor' 0);                  // Create 6 ModelViewProjection matrices' one to look in each direction                  // proj with 90 degrees (1/2 pi) fov                  // translate negative to place cam insize sphere                  Matrix4 model = Matrix4.Scale(-1) * Matrix4.CreateTranslation(spherePos);                  Matrix4 proj = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver2' 1' 0.1f' 100f);                    Matrix4[] m = new Matrix4[6];                    m[0] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitX' -Vector3.UnitY) * proj;                  m[1] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitX' -Vector3.UnitY) * proj;                  m[2] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitY' Vector3.UnitZ) * proj;                  m[3] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitY' -Vector3.UnitZ) * proj;                  m[4] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitZ' -Vector3.UnitY) * proj;                  m[5] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitZ' -Vector3.UnitY) * proj;                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPX")' false' ref m[0]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNX")' false' ref m[1]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPY")' false' ref m[2]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNY")' false' ref m[3]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPZ")' false' ref m[4]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNZ")' false' ref m[5]);                      renderCubeVBO();              }
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,renderCubemap,The following statement contains a magic number: {                  GL.Viewport(0' 0' 512' 512);                    // clear all cubemap faces to blue                  GL.ClearColor(0f' 0f' 1f' 0f);                  for (int i = 0; i < 6; i++)                  {                      GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt' FramebufferAttachment.ColorAttachment0' TextureTarget.TextureCubeMapPositiveX + i' textureCubeColor' 0);                      //todo select depth renderbuffer face and trun depth_test on again                      GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);                  }                  GL.Ext.FramebufferTexture(FramebufferTarget.FramebufferExt' FramebufferAttachment.ColorAttachment0' textureCubeColor' 0);                  // Create 6 ModelViewProjection matrices' one to look in each direction                  // proj with 90 degrees (1/2 pi) fov                  // translate negative to place cam insize sphere                  Matrix4 model = Matrix4.Scale(-1) * Matrix4.CreateTranslation(spherePos);                  Matrix4 proj = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver2' 1' 0.1f' 100f);                    Matrix4[] m = new Matrix4[6];                    m[0] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitX' -Vector3.UnitY) * proj;                  m[1] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitX' -Vector3.UnitY) * proj;                  m[2] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitY' Vector3.UnitZ) * proj;                  m[3] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitY' -Vector3.UnitZ) * proj;                  m[4] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitZ' -Vector3.UnitY) * proj;                  m[5] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitZ' -Vector3.UnitY) * proj;                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPX")' false' ref m[0]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNX")' false' ref m[1]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPY")' false' ref m[2]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNY")' false' ref m[3]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPZ")' false' ref m[4]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNZ")' false' ref m[5]);                      renderCubeVBO();              }
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,renderCubemap,The following statement contains a magic number: {                  GL.Viewport(0' 0' 512' 512);                    // clear all cubemap faces to blue                  GL.ClearColor(0f' 0f' 1f' 0f);                  for (int i = 0; i < 6; i++)                  {                      GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt' FramebufferAttachment.ColorAttachment0' TextureTarget.TextureCubeMapPositiveX + i' textureCubeColor' 0);                      //todo select depth renderbuffer face and trun depth_test on again                      GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);                  }                  GL.Ext.FramebufferTexture(FramebufferTarget.FramebufferExt' FramebufferAttachment.ColorAttachment0' textureCubeColor' 0);                  // Create 6 ModelViewProjection matrices' one to look in each direction                  // proj with 90 degrees (1/2 pi) fov                  // translate negative to place cam insize sphere                  Matrix4 model = Matrix4.Scale(-1) * Matrix4.CreateTranslation(spherePos);                  Matrix4 proj = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver2' 1' 0.1f' 100f);                    Matrix4[] m = new Matrix4[6];                    m[0] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitX' -Vector3.UnitY) * proj;                  m[1] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitX' -Vector3.UnitY) * proj;                  m[2] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitY' Vector3.UnitZ) * proj;                  m[3] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitY' -Vector3.UnitZ) * proj;                  m[4] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitZ' -Vector3.UnitY) * proj;                  m[5] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitZ' -Vector3.UnitY) * proj;                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPX")' false' ref m[0]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNX")' false' ref m[1]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPY")' false' ref m[2]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNY")' false' ref m[3]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPZ")' false' ref m[4]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNZ")' false' ref m[5]);                      renderCubeVBO();              }
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,renderCubemap,The following statement contains a magic number: {                  GL.Viewport(0' 0' 512' 512);                    // clear all cubemap faces to blue                  GL.ClearColor(0f' 0f' 1f' 0f);                  for (int i = 0; i < 6; i++)                  {                      GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt' FramebufferAttachment.ColorAttachment0' TextureTarget.TextureCubeMapPositiveX + i' textureCubeColor' 0);                      //todo select depth renderbuffer face and trun depth_test on again                      GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);                  }                  GL.Ext.FramebufferTexture(FramebufferTarget.FramebufferExt' FramebufferAttachment.ColorAttachment0' textureCubeColor' 0);                  // Create 6 ModelViewProjection matrices' one to look in each direction                  // proj with 90 degrees (1/2 pi) fov                  // translate negative to place cam insize sphere                  Matrix4 model = Matrix4.Scale(-1) * Matrix4.CreateTranslation(spherePos);                  Matrix4 proj = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver2' 1' 0.1f' 100f);                    Matrix4[] m = new Matrix4[6];                    m[0] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitX' -Vector3.UnitY) * proj;                  m[1] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitX' -Vector3.UnitY) * proj;                  m[2] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitY' Vector3.UnitZ) * proj;                  m[3] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitY' -Vector3.UnitZ) * proj;                  m[4] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitZ' -Vector3.UnitY) * proj;                  m[5] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitZ' -Vector3.UnitY) * proj;                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPX")' false' ref m[0]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNX")' false' ref m[1]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPY")' false' ref m[2]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNY")' false' ref m[3]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPZ")' false' ref m[4]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNZ")' false' ref m[5]);                      renderCubeVBO();              }
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,renderCubemap,The following statement contains a magic number: {                  GL.Viewport(0' 0' 512' 512);                    // clear all cubemap faces to blue                  GL.ClearColor(0f' 0f' 1f' 0f);                  for (int i = 0; i < 6; i++)                  {                      GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt' FramebufferAttachment.ColorAttachment0' TextureTarget.TextureCubeMapPositiveX + i' textureCubeColor' 0);                      //todo select depth renderbuffer face and trun depth_test on again                      GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);                  }                  GL.Ext.FramebufferTexture(FramebufferTarget.FramebufferExt' FramebufferAttachment.ColorAttachment0' textureCubeColor' 0);                  // Create 6 ModelViewProjection matrices' one to look in each direction                  // proj with 90 degrees (1/2 pi) fov                  // translate negative to place cam insize sphere                  Matrix4 model = Matrix4.Scale(-1) * Matrix4.CreateTranslation(spherePos);                  Matrix4 proj = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver2' 1' 0.1f' 100f);                    Matrix4[] m = new Matrix4[6];                    m[0] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitX' -Vector3.UnitY) * proj;                  m[1] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitX' -Vector3.UnitY) * proj;                  m[2] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitY' Vector3.UnitZ) * proj;                  m[3] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitY' -Vector3.UnitZ) * proj;                  m[4] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitZ' -Vector3.UnitY) * proj;                  m[5] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitZ' -Vector3.UnitY) * proj;                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPX")' false' ref m[0]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNX")' false' ref m[1]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPY")' false' ref m[2]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNY")' false' ref m[3]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPZ")' false' ref m[4]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNZ")' false' ref m[5]);                      renderCubeVBO();              }
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,renderCubemap,The following statement contains a magic number: {                  GL.Viewport(0' 0' 512' 512);                    // clear all cubemap faces to blue                  GL.ClearColor(0f' 0f' 1f' 0f);                  for (int i = 0; i < 6; i++)                  {                      GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt' FramebufferAttachment.ColorAttachment0' TextureTarget.TextureCubeMapPositiveX + i' textureCubeColor' 0);                      //todo select depth renderbuffer face and trun depth_test on again                      GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);                  }                  GL.Ext.FramebufferTexture(FramebufferTarget.FramebufferExt' FramebufferAttachment.ColorAttachment0' textureCubeColor' 0);                  // Create 6 ModelViewProjection matrices' one to look in each direction                  // proj with 90 degrees (1/2 pi) fov                  // translate negative to place cam insize sphere                  Matrix4 model = Matrix4.Scale(-1) * Matrix4.CreateTranslation(spherePos);                  Matrix4 proj = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver2' 1' 0.1f' 100f);                    Matrix4[] m = new Matrix4[6];                    m[0] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitX' -Vector3.UnitY) * proj;                  m[1] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitX' -Vector3.UnitY) * proj;                  m[2] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitY' Vector3.UnitZ) * proj;                  m[3] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitY' -Vector3.UnitZ) * proj;                  m[4] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitZ' -Vector3.UnitY) * proj;                  m[5] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitZ' -Vector3.UnitY) * proj;                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPX")' false' ref m[0]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNX")' false' ref m[1]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPY")' false' ref m[2]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNY")' false' ref m[3]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPZ")' false' ref m[4]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNZ")' false' ref m[5]);                      renderCubeVBO();              }
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,renderCubemap,The following statement contains a magic number: {                  GL.Viewport(0' 0' 512' 512);                    // clear all cubemap faces to blue                  GL.ClearColor(0f' 0f' 1f' 0f);                  for (int i = 0; i < 6; i++)                  {                      GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt' FramebufferAttachment.ColorAttachment0' TextureTarget.TextureCubeMapPositiveX + i' textureCubeColor' 0);                      //todo select depth renderbuffer face and trun depth_test on again                      GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);                  }                  GL.Ext.FramebufferTexture(FramebufferTarget.FramebufferExt' FramebufferAttachment.ColorAttachment0' textureCubeColor' 0);                  // Create 6 ModelViewProjection matrices' one to look in each direction                  // proj with 90 degrees (1/2 pi) fov                  // translate negative to place cam insize sphere                  Matrix4 model = Matrix4.Scale(-1) * Matrix4.CreateTranslation(spherePos);                  Matrix4 proj = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver2' 1' 0.1f' 100f);                    Matrix4[] m = new Matrix4[6];                    m[0] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitX' -Vector3.UnitY) * proj;                  m[1] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitX' -Vector3.UnitY) * proj;                  m[2] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitY' Vector3.UnitZ) * proj;                  m[3] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitY' -Vector3.UnitZ) * proj;                  m[4] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitZ' -Vector3.UnitY) * proj;                  m[5] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitZ' -Vector3.UnitY) * proj;                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPX")' false' ref m[0]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNX")' false' ref m[1]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPY")' false' ref m[2]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNY")' false' ref m[3]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPZ")' false' ref m[4]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNZ")' false' ref m[5]);                      renderCubeVBO();              }
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,renderCubemap,The following statement contains a magic number: {                  GL.Viewport(0' 0' 512' 512);                    // clear all cubemap faces to blue                  GL.ClearColor(0f' 0f' 1f' 0f);                  for (int i = 0; i < 6; i++)                  {                      GL.Ext.FramebufferTexture2D(FramebufferTarget.FramebufferExt' FramebufferAttachment.ColorAttachment0' TextureTarget.TextureCubeMapPositiveX + i' textureCubeColor' 0);                      //todo select depth renderbuffer face and trun depth_test on again                      GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);                  }                  GL.Ext.FramebufferTexture(FramebufferTarget.FramebufferExt' FramebufferAttachment.ColorAttachment0' textureCubeColor' 0);                  // Create 6 ModelViewProjection matrices' one to look in each direction                  // proj with 90 degrees (1/2 pi) fov                  // translate negative to place cam insize sphere                  Matrix4 model = Matrix4.Scale(-1) * Matrix4.CreateTranslation(spherePos);                  Matrix4 proj = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver2' 1' 0.1f' 100f);                    Matrix4[] m = new Matrix4[6];                    m[0] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitX' -Vector3.UnitY) * proj;                  m[1] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitX' -Vector3.UnitY) * proj;                  m[2] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitY' Vector3.UnitZ) * proj;                  m[3] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitY' -Vector3.UnitZ) * proj;                  m[4] = model * Matrix4.LookAt(Vector3.Zero' Vector3.UnitZ' -Vector3.UnitY) * proj;                  m[5] = model * Matrix4.LookAt(Vector3.Zero' -Vector3.UnitZ' -Vector3.UnitY) * proj;                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPX")' false' ref m[0]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNX")' false' ref m[1]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPY")' false' ref m[2]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNY")' false' ref m[3]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixPZ")' false' ref m[4]);                  GL.UniformMatrix4(GL.GetUniformLocation(shaderProgramCubemap' "matrixNZ")' false' ref m[5]);                      renderCubeVBO();              }
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,OnUpdateFrame,The following statement contains a magic number: spherePos.X = (float)Math.Sin(elapsed / 5000) * 3;
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,OnUpdateFrame,The following statement contains a magic number: spherePos.X = (float)Math.Sin(elapsed / 5000) * 3;
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,OnUpdateFrame,The following statement contains a magic number: spherePos.Z = (float)Math.Cos(elapsed / 5000) * 3;
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,OnUpdateFrame,The following statement contains a magic number: spherePos.Z = (float)Math.Cos(elapsed / 5000) * 3;
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,OnUpdateFrame,The following statement contains a magic number: eyePos.X = (float)Math.Cos(elapsed / 3000) * 8;
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,OnUpdateFrame,The following statement contains a magic number: eyePos.X = (float)Math.Cos(elapsed / 3000) * 8;
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,OnUpdateFrame,The following statement contains a magic number: eyePos.Z = (float)Math.Sin(elapsed / 2000) * 8;
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,OnUpdateFrame,The following statement contains a magic number: eyePos.Z = (float)Math.Sin(elapsed / 2000) * 8;
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,Main,The following statement contains a magic number: using (SimpleGeometryShader2 example = new SimpleGeometryShader2())              {                  Utilities.SetWindowTitle(example);                  example.Run(60.0' 0.0);              }
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,CalculateSphereVertices,The following statement contains a magic number: for (double y = 0; y < rings; y++)              {                  double phi = (y / (rings - 1)) * Math.PI;                  for (double x = 0; x < segments; x++)                  {                      double theta = (x / (segments - 1)) * 2 * Math.PI;                        Vector3 v = new Vector3(                          (float)(radius * Math.Sin(phi) * Math.Cos(theta))'                          (float)(height * Math.Cos(phi))'                          (float)(radius * Math.Sin(phi) * Math.Sin(theta)));                      Vector3 n = Vector3.Normalize(v);                      Vector2 uv = new Vector2(                          (float)(x / (segments - 1))'                          (float)(y / (rings - 1)));                      // Using data[i++] causes i to be incremented multiple times in Mono 2.2 (bug #479506).                      data[i] = new VertexPositionNormalTexture(v' n' uv);                      i++;                  }                }
Magic Number,Examples.Tutorial,SimpleGeometryShader2,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\GeometryShaderAdvanced.cs,CalculateSphereElements,The following statement contains a magic number: ushort[] data = new ushort[num_vertices * 6];
Magic Number,Examples.Tutorial,JuliaSetFractal,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\JuliaSetFractal.cs,OnLoad,The following statement contains a magic number: Version version = new Version(GL.GetString(StringName.Version).Substring(0' 3));
Magic Number,Examples.Tutorial,JuliaSetFractal,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\JuliaSetFractal.cs,OnLoad,The following statement contains a magic number: Version target = new Version(2' 0);
Magic Number,Examples.Tutorial,JuliaSetFractal,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\JuliaSetFractal.cs,OnLoad,The following statement contains a magic number: string[] ShaderFilenames = new string[2];
Magic Number,Examples.Tutorial,JuliaSetFractal,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\2.x\JuliaSetFractal.cs,Main,The following statement contains a magic number: using (JuliaSetFractal example = new JuliaSetFractal())              {                  Utilities.SetWindowTitle(example);                  example.Run(30.0);              }
Magic Number,Examples.Tutorial,HelloGL3,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\3.x\HelloGL3.cs,CreateShaders,The following statement contains a magic number: Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4' aspectRatio' 1' 100' out projectionMatrix);
Magic Number,Examples.Tutorial,HelloGL3,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\3.x\HelloGL3.cs,CreateShaders,The following statement contains a magic number: Matrix4.CreatePerspectiveFieldOfView((float)Math.PI / 4' aspectRatio' 1' 100' out projectionMatrix);
Magic Number,Examples.Tutorial,HelloGL3,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\3.x\HelloGL3.cs,CreateShaders,The following statement contains a magic number: modelviewMatrix = Matrix4.LookAt(new Vector3(0' 3' 5)' new Vector3(0' 0' 0)' new Vector3(0' 1' 0));
Magic Number,Examples.Tutorial,HelloGL3,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\3.x\HelloGL3.cs,CreateShaders,The following statement contains a magic number: modelviewMatrix = Matrix4.LookAt(new Vector3(0' 3' 5)' new Vector3(0' 0' 0)' new Vector3(0' 1' 0));
Magic Number,Examples.Tutorial,HelloGL3,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\3.x\HelloGL3.cs,CreateVAOs,The following statement contains a magic number: GL.VertexAttribPointer(0' 3' VertexAttribPointerType.Float' true' Vector3.SizeInBytes' 0);
Magic Number,Examples.Tutorial,HelloGL3,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\3.x\HelloGL3.cs,CreateVAOs,The following statement contains a magic number: GL.VertexAttribPointer(1' 3' VertexAttribPointerType.Float' true' Vector3.SizeInBytes' 0);
Magic Number,Examples.Tutorial,HelloGL3,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\3.x\HelloGL3.cs,Main,The following statement contains a magic number: using (HelloGL3 example = new HelloGL3())              {                  Utilities.SetWindowTitle(example);                  example.Run(30);              }
Magic Number,Examples.Tutorial,SimpleES20Window,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGLES\2.0\SimpleWindow20.cs,Main,The following statement contains a magic number: using (SimpleES20Window example = new SimpleES20Window())              {                  Utilities.SetWindowTitle(example);                  example.Run(30.0' 0.0);              }
Magic Number,Examples.Tutorial,SimpleES11Window,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGLES\1.1\SimpleWindow.cs,OnResize,The following statement contains a magic number: OpenTK.Matrix4 perspective = OpenTK.Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4' (float)aspect_ratio' 1' 64);
Magic Number,Examples.Tutorial,SimpleES11Window,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGLES\1.1\SimpleWindow.cs,OnRenderFrame,The following statement contains a magic number: Matrix4 lookat = Matrix4.LookAt(0' 5' 5' 0' 0' 0' 0' 1' 0);
Magic Number,Examples.Tutorial,SimpleES11Window,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGLES\1.1\SimpleWindow.cs,OnRenderFrame,The following statement contains a magic number: Matrix4 lookat = Matrix4.LookAt(0' 5' 5' 0' 0' 0' 0' 1' 0);
Magic Number,Examples.Tutorial,SimpleES11Window,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGLES\1.1\SimpleWindow.cs,Main,The following statement contains a magic number: using (SimpleES11Window example = new SimpleES11Window())              {                  Utilities.SetWindowTitle(example);                  example.Run(30.0' 0.0);              }
Magic Number,Examples.Tutorial,VertexPositionColor,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\VertexPositionColor.cs,ToRgba,The following statement contains a magic number: return (uint)color.A << 24 | (uint)color.B << 16 | (uint)color.G << 8 | (uint)color.R;
Magic Number,Examples.Tutorial,VertexPositionColor,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\VertexPositionColor.cs,ToRgba,The following statement contains a magic number: return (uint)color.A << 24 | (uint)color.B << 16 | (uint)color.G << 8 | (uint)color.R;
Magic Number,Examples.Tutorial,VertexPositionColor,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\VertexPositionColor.cs,ToRgba,The following statement contains a magic number: return (uint)color.A << 24 | (uint)color.B << 16 | (uint)color.G << 8 | (uint)color.R;
Magic Number,Examples.Tutorial,ThreadedRendering,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GameWindow\GameWindowThreaded.cs,RenderLoop,The following statement contains a magic number: for (int i = 0; i < 64; i++)              {                  Particle p = new Particle();                  p.Position = new Vector2((float)rand.NextDouble() * 2 - 1' (float)rand.NextDouble() * 2 - 1);                  p.Color.R = (float)rand.NextDouble();                  p.Color.G = (float)rand.NextDouble();                  p.Color.B = (float)rand.NextDouble();                  Particles.Add(p);              }
Magic Number,Examples.Tutorial,ThreadedRendering,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GameWindow\GameWindowThreaded.cs,RenderLoop,The following statement contains a magic number: for (int i = 0; i < 64; i++)              {                  Particle p = new Particle();                  p.Position = new Vector2((float)rand.NextDouble() * 2 - 1' (float)rand.NextDouble() * 2 - 1);                  p.Color.R = (float)rand.NextDouble();                  p.Color.G = (float)rand.NextDouble();                  p.Color.B = (float)rand.NextDouble();                  Particles.Add(p);              }
Magic Number,Examples.Tutorial,ThreadedRendering,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GameWindow\GameWindowThreaded.cs,RenderLoop,The following statement contains a magic number: for (int i = 0; i < 64; i++)              {                  Particle p = new Particle();                  p.Position = new Vector2((float)rand.NextDouble() * 2 - 1' (float)rand.NextDouble() * 2 - 1);                  p.Color.R = (float)rand.NextDouble();                  p.Color.G = (float)rand.NextDouble();                  p.Color.B = (float)rand.NextDouble();                  Particles.Add(p);              }
Magic Number,Examples.Tutorial,ThreadedRendering,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GameWindow\GameWindowThreaded.cs,RenderLoop,The following statement contains a magic number: GL.PointSize(16);
Magic Number,Examples.Tutorial,ThreadedRendering,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GameWindow\GameWindowThreaded.cs,Update,The following statement contains a magic number: lock (update_lock)              {                  // When the user moves the window we make the particles react to                  // this movement. The reaction is semi-random and not physically                  // correct. It looks quite good' however.                  if (position_changed)                  {                      for (int i = 0; i < Particles.Count; i++)                      {                          Particle p = Particles[i];                          p.Velocity += new Vector2(                              16 * (position_dx + 0.05f * (float)(rand.NextDouble() - 0.5))'                              32 * (position_dy + 0.05f * (float)(rand.NextDouble() - 0.5)));                          Particles[i] = p;                      }                        position_changed = false;                  }              }
Magic Number,Examples.Tutorial,ThreadedRendering,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GameWindow\GameWindowThreaded.cs,Update,The following statement contains a magic number: lock (update_lock)              {                  // When the user moves the window we make the particles react to                  // this movement. The reaction is semi-random and not physically                  // correct. It looks quite good' however.                  if (position_changed)                  {                      for (int i = 0; i < Particles.Count; i++)                      {                          Particle p = Particles[i];                          p.Velocity += new Vector2(                              16 * (position_dx + 0.05f * (float)(rand.NextDouble() - 0.5))'                              32 * (position_dy + 0.05f * (float)(rand.NextDouble() - 0.5)));                          Particles[i] = p;                      }                        position_changed = false;                  }              }
Magic Number,Examples.Tutorial,ThreadedRendering,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GameWindow\GameWindowThreaded.cs,Update,The following statement contains a magic number: lock (update_lock)              {                  // When the user moves the window we make the particles react to                  // this movement. The reaction is semi-random and not physically                  // correct. It looks quite good' however.                  if (position_changed)                  {                      for (int i = 0; i < Particles.Count; i++)                      {                          Particle p = Particles[i];                          p.Velocity += new Vector2(                              16 * (position_dx + 0.05f * (float)(rand.NextDouble() - 0.5))'                              32 * (position_dy + 0.05f * (float)(rand.NextDouble() - 0.5)));                          Particles[i] = p;                      }                        position_changed = false;                  }              }
Magic Number,Examples.Tutorial,ThreadedRendering,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GameWindow\GameWindowThreaded.cs,Update,The following statement contains a magic number: lock (update_lock)              {                  // When the user moves the window we make the particles react to                  // this movement. The reaction is semi-random and not physically                  // correct. It looks quite good' however.                  if (position_changed)                  {                      for (int i = 0; i < Particles.Count; i++)                      {                          Particle p = Particles[i];                          p.Velocity += new Vector2(                              16 * (position_dx + 0.05f * (float)(rand.NextDouble() - 0.5))'                              32 * (position_dy + 0.05f * (float)(rand.NextDouble() - 0.5)));                          Particles[i] = p;                      }                        position_changed = false;                  }              }
Magic Number,Examples.Tutorial,ThreadedRendering,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GameWindow\GameWindowThreaded.cs,Update,The following statement contains a magic number: for (int i = 0; i < Particles.Count; i++)              {                  Particle p = Particles[i];                    p.Velocity.X = Math.Abs(p.Position.X) >= 1 ?-p.Velocity.X * 0.92f : p.Velocity.X * 0.97f;                  p.Velocity.Y = Math.Abs(p.Position.Y) >= 1 ? -p.Velocity.Y * 0.92f : p.Velocity.Y * 0.97f;                  if (p.Position.Y > -0.99)                  {                      p.Velocity.Y += (float)(GravityAccel * time);                  }                  else                  {                      if (Math.Abs(p.Velocity.Y) < 0.02)                      {                          p.Velocity.Y = 0;                          p.Position.Y = -1;                      }                      else                      {                          p.Velocity.Y *= 0.9f;                      }                  }                    p.Position += p.Velocity * (float)time;                  if (p.Position.Y <= -1)                      p.Position.Y = -1;                    Particles[i] = p;              }
Magic Number,Examples.Tutorial,ThreadedRendering,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GameWindow\GameWindowThreaded.cs,Update,The following statement contains a magic number: for (int i = 0; i < Particles.Count; i++)              {                  Particle p = Particles[i];                    p.Velocity.X = Math.Abs(p.Position.X) >= 1 ?-p.Velocity.X * 0.92f : p.Velocity.X * 0.97f;                  p.Velocity.Y = Math.Abs(p.Position.Y) >= 1 ? -p.Velocity.Y * 0.92f : p.Velocity.Y * 0.97f;                  if (p.Position.Y > -0.99)                  {                      p.Velocity.Y += (float)(GravityAccel * time);                  }                  else                  {                      if (Math.Abs(p.Velocity.Y) < 0.02)                      {                          p.Velocity.Y = 0;                          p.Position.Y = -1;                      }                      else                      {                          p.Velocity.Y *= 0.9f;                      }                  }                    p.Position += p.Velocity * (float)time;                  if (p.Position.Y <= -1)                      p.Position.Y = -1;                    Particles[i] = p;              }
Magic Number,Examples.Tutorial,ThreadedRendering,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GameWindow\GameWindowThreaded.cs,Render,The following statement contains a magic number: Matrix4 perspective =                  Matrix4.CreateOrthographic(2' 2' -1' 1);
Magic Number,Examples.Tutorial,ThreadedRendering,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GameWindow\GameWindowThreaded.cs,Render,The following statement contains a magic number: Matrix4 perspective =                  Matrix4.CreateOrthographic(2' 2' -1' 1);
Magic Number,Examples.Tutorial,SimpleWindow,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GameWindow\GameWindowSimple.cs,OnResize,The following statement contains a magic number: GL.Ortho(-1.0' 1.0' -1.0' 1.0' 0.0' 4.0);
Magic Number,Examples.Tutorial,SimpleWindow,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GameWindow\GameWindowSimple.cs,Main,The following statement contains a magic number: using (SimpleWindow example = new SimpleWindow())              {                  // Get the title and category  of this example using reflection.                  Utilities.SetWindowTitle(example);                  example.Run(30.0' 0.0);              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,LoadFromDisk,The following statement contains a magic number: try // Exceptions will be thrown if any Problem occurs while working on the file.               {                  _RawDataFromFile = File.ReadAllBytes( @filename );                    #region Translate Header to less cryptic representation                  ConvertDX9Header( ref _RawDataFromFile ); // The first 128 Bytes of the file is non-image data                    // start by checking if all forced flags are present. Flags indicate valid fields' but aren't written by every tool .....                  if ( idString != "DDS " || // magic key                       dwSize != 124 || // constant size of struct' never reused                       pfSize != 32 || // constant size of struct' never reused                       !CheckFlag( dwFlags' (uint) eDDSD.CAPS ) ||        // must know it's caps                       !CheckFlag( dwFlags' (uint) eDDSD.PIXELFORMAT ) || // must know it's format                       !CheckFlag( dwCaps1' (uint) eDDSCAPS.TEXTURE )     // must be a Texture                      )                      throw new ArgumentException( "ERROR: File has invalid signature or missing Flags." );                    #region Examine Flags                  if ( CheckFlag( dwFlags' (uint) eDDSD.WIDTH ) )                      _Width = (int) dwWidth;                  else                      throw new ArgumentException( "ERROR: Flag for Width not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.HEIGHT ) )                      _Height = (int) dwHeight;                  else                      throw new ArgumentException( "ERROR: Flag for Height not set." );                    if ( CheckFlag( dwFlags' (uint) eDDSD.DEPTH ) && CheckFlag( dwCaps2' (uint) eDDSCAPS2.VOLUME ) )                  {                      dimension = TextureTarget.Texture3D; // image is 3D Volume                      _Depth = (int) dwDepth;                      throw Unfinished;                  } else                  {// image is 2D or Cube                      if ( CheckFlag( dwCaps2' (uint) eDDSCAPS2.CUBEMAP ) )                      {                          dimension = TextureTarget.TextureCubeMap;                          _Depth = 6;                      } else                      {                          dimension = TextureTarget.Texture2D;                          _Depth = 1;                      }                  }                    // these flags must be set for mipmaps to be included                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.MIPMAP ) && CheckFlag( dwFlags' (uint) eDDSD.MIPMAPCOUNT ) )                      _MipMapCount = (int) dwMipMapCount; // image contains MipMaps                  else                      _MipMapCount = 1; // only 1 main image                    // Should never happen                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) && CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                      throw new ArgumentException( "INVALID: Pitch AND Linear Flags both set. Image cannot be uncompressed and DTXn compressed at the same time." );                    // This flag is set if format is uncompressed RGB RGBA etc.                  if ( CheckFlag( dwFlags' (uint) eDDSD.PITCH ) )                  {                      // _BytesForMainSurface = (int) dwPitchOrLinearSize; // holds bytes-per-scanline for uncompressed                      _IsCompressed = false;                      throw Unfinished;                  }                    // This flag is set if format is compressed DXTn.                  if ( CheckFlag( dwFlags' (uint) eDDSD.LINEARSIZE ) )                  {                      _BytesForMainSurface = (int) dwPitchOrLinearSize;                      _IsCompressed = true;                  }                  #endregion Examine Flags                    #region Examine Pixel Format' anything but DXTn will fail atm.                  if ( CheckFlag( pfFlags' (uint) eDDPF.FOURCC ) )                      switch ( (eFOURCC) pfFourCC )                      {                      case eFOURCC.DXT1:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext;                          _BytesPerBlock = 8;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT2:                      case eFOURCC.DXT3:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      //case eFOURCC.DXT4:                      case eFOURCC.DXT5:                          _PixelInternalFormat = (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext;                          _BytesPerBlock = 16;                          _IsCompressed = true;                          break;                      default:                          throw Unfinished; // handle uncompressed formats                       } else                      throw Unfinished;                  // pf*Bitmasks should be examined here                  #endregion                    // Works' but commented out because some texture authoring tools don't set this flag.                  /* Safety Check' if file is only 1x 2D surface without mipmaps' eDDSCAPS.COMPLEX should not be set                  if ( CheckFlag( dwCaps1' (uint) eDDSCAPS.COMPLEX ) )                  {                      if ( result == eTextureDimension.Texture2D && _MipMapCount == 1 ) // catch potential problem                          Trace.WriteLine( "Warning: Image is declared complex' but contains only 1 surface." );                  }*/                    if ( TextureLoaderParameters.Verbose )                      Trace.WriteLine( "\n" + GetDescriptionFromMemory( filename' dimension ) );                  #endregion Translate Header to less cryptic representation                    #region send the Texture to GL                  #region Generate and Bind Handle                  GL.GenTextures( 1' out texturehandle );                  GL.BindTexture( dimension' texturehandle );                  #endregion Generate and Bind Handle                    int Cursor = HeaderSizeInBytes;                  // foreach face in the cubemap' get all it's mipmaps levels. Only one iteration for Texture2D                  for ( int Slices = 0 ; Slices < _Depth ; Slices++ )                  {                      int trueMipMapCount = _MipMapCount - 1; // TODO: triplecheck correctness                      int Width = _Width;                      int Height = _Height;                      for ( int Level = 0 ; Level < _MipMapCount ; Level++ ) // start at base image                      {                          #region determine Dimensions                          int BlocksPerRow = ( Width + 3 ) >> 2;                          int BlocksPerColumn = ( Height + 3 ) >> 2;                          int SurfaceBlockCount = BlocksPerRow * BlocksPerColumn; //   // DXTn stores Texels in 4x4 blocks' a Color block is 8 Bytes' an Alpha block is 8 Bytes for DXT3/5                          int SurfaceSizeInBytes = SurfaceBlockCount * _BytesPerBlock;                            // this check must evaluate to false for 2D and Cube maps' or it's impossible to determine MipMap sizes.                          if ( TextureLoaderParameters.Verbose && Level == 0 && _IsCompressed && _BytesForMainSurface != SurfaceSizeInBytes )                              Trace.WriteLine( "Warning: Calculated byte-count of main image differs from what was read from file." );                          #endregion determine Dimensions                            // skip mipmaps smaller than a 4x4 Pixels block' which is the smallest DXTn unit.                          if ( Width > 2 && Height > 2 )                          { // Note: there could be a potential problem with non-power-of-two cube maps                              #region Prepare Array for TexImage                              byte[] RawDataOfSurface = new byte[SurfaceSizeInBytes];                              if ( !TextureLoaderParameters.FlipImages )                              { // no changes to the image' copy as is                                  Array.Copy( _RawDataFromFile' Cursor' RawDataOfSurface' 0' SurfaceSizeInBytes );                              } else                              {  // Turn the blocks upside down and the rows aswell' done in a single pass through all blocks                                  for ( int sourceColumn = 0 ; sourceColumn < BlocksPerColumn ; sourceColumn++ )                                  {                                      int targetColumn = BlocksPerColumn - sourceColumn - 1;                                      for ( int row = 0 ; row < BlocksPerRow ; row++ )                                      {                                          int target = ( targetColumn * BlocksPerRow + row ) * _BytesPerBlock;                                          int source = ( sourceColumn * BlocksPerRow + row ) * _BytesPerBlock + Cursor;                                          #region Swap Bytes                                          switch ( _PixelInternalFormat )                                          {                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbS3tcDxt1Ext:                                              // Color only                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 4];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt3Ext:                                              // Alpha                                              RawDataOfSurface[target + 0] = _RawDataFromFile[source + 6];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 7];                                              RawDataOfSurface[target + 2] = _RawDataFromFile[source + 4];                                              RawDataOfSurface[target + 3] = _RawDataFromFile[source + 5];                                              RawDataOfSurface[target + 4] = _RawDataFromFile[source + 2];                                              RawDataOfSurface[target + 5] = _RawDataFromFile[source + 3];                                              RawDataOfSurface[target + 6] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 7] = _RawDataFromFile[source + 1];                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          case (PixelInternalFormat) ExtTextureCompressionS3tc.CompressedRgbaS3tcDxt5Ext:                                              // Alpha' the first 2 bytes remain                                               RawDataOfSurface[target + 0] = _RawDataFromFile[source + 0];                                              RawDataOfSurface[target + 1] = _RawDataFromFile[source + 1];                                                // extract 3 bits each and flip them                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 5' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 2 ) ) );                                              GetBytesFromUInt24( ref RawDataOfSurface' (uint) target + 2' FlipUInt24( GetUInt24( ref _RawDataFromFile' (uint) source + 5 ) ) );                                                // Color                                              RawDataOfSurface[target + 8] = _RawDataFromFile[source + 8];                                              RawDataOfSurface[target + 9] = _RawDataFromFile[source + 9];                                              RawDataOfSurface[target + 10] = _RawDataFromFile[source + 10];                                              RawDataOfSurface[target + 11] = _RawDataFromFile[source + 11];                                              RawDataOfSurface[target + 12] = _RawDataFromFile[source + 15];                                              RawDataOfSurface[target + 13] = _RawDataFromFile[source + 14];                                              RawDataOfSurface[target + 14] = _RawDataFromFile[source + 13];                                              RawDataOfSurface[target + 15] = _RawDataFromFile[source + 12];                                              break;                                          default:                                              throw new ArgumentException( "ERROR: Should have never arrived here! Bad _PixelInternalFormat! Should have been dealt with much earlier." );                                          }                                          #endregion Swap Bytes                                      }                                  }                              }                              #endregion Prepare Array for TexImage                                #region Create TexImage                              switch ( dimension )                              {                              case TextureTarget.Texture2D:                                  GL.CompressedTexImage2D( TextureTarget.Texture2D'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                          TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.CompressedTexImage2D( TextureTarget.TextureCubeMapPositiveX + Slices'                                                           Level'                                                           _PixelInternalFormat'                                                           Width'                                                           Height'                                                           TextureLoaderParameters.Border'                                                           SurfaceSizeInBytes'                                                           RawDataOfSurface );                                  break;                              case TextureTarget.Texture1D: // Untested                              case TextureTarget.Texture3D: // Untested                              default:                                  throw new ArgumentException( "ERROR: Use DXT for 2D Images only. Cannot evaluate " + dimension );                              }                              GL.Finish( );                              #endregion Create TexImage                                #region Query Success                              int width' height' internalformat' compressed;                              switch ( dimension )                              {                              case TextureTarget.Texture1D:                              case TextureTarget.Texture2D:                              case TextureTarget.Texture3D:                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( dimension' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              case TextureTarget.TextureCubeMap:                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureWidth' out width );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureHeight' out height );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureInternalFormat' out internalformat );                                  GL.GetTexLevelParameter( TextureTarget.TextureCubeMapPositiveX + Slices' Level' GetTextureParameter.TextureCompressed' out compressed );                                  break;                              default:                                  throw Unfinished;                              }                              GLError = GL.GetError( );                              if ( TextureLoaderParameters.Verbose )                                  Trace.WriteLine( "GL: " + GLError.ToString( ) + " Level: " + Level + " DXTn: " + ( ( compressed == 1 ) ? "Yes" : "No" ) + " Frmt:" + (ExtTextureCompressionS3tc) internalformat + " " + width + "*" + height );                              if ( GLError != ErrorCode.NoError || compressed == 0 || width == 0 || height == 0 || internalformat == 0 )                              {                                  GL.DeleteTextures( 1' ref texturehandle );                                  throw new ArgumentException( "ERROR: Something went wrong after GL.CompressedTexImage(); Last GL Error: " + GLError.ToString( ) );                              }                              #endregion Query Success                          } else                          {                              if ( trueMipMapCount > Level )                                  trueMipMapCount = Level - 1; // The current Level is invalid                          }                            #region Prepare the next MipMap level                          Width /= 2;                          if ( Width < 1 )                              Width = 1;                          Height /= 2;                          if ( Height < 1 )                              Height = 1;                          Cursor += SurfaceSizeInBytes;                          #endregion Prepare the next MipMap level                      }                        #region Set States properly                      GL.TexParameter( dimension' (TextureParameterName) All.TextureBaseLevel' 0 );                      GL.TexParameter( dimension' (TextureParameterName) All.TextureMaxLevel' trueMipMapCount );                        int TexMaxLevel;                      GL.GetTexParameter( dimension' GetTextureParameter.TextureMaxLevel' out TexMaxLevel );                        if ( TextureLoaderParameters.Verbose )                          Trace.WriteLine( "Verification: GL: " + GL.GetError( ).ToString( ) + " TextureMaxLevel: " + TexMaxLevel + ( ( TexMaxLevel == trueMipMapCount ) ? " (Correct.)" : " (Wrong!)" ) );                      #endregion Set States properly                  }                    #region Set Texture Parameters                  GL.TexParameter( dimension' TextureParameterName.TextureMinFilter' (int) TextureLoaderParameters.MinificationFilter );                  GL.TexParameter( dimension' TextureParameterName.TextureMagFilter' (int) TextureLoaderParameters.MagnificationFilter );                    GL.TexParameter( dimension' TextureParameterName.TextureWrapS' (int) TextureLoaderParameters.WrapModeS );                  GL.TexParameter( dimension' TextureParameterName.TextureWrapT' (int) TextureLoaderParameters.WrapModeT );                    GL.TexEnv( TextureEnvTarget.TextureEnv' TextureEnvParameter.TextureEnvMode' (int) TextureLoaderParameters.EnvMode );                    GLError = GL.GetError( );                  if ( GLError != ErrorCode.NoError )                  {                      throw new ArgumentException( "Error setting Texture Parameters. GL Error: " + GLError );                  }                  #endregion Set Texture Parameters                    // If it made it here without throwing any Exception the result is a valid Texture.                  return; // success                  #endregion send the Texture to GL              } catch ( Exception e )              {                  dimension = (TextureTarget) 0;                  texturehandle = TextureLoaderParameters.OpenGLDefaultTexture;                  throw new ArgumentException( "ERROR: Exception caught when attempting to load file " + filename + ".\n" + e + "\n" + GetDescriptionFromFile( filename ) );                  // return; // failure              } finally              {                  _RawDataFromFile = null; // clarity' not really needed              }
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4 * 11;
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4 * 11;
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 20;
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4;
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4 * 3;
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,ConvertDX9Header,The following statement contains a magic number: offset += 4 * 3;
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,GetString,The following statement contains a magic number: return "" + (char) input[offset + 0] + (char) input[offset + 1] + (char) input[offset + 2] + (char) input[offset + 3];
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,GetString,The following statement contains a magic number: return "" + (char) input[offset + 0] + (char) input[offset + 1] + (char) input[offset + 2] + (char) input[offset + 3];
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,GetUInt32,The following statement contains a magic number: return (uint) ( ( ( input[offset + 3] * 256 + input[offset + 2] ) * 256 + input[offset + 1] ) * 256 + input[offset + 0] );
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,GetUInt32,The following statement contains a magic number: return (uint) ( ( ( input[offset + 3] * 256 + input[offset + 2] ) * 256 + input[offset + 1] ) * 256 + input[offset + 0] );
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,GetUInt32,The following statement contains a magic number: return (uint) ( ( ( input[offset + 3] * 256 + input[offset + 2] ) * 256 + input[offset + 1] ) * 256 + input[offset + 0] );
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,GetUInt32,The following statement contains a magic number: return (uint) ( ( ( input[offset + 3] * 256 + input[offset + 2] ) * 256 + input[offset + 1] ) * 256 + input[offset + 0] );
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,GetUInt32,The following statement contains a magic number: return (uint) ( ( ( input[offset + 3] * 256 + input[offset + 2] ) * 256 + input[offset + 1] ) * 256 + input[offset + 0] );
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,GetUInt24,The following statement contains a magic number: return (uint) ( ( input[offset + 2] * 256 + input[offset + 1] ) * 256 + input[offset + 0] );
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,GetUInt24,The following statement contains a magic number: return (uint) ( ( input[offset + 2] * 256 + input[offset + 1] ) * 256 + input[offset + 0] );
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,GetUInt24,The following statement contains a magic number: return (uint) ( ( input[offset + 2] * 256 + input[offset + 1] ) * 256 + input[offset + 0] );
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,GetBytesFromUInt24,The following statement contains a magic number: input[offset + 1] = (byte) ( ( splitme & 0x0000ff00 ) >> 8 );
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,GetBytesFromUInt24,The following statement contains a magic number: input[offset + 2] = (byte) ( ( splitme & 0x00ff0000 ) >> 16 );
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,GetBytesFromUInt24,The following statement contains a magic number: input[offset + 2] = (byte) ( ( splitme & 0x00ff0000 ) >> 16 );
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: byte[][] ThreeBits = new byte[2][];
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: for ( int i = 0 ; i < 2 ; i++ )                  ThreeBits[i] = new byte[4];
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: for ( int i = 0 ; i < 2 ; i++ )                  ThreeBits[i] = new byte[4];
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: ThreeBits[0][2] = (byte) ( inputUInt24 & BitMask );
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: ThreeBits[0][3] = (byte) ( inputUInt24 & BitMask );
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: ThreeBits[1][2] = (byte) ( inputUInt24 & BitMask );
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: inputUInt24 >>= 3;
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: ThreeBits[1][3] = (byte) ( inputUInt24 & BitMask );
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[1][1] << 3 );
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[1][2] << 6 );
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[1][2] << 6 );
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[1][3] << 9 );
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[1][3] << 9 );
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[0][0] << 12 );
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[0][1] << 15 );
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[0][2] << 18 );
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[0][2] << 18 );
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[0][3] << 21 );
Magic Number,Examples.TextureLoaders,ImageDDS,C:\repos\lachesis_scallion\opentk\Source\Examples\Utilities\LoaderDDS.cs,FlipUInt24,The following statement contains a magic number: Result = Result | (uint) ( ThreeBits[0][3] << 21 );
Magic Number,Examples.Shapes,MengerSponge,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\MengerSponge.cs,SubdivideMengerSponge,The following statement contains a magic number: output = new List<MengerCube>( input.Count * 20 );
Magic Number,Examples.Shapes,TorusKnot,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\TorusKnot.cs,TorusKnot,The following statement contains a magic number: for ( int i = 0; i < pathsteps; i++ )              {                  double Angle = ( i / (double)pathsteps ) * TwoPi;                  double AngleTimesP = Angle * p;                  double AngleTimesQ = Angle * q;                  double r = ( 0.5 * ( 2.0 + System.Math.Sin( AngleTimesQ ) ) );                    PathPositions[i] = new Vector3d( ( r * System.Math.Cos( AngleTimesP ) )'                                                   ( r * System.Math.Cos( AngleTimesQ ) )'                                                   ( r * System.Math.Sin( AngleTimesP ) ) );                }
Magic Number,Examples.Shapes,TorusKnot,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\TorusKnot.cs,TorusKnot,The following statement contains a magic number: for ( int i = 0; i < pathsteps; i++ )              {                  double Angle = ( i / (double)pathsteps ) * TwoPi;                  double AngleTimesP = Angle * p;                  double AngleTimesQ = Angle * q;                  double r = ( 0.5 * ( 2.0 + System.Math.Sin( AngleTimesQ ) ) );                    PathPositions[i] = new Vector3d( ( r * System.Math.Cos( AngleTimesP ) )'                                                   ( r * System.Math.Cos( AngleTimesQ ) )'                                                   ( r * System.Math.Sin( AngleTimesP ) ) );                }
Magic Number,Examples.Shapes,TorusKnot,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\TorusKnot.cs,TorusKnot,The following statement contains a magic number: IndexArray = new uint[pathsteps * ( shapevertices * 2 + 2 )];
Magic Number,Examples.Shapes,TorusKnot,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\TorusKnot.cs,TorusKnot,The following statement contains a magic number: IndexArray = new uint[pathsteps * ( shapevertices * 2 + 2 )];
Magic Number,Examples.Shapes,KochTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\KochTetrahedron.cs,SubdivideKoch,The following statement contains a magic number: output = new TetrahedronFace[input.Length * 6];
Magic Number,Examples.Shapes,KochTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\KochTetrahedron.cs,SubdivideKoch,The following statement contains a magic number: for ( int i = 0; i < input.Length; i++ )              {                  input[i].SubdivideKoch(height' out output[counter + 0]' out output[counter + 1]' out output[counter + 2]' out output[counter + 3]' out output[counter + 4]' out output[counter + 5] );                  counter += 6; // every source triangle emits 6 new triangles              }
Magic Number,Examples.Shapes,KochTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\KochTetrahedron.cs,SubdivideKoch,The following statement contains a magic number: for ( int i = 0; i < input.Length; i++ )              {                  input[i].SubdivideKoch(height' out output[counter + 0]' out output[counter + 1]' out output[counter + 2]' out output[counter + 3]' out output[counter + 4]' out output[counter + 5] );                  counter += 6; // every source triangle emits 6 new triangles              }
Magic Number,Examples.Shapes,KochTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\KochTetrahedron.cs,SubdivideKoch,The following statement contains a magic number: for ( int i = 0; i < input.Length; i++ )              {                  input[i].SubdivideKoch(height' out output[counter + 0]' out output[counter + 1]' out output[counter + 2]' out output[counter + 3]' out output[counter + 4]' out output[counter + 5] );                  counter += 6; // every source triangle emits 6 new triangles              }
Magic Number,Examples.Shapes,KochTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\KochTetrahedron.cs,SubdivideKoch,The following statement contains a magic number: for ( int i = 0; i < input.Length; i++ )              {                  input[i].SubdivideKoch(height' out output[counter + 0]' out output[counter + 1]' out output[counter + 2]' out output[counter + 3]' out output[counter + 4]' out output[counter + 5] );                  counter += 6; // every source triangle emits 6 new triangles              }
Magic Number,Examples.Shapes,KochTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\KochTetrahedron.cs,SubdivideKoch,The following statement contains a magic number: for ( int i = 0; i < input.Length; i++ )              {                  input[i].SubdivideKoch(height' out output[counter + 0]' out output[counter + 1]' out output[counter + 2]' out output[counter + 3]' out output[counter + 4]' out output[counter + 5] );                  counter += 6; // every source triangle emits 6 new triangles              }
Magic Number,Examples.Shapes,Capsule,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Capsule.cs,Capsule,The following statement contains a magic number: switch ( subdivs )              {              case eSubdivisions.None:                  spheresubdivs = SlicedSphere.eSubdivisions.Zero;                  HoseSubDivs = 0;                  break;              case eSubdivisions.One:                  spheresubdivs = SlicedSphere.eSubdivisions.One;                  HoseSubDivs = 1;                  break;              case eSubdivisions.Two:                  spheresubdivs = SlicedSphere.eSubdivisions.Two;                  HoseSubDivs = 3;                  break;              case eSubdivisions.Three:                  spheresubdivs = SlicedSphere.eSubdivisions.Three;                  HoseSubDivs = 7;                  break;              case eSubdivisions.Four:                  spheresubdivs = SlicedSphere.eSubdivisions.Four;                  HoseSubDivs = 15;                  break;              }
Magic Number,Examples.Shapes,Capsule,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Capsule.cs,Capsule,The following statement contains a magic number: switch ( subdivs )              {              case eSubdivisions.None:                  spheresubdivs = SlicedSphere.eSubdivisions.Zero;                  HoseSubDivs = 0;                  break;              case eSubdivisions.One:                  spheresubdivs = SlicedSphere.eSubdivisions.One;                  HoseSubDivs = 1;                  break;              case eSubdivisions.Two:                  spheresubdivs = SlicedSphere.eSubdivisions.Two;                  HoseSubDivs = 3;                  break;              case eSubdivisions.Three:                  spheresubdivs = SlicedSphere.eSubdivisions.Three;                  HoseSubDivs = 7;                  break;              case eSubdivisions.Four:                  spheresubdivs = SlicedSphere.eSubdivisions.Four;                  HoseSubDivs = 15;                  break;              }
Magic Number,Examples.Shapes,Capsule,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Capsule.cs,Capsule,The following statement contains a magic number: switch ( subdivs )              {              case eSubdivisions.None:                  spheresubdivs = SlicedSphere.eSubdivisions.Zero;                  HoseSubDivs = 0;                  break;              case eSubdivisions.One:                  spheresubdivs = SlicedSphere.eSubdivisions.One;                  HoseSubDivs = 1;                  break;              case eSubdivisions.Two:                  spheresubdivs = SlicedSphere.eSubdivisions.Two;                  HoseSubDivs = 3;                  break;              case eSubdivisions.Three:                  spheresubdivs = SlicedSphere.eSubdivisions.Three;                  HoseSubDivs = 7;                  break;              case eSubdivisions.Four:                  spheresubdivs = SlicedSphere.eSubdivisions.Four;                  HoseSubDivs = 15;                  break;              }
Magic Number,Examples.Shapes,Capsule,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Capsule.cs,Capsule,The following statement contains a magic number: for ( int i = 0; i < 4; i++ )              {                  SlicedHose.eSide tempSide = SlicedHose.eSide.FrontTop;                  switch ( i )                  {                  case 0:                      tempSide = SlicedHose.eSide.FrontBottom;                      break;                  case 1:                      tempSide = SlicedHose.eSide.BackBottom;                      break;                  case 2:                      tempSide = SlicedHose.eSide.BackTop;                      break;                  case 3:                      tempSide = SlicedHose.eSide.FrontTop;                      break;                  }                  SlicedHose tempHose = new SlicedHose( tempSide' HoseSubDivs' radius' offset1' offset2' false );                  tempHose.GetArraysforVBO( out TemporaryMode' out TemporaryVBO' out TemporaryIBO );                  tempHose.Dispose();                  AllChunks.Add( new Chunk( ref TemporaryVBO' ref TemporaryIBO ) );              }
Magic Number,Examples.Shapes,Capsule,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Capsule.cs,Capsule,The following statement contains a magic number: for ( int i = 0; i < 4; i++ )              {                  SlicedHose.eSide tempSide = SlicedHose.eSide.FrontTop;                  switch ( i )                  {                  case 0:                      tempSide = SlicedHose.eSide.FrontBottom;                      break;                  case 1:                      tempSide = SlicedHose.eSide.BackBottom;                      break;                  case 2:                      tempSide = SlicedHose.eSide.BackTop;                      break;                  case 3:                      tempSide = SlicedHose.eSide.FrontTop;                      break;                  }                  SlicedHose tempHose = new SlicedHose( tempSide' HoseSubDivs' radius' offset1' offset2' false );                  tempHose.GetArraysforVBO( out TemporaryMode' out TemporaryVBO' out TemporaryIBO );                  tempHose.Dispose();                  AllChunks.Add( new Chunk( ref TemporaryVBO' ref TemporaryIBO ) );              }
Magic Number,Examples.Shapes,Capsule,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Capsule.cs,Capsule,The following statement contains a magic number: for ( int i = 0; i < 4; i++ )              {                  SlicedHose.eSide tempSide = SlicedHose.eSide.FrontTop;                  switch ( i )                  {                  case 0:                      tempSide = SlicedHose.eSide.FrontBottom;                      break;                  case 1:                      tempSide = SlicedHose.eSide.BackBottom;                      break;                  case 2:                      tempSide = SlicedHose.eSide.BackTop;                      break;                  case 3:                      tempSide = SlicedHose.eSide.FrontTop;                      break;                  }                  SlicedHose tempHose = new SlicedHose( tempSide' HoseSubDivs' radius' offset1' offset2' false );                  tempHose.GetArraysforVBO( out TemporaryMode' out TemporaryVBO' out TemporaryIBO );                  tempHose.Dispose();                  AllChunks.Add( new Chunk( ref TemporaryVBO' ref TemporaryIBO ) );              }
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: switch ( subdivs )              {              case SubDivs.Zero:                  sphereSubDivs = SlicedSphere.eSubdivisions.Zero;                  hoseSubDivs = 0;                  break;              case SubDivs.One:                  sphereSubDivs = SlicedSphere.eSubdivisions.One;                  hoseSubDivs = 1;                  break;              case SubDivs.Two:                  sphereSubDivs = SlicedSphere.eSubdivisions.Two;                  hoseSubDivs = 3;                  break;              case SubDivs.Three:                  sphereSubDivs = SlicedSphere.eSubdivisions.Three;                  hoseSubDivs = 7;                  break;              case SubDivs.Four:                  sphereSubDivs = SlicedSphere.eSubdivisions.Four;                  hoseSubDivs = 15;                  break;              }
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: switch ( subdivs )              {              case SubDivs.Zero:                  sphereSubDivs = SlicedSphere.eSubdivisions.Zero;                  hoseSubDivs = 0;                  break;              case SubDivs.One:                  sphereSubDivs = SlicedSphere.eSubdivisions.One;                  hoseSubDivs = 1;                  break;              case SubDivs.Two:                  sphereSubDivs = SlicedSphere.eSubdivisions.Two;                  hoseSubDivs = 3;                  break;              case SubDivs.Three:                  sphereSubDivs = SlicedSphere.eSubdivisions.Three;                  hoseSubDivs = 7;                  break;              case SubDivs.Four:                  sphereSubDivs = SlicedSphere.eSubdivisions.Four;                  hoseSubDivs = 15;                  break;              }
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: switch ( subdivs )              {              case SubDivs.Zero:                  sphereSubDivs = SlicedSphere.eSubdivisions.Zero;                  hoseSubDivs = 0;                  break;              case SubDivs.One:                  sphereSubDivs = SlicedSphere.eSubdivisions.One;                  hoseSubDivs = 1;                  break;              case SubDivs.Two:                  sphereSubDivs = SlicedSphere.eSubdivisions.Two;                  hoseSubDivs = 3;                  break;              case SubDivs.Three:                  sphereSubDivs = SlicedSphere.eSubdivisions.Three;                  hoseSubDivs = 7;                  break;              case SubDivs.Four:                  sphereSubDivs = SlicedSphere.eSubdivisions.Four;                  hoseSubDivs = 15;                  break;              }
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: for ( int i = 0; i < 8; i++ )              {                  switch ( i )                  {                  case 0:                      tempVector = FrontTopRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontTopRight };                      break;                  case 1:                      tempVector = FrontTopLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontTopLeft };                      break;                  case 2:                      tempVector = FrontBottomRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontBottomRight };                      break;                  case 3:                      tempVector = FrontBottomLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontBottomLeft };                      break;                  case 4:                      tempVector = BackBottomRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackBottomRight };                      break;                  case 5:                      tempVector = BackBottomLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackBottomLeft };                      break;                  case 6:                      tempVector = BackTopRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackTopRight };                      break;                  case 7:                      tempVector = BackTopLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackTopLeft };                      break;                  }                  tempSphere = new SlicedSphere( radius'                                                   tempVector'                                                   sphereSubDivs'                                                   tempEdge'                                                   false );                  tempSphere.GetArraysforVBO( out TemporaryMode' out TemporaryVBO' out TemporaryIBO );                  tempSphere.Dispose();                  AllChunks.Add( new Chunk( ref TemporaryVBO' ref TemporaryIBO ) );              }
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: for ( int i = 0; i < 8; i++ )              {                  switch ( i )                  {                  case 0:                      tempVector = FrontTopRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontTopRight };                      break;                  case 1:                      tempVector = FrontTopLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontTopLeft };                      break;                  case 2:                      tempVector = FrontBottomRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontBottomRight };                      break;                  case 3:                      tempVector = FrontBottomLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontBottomLeft };                      break;                  case 4:                      tempVector = BackBottomRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackBottomRight };                      break;                  case 5:                      tempVector = BackBottomLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackBottomLeft };                      break;                  case 6:                      tempVector = BackTopRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackTopRight };                      break;                  case 7:                      tempVector = BackTopLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackTopLeft };                      break;                  }                  tempSphere = new SlicedSphere( radius'                                                   tempVector'                                                   sphereSubDivs'                                                   tempEdge'                                                   false );                  tempSphere.GetArraysforVBO( out TemporaryMode' out TemporaryVBO' out TemporaryIBO );                  tempSphere.Dispose();                  AllChunks.Add( new Chunk( ref TemporaryVBO' ref TemporaryIBO ) );              }
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: for ( int i = 0; i < 8; i++ )              {                  switch ( i )                  {                  case 0:                      tempVector = FrontTopRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontTopRight };                      break;                  case 1:                      tempVector = FrontTopLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontTopLeft };                      break;                  case 2:                      tempVector = FrontBottomRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontBottomRight };                      break;                  case 3:                      tempVector = FrontBottomLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontBottomLeft };                      break;                  case 4:                      tempVector = BackBottomRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackBottomRight };                      break;                  case 5:                      tempVector = BackBottomLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackBottomLeft };                      break;                  case 6:                      tempVector = BackTopRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackTopRight };                      break;                  case 7:                      tempVector = BackTopLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackTopLeft };                      break;                  }                  tempSphere = new SlicedSphere( radius'                                                   tempVector'                                                   sphereSubDivs'                                                   tempEdge'                                                   false );                  tempSphere.GetArraysforVBO( out TemporaryMode' out TemporaryVBO' out TemporaryIBO );                  tempSphere.Dispose();                  AllChunks.Add( new Chunk( ref TemporaryVBO' ref TemporaryIBO ) );              }
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: for ( int i = 0; i < 8; i++ )              {                  switch ( i )                  {                  case 0:                      tempVector = FrontTopRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontTopRight };                      break;                  case 1:                      tempVector = FrontTopLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontTopLeft };                      break;                  case 2:                      tempVector = FrontBottomRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontBottomRight };                      break;                  case 3:                      tempVector = FrontBottomLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontBottomLeft };                      break;                  case 4:                      tempVector = BackBottomRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackBottomRight };                      break;                  case 5:                      tempVector = BackBottomLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackBottomLeft };                      break;                  case 6:                      tempVector = BackTopRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackTopRight };                      break;                  case 7:                      tempVector = BackTopLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackTopLeft };                      break;                  }                  tempSphere = new SlicedSphere( radius'                                                   tempVector'                                                   sphereSubDivs'                                                   tempEdge'                                                   false );                  tempSphere.GetArraysforVBO( out TemporaryMode' out TemporaryVBO' out TemporaryIBO );                  tempSphere.Dispose();                  AllChunks.Add( new Chunk( ref TemporaryVBO' ref TemporaryIBO ) );              }
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: for ( int i = 0; i < 8; i++ )              {                  switch ( i )                  {                  case 0:                      tempVector = FrontTopRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontTopRight };                      break;                  case 1:                      tempVector = FrontTopLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontTopLeft };                      break;                  case 2:                      tempVector = FrontBottomRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontBottomRight };                      break;                  case 3:                      tempVector = FrontBottomLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontBottomLeft };                      break;                  case 4:                      tempVector = BackBottomRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackBottomRight };                      break;                  case 5:                      tempVector = BackBottomLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackBottomLeft };                      break;                  case 6:                      tempVector = BackTopRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackTopRight };                      break;                  case 7:                      tempVector = BackTopLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackTopLeft };                      break;                  }                  tempSphere = new SlicedSphere( radius'                                                   tempVector'                                                   sphereSubDivs'                                                   tempEdge'                                                   false );                  tempSphere.GetArraysforVBO( out TemporaryMode' out TemporaryVBO' out TemporaryIBO );                  tempSphere.Dispose();                  AllChunks.Add( new Chunk( ref TemporaryVBO' ref TemporaryIBO ) );              }
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: for ( int i = 0; i < 8; i++ )              {                  switch ( i )                  {                  case 0:                      tempVector = FrontTopRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontTopRight };                      break;                  case 1:                      tempVector = FrontTopLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontTopLeft };                      break;                  case 2:                      tempVector = FrontBottomRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontBottomRight };                      break;                  case 3:                      tempVector = FrontBottomLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontBottomLeft };                      break;                  case 4:                      tempVector = BackBottomRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackBottomRight };                      break;                  case 5:                      tempVector = BackBottomLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackBottomLeft };                      break;                  case 6:                      tempVector = BackTopRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackTopRight };                      break;                  case 7:                      tempVector = BackTopLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackTopLeft };                      break;                  }                  tempSphere = new SlicedSphere( radius'                                                   tempVector'                                                   sphereSubDivs'                                                   tempEdge'                                                   false );                  tempSphere.GetArraysforVBO( out TemporaryMode' out TemporaryVBO' out TemporaryIBO );                  tempSphere.Dispose();                  AllChunks.Add( new Chunk( ref TemporaryVBO' ref TemporaryIBO ) );              }
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: for ( int i = 0; i < 8; i++ )              {                  switch ( i )                  {                  case 0:                      tempVector = FrontTopRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontTopRight };                      break;                  case 1:                      tempVector = FrontTopLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontTopLeft };                      break;                  case 2:                      tempVector = FrontBottomRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontBottomRight };                      break;                  case 3:                      tempVector = FrontBottomLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontBottomLeft };                      break;                  case 4:                      tempVector = BackBottomRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackBottomRight };                      break;                  case 5:                      tempVector = BackBottomLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackBottomLeft };                      break;                  case 6:                      tempVector = BackTopRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackTopRight };                      break;                  case 7:                      tempVector = BackTopLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackTopLeft };                      break;                  }                  tempSphere = new SlicedSphere( radius'                                                   tempVector'                                                   sphereSubDivs'                                                   tempEdge'                                                   false );                  tempSphere.GetArraysforVBO( out TemporaryMode' out TemporaryVBO' out TemporaryIBO );                  tempSphere.Dispose();                  AllChunks.Add( new Chunk( ref TemporaryVBO' ref TemporaryIBO ) );              }
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: for ( int i = 0; i < 12; i++ )              {                  switch ( i )                  {                  #region Around X Axis                  case 0:                      tempSide = SlicedHose.eSide.BottomRight;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = FrontBottomRightEdge;                      break;                  case 1:                      tempSide = SlicedHose.eSide.TopRight;                      tempHoseStart = BackTopRightEdge;                      tempHoseEnd = FrontTopRightEdge;                      break;                  case 2:                      tempSide = SlicedHose.eSide.TopLeft;                      tempHoseStart = BackTopLeftEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  case 3:                      tempSide = SlicedHose.eSide.BottomLeft;                      tempHoseStart = BackBottomLeftEdge;                      tempHoseEnd = FrontBottomLeftEdge;                      break;                  #endregion Around X Axis                  #region Around Y Axis                  case 4:                      tempSide = SlicedHose.eSide.FrontRight;                      tempHoseStart = FrontBottomRightEdge;                      tempHoseEnd = FrontTopRightEdge;                      break;                  case 5:                      tempSide = SlicedHose.eSide.BackRight;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = BackTopRightEdge;                      break;                  case 6:                      tempSide = SlicedHose.eSide.BackLeft;                      tempHoseStart = BackBottomLeftEdge;                      tempHoseEnd = BackTopLeftEdge;                      break;                  case 7:                      tempSide = SlicedHose.eSide.FrontLeft;                      tempHoseStart = FrontBottomLeftEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  #endregion Around Y Axis                  #region Around Z Axis                  case 8:                      tempSide = SlicedHose.eSide.FrontTop;                      tempHoseStart = FrontTopRightEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  case 9:                      tempSide = SlicedHose.eSide.BackTop;                      tempHoseStart = BackTopRightEdge;                      tempHoseEnd = BackTopLeftEdge;                      break;                  case 10:                      tempSide = SlicedHose.eSide.BackBottom;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = BackBottomLeftEdge;                      break;                  case 11:                      tempSide = SlicedHose.eSide.FrontBottom;                      tempHoseStart = FrontBottomRightEdge;                      tempHoseEnd = FrontBottomLeftEdge;                      break;                  #endregion Around Z Axis                  }                  tempHose = new SlicedHose( tempSide'                                               hoseSubDivs'                                               radius'                                               tempHoseStart'                                               tempHoseEnd'                                               false );                  tempHose.GetArraysforVBO( out TemporaryMode' out TemporaryVBO' out TemporaryIBO );                  tempHose.Dispose();                  AllChunks.Add( new Chunk( ref TemporaryVBO' ref TemporaryIBO ) );              }
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: for ( int i = 0; i < 12; i++ )              {                  switch ( i )                  {                  #region Around X Axis                  case 0:                      tempSide = SlicedHose.eSide.BottomRight;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = FrontBottomRightEdge;                      break;                  case 1:                      tempSide = SlicedHose.eSide.TopRight;                      tempHoseStart = BackTopRightEdge;                      tempHoseEnd = FrontTopRightEdge;                      break;                  case 2:                      tempSide = SlicedHose.eSide.TopLeft;                      tempHoseStart = BackTopLeftEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  case 3:                      tempSide = SlicedHose.eSide.BottomLeft;                      tempHoseStart = BackBottomLeftEdge;                      tempHoseEnd = FrontBottomLeftEdge;                      break;                  #endregion Around X Axis                  #region Around Y Axis                  case 4:                      tempSide = SlicedHose.eSide.FrontRight;                      tempHoseStart = FrontBottomRightEdge;                      tempHoseEnd = FrontTopRightEdge;                      break;                  case 5:                      tempSide = SlicedHose.eSide.BackRight;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = BackTopRightEdge;                      break;                  case 6:                      tempSide = SlicedHose.eSide.BackLeft;                      tempHoseStart = BackBottomLeftEdge;                      tempHoseEnd = BackTopLeftEdge;                      break;                  case 7:                      tempSide = SlicedHose.eSide.FrontLeft;                      tempHoseStart = FrontBottomLeftEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  #endregion Around Y Axis                  #region Around Z Axis                  case 8:                      tempSide = SlicedHose.eSide.FrontTop;                      tempHoseStart = FrontTopRightEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  case 9:                      tempSide = SlicedHose.eSide.BackTop;                      tempHoseStart = BackTopRightEdge;                      tempHoseEnd = BackTopLeftEdge;                      break;                  case 10:                      tempSide = SlicedHose.eSide.BackBottom;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = BackBottomLeftEdge;                      break;                  case 11:                      tempSide = SlicedHose.eSide.FrontBottom;                      tempHoseStart = FrontBottomRightEdge;                      tempHoseEnd = FrontBottomLeftEdge;                      break;                  #endregion Around Z Axis                  }                  tempHose = new SlicedHose( tempSide'                                               hoseSubDivs'                                               radius'                                               tempHoseStart'                                               tempHoseEnd'                                               false );                  tempHose.GetArraysforVBO( out TemporaryMode' out TemporaryVBO' out TemporaryIBO );                  tempHose.Dispose();                  AllChunks.Add( new Chunk( ref TemporaryVBO' ref TemporaryIBO ) );              }
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: for ( int i = 0; i < 12; i++ )              {                  switch ( i )                  {                  #region Around X Axis                  case 0:                      tempSide = SlicedHose.eSide.BottomRight;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = FrontBottomRightEdge;                      break;                  case 1:                      tempSide = SlicedHose.eSide.TopRight;                      tempHoseStart = BackTopRightEdge;                      tempHoseEnd = FrontTopRightEdge;                      break;                  case 2:                      tempSide = SlicedHose.eSide.TopLeft;                      tempHoseStart = BackTopLeftEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  case 3:                      tempSide = SlicedHose.eSide.BottomLeft;                      tempHoseStart = BackBottomLeftEdge;                      tempHoseEnd = FrontBottomLeftEdge;                      break;                  #endregion Around X Axis                  #region Around Y Axis                  case 4:                      tempSide = SlicedHose.eSide.FrontRight;                      tempHoseStart = FrontBottomRightEdge;                      tempHoseEnd = FrontTopRightEdge;                      break;                  case 5:                      tempSide = SlicedHose.eSide.BackRight;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = BackTopRightEdge;                      break;                  case 6:                      tempSide = SlicedHose.eSide.BackLeft;                      tempHoseStart = BackBottomLeftEdge;                      tempHoseEnd = BackTopLeftEdge;                      break;                  case 7:                      tempSide = SlicedHose.eSide.FrontLeft;                      tempHoseStart = FrontBottomLeftEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  #endregion Around Y Axis                  #region Around Z Axis                  case 8:                      tempSide = SlicedHose.eSide.FrontTop;                      tempHoseStart = FrontTopRightEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  case 9:                      tempSide = SlicedHose.eSide.BackTop;                      tempHoseStart = BackTopRightEdge;                      tempHoseEnd = BackTopLeftEdge;                      break;                  case 10:                      tempSide = SlicedHose.eSide.BackBottom;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = BackBottomLeftEdge;                      break;                  case 11:                      tempSide = SlicedHose.eSide.FrontBottom;                      tempHoseStart = FrontBottomRightEdge;                      tempHoseEnd = FrontBottomLeftEdge;                      break;                  #endregion Around Z Axis                  }                  tempHose = new SlicedHose( tempSide'                                               hoseSubDivs'                                               radius'                                               tempHoseStart'                                               tempHoseEnd'                                               false );                  tempHose.GetArraysforVBO( out TemporaryMode' out TemporaryVBO' out TemporaryIBO );                  tempHose.Dispose();                  AllChunks.Add( new Chunk( ref TemporaryVBO' ref TemporaryIBO ) );              }
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: for ( int i = 0; i < 12; i++ )              {                  switch ( i )                  {                  #region Around X Axis                  case 0:                      tempSide = SlicedHose.eSide.BottomRight;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = FrontBottomRightEdge;                      break;                  case 1:                      tempSide = SlicedHose.eSide.TopRight;                      tempHoseStart = BackTopRightEdge;                      tempHoseEnd = FrontTopRightEdge;                      break;                  case 2:                      tempSide = SlicedHose.eSide.TopLeft;                      tempHoseStart = BackTopLeftEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  case 3:                      tempSide = SlicedHose.eSide.BottomLeft;                      tempHoseStart = BackBottomLeftEdge;                      tempHoseEnd = FrontBottomLeftEdge;                      break;                  #endregion Around X Axis                  #region Around Y Axis                  case 4:                      tempSide = SlicedHose.eSide.FrontRight;                      tempHoseStart = FrontBottomRightEdge;                      tempHoseEnd = FrontTopRightEdge;                      break;                  case 5:                      tempSide = SlicedHose.eSide.BackRight;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = BackTopRightEdge;                      break;                  case 6:                      tempSide = SlicedHose.eSide.BackLeft;                      tempHoseStart = BackBottomLeftEdge;                      tempHoseEnd = BackTopLeftEdge;                      break;                  case 7:                      tempSide = SlicedHose.eSide.FrontLeft;                      tempHoseStart = FrontBottomLeftEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  #endregion Around Y Axis                  #region Around Z Axis                  case 8:                      tempSide = SlicedHose.eSide.FrontTop;                      tempHoseStart = FrontTopRightEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  case 9:                      tempSide = SlicedHose.eSide.BackTop;                      tempHoseStart = BackTopRightEdge;                      tempHoseEnd = BackTopLeftEdge;                      break;                  case 10:                      tempSide = SlicedHose.eSide.BackBottom;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = BackBottomLeftEdge;                      break;                  case 11:                      tempSide = SlicedHose.eSide.FrontBottom;                      tempHoseStart = FrontBottomRightEdge;                      tempHoseEnd = FrontBottomLeftEdge;                      break;                  #endregion Around Z Axis                  }                  tempHose = new SlicedHose( tempSide'                                               hoseSubDivs'                                               radius'                                               tempHoseStart'                                               tempHoseEnd'                                               false );                  tempHose.GetArraysforVBO( out TemporaryMode' out TemporaryVBO' out TemporaryIBO );                  tempHose.Dispose();                  AllChunks.Add( new Chunk( ref TemporaryVBO' ref TemporaryIBO ) );              }
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: for ( int i = 0; i < 12; i++ )              {                  switch ( i )                  {                  #region Around X Axis                  case 0:                      tempSide = SlicedHose.eSide.BottomRight;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = FrontBottomRightEdge;                      break;                  case 1:                      tempSide = SlicedHose.eSide.TopRight;                      tempHoseStart = BackTopRightEdge;                      tempHoseEnd = FrontTopRightEdge;                      break;                  case 2:                      tempSide = SlicedHose.eSide.TopLeft;                      tempHoseStart = BackTopLeftEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  case 3:                      tempSide = SlicedHose.eSide.BottomLeft;                      tempHoseStart = BackBottomLeftEdge;                      tempHoseEnd = FrontBottomLeftEdge;                      break;                  #endregion Around X Axis                  #region Around Y Axis                  case 4:                      tempSide = SlicedHose.eSide.FrontRight;                      tempHoseStart = FrontBottomRightEdge;                      tempHoseEnd = FrontTopRightEdge;                      break;                  case 5:                      tempSide = SlicedHose.eSide.BackRight;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = BackTopRightEdge;                      break;                  case 6:                      tempSide = SlicedHose.eSide.BackLeft;                      tempHoseStart = BackBottomLeftEdge;                      tempHoseEnd = BackTopLeftEdge;                      break;                  case 7:                      tempSide = SlicedHose.eSide.FrontLeft;                      tempHoseStart = FrontBottomLeftEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  #endregion Around Y Axis                  #region Around Z Axis                  case 8:                      tempSide = SlicedHose.eSide.FrontTop;                      tempHoseStart = FrontTopRightEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  case 9:                      tempSide = SlicedHose.eSide.BackTop;                      tempHoseStart = BackTopRightEdge;                      tempHoseEnd = BackTopLeftEdge;                      break;                  case 10:                      tempSide = SlicedHose.eSide.BackBottom;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = BackBottomLeftEdge;                      break;                  case 11:                      tempSide = SlicedHose.eSide.FrontBottom;                      tempHoseStart = FrontBottomRightEdge;                      tempHoseEnd = FrontBottomLeftEdge;                      break;                  #endregion Around Z Axis                  }                  tempHose = new SlicedHose( tempSide'                                               hoseSubDivs'                                               radius'                                               tempHoseStart'                                               tempHoseEnd'                                               false );                  tempHose.GetArraysforVBO( out TemporaryMode' out TemporaryVBO' out TemporaryIBO );                  tempHose.Dispose();                  AllChunks.Add( new Chunk( ref TemporaryVBO' ref TemporaryIBO ) );              }
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: for ( int i = 0; i < 12; i++ )              {                  switch ( i )                  {                  #region Around X Axis                  case 0:                      tempSide = SlicedHose.eSide.BottomRight;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = FrontBottomRightEdge;                      break;                  case 1:                      tempSide = SlicedHose.eSide.TopRight;                      tempHoseStart = BackTopRightEdge;                      tempHoseEnd = FrontTopRightEdge;                      break;                  case 2:                      tempSide = SlicedHose.eSide.TopLeft;                      tempHoseStart = BackTopLeftEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  case 3:                      tempSide = SlicedHose.eSide.BottomLeft;                      tempHoseStart = BackBottomLeftEdge;                      tempHoseEnd = FrontBottomLeftEdge;                      break;                  #endregion Around X Axis                  #region Around Y Axis                  case 4:                      tempSide = SlicedHose.eSide.FrontRight;                      tempHoseStart = FrontBottomRightEdge;                      tempHoseEnd = FrontTopRightEdge;                      break;                  case 5:                      tempSide = SlicedHose.eSide.BackRight;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = BackTopRightEdge;                      break;                  case 6:                      tempSide = SlicedHose.eSide.BackLeft;                      tempHoseStart = BackBottomLeftEdge;                      tempHoseEnd = BackTopLeftEdge;                      break;                  case 7:                      tempSide = SlicedHose.eSide.FrontLeft;                      tempHoseStart = FrontBottomLeftEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  #endregion Around Y Axis                  #region Around Z Axis                  case 8:                      tempSide = SlicedHose.eSide.FrontTop;                      tempHoseStart = FrontTopRightEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  case 9:                      tempSide = SlicedHose.eSide.BackTop;                      tempHoseStart = BackTopRightEdge;                      tempHoseEnd = BackTopLeftEdge;                      break;                  case 10:                      tempSide = SlicedHose.eSide.BackBottom;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = BackBottomLeftEdge;                      break;                  case 11:                      tempSide = SlicedHose.eSide.FrontBottom;                      tempHoseStart = FrontBottomRightEdge;                      tempHoseEnd = FrontBottomLeftEdge;                      break;                  #endregion Around Z Axis                  }                  tempHose = new SlicedHose( tempSide'                                               hoseSubDivs'                                               radius'                                               tempHoseStart'                                               tempHoseEnd'                                               false );                  tempHose.GetArraysforVBO( out TemporaryMode' out TemporaryVBO' out TemporaryIBO );                  tempHose.Dispose();                  AllChunks.Add( new Chunk( ref TemporaryVBO' ref TemporaryIBO ) );              }
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: for ( int i = 0; i < 12; i++ )              {                  switch ( i )                  {                  #region Around X Axis                  case 0:                      tempSide = SlicedHose.eSide.BottomRight;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = FrontBottomRightEdge;                      break;                  case 1:                      tempSide = SlicedHose.eSide.TopRight;                      tempHoseStart = BackTopRightEdge;                      tempHoseEnd = FrontTopRightEdge;                      break;                  case 2:                      tempSide = SlicedHose.eSide.TopLeft;                      tempHoseStart = BackTopLeftEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  case 3:                      tempSide = SlicedHose.eSide.BottomLeft;                      tempHoseStart = BackBottomLeftEdge;                      tempHoseEnd = FrontBottomLeftEdge;                      break;                  #endregion Around X Axis                  #region Around Y Axis                  case 4:                      tempSide = SlicedHose.eSide.FrontRight;                      tempHoseStart = FrontBottomRightEdge;                      tempHoseEnd = FrontTopRightEdge;                      break;                  case 5:                      tempSide = SlicedHose.eSide.BackRight;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = BackTopRightEdge;                      break;                  case 6:                      tempSide = SlicedHose.eSide.BackLeft;                      tempHoseStart = BackBottomLeftEdge;                      tempHoseEnd = BackTopLeftEdge;                      break;                  case 7:                      tempSide = SlicedHose.eSide.FrontLeft;                      tempHoseStart = FrontBottomLeftEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  #endregion Around Y Axis                  #region Around Z Axis                  case 8:                      tempSide = SlicedHose.eSide.FrontTop;                      tempHoseStart = FrontTopRightEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  case 9:                      tempSide = SlicedHose.eSide.BackTop;                      tempHoseStart = BackTopRightEdge;                      tempHoseEnd = BackTopLeftEdge;                      break;                  case 10:                      tempSide = SlicedHose.eSide.BackBottom;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = BackBottomLeftEdge;                      break;                  case 11:                      tempSide = SlicedHose.eSide.FrontBottom;                      tempHoseStart = FrontBottomRightEdge;                      tempHoseEnd = FrontBottomLeftEdge;                      break;                  #endregion Around Z Axis                  }                  tempHose = new SlicedHose( tempSide'                                               hoseSubDivs'                                               radius'                                               tempHoseStart'                                               tempHoseEnd'                                               false );                  tempHose.GetArraysforVBO( out TemporaryMode' out TemporaryVBO' out TemporaryIBO );                  tempHose.Dispose();                  AllChunks.Add( new Chunk( ref TemporaryVBO' ref TemporaryIBO ) );              }
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: for ( int i = 0; i < 12; i++ )              {                  switch ( i )                  {                  #region Around X Axis                  case 0:                      tempSide = SlicedHose.eSide.BottomRight;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = FrontBottomRightEdge;                      break;                  case 1:                      tempSide = SlicedHose.eSide.TopRight;                      tempHoseStart = BackTopRightEdge;                      tempHoseEnd = FrontTopRightEdge;                      break;                  case 2:                      tempSide = SlicedHose.eSide.TopLeft;                      tempHoseStart = BackTopLeftEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  case 3:                      tempSide = SlicedHose.eSide.BottomLeft;                      tempHoseStart = BackBottomLeftEdge;                      tempHoseEnd = FrontBottomLeftEdge;                      break;                  #endregion Around X Axis                  #region Around Y Axis                  case 4:                      tempSide = SlicedHose.eSide.FrontRight;                      tempHoseStart = FrontBottomRightEdge;                      tempHoseEnd = FrontTopRightEdge;                      break;                  case 5:                      tempSide = SlicedHose.eSide.BackRight;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = BackTopRightEdge;                      break;                  case 6:                      tempSide = SlicedHose.eSide.BackLeft;                      tempHoseStart = BackBottomLeftEdge;                      tempHoseEnd = BackTopLeftEdge;                      break;                  case 7:                      tempSide = SlicedHose.eSide.FrontLeft;                      tempHoseStart = FrontBottomLeftEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  #endregion Around Y Axis                  #region Around Z Axis                  case 8:                      tempSide = SlicedHose.eSide.FrontTop;                      tempHoseStart = FrontTopRightEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  case 9:                      tempSide = SlicedHose.eSide.BackTop;                      tempHoseStart = BackTopRightEdge;                      tempHoseEnd = BackTopLeftEdge;                      break;                  case 10:                      tempSide = SlicedHose.eSide.BackBottom;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = BackBottomLeftEdge;                      break;                  case 11:                      tempSide = SlicedHose.eSide.FrontBottom;                      tempHoseStart = FrontBottomRightEdge;                      tempHoseEnd = FrontBottomLeftEdge;                      break;                  #endregion Around Z Axis                  }                  tempHose = new SlicedHose( tempSide'                                               hoseSubDivs'                                               radius'                                               tempHoseStart'                                               tempHoseEnd'                                               false );                  tempHose.GetArraysforVBO( out TemporaryMode' out TemporaryVBO' out TemporaryIBO );                  tempHose.Dispose();                  AllChunks.Add( new Chunk( ref TemporaryVBO' ref TemporaryIBO ) );              }
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: for ( int i = 0; i < 12; i++ )              {                  switch ( i )                  {                  #region Around X Axis                  case 0:                      tempSide = SlicedHose.eSide.BottomRight;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = FrontBottomRightEdge;                      break;                  case 1:                      tempSide = SlicedHose.eSide.TopRight;                      tempHoseStart = BackTopRightEdge;                      tempHoseEnd = FrontTopRightEdge;                      break;                  case 2:                      tempSide = SlicedHose.eSide.TopLeft;                      tempHoseStart = BackTopLeftEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  case 3:                      tempSide = SlicedHose.eSide.BottomLeft;                      tempHoseStart = BackBottomLeftEdge;                      tempHoseEnd = FrontBottomLeftEdge;                      break;                  #endregion Around X Axis                  #region Around Y Axis                  case 4:                      tempSide = SlicedHose.eSide.FrontRight;                      tempHoseStart = FrontBottomRightEdge;                      tempHoseEnd = FrontTopRightEdge;                      break;                  case 5:                      tempSide = SlicedHose.eSide.BackRight;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = BackTopRightEdge;                      break;                  case 6:                      tempSide = SlicedHose.eSide.BackLeft;                      tempHoseStart = BackBottomLeftEdge;                      tempHoseEnd = BackTopLeftEdge;                      break;                  case 7:                      tempSide = SlicedHose.eSide.FrontLeft;                      tempHoseStart = FrontBottomLeftEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  #endregion Around Y Axis                  #region Around Z Axis                  case 8:                      tempSide = SlicedHose.eSide.FrontTop;                      tempHoseStart = FrontTopRightEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  case 9:                      tempSide = SlicedHose.eSide.BackTop;                      tempHoseStart = BackTopRightEdge;                      tempHoseEnd = BackTopLeftEdge;                      break;                  case 10:                      tempSide = SlicedHose.eSide.BackBottom;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = BackBottomLeftEdge;                      break;                  case 11:                      tempSide = SlicedHose.eSide.FrontBottom;                      tempHoseStart = FrontBottomRightEdge;                      tempHoseEnd = FrontBottomLeftEdge;                      break;                  #endregion Around Z Axis                  }                  tempHose = new SlicedHose( tempSide'                                               hoseSubDivs'                                               radius'                                               tempHoseStart'                                               tempHoseEnd'                                               false );                  tempHose.GetArraysforVBO( out TemporaryMode' out TemporaryVBO' out TemporaryIBO );                  tempHose.Dispose();                  AllChunks.Add( new Chunk( ref TemporaryVBO' ref TemporaryIBO ) );              }
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: for ( int i = 0; i < 12; i++ )              {                  switch ( i )                  {                  #region Around X Axis                  case 0:                      tempSide = SlicedHose.eSide.BottomRight;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = FrontBottomRightEdge;                      break;                  case 1:                      tempSide = SlicedHose.eSide.TopRight;                      tempHoseStart = BackTopRightEdge;                      tempHoseEnd = FrontTopRightEdge;                      break;                  case 2:                      tempSide = SlicedHose.eSide.TopLeft;                      tempHoseStart = BackTopLeftEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  case 3:                      tempSide = SlicedHose.eSide.BottomLeft;                      tempHoseStart = BackBottomLeftEdge;                      tempHoseEnd = FrontBottomLeftEdge;                      break;                  #endregion Around X Axis                  #region Around Y Axis                  case 4:                      tempSide = SlicedHose.eSide.FrontRight;                      tempHoseStart = FrontBottomRightEdge;                      tempHoseEnd = FrontTopRightEdge;                      break;                  case 5:                      tempSide = SlicedHose.eSide.BackRight;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = BackTopRightEdge;                      break;                  case 6:                      tempSide = SlicedHose.eSide.BackLeft;                      tempHoseStart = BackBottomLeftEdge;                      tempHoseEnd = BackTopLeftEdge;                      break;                  case 7:                      tempSide = SlicedHose.eSide.FrontLeft;                      tempHoseStart = FrontBottomLeftEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  #endregion Around Y Axis                  #region Around Z Axis                  case 8:                      tempSide = SlicedHose.eSide.FrontTop;                      tempHoseStart = FrontTopRightEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  case 9:                      tempSide = SlicedHose.eSide.BackTop;                      tempHoseStart = BackTopRightEdge;                      tempHoseEnd = BackTopLeftEdge;                      break;                  case 10:                      tempSide = SlicedHose.eSide.BackBottom;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = BackBottomLeftEdge;                      break;                  case 11:                      tempSide = SlicedHose.eSide.FrontBottom;                      tempHoseStart = FrontBottomRightEdge;                      tempHoseEnd = FrontBottomLeftEdge;                      break;                  #endregion Around Z Axis                  }                  tempHose = new SlicedHose( tempSide'                                               hoseSubDivs'                                               radius'                                               tempHoseStart'                                               tempHoseEnd'                                               false );                  tempHose.GetArraysforVBO( out TemporaryMode' out TemporaryVBO' out TemporaryIBO );                  tempHose.Dispose();                  AllChunks.Add( new Chunk( ref TemporaryVBO' ref TemporaryIBO ) );              }
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: for ( int i = 0; i < 12; i++ )              {                  switch ( i )                  {                  #region Around X Axis                  case 0:                      tempSide = SlicedHose.eSide.BottomRight;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = FrontBottomRightEdge;                      break;                  case 1:                      tempSide = SlicedHose.eSide.TopRight;                      tempHoseStart = BackTopRightEdge;                      tempHoseEnd = FrontTopRightEdge;                      break;                  case 2:                      tempSide = SlicedHose.eSide.TopLeft;                      tempHoseStart = BackTopLeftEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  case 3:                      tempSide = SlicedHose.eSide.BottomLeft;                      tempHoseStart = BackBottomLeftEdge;                      tempHoseEnd = FrontBottomLeftEdge;                      break;                  #endregion Around X Axis                  #region Around Y Axis                  case 4:                      tempSide = SlicedHose.eSide.FrontRight;                      tempHoseStart = FrontBottomRightEdge;                      tempHoseEnd = FrontTopRightEdge;                      break;                  case 5:                      tempSide = SlicedHose.eSide.BackRight;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = BackTopRightEdge;                      break;                  case 6:                      tempSide = SlicedHose.eSide.BackLeft;                      tempHoseStart = BackBottomLeftEdge;                      tempHoseEnd = BackTopLeftEdge;                      break;                  case 7:                      tempSide = SlicedHose.eSide.FrontLeft;                      tempHoseStart = FrontBottomLeftEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  #endregion Around Y Axis                  #region Around Z Axis                  case 8:                      tempSide = SlicedHose.eSide.FrontTop;                      tempHoseStart = FrontTopRightEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  case 9:                      tempSide = SlicedHose.eSide.BackTop;                      tempHoseStart = BackTopRightEdge;                      tempHoseEnd = BackTopLeftEdge;                      break;                  case 10:                      tempSide = SlicedHose.eSide.BackBottom;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = BackBottomLeftEdge;                      break;                  case 11:                      tempSide = SlicedHose.eSide.FrontBottom;                      tempHoseStart = FrontBottomRightEdge;                      tempHoseEnd = FrontBottomLeftEdge;                      break;                  #endregion Around Z Axis                  }                  tempHose = new SlicedHose( tempSide'                                               hoseSubDivs'                                               radius'                                               tempHoseStart'                                               tempHoseEnd'                                               false );                  tempHose.GetArraysforVBO( out TemporaryMode' out TemporaryVBO' out TemporaryIBO );                  tempHose.Dispose();                  AllChunks.Add( new Chunk( ref TemporaryVBO' ref TemporaryIBO ) );              }
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: VertexT2dN3dV3d[] tempVBO = new VertexT2dN3dV3d[4];
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: uint[] tempIBO = new uint[6] { 0' 1' 2' 0' 2' 3 };
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: uint[] tempIBO = new uint[6] { 0' 1' 2' 0' 2' 3 };
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: uint[] tempIBO = new uint[6] { 0' 1' 2' 0' 2' 3 };
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: uint[] tempIBO = new uint[6] { 0' 1' 2' 0' 2' 3 };
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: tempVBO[2].TexCoord = new Vector2d( 1.0' 0.0 );
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: tempVBO[3].TexCoord = new Vector2d( 1.0' 1.0 );
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = Vector3d.UnitX;
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = Vector3d.UnitX;
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: tempVBO[2].Position = FrontBottomLeftEdge + new Vector3d( radius' 0.0' 0.0 );
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: tempVBO[3].Position = FrontTopLeftEdge + new Vector3d( radius' 0.0' 0.0 );
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = -Vector3d.UnitX;
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = -Vector3d.UnitX;
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: tempVBO[2].Position = BackBottomRightEdge - new Vector3d( radius' 0.0' 0.0 );
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: tempVBO[3].Position = BackTopRightEdge - new Vector3d( radius' 0.0' 0.0 );
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = Vector3d.UnitY;
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = Vector3d.UnitY;
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: tempVBO[2].Position = FrontTopLeftEdge + new Vector3d( 0.0' radius' 0.0 );
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: tempVBO[3].Position = BackTopLeftEdge + new Vector3d( 0.0' radius' 0.0 );
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = -Vector3d.UnitY;
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = -Vector3d.UnitY;
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: tempVBO[2].Position = FrontBottomRightEdge - new Vector3d( 0.0' radius' 0.0 );
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: tempVBO[3].Position = BackBottomRightEdge - new Vector3d( 0.0' radius' 0.0 );
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = Vector3d.UnitZ;
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = Vector3d.UnitZ;
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: tempVBO[2].Position = FrontBottomRightEdge + new Vector3d( 0.0' 0.0' radius );
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: tempVBO[3].Position = FrontTopRightEdge + new Vector3d( 0.0' 0.0' radius );
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = -Vector3d.UnitZ;
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: tempVBO[0].Normal = tempVBO[1].Normal = tempVBO[2].Normal = tempVBO[3].Normal = -Vector3d.UnitZ;
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: tempVBO[2].Position = BackBottomLeftEdge - new Vector3d( 0.0' 0.0' radius );
Magic Number,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following statement contains a magic number: tempVBO[3].Position = BackTopLeftEdge - new Vector3d( 0.0' 0.0' radius );
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: switch ( side )              {              #region Around X Axis              case eSide.BottomRight:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.TopRight:                  start = Vector3d.UnitZ;                  end = Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.TopLeft:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.BottomLeft:                  start = -Vector3d.UnitZ;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;              #endregion Around X Axis              #region Around Y Axis              case eSide.FrontRight:                  start = Vector3d.UnitX;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackRight:                  start = Vector3d.UnitZ;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackLeft:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontLeft:                  start = -Vector3d.UnitZ;                  end = Vector3d.UnitX;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Y Axis              #region Around Z Axis              case eSide.FrontBottom:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitX;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackBottom:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackTop:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontTop:                  start = Vector3d.UnitX;                  end = Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Z Axis                }
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: switch ( side )              {              #region Around X Axis              case eSide.BottomRight:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.TopRight:                  start = Vector3d.UnitZ;                  end = Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.TopLeft:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.BottomLeft:                  start = -Vector3d.UnitZ;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;              #endregion Around X Axis              #region Around Y Axis              case eSide.FrontRight:                  start = Vector3d.UnitX;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackRight:                  start = Vector3d.UnitZ;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackLeft:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontLeft:                  start = -Vector3d.UnitZ;                  end = Vector3d.UnitX;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Y Axis              #region Around Z Axis              case eSide.FrontBottom:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitX;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackBottom:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackTop:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontTop:                  start = Vector3d.UnitX;                  end = Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Z Axis                }
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: switch ( side )              {              #region Around X Axis              case eSide.BottomRight:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.TopRight:                  start = Vector3d.UnitZ;                  end = Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.TopLeft:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.BottomLeft:                  start = -Vector3d.UnitZ;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;              #endregion Around X Axis              #region Around Y Axis              case eSide.FrontRight:                  start = Vector3d.UnitX;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackRight:                  start = Vector3d.UnitZ;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackLeft:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontLeft:                  start = -Vector3d.UnitZ;                  end = Vector3d.UnitX;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Y Axis              #region Around Z Axis              case eSide.FrontBottom:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitX;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackBottom:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackTop:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontTop:                  start = Vector3d.UnitX;                  end = Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Z Axis                }
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: switch ( side )              {              #region Around X Axis              case eSide.BottomRight:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.TopRight:                  start = Vector3d.UnitZ;                  end = Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.TopLeft:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.BottomLeft:                  start = -Vector3d.UnitZ;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;              #endregion Around X Axis              #region Around Y Axis              case eSide.FrontRight:                  start = Vector3d.UnitX;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackRight:                  start = Vector3d.UnitZ;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackLeft:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontLeft:                  start = -Vector3d.UnitZ;                  end = Vector3d.UnitX;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Y Axis              #region Around Z Axis              case eSide.FrontBottom:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitX;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackBottom:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackTop:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontTop:                  start = Vector3d.UnitX;                  end = Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Z Axis                }
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: switch ( side )              {              #region Around X Axis              case eSide.BottomRight:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.TopRight:                  start = Vector3d.UnitZ;                  end = Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.TopLeft:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.BottomLeft:                  start = -Vector3d.UnitZ;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;              #endregion Around X Axis              #region Around Y Axis              case eSide.FrontRight:                  start = Vector3d.UnitX;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackRight:                  start = Vector3d.UnitZ;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackLeft:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontLeft:                  start = -Vector3d.UnitZ;                  end = Vector3d.UnitX;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Y Axis              #region Around Z Axis              case eSide.FrontBottom:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitX;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackBottom:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackTop:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontTop:                  start = Vector3d.UnitX;                  end = Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Z Axis                }
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: switch ( side )              {              #region Around X Axis              case eSide.BottomRight:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.TopRight:                  start = Vector3d.UnitZ;                  end = Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.TopLeft:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.BottomLeft:                  start = -Vector3d.UnitZ;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;              #endregion Around X Axis              #region Around Y Axis              case eSide.FrontRight:                  start = Vector3d.UnitX;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackRight:                  start = Vector3d.UnitZ;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackLeft:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontLeft:                  start = -Vector3d.UnitZ;                  end = Vector3d.UnitX;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Y Axis              #region Around Z Axis              case eSide.FrontBottom:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitX;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackBottom:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackTop:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontTop:                  start = Vector3d.UnitX;                  end = Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Z Axis                }
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: switch ( side )              {              #region Around X Axis              case eSide.BottomRight:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.TopRight:                  start = Vector3d.UnitZ;                  end = Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.TopLeft:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.BottomLeft:                  start = -Vector3d.UnitZ;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;              #endregion Around X Axis              #region Around Y Axis              case eSide.FrontRight:                  start = Vector3d.UnitX;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackRight:                  start = Vector3d.UnitZ;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackLeft:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontLeft:                  start = -Vector3d.UnitZ;                  end = Vector3d.UnitX;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Y Axis              #region Around Z Axis              case eSide.FrontBottom:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitX;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackBottom:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackTop:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontTop:                  start = Vector3d.UnitX;                  end = Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Z Axis                }
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: switch ( side )              {              #region Around X Axis              case eSide.BottomRight:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.TopRight:                  start = Vector3d.UnitZ;                  end = Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.TopLeft:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.BottomLeft:                  start = -Vector3d.UnitZ;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;              #endregion Around X Axis              #region Around Y Axis              case eSide.FrontRight:                  start = Vector3d.UnitX;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackRight:                  start = Vector3d.UnitZ;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackLeft:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontLeft:                  start = -Vector3d.UnitZ;                  end = Vector3d.UnitX;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Y Axis              #region Around Z Axis              case eSide.FrontBottom:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitX;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackBottom:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackTop:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontTop:                  start = Vector3d.UnitX;                  end = Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Z Axis                }
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: switch ( side )              {              #region Around X Axis              case eSide.BottomRight:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.TopRight:                  start = Vector3d.UnitZ;                  end = Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.TopLeft:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.BottomLeft:                  start = -Vector3d.UnitZ;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;              #endregion Around X Axis              #region Around Y Axis              case eSide.FrontRight:                  start = Vector3d.UnitX;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackRight:                  start = Vector3d.UnitZ;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackLeft:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontLeft:                  start = -Vector3d.UnitZ;                  end = Vector3d.UnitX;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Y Axis              #region Around Z Axis              case eSide.FrontBottom:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitX;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackBottom:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackTop:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontTop:                  start = Vector3d.UnitX;                  end = Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Z Axis                }
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: switch ( side )              {              #region Around X Axis              case eSide.BottomRight:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.TopRight:                  start = Vector3d.UnitZ;                  end = Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.TopLeft:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.BottomLeft:                  start = -Vector3d.UnitZ;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;              #endregion Around X Axis              #region Around Y Axis              case eSide.FrontRight:                  start = Vector3d.UnitX;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackRight:                  start = Vector3d.UnitZ;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackLeft:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontLeft:                  start = -Vector3d.UnitZ;                  end = Vector3d.UnitX;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Y Axis              #region Around Z Axis              case eSide.FrontBottom:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitX;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackBottom:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackTop:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontTop:                  start = Vector3d.UnitX;                  end = Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Z Axis                }
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: switch ( side )              {              #region Around X Axis              case eSide.BottomRight:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.TopRight:                  start = Vector3d.UnitZ;                  end = Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.TopLeft:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.BottomLeft:                  start = -Vector3d.UnitZ;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;              #endregion Around X Axis              #region Around Y Axis              case eSide.FrontRight:                  start = Vector3d.UnitX;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackRight:                  start = Vector3d.UnitZ;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackLeft:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontLeft:                  start = -Vector3d.UnitZ;                  end = Vector3d.UnitX;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Y Axis              #region Around Z Axis              case eSide.FrontBottom:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitX;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackBottom:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackTop:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontTop:                  start = Vector3d.UnitX;                  end = Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Z Axis                }
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: switch ( side )              {              #region Around X Axis              case eSide.BottomRight:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.TopRight:                  start = Vector3d.UnitZ;                  end = Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.TopLeft:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.BottomLeft:                  start = -Vector3d.UnitZ;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;              #endregion Around X Axis              #region Around Y Axis              case eSide.FrontRight:                  start = Vector3d.UnitX;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackRight:                  start = Vector3d.UnitZ;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackLeft:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontLeft:                  start = -Vector3d.UnitZ;                  end = Vector3d.UnitX;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Y Axis              #region Around Z Axis              case eSide.FrontBottom:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitX;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackBottom:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackTop:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontTop:                  start = Vector3d.UnitX;                  end = Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Z Axis                }
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: switch ( side )              {              #region Around X Axis              case eSide.BottomRight:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.TopRight:                  start = Vector3d.UnitZ;                  end = Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.TopLeft:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.BottomLeft:                  start = -Vector3d.UnitZ;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;              #endregion Around X Axis              #region Around Y Axis              case eSide.FrontRight:                  start = Vector3d.UnitX;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackRight:                  start = Vector3d.UnitZ;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackLeft:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontLeft:                  start = -Vector3d.UnitZ;                  end = Vector3d.UnitX;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Y Axis              #region Around Z Axis              case eSide.FrontBottom:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitX;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackBottom:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackTop:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontTop:                  start = Vector3d.UnitX;                  end = Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Z Axis                }
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: switch ( side )              {              #region Around X Axis              case eSide.BottomRight:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.TopRight:                  start = Vector3d.UnitZ;                  end = Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.TopLeft:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.BottomLeft:                  start = -Vector3d.UnitZ;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;              #endregion Around X Axis              #region Around Y Axis              case eSide.FrontRight:                  start = Vector3d.UnitX;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackRight:                  start = Vector3d.UnitZ;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackLeft:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontLeft:                  start = -Vector3d.UnitZ;                  end = Vector3d.UnitX;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Y Axis              #region Around Z Axis              case eSide.FrontBottom:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitX;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackBottom:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackTop:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontTop:                  start = Vector3d.UnitX;                  end = Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Z Axis                }
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: switch ( side )              {              #region Around X Axis              case eSide.BottomRight:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.TopRight:                  start = Vector3d.UnitZ;                  end = Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.TopLeft:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.BottomLeft:                  start = -Vector3d.UnitZ;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;              #endregion Around X Axis              #region Around Y Axis              case eSide.FrontRight:                  start = Vector3d.UnitX;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackRight:                  start = Vector3d.UnitZ;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackLeft:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontLeft:                  start = -Vector3d.UnitZ;                  end = Vector3d.UnitX;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Y Axis              #region Around Z Axis              case eSide.FrontBottom:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitX;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackBottom:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackTop:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontTop:                  start = Vector3d.UnitX;                  end = Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Z Axis                }
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: switch ( side )              {              #region Around X Axis              case eSide.BottomRight:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.TopRight:                  start = Vector3d.UnitZ;                  end = Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.TopLeft:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.BottomLeft:                  start = -Vector3d.UnitZ;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;              #endregion Around X Axis              #region Around Y Axis              case eSide.FrontRight:                  start = Vector3d.UnitX;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackRight:                  start = Vector3d.UnitZ;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackLeft:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontLeft:                  start = -Vector3d.UnitZ;                  end = Vector3d.UnitX;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Y Axis              #region Around Z Axis              case eSide.FrontBottom:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitX;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackBottom:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackTop:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontTop:                  start = Vector3d.UnitX;                  end = Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Z Axis                }
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: switch ( side )              {              #region Around X Axis              case eSide.BottomRight:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.TopRight:                  start = Vector3d.UnitZ;                  end = Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.TopLeft:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.BottomLeft:                  start = -Vector3d.UnitZ;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;              #endregion Around X Axis              #region Around Y Axis              case eSide.FrontRight:                  start = Vector3d.UnitX;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackRight:                  start = Vector3d.UnitZ;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackLeft:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontLeft:                  start = -Vector3d.UnitZ;                  end = Vector3d.UnitX;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Y Axis              #region Around Z Axis              case eSide.FrontBottom:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitX;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackBottom:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackTop:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontTop:                  start = Vector3d.UnitX;                  end = Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Z Axis                }
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: switch ( side )              {              #region Around X Axis              case eSide.BottomRight:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.TopRight:                  start = Vector3d.UnitZ;                  end = Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.TopLeft:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.BottomLeft:                  start = -Vector3d.UnitZ;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;              #endregion Around X Axis              #region Around Y Axis              case eSide.FrontRight:                  start = Vector3d.UnitX;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackRight:                  start = Vector3d.UnitZ;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackLeft:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontLeft:                  start = -Vector3d.UnitZ;                  end = Vector3d.UnitX;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Y Axis              #region Around Z Axis              case eSide.FrontBottom:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitX;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackBottom:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackTop:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontTop:                  start = Vector3d.UnitX;                  end = Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Z Axis                }
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: VertexT2dN3dV3d[] temp = new VertexT2dN3dV3d[2 + subdivs];
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: VertexArray = new VertexT2dN3dV3d[temp.Length * 2];
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: IndexArray = new uint[( temp.Length - 1 ) * 2 * 3];
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: IndexArray = new uint[( temp.Length - 1 ) * 2 * 3];
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: for ( int i = 0; i < temp.Length; i++ )              {                  VertexArray[VertexCounter + 0].TexCoord.X = temp[i].TexCoord.X;                  VertexArray[VertexCounter + 0].TexCoord.Y = 0.0;                  VertexArray[VertexCounter + 0].Normal = temp[i].Normal;                  VertexArray[VertexCounter + 0].Position = temp[i].Position + offset1;                      VertexArray[VertexCounter + 1].TexCoord.X = temp[i].TexCoord.X;                  VertexArray[VertexCounter + 1].TexCoord.Y = 1.0;                  VertexArray[VertexCounter + 1].Normal = temp[i].Normal;                  VertexArray[VertexCounter + 1].Position = temp[i].Position + offset2;                  VertexCounter += 2;                    if ( i < temp.Length - 1 )                  {                      IndexArray[IndexCounter + 0] = QuadCounter + 0;                      IndexArray[IndexCounter + 1] = QuadCounter + 1;                      IndexArray[IndexCounter + 2] = QuadCounter + 2;                        IndexArray[IndexCounter + 3] = QuadCounter + 2;                      IndexArray[IndexCounter + 4] = QuadCounter + 1;                      IndexArray[IndexCounter + 5] = QuadCounter + 3;                        IndexCounter += 6;                      QuadCounter += 2;                  }              }
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: for ( int i = 0; i < temp.Length; i++ )              {                  VertexArray[VertexCounter + 0].TexCoord.X = temp[i].TexCoord.X;                  VertexArray[VertexCounter + 0].TexCoord.Y = 0.0;                  VertexArray[VertexCounter + 0].Normal = temp[i].Normal;                  VertexArray[VertexCounter + 0].Position = temp[i].Position + offset1;                      VertexArray[VertexCounter + 1].TexCoord.X = temp[i].TexCoord.X;                  VertexArray[VertexCounter + 1].TexCoord.Y = 1.0;                  VertexArray[VertexCounter + 1].Normal = temp[i].Normal;                  VertexArray[VertexCounter + 1].Position = temp[i].Position + offset2;                  VertexCounter += 2;                    if ( i < temp.Length - 1 )                  {                      IndexArray[IndexCounter + 0] = QuadCounter + 0;                      IndexArray[IndexCounter + 1] = QuadCounter + 1;                      IndexArray[IndexCounter + 2] = QuadCounter + 2;                        IndexArray[IndexCounter + 3] = QuadCounter + 2;                      IndexArray[IndexCounter + 4] = QuadCounter + 1;                      IndexArray[IndexCounter + 5] = QuadCounter + 3;                        IndexCounter += 6;                      QuadCounter += 2;                  }              }
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: for ( int i = 0; i < temp.Length; i++ )              {                  VertexArray[VertexCounter + 0].TexCoord.X = temp[i].TexCoord.X;                  VertexArray[VertexCounter + 0].TexCoord.Y = 0.0;                  VertexArray[VertexCounter + 0].Normal = temp[i].Normal;                  VertexArray[VertexCounter + 0].Position = temp[i].Position + offset1;                      VertexArray[VertexCounter + 1].TexCoord.X = temp[i].TexCoord.X;                  VertexArray[VertexCounter + 1].TexCoord.Y = 1.0;                  VertexArray[VertexCounter + 1].Normal = temp[i].Normal;                  VertexArray[VertexCounter + 1].Position = temp[i].Position + offset2;                  VertexCounter += 2;                    if ( i < temp.Length - 1 )                  {                      IndexArray[IndexCounter + 0] = QuadCounter + 0;                      IndexArray[IndexCounter + 1] = QuadCounter + 1;                      IndexArray[IndexCounter + 2] = QuadCounter + 2;                        IndexArray[IndexCounter + 3] = QuadCounter + 2;                      IndexArray[IndexCounter + 4] = QuadCounter + 1;                      IndexArray[IndexCounter + 5] = QuadCounter + 3;                        IndexCounter += 6;                      QuadCounter += 2;                  }              }
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: for ( int i = 0; i < temp.Length; i++ )              {                  VertexArray[VertexCounter + 0].TexCoord.X = temp[i].TexCoord.X;                  VertexArray[VertexCounter + 0].TexCoord.Y = 0.0;                  VertexArray[VertexCounter + 0].Normal = temp[i].Normal;                  VertexArray[VertexCounter + 0].Position = temp[i].Position + offset1;                      VertexArray[VertexCounter + 1].TexCoord.X = temp[i].TexCoord.X;                  VertexArray[VertexCounter + 1].TexCoord.Y = 1.0;                  VertexArray[VertexCounter + 1].Normal = temp[i].Normal;                  VertexArray[VertexCounter + 1].Position = temp[i].Position + offset2;                  VertexCounter += 2;                    if ( i < temp.Length - 1 )                  {                      IndexArray[IndexCounter + 0] = QuadCounter + 0;                      IndexArray[IndexCounter + 1] = QuadCounter + 1;                      IndexArray[IndexCounter + 2] = QuadCounter + 2;                        IndexArray[IndexCounter + 3] = QuadCounter + 2;                      IndexArray[IndexCounter + 4] = QuadCounter + 1;                      IndexArray[IndexCounter + 5] = QuadCounter + 3;                        IndexCounter += 6;                      QuadCounter += 2;                  }              }
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: for ( int i = 0; i < temp.Length; i++ )              {                  VertexArray[VertexCounter + 0].TexCoord.X = temp[i].TexCoord.X;                  VertexArray[VertexCounter + 0].TexCoord.Y = 0.0;                  VertexArray[VertexCounter + 0].Normal = temp[i].Normal;                  VertexArray[VertexCounter + 0].Position = temp[i].Position + offset1;                      VertexArray[VertexCounter + 1].TexCoord.X = temp[i].TexCoord.X;                  VertexArray[VertexCounter + 1].TexCoord.Y = 1.0;                  VertexArray[VertexCounter + 1].Normal = temp[i].Normal;                  VertexArray[VertexCounter + 1].Position = temp[i].Position + offset2;                  VertexCounter += 2;                    if ( i < temp.Length - 1 )                  {                      IndexArray[IndexCounter + 0] = QuadCounter + 0;                      IndexArray[IndexCounter + 1] = QuadCounter + 1;                      IndexArray[IndexCounter + 2] = QuadCounter + 2;                        IndexArray[IndexCounter + 3] = QuadCounter + 2;                      IndexArray[IndexCounter + 4] = QuadCounter + 1;                      IndexArray[IndexCounter + 5] = QuadCounter + 3;                        IndexCounter += 6;                      QuadCounter += 2;                  }              }
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: for ( int i = 0; i < temp.Length; i++ )              {                  VertexArray[VertexCounter + 0].TexCoord.X = temp[i].TexCoord.X;                  VertexArray[VertexCounter + 0].TexCoord.Y = 0.0;                  VertexArray[VertexCounter + 0].Normal = temp[i].Normal;                  VertexArray[VertexCounter + 0].Position = temp[i].Position + offset1;                      VertexArray[VertexCounter + 1].TexCoord.X = temp[i].TexCoord.X;                  VertexArray[VertexCounter + 1].TexCoord.Y = 1.0;                  VertexArray[VertexCounter + 1].Normal = temp[i].Normal;                  VertexArray[VertexCounter + 1].Position = temp[i].Position + offset2;                  VertexCounter += 2;                    if ( i < temp.Length - 1 )                  {                      IndexArray[IndexCounter + 0] = QuadCounter + 0;                      IndexArray[IndexCounter + 1] = QuadCounter + 1;                      IndexArray[IndexCounter + 2] = QuadCounter + 2;                        IndexArray[IndexCounter + 3] = QuadCounter + 2;                      IndexArray[IndexCounter + 4] = QuadCounter + 1;                      IndexArray[IndexCounter + 5] = QuadCounter + 3;                        IndexCounter += 6;                      QuadCounter += 2;                  }              }
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: for ( int i = 0; i < temp.Length; i++ )              {                  VertexArray[VertexCounter + 0].TexCoord.X = temp[i].TexCoord.X;                  VertexArray[VertexCounter + 0].TexCoord.Y = 0.0;                  VertexArray[VertexCounter + 0].Normal = temp[i].Normal;                  VertexArray[VertexCounter + 0].Position = temp[i].Position + offset1;                      VertexArray[VertexCounter + 1].TexCoord.X = temp[i].TexCoord.X;                  VertexArray[VertexCounter + 1].TexCoord.Y = 1.0;                  VertexArray[VertexCounter + 1].Normal = temp[i].Normal;                  VertexArray[VertexCounter + 1].Position = temp[i].Position + offset2;                  VertexCounter += 2;                    if ( i < temp.Length - 1 )                  {                      IndexArray[IndexCounter + 0] = QuadCounter + 0;                      IndexArray[IndexCounter + 1] = QuadCounter + 1;                      IndexArray[IndexCounter + 2] = QuadCounter + 2;                        IndexArray[IndexCounter + 3] = QuadCounter + 2;                      IndexArray[IndexCounter + 4] = QuadCounter + 1;                      IndexArray[IndexCounter + 5] = QuadCounter + 3;                        IndexCounter += 6;                      QuadCounter += 2;                  }              }
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: for ( int i = 0; i < temp.Length; i++ )              {                  VertexArray[VertexCounter + 0].TexCoord.X = temp[i].TexCoord.X;                  VertexArray[VertexCounter + 0].TexCoord.Y = 0.0;                  VertexArray[VertexCounter + 0].Normal = temp[i].Normal;                  VertexArray[VertexCounter + 0].Position = temp[i].Position + offset1;                      VertexArray[VertexCounter + 1].TexCoord.X = temp[i].TexCoord.X;                  VertexArray[VertexCounter + 1].TexCoord.Y = 1.0;                  VertexArray[VertexCounter + 1].Normal = temp[i].Normal;                  VertexArray[VertexCounter + 1].Position = temp[i].Position + offset2;                  VertexCounter += 2;                    if ( i < temp.Length - 1 )                  {                      IndexArray[IndexCounter + 0] = QuadCounter + 0;                      IndexArray[IndexCounter + 1] = QuadCounter + 1;                      IndexArray[IndexCounter + 2] = QuadCounter + 2;                        IndexArray[IndexCounter + 3] = QuadCounter + 2;                      IndexArray[IndexCounter + 4] = QuadCounter + 1;                      IndexArray[IndexCounter + 5] = QuadCounter + 3;                        IndexCounter += 6;                      QuadCounter += 2;                  }              }
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: for ( int i = 0; i < temp.Length; i++ )              {                  VertexArray[VertexCounter + 0].TexCoord.X = temp[i].TexCoord.X;                  VertexArray[VertexCounter + 0].TexCoord.Y = 0.0;                  VertexArray[VertexCounter + 0].Normal = temp[i].Normal;                  VertexArray[VertexCounter + 0].Position = temp[i].Position + offset1;                      VertexArray[VertexCounter + 1].TexCoord.X = temp[i].TexCoord.X;                  VertexArray[VertexCounter + 1].TexCoord.Y = 1.0;                  VertexArray[VertexCounter + 1].Normal = temp[i].Normal;                  VertexArray[VertexCounter + 1].Position = temp[i].Position + offset2;                  VertexCounter += 2;                    if ( i < temp.Length - 1 )                  {                      IndexArray[IndexCounter + 0] = QuadCounter + 0;                      IndexArray[IndexCounter + 1] = QuadCounter + 1;                      IndexArray[IndexCounter + 2] = QuadCounter + 2;                        IndexArray[IndexCounter + 3] = QuadCounter + 2;                      IndexArray[IndexCounter + 4] = QuadCounter + 1;                      IndexArray[IndexCounter + 5] = QuadCounter + 3;                        IndexCounter += 6;                      QuadCounter += 2;                  }              }
Magic Number,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following statement contains a magic number: for ( int i = 0; i < temp.Length; i++ )              {                  VertexArray[VertexCounter + 0].TexCoord.X = temp[i].TexCoord.X;                  VertexArray[VertexCounter + 0].TexCoord.Y = 0.0;                  VertexArray[VertexCounter + 0].Normal = temp[i].Normal;                  VertexArray[VertexCounter + 0].Position = temp[i].Position + offset1;                      VertexArray[VertexCounter + 1].TexCoord.X = temp[i].TexCoord.X;                  VertexArray[VertexCounter + 1].TexCoord.Y = 1.0;                  VertexArray[VertexCounter + 1].Normal = temp[i].Normal;                  VertexArray[VertexCounter + 1].Position = temp[i].Position + offset2;                  VertexCounter += 2;                    if ( i < temp.Length - 1 )                  {                      IndexArray[IndexCounter + 0] = QuadCounter + 0;                      IndexArray[IndexCounter + 1] = QuadCounter + 1;                      IndexArray[IndexCounter + 2] = QuadCounter + 2;                        IndexArray[IndexCounter + 3] = QuadCounter + 2;                      IndexArray[IndexCounter + 4] = QuadCounter + 1;                      IndexArray[IndexCounter + 5] = QuadCounter + 3;                        IndexCounter += 6;                      QuadCounter += 2;                  }              }
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,SlicedSphere,The following statement contains a magic number: VertexArray = new VertexT2dN3dV3d[sides.Length * 3];
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,SlicedSphere,The following statement contains a magic number: IndexArray = new uint[sides.Length * 3];
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,SlicedSphere,The following statement contains a magic number: foreach ( eDir s in sides )              {                  GetDefaultVertices( s' Diameter' out VertexArray[counter + 0]' out VertexArray[counter + 1]' out VertexArray[counter + 2] );                  IndexArray[counter + 0] = counter + 0;                  IndexArray[counter + 1] = counter + 1;                  IndexArray[counter + 2] = counter + 2;                  counter += 3;              }
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,SlicedSphere,The following statement contains a magic number: foreach ( eDir s in sides )              {                  GetDefaultVertices( s' Diameter' out VertexArray[counter + 0]' out VertexArray[counter + 1]' out VertexArray[counter + 2] );                  IndexArray[counter + 0] = counter + 0;                  IndexArray[counter + 1] = counter + 1;                  IndexArray[counter + 2] = counter + 2;                  counter += 3;              }
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,SlicedSphere,The following statement contains a magic number: foreach ( eDir s in sides )              {                  GetDefaultVertices( s' Diameter' out VertexArray[counter + 0]' out VertexArray[counter + 1]' out VertexArray[counter + 2] );                  IndexArray[counter + 0] = counter + 0;                  IndexArray[counter + 1] = counter + 1;                  IndexArray[counter + 2] = counter + 2;                  counter += 3;              }
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,SlicedSphere,The following statement contains a magic number: foreach ( eDir s in sides )              {                  GetDefaultVertices( s' Diameter' out VertexArray[counter + 0]' out VertexArray[counter + 1]' out VertexArray[counter + 2] );                  IndexArray[counter + 0] = counter + 0;                  IndexArray[counter + 1] = counter + 1;                  IndexArray[counter + 2] = counter + 2;                  counter += 3;              }
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,SlicedSphere,The following statement contains a magic number: if ( subdivs != eSubdivisions.Zero )              {                    for ( int s = 0; s < (int)subdivs; s++ )                  {                      #region Assemble Chunks and convert to Arrays                      List<Chunk> AllChunks = new List<Chunk>();                      for ( uint i = 0; i < IndexArray.Length; i += 3 )                      {                          Chunk chu;                          Subdivide( Diameter'                                     ref VertexArray[IndexArray[i + 0]]'                                     ref VertexArray[IndexArray[i + 1]]'                                     ref VertexArray[IndexArray[i + 2]]'                                     out chu );                          AllChunks.Add( chu );                      }                        Chunk.GetArray( ref AllChunks' out VertexArray' out IndexArray );                      AllChunks.Clear();                      #endregion Assemble Chunks and convert to Arrays                  }              }
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,SlicedSphere,The following statement contains a magic number: if ( subdivs != eSubdivisions.Zero )              {                    for ( int s = 0; s < (int)subdivs; s++ )                  {                      #region Assemble Chunks and convert to Arrays                      List<Chunk> AllChunks = new List<Chunk>();                      for ( uint i = 0; i < IndexArray.Length; i += 3 )                      {                          Chunk chu;                          Subdivide( Diameter'                                     ref VertexArray[IndexArray[i + 0]]'                                     ref VertexArray[IndexArray[i + 1]]'                                     ref VertexArray[IndexArray[i + 2]]'                                     out chu );                          AllChunks.Add( chu );                      }                        Chunk.GetArray( ref AllChunks' out VertexArray' out IndexArray );                      AllChunks.Clear();                      #endregion Assemble Chunks and convert to Arrays                  }              }
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,GetDefaultVertices,The following statement contains a magic number: switch ( s )              {              case eDir.FrontTopRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  break;              case eDir.FrontBottomRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  break;              case eDir.FrontBottomLeft:                   t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  break;              case eDir.FrontTopLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  break;              case eDir.BackTopRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  break;              case eDir.BackBottomRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  break;              case eDir.BackBottomLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 1.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  break;              case eDir.BackTopLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  break;              }
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,GetDefaultVertices,The following statement contains a magic number: switch ( s )              {              case eDir.FrontTopRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  break;              case eDir.FrontBottomRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  break;              case eDir.FrontBottomLeft:                   t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  break;              case eDir.FrontTopLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  break;              case eDir.BackTopRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  break;              case eDir.BackBottomRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  break;              case eDir.BackBottomLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 1.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  break;              case eDir.BackTopLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  break;              }
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,GetDefaultVertices,The following statement contains a magic number: switch ( s )              {              case eDir.FrontTopRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  break;              case eDir.FrontBottomRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  break;              case eDir.FrontBottomLeft:                   t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  break;              case eDir.FrontTopLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  break;              case eDir.BackTopRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  break;              case eDir.BackBottomRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  break;              case eDir.BackBottomLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 1.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  break;              case eDir.BackTopLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  break;              }
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,GetDefaultVertices,The following statement contains a magic number: switch ( s )              {              case eDir.FrontTopRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  break;              case eDir.FrontBottomRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  break;              case eDir.FrontBottomLeft:                   t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  break;              case eDir.FrontTopLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  break;              case eDir.BackTopRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  break;              case eDir.BackBottomRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  break;              case eDir.BackBottomLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 1.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  break;              case eDir.BackTopLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  break;              }
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,GetDefaultVertices,The following statement contains a magic number: switch ( s )              {              case eDir.FrontTopRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  break;              case eDir.FrontBottomRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  break;              case eDir.FrontBottomLeft:                   t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  break;              case eDir.FrontTopLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  break;              case eDir.BackTopRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  break;              case eDir.BackBottomRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  break;              case eDir.BackBottomLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 1.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  break;              case eDir.BackTopLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  break;              }
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,GetDefaultVertices,The following statement contains a magic number: switch ( s )              {              case eDir.FrontTopRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  break;              case eDir.FrontBottomRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  break;              case eDir.FrontBottomLeft:                   t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  break;              case eDir.FrontTopLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  break;              case eDir.BackTopRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  break;              case eDir.BackBottomRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  break;              case eDir.BackBottomLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 1.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  break;              case eDir.BackTopLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  break;              }
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,GetDefaultVertices,The following statement contains a magic number: switch ( s )              {              case eDir.FrontTopRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  break;              case eDir.FrontBottomRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  break;              case eDir.FrontBottomLeft:                   t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  break;              case eDir.FrontTopLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  break;              case eDir.BackTopRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  break;              case eDir.BackBottomRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  break;              case eDir.BackBottomLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 1.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  break;              case eDir.BackTopLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  break;              }
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,GetDefaultVertices,The following statement contains a magic number: switch ( s )              {              case eDir.FrontTopRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  break;              case eDir.FrontBottomRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  break;              case eDir.FrontBottomLeft:                   t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  break;              case eDir.FrontTopLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  break;              case eDir.BackTopRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  break;              case eDir.BackBottomRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  break;              case eDir.BackBottomLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 1.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  break;              case eDir.BackTopLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  break;              }
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,GetDefaultVertices,The following statement contains a magic number: switch ( s )              {              case eDir.FrontTopRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  break;              case eDir.FrontBottomRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  break;              case eDir.FrontBottomLeft:                   t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  break;              case eDir.FrontTopLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  break;              case eDir.BackTopRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  break;              case eDir.BackBottomRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  break;              case eDir.BackBottomLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 1.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  break;              case eDir.BackTopLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  break;              }
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,GetDefaultVertices,The following statement contains a magic number: switch ( s )              {              case eDir.FrontTopRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  break;              case eDir.FrontBottomRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  break;              case eDir.FrontBottomLeft:                   t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  break;              case eDir.FrontTopLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  break;              case eDir.BackTopRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  break;              case eDir.BackBottomRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  break;              case eDir.BackBottomLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 1.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  break;              case eDir.BackTopLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  break;              }
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,GetDefaultVertices,The following statement contains a magic number: switch ( s )              {              case eDir.FrontTopRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  break;              case eDir.FrontBottomRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  break;              case eDir.FrontBottomLeft:                   t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  break;              case eDir.FrontTopLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  break;              case eDir.BackTopRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  break;              case eDir.BackBottomRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  break;              case eDir.BackBottomLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 1.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  break;              case eDir.BackTopLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  break;              }
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,GetDefaultVertices,The following statement contains a magic number: switch ( s )              {              case eDir.FrontTopRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  break;              case eDir.FrontBottomRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  break;              case eDir.FrontBottomLeft:                   t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  break;              case eDir.FrontTopLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  break;              case eDir.BackTopRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  break;              case eDir.BackBottomRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  break;              case eDir.BackBottomLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 1.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  break;              case eDir.BackTopLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  break;              }
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: c = new Chunk(6' 12);
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: c = new Chunk(6' 12);
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: Vector3d.Lerp(ref first.Position' ref second.Position' 0.5'out c.Vertices[1].Normal );
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: Vector2d.Lerp( ref first.TexCoord' ref second.TexCoord' 0.5' out c.Vertices[1].TexCoord );
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: Vector3d.Lerp( ref third.Position' ref first.Position' 0.5' out c.Vertices[2].Normal );
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: Vector3d.Lerp( ref third.Position' ref first.Position' 0.5' out c.Vertices[2].Normal );
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: c.Vertices[2].Normal.Normalize();
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: c.Vertices[2].Position = c.Vertices[2].Normal * Scale;
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: c.Vertices[2].Position = c.Vertices[2].Normal * Scale;
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: Vector2d.Lerp( ref third.TexCoord' ref first.TexCoord' 0.5' out c.Vertices[2].TexCoord );
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: Vector2d.Lerp( ref third.TexCoord' ref first.TexCoord' 0.5' out c.Vertices[2].TexCoord );
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: c.Vertices[3] = second;
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: Vector3d.Lerp( ref second.Position' ref third.Position' 0.5' out c.Vertices[4].Normal );
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: Vector3d.Lerp( ref second.Position' ref third.Position' 0.5' out c.Vertices[4].Normal );
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: c.Vertices[4].Normal.Normalize();
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: c.Vertices[4].Position = c.Vertices[4].Normal * Scale;
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: c.Vertices[4].Position = c.Vertices[4].Normal * Scale;
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: Vector2d.Lerp( ref second.TexCoord' ref third.TexCoord' 0.5' out c.Vertices[4].TexCoord );
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: Vector2d.Lerp( ref second.TexCoord' ref third.TexCoord' 0.5' out c.Vertices[4].TexCoord );
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: c.Vertices[5] = third;
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: c.Indices[2]=2;
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: c.Indices[2]=2;
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: c.Indices[3]=2;
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: c.Indices[3]=2;
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: c.Indices[4]=1;
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: c.Indices[5]=4;
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: c.Indices[5]=4;
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: c.Indices[6]=1;
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: c.Indices[7]=3;
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: c.Indices[7]=3;
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: c.Indices[8]=4;
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: c.Indices[8]=4;
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: c.Indices[9]=2;
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: c.Indices[9]=2;
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: c.Indices[10]=4;
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: c.Indices[10]=4;
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: c.Indices[11]=5;
Magic Number,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,Subdivide,The following statement contains a magic number: c.Indices[11]=5;
Magic Number,Examples.Shapes,IsoSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\IsoSphere.cs,IsoSphere,The following statement contains a magic number: int count = 4 * s_steps * t_steps ;
Magic Number,Examples.Shapes,IsoSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\IsoSphere.cs,IsoSphere,The following statement contains a magic number: Indices = new int[6 * count / 4];
Magic Number,Examples.Shapes,IsoSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\IsoSphere.cs,IsoSphere,The following statement contains a magic number: Indices = new int[6 * count / 4];
Magic Number,Examples.Shapes,IsoSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\IsoSphere.cs,IsoSphere,The following statement contains a magic number: for (i = 0; i < 6*count/4; i+=6)              {                  Indices[i] = i;                  Indices[i + 1] = i + 1;                  Indices[i + 2] = i + 2 * s_steps + 1;                  Indices[i + 3] = i + 2 * s_steps;                  Indices[i + 4] = i;                  Indices[i + 5] = i + 2 * s_steps + 1;              }
Magic Number,Examples.Shapes,IsoSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\IsoSphere.cs,IsoSphere,The following statement contains a magic number: for (i = 0; i < 6*count/4; i+=6)              {                  Indices[i] = i;                  Indices[i + 1] = i + 1;                  Indices[i + 2] = i + 2 * s_steps + 1;                  Indices[i + 3] = i + 2 * s_steps;                  Indices[i + 4] = i;                  Indices[i + 5] = i + 2 * s_steps + 1;              }
Magic Number,Examples.Shapes,IsoSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\IsoSphere.cs,IsoSphere,The following statement contains a magic number: for (i = 0; i < 6*count/4; i+=6)              {                  Indices[i] = i;                  Indices[i + 1] = i + 1;                  Indices[i + 2] = i + 2 * s_steps + 1;                  Indices[i + 3] = i + 2 * s_steps;                  Indices[i + 4] = i;                  Indices[i + 5] = i + 2 * s_steps + 1;              }
Magic Number,Examples.Shapes,IsoSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\IsoSphere.cs,IsoSphere,The following statement contains a magic number: for (i = 0; i < 6*count/4; i+=6)              {                  Indices[i] = i;                  Indices[i + 1] = i + 1;                  Indices[i + 2] = i + 2 * s_steps + 1;                  Indices[i + 3] = i + 2 * s_steps;                  Indices[i + 4] = i;                  Indices[i + 5] = i + 2 * s_steps + 1;              }
Magic Number,Examples.Shapes,IsoSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\IsoSphere.cs,IsoSphere,The following statement contains a magic number: for (i = 0; i < 6*count/4; i+=6)              {                  Indices[i] = i;                  Indices[i + 1] = i + 1;                  Indices[i + 2] = i + 2 * s_steps + 1;                  Indices[i + 3] = i + 2 * s_steps;                  Indices[i + 4] = i;                  Indices[i + 5] = i + 2 * s_steps + 1;              }
Magic Number,Examples.Shapes,IsoSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\IsoSphere.cs,IsoSphere,The following statement contains a magic number: for (i = 0; i < 6*count/4; i+=6)              {                  Indices[i] = i;                  Indices[i + 1] = i + 1;                  Indices[i + 2] = i + 2 * s_steps + 1;                  Indices[i + 3] = i + 2 * s_steps;                  Indices[i + 4] = i;                  Indices[i + 5] = i + 2 * s_steps + 1;              }
Magic Number,Examples.Shapes,IsoSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\IsoSphere.cs,IsoSphere,The following statement contains a magic number: for (i = 0; i < 6*count/4; i+=6)              {                  Indices[i] = i;                  Indices[i + 1] = i + 1;                  Indices[i + 2] = i + 2 * s_steps + 1;                  Indices[i + 3] = i + 2 * s_steps;                  Indices[i + 4] = i;                  Indices[i + 5] = i + 2 * s_steps + 1;              }
Magic Number,Examples.Shapes,IsoSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\IsoSphere.cs,IsoSphere,The following statement contains a magic number: for (i = 0; i < 6*count/4; i+=6)              {                  Indices[i] = i;                  Indices[i + 1] = i + 1;                  Indices[i + 2] = i + 2 * s_steps + 1;                  Indices[i + 3] = i + 2 * s_steps;                  Indices[i + 4] = i;                  Indices[i + 5] = i + 2 * s_steps + 1;              }
Magic Number,Examples.Shapes,IsoSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\IsoSphere.cs,IsoSphere,The following statement contains a magic number: for (i = 0; i < 6*count/4; i+=6)              {                  Indices[i] = i;                  Indices[i + 1] = i + 1;                  Indices[i + 2] = i + 2 * s_steps + 1;                  Indices[i + 3] = i + 2 * s_steps;                  Indices[i + 4] = i;                  Indices[i + 5] = i + 2 * s_steps + 1;              }
Magic Number,Examples.Shapes,IsoSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\IsoSphere.cs,IsoSphere,The following statement contains a magic number: for (i = 0; i < 6*count/4; i+=6)              {                  Indices[i] = i;                  Indices[i + 1] = i + 1;                  Indices[i + 2] = i + 2 * s_steps + 1;                  Indices[i + 3] = i + 2 * s_steps;                  Indices[i + 4] = i;                  Indices[i + 5] = i + 2 * s_steps + 1;              }
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,GetVertexArray,The following statement contains a magic number: output = new VertexT2dN3dV3d[input.Length * 3];
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,GetVertexArray,The following statement contains a magic number: for ( int i = 0; i < input.Length; i++ )              {                  input[i].GetVertices( out output[counter + 0]' out output[counter + 1]' out output[counter + 2] );                  counter += 3;              }
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,GetVertexArray,The following statement contains a magic number: for ( int i = 0; i < input.Length; i++ )              {                  input[i].GetVertices( out output[counter + 0]' out output[counter + 1]' out output[counter + 2] );                  counter += 3;              }
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: Vector3d[] Points = new Vector3d[4];
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: Points[1] = new Vector3d( -0.816 * scale' 0.471 * scale' -0.333 * scale );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: Points[1] = new Vector3d( -0.816 * scale' 0.471 * scale' -0.333 * scale );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: Points[1] = new Vector3d( -0.816 * scale' 0.471 * scale' -0.333 * scale );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: Points[2] = new Vector3d( 0.816 * scale' 0.471 * scale' -0.333 * scale );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: Points[2] = new Vector3d( 0.816 * scale' 0.471 * scale' -0.333 * scale );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: Points[2] = new Vector3d( 0.816 * scale' 0.471 * scale' -0.333 * scale );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: Points[2] = new Vector3d( 0.816 * scale' 0.471 * scale' -0.333 * scale );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: Points[3] = new Vector3d( 0.0 * scale' -0.943 * scale' -0.333 * scale );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: Points[3] = new Vector3d( 0.0 * scale' -0.943 * scale' -0.333 * scale );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: Points[3] = new Vector3d( 0.0 * scale' -0.943 * scale' -0.333 * scale );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: Vector2d[] TexCoords = new Vector2d[4];
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: TexCoords[2] = new Vector2d( 0.0' 1.0 );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: TexCoords[3] = new Vector2d( 1.0' 1.0 );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: array = new TetrahedronFace[4];
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: FindNormal( ref Points[0]' ref Points[2]' ref Points[1]' ref Points[3]' out Normal );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: FindNormal( ref Points[0]' ref Points[2]' ref Points[1]' ref Points[3]' out Normal );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: array[0] = new TetrahedronFace( ref Points[0]' ref TexCoords[2]'                                                     ref Points[2]' ref TexCoords[0]'                                                     ref Points[1]' ref TexCoords[1]'                                                     ref Points[3]'                                                     ref Normal );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: array[0] = new TetrahedronFace( ref Points[0]' ref TexCoords[2]'                                                     ref Points[2]' ref TexCoords[0]'                                                     ref Points[1]' ref TexCoords[1]'                                                     ref Points[3]'                                                     ref Normal );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: array[0] = new TetrahedronFace( ref Points[0]' ref TexCoords[2]'                                                     ref Points[2]' ref TexCoords[0]'                                                     ref Points[1]' ref TexCoords[1]'                                                     ref Points[3]'                                                     ref Normal );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: FindNormal( ref Points[0]' ref Points[3]' ref Points[2]' ref Points[1]' out Normal );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: FindNormal( ref Points[0]' ref Points[3]' ref Points[2]' ref Points[1]' out Normal );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: array[1] = new TetrahedronFace( ref Points[0]' ref TexCoords[0]'                                                     ref Points[3]' ref TexCoords[1]'                                                     ref Points[2]' ref TexCoords[2]'                                                     ref Points[1]'                                                     ref Normal );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: array[1] = new TetrahedronFace( ref Points[0]' ref TexCoords[0]'                                                     ref Points[3]' ref TexCoords[1]'                                                     ref Points[2]' ref TexCoords[2]'                                                     ref Points[1]'                                                     ref Normal );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: array[1] = new TetrahedronFace( ref Points[0]' ref TexCoords[0]'                                                     ref Points[3]' ref TexCoords[1]'                                                     ref Points[2]' ref TexCoords[2]'                                                     ref Points[1]'                                                     ref Normal );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: FindNormal( ref Points[0]' ref Points[1]' ref Points[3]' ref Points[2]' out Normal );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: FindNormal( ref Points[0]' ref Points[1]' ref Points[3]' ref Points[2]' out Normal );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: array[2] = new TetrahedronFace( ref Points[0]' ref TexCoords[2]'                                                     ref Points[1]' ref TexCoords[1]'                                                     ref Points[3]' ref TexCoords[3]'                                                     ref Points[2]'                                                     ref Normal );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: array[2] = new TetrahedronFace( ref Points[0]' ref TexCoords[2]'                                                     ref Points[1]' ref TexCoords[1]'                                                     ref Points[3]' ref TexCoords[3]'                                                     ref Points[2]'                                                     ref Normal );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: array[2] = new TetrahedronFace( ref Points[0]' ref TexCoords[2]'                                                     ref Points[1]' ref TexCoords[1]'                                                     ref Points[3]' ref TexCoords[3]'                                                     ref Points[2]'                                                     ref Normal );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: array[2] = new TetrahedronFace( ref Points[0]' ref TexCoords[2]'                                                     ref Points[1]' ref TexCoords[1]'                                                     ref Points[3]' ref TexCoords[3]'                                                     ref Points[2]'                                                     ref Normal );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: array[2] = new TetrahedronFace( ref Points[0]' ref TexCoords[2]'                                                     ref Points[1]' ref TexCoords[1]'                                                     ref Points[3]' ref TexCoords[3]'                                                     ref Points[2]'                                                     ref Normal );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: FindNormal( ref Points[1]' ref Points[2]' ref Points[3]' ref Points[0]' out Normal );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: FindNormal( ref Points[1]' ref Points[2]' ref Points[3]' ref Points[0]' out Normal );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: array[3] = new TetrahedronFace( ref Points[1]' ref TexCoords[3]'                                                     ref Points[2]' ref TexCoords[2]'                                                     ref Points[3]' ref TexCoords[1]'                                                     ref Points[0]'                                                     ref Normal );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: array[3] = new TetrahedronFace( ref Points[1]' ref TexCoords[3]'                                                     ref Points[2]' ref TexCoords[2]'                                                     ref Points[3]' ref TexCoords[1]'                                                     ref Points[0]'                                                     ref Normal );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: array[3] = new TetrahedronFace( ref Points[1]' ref TexCoords[3]'                                                     ref Points[2]' ref TexCoords[2]'                                                     ref Points[3]' ref TexCoords[1]'                                                     ref Points[0]'                                                     ref Normal );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: array[3] = new TetrahedronFace( ref Points[1]' ref TexCoords[3]'                                                     ref Points[2]' ref TexCoords[2]'                                                     ref Points[3]' ref TexCoords[1]'                                                     ref Points[0]'                                                     ref Normal );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,CreateDefaultTetrahedron,The following statement contains a magic number: array[3] = new TetrahedronFace( ref Points[1]' ref TexCoords[3]'                                                     ref Points[2]' ref TexCoords[2]'                                                     ref Points[3]' ref TexCoords[1]'                                                     ref Points[0]'                                                     ref Normal );
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,SubdivideTetrahedron,The following statement contains a magic number: output = new TetrahedronFace[source.Length * 4];
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,SubdivideTetrahedron,The following statement contains a magic number: for ( int i = 0; i < source.Length; i++ )              {                  source[i].SubdivideSierpinski( out output[counter + 0]' out output[counter + 1]' out output[counter + 2]' out output[counter + 3] );                  counter += 4; // every source triangle emits 4 new triangles              }
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,SubdivideTetrahedron,The following statement contains a magic number: for ( int i = 0; i < source.Length; i++ )              {                  source[i].SubdivideSierpinski( out output[counter + 0]' out output[counter + 1]' out output[counter + 2]' out output[counter + 3] );                  counter += 4; // every source triangle emits 4 new triangles              }
Magic Number,Examples.Shapes,SierpinskiTetrahedron,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\SierpinskiTetrahedron.cs,SubdivideTetrahedron,The following statement contains a magic number: for ( int i = 0; i < source.Length; i++ )              {                  source[i].SubdivideSierpinski( out output[counter + 0]' out output[counter + 1]' out output[counter + 2]' out output[counter + 3] );                  counter += 4; // every source triangle emits 4 new triangles              }
Magic Number,Examples.Shapes,Plane,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Plane.cs,Plane,The following statement contains a magic number: Indices = new int[6 * x_res * y_res];
Magic Number,Examples.Shapes,Plane,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Plane.cs,Plane,The following statement contains a magic number: for (int y = -y_res / 2; y < y_res / 2; y++)              {                  for (int x = -x_res / 2; x < x_res / 2; x++)                  {                      Vertices[i].X = x_scale * (float)x / (float)x_res;                      Vertices[i].Y = y_scale * (float)y / (float)y_res;                      Vertices[i].Z = 0;                      Normals[i].X = Normals[i].Y = 0;                      Normals[i].Z = 1;                      i++;                  }              }
Magic Number,Examples.Shapes,Plane,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Plane.cs,Plane,The following statement contains a magic number: for (int y = -y_res / 2; y < y_res / 2; y++)              {                  for (int x = -x_res / 2; x < x_res / 2; x++)                  {                      Vertices[i].X = x_scale * (float)x / (float)x_res;                      Vertices[i].Y = y_scale * (float)y / (float)y_res;                      Vertices[i].Z = 0;                      Normals[i].X = Normals[i].Y = 0;                      Normals[i].Z = 1;                      i++;                  }              }
Magic Number,Examples.Shapes,Plane,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Plane.cs,Plane,The following statement contains a magic number: for (int y = -y_res / 2; y < y_res / 2; y++)              {                  for (int x = -x_res / 2; x < x_res / 2; x++)                  {                      Vertices[i].X = x_scale * (float)x / (float)x_res;                      Vertices[i].Y = y_scale * (float)y / (float)y_res;                      Vertices[i].Z = 0;                      Normals[i].X = Normals[i].Y = 0;                      Normals[i].Z = 1;                      i++;                  }              }
Magic Number,Examples.Shapes,Plane,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Plane.cs,Plane,The following statement contains a magic number: for (int y = -y_res / 2; y < y_res / 2; y++)              {                  for (int x = -x_res / 2; x < x_res / 2; x++)                  {                      Vertices[i].X = x_scale * (float)x / (float)x_res;                      Vertices[i].Y = y_scale * (float)y / (float)y_res;                      Vertices[i].Z = 0;                      Normals[i].X = Normals[i].Y = 0;                      Normals[i].Z = 1;                      i++;                  }              }
Magic Number,Examples.Shapes,Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Cube.cs,Cube,The following statement contains a magic number: Indices = new int[]              {                  // front face                  0' 1' 2' 2' 3' 0'                  // top face                  3' 2' 6' 6' 7' 3'                  // back face                  7' 6' 5' 5' 4' 7'                  // left face                  4' 0' 3' 3' 7' 4'                  // bottom face                  0' 1' 5' 5' 4' 0'                  // right face                  1' 5' 6' 6' 2' 1'              };
Magic Number,Examples.Shapes,Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Cube.cs,Cube,The following statement contains a magic number: Indices = new int[]              {                  // front face                  0' 1' 2' 2' 3' 0'                  // top face                  3' 2' 6' 6' 7' 3'                  // back face                  7' 6' 5' 5' 4' 7'                  // left face                  4' 0' 3' 3' 7' 4'                  // bottom face                  0' 1' 5' 5' 4' 0'                  // right face                  1' 5' 6' 6' 2' 1'              };
Magic Number,Examples.Shapes,Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Cube.cs,Cube,The following statement contains a magic number: Indices = new int[]              {                  // front face                  0' 1' 2' 2' 3' 0'                  // top face                  3' 2' 6' 6' 7' 3'                  // back face                  7' 6' 5' 5' 4' 7'                  // left face                  4' 0' 3' 3' 7' 4'                  // bottom face                  0' 1' 5' 5' 4' 0'                  // right face                  1' 5' 6' 6' 2' 1'              };
Magic Number,Examples.Shapes,Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Cube.cs,Cube,The following statement contains a magic number: Indices = new int[]              {                  // front face                  0' 1' 2' 2' 3' 0'                  // top face                  3' 2' 6' 6' 7' 3'                  // back face                  7' 6' 5' 5' 4' 7'                  // left face                  4' 0' 3' 3' 7' 4'                  // bottom face                  0' 1' 5' 5' 4' 0'                  // right face                  1' 5' 6' 6' 2' 1'              };
Magic Number,Examples.Shapes,Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Cube.cs,Cube,The following statement contains a magic number: Indices = new int[]              {                  // front face                  0' 1' 2' 2' 3' 0'                  // top face                  3' 2' 6' 6' 7' 3'                  // back face                  7' 6' 5' 5' 4' 7'                  // left face                  4' 0' 3' 3' 7' 4'                  // bottom face                  0' 1' 5' 5' 4' 0'                  // right face                  1' 5' 6' 6' 2' 1'              };
Magic Number,Examples.Shapes,Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Cube.cs,Cube,The following statement contains a magic number: Indices = new int[]              {                  // front face                  0' 1' 2' 2' 3' 0'                  // top face                  3' 2' 6' 6' 7' 3'                  // back face                  7' 6' 5' 5' 4' 7'                  // left face                  4' 0' 3' 3' 7' 4'                  // bottom face                  0' 1' 5' 5' 4' 0'                  // right face                  1' 5' 6' 6' 2' 1'              };
Magic Number,Examples.Shapes,Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Cube.cs,Cube,The following statement contains a magic number: Indices = new int[]              {                  // front face                  0' 1' 2' 2' 3' 0'                  // top face                  3' 2' 6' 6' 7' 3'                  // back face                  7' 6' 5' 5' 4' 7'                  // left face                  4' 0' 3' 3' 7' 4'                  // bottom face                  0' 1' 5' 5' 4' 0'                  // right face                  1' 5' 6' 6' 2' 1'              };
Magic Number,Examples.Shapes,Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Cube.cs,Cube,The following statement contains a magic number: Indices = new int[]              {                  // front face                  0' 1' 2' 2' 3' 0'                  // top face                  3' 2' 6' 6' 7' 3'                  // back face                  7' 6' 5' 5' 4' 7'                  // left face                  4' 0' 3' 3' 7' 4'                  // bottom face                  0' 1' 5' 5' 4' 0'                  // right face                  1' 5' 6' 6' 2' 1'              };
Magic Number,Examples.Shapes,Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Cube.cs,Cube,The following statement contains a magic number: Indices = new int[]              {                  // front face                  0' 1' 2' 2' 3' 0'                  // top face                  3' 2' 6' 6' 7' 3'                  // back face                  7' 6' 5' 5' 4' 7'                  // left face                  4' 0' 3' 3' 7' 4'                  // bottom face                  0' 1' 5' 5' 4' 0'                  // right face                  1' 5' 6' 6' 2' 1'              };
Magic Number,Examples.Shapes,Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Cube.cs,Cube,The following statement contains a magic number: Indices = new int[]              {                  // front face                  0' 1' 2' 2' 3' 0'                  // top face                  3' 2' 6' 6' 7' 3'                  // back face                  7' 6' 5' 5' 4' 7'                  // left face                  4' 0' 3' 3' 7' 4'                  // bottom face                  0' 1' 5' 5' 4' 0'                  // right face                  1' 5' 6' 6' 2' 1'              };
Magic Number,Examples.Shapes,Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Cube.cs,Cube,The following statement contains a magic number: Indices = new int[]              {                  // front face                  0' 1' 2' 2' 3' 0'                  // top face                  3' 2' 6' 6' 7' 3'                  // back face                  7' 6' 5' 5' 4' 7'                  // left face                  4' 0' 3' 3' 7' 4'                  // bottom face                  0' 1' 5' 5' 4' 0'                  // right face                  1' 5' 6' 6' 2' 1'              };
Magic Number,Examples.Shapes,Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Cube.cs,Cube,The following statement contains a magic number: Indices = new int[]              {                  // front face                  0' 1' 2' 2' 3' 0'                  // top face                  3' 2' 6' 6' 7' 3'                  // back face                  7' 6' 5' 5' 4' 7'                  // left face                  4' 0' 3' 3' 7' 4'                  // bottom face                  0' 1' 5' 5' 4' 0'                  // right face                  1' 5' 6' 6' 2' 1'              };
Magic Number,Examples.Shapes,Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Cube.cs,Cube,The following statement contains a magic number: Indices = new int[]              {                  // front face                  0' 1' 2' 2' 3' 0'                  // top face                  3' 2' 6' 6' 7' 3'                  // back face                  7' 6' 5' 5' 4' 7'                  // left face                  4' 0' 3' 3' 7' 4'                  // bottom face                  0' 1' 5' 5' 4' 0'                  // right face                  1' 5' 6' 6' 2' 1'              };
Magic Number,Examples.Shapes,Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Cube.cs,Cube,The following statement contains a magic number: Indices = new int[]              {                  // front face                  0' 1' 2' 2' 3' 0'                  // top face                  3' 2' 6' 6' 7' 3'                  // back face                  7' 6' 5' 5' 4' 7'                  // left face                  4' 0' 3' 3' 7' 4'                  // bottom face                  0' 1' 5' 5' 4' 0'                  // right face                  1' 5' 6' 6' 2' 1'              };
Magic Number,Examples.Shapes,Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Cube.cs,Cube,The following statement contains a magic number: Indices = new int[]              {                  // front face                  0' 1' 2' 2' 3' 0'                  // top face                  3' 2' 6' 6' 7' 3'                  // back face                  7' 6' 5' 5' 4' 7'                  // left face                  4' 0' 3' 3' 7' 4'                  // bottom face                  0' 1' 5' 5' 4' 0'                  // right face                  1' 5' 6' 6' 2' 1'              };
Magic Number,Examples.Shapes,Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Cube.cs,Cube,The following statement contains a magic number: Indices = new int[]              {                  // front face                  0' 1' 2' 2' 3' 0'                  // top face                  3' 2' 6' 6' 7' 3'                  // back face                  7' 6' 5' 5' 4' 7'                  // left face                  4' 0' 3' 3' 7' 4'                  // bottom face                  0' 1' 5' 5' 4' 0'                  // right face                  1' 5' 6' 6' 2' 1'              };
Magic Number,Examples.Shapes,Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Cube.cs,Cube,The following statement contains a magic number: Indices = new int[]              {                  // front face                  0' 1' 2' 2' 3' 0'                  // top face                  3' 2' 6' 6' 7' 3'                  // back face                  7' 6' 5' 5' 4' 7'                  // left face                  4' 0' 3' 3' 7' 4'                  // bottom face                  0' 1' 5' 5' 4' 0'                  // right face                  1' 5' 6' 6' 2' 1'              };
Magic Number,Examples.Shapes,Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Cube.cs,Cube,The following statement contains a magic number: Indices = new int[]              {                  // front face                  0' 1' 2' 2' 3' 0'                  // top face                  3' 2' 6' 6' 7' 3'                  // back face                  7' 6' 5' 5' 4' 7'                  // left face                  4' 0' 3' 3' 7' 4'                  // bottom face                  0' 1' 5' 5' 4' 0'                  // right face                  1' 5' 6' 6' 2' 1'              };
Magic Number,Examples.Shapes,Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Cube.cs,Cube,The following statement contains a magic number: Indices = new int[]              {                  // front face                  0' 1' 2' 2' 3' 0'                  // top face                  3' 2' 6' 6' 7' 3'                  // back face                  7' 6' 5' 5' 4' 7'                  // left face                  4' 0' 3' 3' 7' 4'                  // bottom face                  0' 1' 5' 5' 4' 0'                  // right face                  1' 5' 6' 6' 2' 1'              };
Magic Number,Examples.Shapes,Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Cube.cs,Cube,The following statement contains a magic number: Indices = new int[]              {                  // front face                  0' 1' 2' 2' 3' 0'                  // top face                  3' 2' 6' 6' 7' 3'                  // back face                  7' 6' 5' 5' 4' 7'                  // left face                  4' 0' 3' 3' 7' 4'                  // bottom face                  0' 1' 5' 5' 4' 0'                  // right face                  1' 5' 6' 6' 2' 1'              };
Magic Number,Examples.Shapes,Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Cube.cs,Cube,The following statement contains a magic number: Indices = new int[]              {                  // front face                  0' 1' 2' 2' 3' 0'                  // top face                  3' 2' 6' 6' 7' 3'                  // back face                  7' 6' 5' 5' 4' 7'                  // left face                  4' 0' 3' 3' 7' 4'                  // bottom face                  0' 1' 5' 5' 4' 0'                  // right face                  1' 5' 6' 6' 2' 1'              };
Magic Number,Examples.Shapes,Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Cube.cs,Cube,The following statement contains a magic number: Indices = new int[]              {                  // front face                  0' 1' 2' 2' 3' 0'                  // top face                  3' 2' 6' 6' 7' 3'                  // back face                  7' 6' 5' 5' 4' 7'                  // left face                  4' 0' 3' 3' 7' 4'                  // bottom face                  0' 1' 5' 5' 4' 0'                  // right face                  1' 5' 6' 6' 2' 1'              };
Magic Number,Examples.Shapes,Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Cube.cs,Cube,The following statement contains a magic number: Indices = new int[]              {                  // front face                  0' 1' 2' 2' 3' 0'                  // top face                  3' 2' 6' 6' 7' 3'                  // back face                  7' 6' 5' 5' 4' 7'                  // left face                  4' 0' 3' 3' 7' 4'                  // bottom face                  0' 1' 5' 5' 4' 0'                  // right face                  1' 5' 6' 6' 2' 1'              };
Magic Number,Examples.Shapes,Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Cube.cs,Cube,The following statement contains a magic number: Indices = new int[]              {                  // front face                  0' 1' 2' 2' 3' 0'                  // top face                  3' 2' 6' 6' 7' 3'                  // back face                  7' 6' 5' 5' 4' 7'                  // left face                  4' 0' 3' 3' 7' 4'                  // bottom face                  0' 1' 5' 5' 4' 0'                  // right face                  1' 5' 6' 6' 2' 1'              };
Magic Number,Examples.Shapes,Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Cube.cs,Cube,The following statement contains a magic number: Indices = new int[]              {                  // front face                  0' 1' 2' 2' 3' 0'                  // top face                  3' 2' 6' 6' 7' 3'                  // back face                  7' 6' 5' 5' 4' 7'                  // left face                  4' 0' 3' 3' 7' 4'                  // bottom face                  0' 1' 5' 5' 4' 0'                  // right face                  1' 5' 6' 6' 2' 1'              };
Magic Number,Examples.Shapes,Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Cube.cs,Cube,The following statement contains a magic number: Indices = new int[]              {                  // front face                  0' 1' 2' 2' 3' 0'                  // top face                  3' 2' 6' 6' 7' 3'                  // back face                  7' 6' 5' 5' 4' 7'                  // left face                  4' 0' 3' 3' 7' 4'                  // bottom face                  0' 1' 5' 5' 4' 0'                  // right face                  1' 5' 6' 6' 2' 1'              };
Magic Number,Examples.Shapes,Cube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Old\Cube.cs,Cube,The following statement contains a magic number: Indices = new int[]              {                  // front face                  0' 1' 2' 2' 3' 0'                  // top face                  3' 2' 6' 6' 7' 3'                  // back face                  7' 6' 5' 5' 4' 7'                  // left face                  4' 0' 3' 3' 7' 4'                  // bottom face                  0' 1' 5' 5' 4' 0'                  // right face                  1' 5' 6' 6' 2' 1'              };
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,GetArraySizes,The following statement contains a magic number: vertexcount = (uint)VisibleSides.Length * 8 + 6 * 12;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,GetArraySizes,The following statement contains a magic number: vertexcount = (uint)VisibleSides.Length * 8 + 6 * 12;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,GetArraySizes,The following statement contains a magic number: vertexcount = (uint)VisibleSides.Length * 8 + 6 * 12;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,GetArraySizes,The following statement contains a magic number: indexcount = (uint)VisibleSides.Length * 8 * 3 + 6 * 8 * 3;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,GetArraySizes,The following statement contains a magic number: indexcount = (uint)VisibleSides.Length * 8 * 3 + 6 * 8 * 3;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,GetArraySizes,The following statement contains a magic number: indexcount = (uint)VisibleSides.Length * 8 * 3 + 6 * 8 * 3;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,GetArraySizes,The following statement contains a magic number: indexcount = (uint)VisibleSides.Length * 8 * 3 + 6 * 8 * 3;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,GetArraySizes,The following statement contains a magic number: indexcount = (uint)VisibleSides.Length * 8 * 3 + 6 * 8 * 3;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The following statement contains a magic number: cubes = new MengerCube[20];
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The following statement contains a magic number: double NewLength = this.SideLength / 3.0;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The following statement contains a magic number: double six = this.SideLength * 2.0 / 3.0;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The following statement contains a magic number: double six = this.SideLength * 2.0 / 3.0;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The following statement contains a magic number: cubes[2] = new MengerCube( new Vector3d( Center.X + six' Center.Y + six' Center.Z + six )' NewLength' new eSides[] { eSides.Front' eSides.Right' eSides.Top }' this.VisibilityToInherit );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The following statement contains a magic number: cubes[3] = new MengerCube( new Vector3d( Center.X - six' Center.Y + 0.0' Center.Z + six )' NewLength' new eSides[] { eSides.Front' eSides.Right' eSides.Back' eSides.Left }' this.VisibilityToInherit );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The following statement contains a magic number: cubes[4] = new MengerCube( new Vector3d( Center.X + six' Center.Y + 0.0' Center.Z + six )' NewLength' new eSides[] { eSides.Front' eSides.Right' eSides.Back' eSides.Left }' this.VisibilityToInherit );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The following statement contains a magic number: cubes[5] = new MengerCube( new Vector3d( Center.X - six' Center.Y - six' Center.Z + six )' NewLength' new eSides[] { eSides.Front' eSides.Left' eSides.Bottom } ' this.VisibilityToInherit );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The following statement contains a magic number: cubes[6] = new MengerCube( new Vector3d( Center.X + 0.0' Center.Y - six' Center.Z + six )' NewLength' new eSides[] { eSides.Front' eSides.Top' eSides.Back' eSides.Bottom }' this.VisibilityToInherit );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The following statement contains a magic number: cubes[7] = new MengerCube( new Vector3d( Center.X + six' Center.Y - six' Center.Z + six )' NewLength' new eSides[] { eSides.Front' eSides.Right' eSides.Bottom }' this.VisibilityToInherit );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The following statement contains a magic number: cubes[8] = new MengerCube( new Vector3d( Center.X - six' Center.Y + six' Center.Z + 0.0 )' NewLength' new eSides[] { eSides.Top' eSides.Right' eSides.Bottom' eSides.Left }' this.VisibilityToInherit );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The following statement contains a magic number: cubes[9] = new MengerCube( new Vector3d( Center.X + six' Center.Y + six' Center.Z + 0.0 )' NewLength' new eSides[] { eSides.Top' eSides.Right' eSides.Bottom' eSides.Left }' this.VisibilityToInherit );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The following statement contains a magic number: cubes[10] = new MengerCube( new Vector3d( Center.X - six' Center.Y - six' Center.Z + 0.0 )' NewLength' new eSides[] { eSides.Top' eSides.Right' eSides.Bottom' eSides.Left }' this.VisibilityToInherit );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The following statement contains a magic number: cubes[11] = new MengerCube( new Vector3d( Center.X + six' Center.Y - six' Center.Z + 0.0 )' NewLength' new eSides[] { eSides.Top' eSides.Right' eSides.Bottom' eSides.Left }' this.VisibilityToInherit );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The following statement contains a magic number: cubes[12] = new MengerCube( new Vector3d( Center.X - six' Center.Y + six' Center.Z - six )' NewLength' new eSides[] { eSides.Top' eSides.Back' eSides.Left }' this.VisibilityToInherit );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The following statement contains a magic number: cubes[13] = new MengerCube( new Vector3d( Center.X + 0.0' Center.Y + six' Center.Z - six )' NewLength' new eSides[] { eSides.Top' eSides.Back' eSides.Bottom' eSides.Front }' this.VisibilityToInherit );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The following statement contains a magic number: cubes[14] = new MengerCube( new Vector3d( Center.X + six' Center.Y + six' Center.Z - six )' NewLength' new eSides[] { eSides.Top' eSides.Back' eSides.Right }' this.VisibilityToInherit );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The following statement contains a magic number: cubes[15] = new MengerCube( new Vector3d( Center.X - six' Center.Y + 0.0' Center.Z - six )' NewLength' new eSides[] { eSides.Front' eSides.Right' eSides.Back' eSides.Left } ' this.VisibilityToInherit );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The following statement contains a magic number: cubes[16] = new MengerCube( new Vector3d( Center.X + six' Center.Y + 0.0' Center.Z - six )' NewLength' new eSides[] { eSides.Front' eSides.Right' eSides.Back' eSides.Left } ' this.VisibilityToInherit );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The following statement contains a magic number: cubes[17] = new MengerCube( new Vector3d( Center.X - six' Center.Y - six' Center.Z - six )' NewLength' new eSides[] { eSides.Back' eSides.Bottom' eSides.Left } ' this.VisibilityToInherit );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The following statement contains a magic number: cubes[18] = new MengerCube( new Vector3d( Center.X + 0.0' Center.Y - six' Center.Z - six )' NewLength' new eSides[] { eSides.Top' eSides.Back' eSides.Bottom' eSides.Front }' this.VisibilityToInherit );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,Subdivide,The following statement contains a magic number: cubes[19] = new MengerCube( new Vector3d( Center.X + six' Center.Y - six' Center.Z - six )' NewLength' new eSides[] { eSides.Back' eSides.Bottom' eSides.Right }' this.VisibilityToInherit );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: double _Three = 0.3333333333333;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: double _Six = 0.66666666666666;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: if ( FaceIsVisible )                  {                      #region Define Layer1 Vertices                      Chunk Layer1 = new Chunk( 8' 8 * 3 );                        Layer1.Vertices[0].TexCoord = new Vector2d( _Zero' _Zero );                      Layer1.Vertices[0].Normal = FaceNormal;                      Layer1.Vertices[0].Position = P0;                        Layer1.Vertices[1].TexCoord = new Vector2d( _One' _Zero );                      Layer1.Vertices[1].Normal = FaceNormal;                      Layer1.Vertices[1].Position = P1;                        Layer1.Vertices[2].TexCoord = new Vector2d( _One' _One );                      Layer1.Vertices[2].Normal = FaceNormal;                      Layer1.Vertices[2].Position = P2;                        Layer1.Vertices[3].TexCoord = new Vector2d( _Zero' _One );                      Layer1.Vertices[3].Normal = FaceNormal;                      Layer1.Vertices[3].Position = P3;                        Layer1.Vertices[4].TexCoord = new Vector2d( _Three' _Three );                      Layer1.Vertices[4].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Three' out Layer1.Vertices[4].Position );                        Layer1.Vertices[5].TexCoord = new Vector2d( _Six' _Three );                      Layer1.Vertices[5].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Three' out Layer1.Vertices[5].Position );                        Layer1.Vertices[6].TexCoord = new Vector2d( _Six' _Six );                      Layer1.Vertices[6].Normal = FaceNormal;                      Vector3d.Lerp( ref P0' ref P2' _Six' out Layer1.Vertices[6].Position );                        Layer1.Vertices[7].TexCoord = new Vector2d( _Three' _Six );                      Layer1.Vertices[7].Normal = FaceNormal;                      Vector3d.Lerp( ref P1' ref P3' _Six' out Layer1.Vertices[7].Position );                      #endregion Define Layer1 Vertices                        #region Define Layer1 Indices                      Layer1.Indices[0] = 0;                      Layer1.Indices[1] = 5;                      Layer1.Indices[2] = 4;                        Layer1.Indices[3] = 0;                      Layer1.Indices[4] = 1;                      Layer1.Indices[5] = 5;                        Layer1.Indices[6] = 5;                      Layer1.Indices[7] = 1;                      Layer1.Indices[8] = 2;                        Layer1.Indices[9] = 6;                      Layer1.Indices[10] = 5;                      Layer1.Indices[11] = 2;                        Layer1.Indices[12] = 7;                      Layer1.Indices[13] = 6;                      Layer1.Indices[14] = 2;                        Layer1.Indices[15] = 3;                      Layer1.Indices[16] = 7;                      Layer1.Indices[17] = 2;                        Layer1.Indices[18] = 0;                      Layer1.Indices[19] = 7;                      Layer1.Indices[20] = 3;                        Layer1.Indices[21] = 0;                      Layer1.Indices[22] = 4;                      Layer1.Indices[23] = 7;                        chunks.Add( Layer1 );                      #endregion Define Layer1 Indices                  }
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Chunk Layer2 = new Chunk( 12' 8 * 3 );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Chunk Layer2 = new Chunk( 12' 8 * 3 );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Chunk Layer2 = new Chunk( 12' 8 * 3 );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Vertices[3].TexCoord = new Vector2d( _One' _Three );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Vertices[3].Normal = FaceNormal;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Vector3d.Lerp( ref T1' ref  T2' _Three' out Layer2.Vertices[3].Position );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Vertices[4].TexCoord = new Vector2d( _One' _Six );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Vertices[4].Normal = FaceNormal;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Vector3d.Lerp( ref T1' ref  T2' _Six' out Layer2.Vertices[4].Position );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Vertices[6].TexCoord = new Vector2d( _Six' _One );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Vertices[6].Normal = FaceNormal;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Vector3d.Lerp( ref T2' ref T3' _Three' out Layer2.Vertices[6].Position );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Vertices[7].TexCoord = new Vector2d( _Three' _One );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Vertices[7].Normal = FaceNormal;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Vector3d.Lerp( ref T2' ref  T3' _Six' out Layer2.Vertices[7].Position );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Vertices[9].TexCoord = new Vector2d( _Zero' _Six );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Vertices[9].Normal = FaceNormal;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Vector3d.Lerp( ref T3' ref  T0' _Three' out Layer2.Vertices[9].Position );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Vertices[10].TexCoord = new Vector2d( _Zero' _Three );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Vertices[10].Normal = FaceNormal;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Vector3d.Lerp( ref  T3' ref  T0' _Six' out Layer2.Vertices[10].Position );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Vertices[2].TexCoord = new Vector2d( _Six' _Three );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Vertices[2].Normal = FaceNormal;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Vector3d.Lerp( ref Layer2.Vertices[1].Position' ref Layer2.Vertices[6].Position' _Three' out Layer2.Vertices[2].Position );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Vector3d.Lerp( ref Layer2.Vertices[1].Position' ref Layer2.Vertices[6].Position' _Three' out Layer2.Vertices[2].Position );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Vertices[5].TexCoord = new Vector2d( _Six' _Six );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Vertices[5].Normal = FaceNormal;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Vector3d.Lerp( ref Layer2.Vertices[1].Position' ref Layer2.Vertices[6].Position' _Six' out Layer2.Vertices[5].Position );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Vector3d.Lerp( ref Layer2.Vertices[1].Position' ref Layer2.Vertices[6].Position' _Six' out Layer2.Vertices[5].Position );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Vertices[8].TexCoord = new Vector2d( _Three' _Six );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Vertices[8].Normal = FaceNormal;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Vector3d.Lerp( ref Layer2.Vertices[7].Position' ref Layer2.Vertices[0].Position' _Three' out Layer2.Vertices[8].Position );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Vector3d.Lerp( ref Layer2.Vertices[7].Position' ref Layer2.Vertices[0].Position' _Three' out Layer2.Vertices[8].Position );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Vertices[11].TexCoord = new Vector2d( _Three' _Three );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Vertices[11].Normal = FaceNormal;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Vector3d.Lerp( ref Layer2.Vertices[7].Position' ref Layer2.Vertices[0].Position' _Six' out Layer2.Vertices[11].Position );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Vector3d.Lerp( ref Layer2.Vertices[7].Position' ref Layer2.Vertices[0].Position' _Six' out Layer2.Vertices[11].Position );
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[1] = 2;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[2] = 11;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[2] = 11;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[3] = 0;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[4] = 1;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[5] = 2;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[5] = 2;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[6] = 2;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[6] = 2;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[7] = 3;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[7] = 3;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[8] = 4;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[8] = 4;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[9] = 2;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[9] = 2;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[10] = 4;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[10] = 4;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[11] = 5;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[11] = 5;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[12] = 5;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[12] = 5;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[13] = 6;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[13] = 6;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[14] = 8;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[14] = 8;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[15] = 8;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[15] = 8;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[16] = 6;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[16] = 6;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[17] = 7;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[17] = 7;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[18] = 11;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[18] = 11;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[19] = 8;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[19] = 8;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[20] = 10;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[20] = 10;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[21] = 10;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[21] = 10;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[22] = 8;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[22] = 8;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[23] = 9;
Magic Number,Examples.Shapes,MengerCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\MengerCube.cs,DrawSide,The following statement contains a magic number: Layer2.Indices[23] = 9;
Magic Number,Examples.Shapes,TetrahedronFace,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\TetrahedronFace.cs,SubdivideSierpinski,The following statement contains a magic number: Vector3d.Lerp( ref this.APosition' ref this.DPosition' 0.5' out CenterAD );
Magic Number,Examples.Shapes,TetrahedronFace,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\TetrahedronFace.cs,SubdivideSierpinski,The following statement contains a magic number: Vector3d.Lerp( ref this.BPosition' ref this.DPosition' 0.5' out CenterBD );
Magic Number,Examples.Shapes,TetrahedronFace,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\TetrahedronFace.cs,SubdivideSierpinski,The following statement contains a magic number: Vector3d.Lerp( ref this.CPosition' ref this.DPosition' 0.5' out CenterCD );
Magic Number,Examples.Shapes,TetrahedronFace,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\TetrahedronFace.cs,SubdivideKoch,The following statement contains a magic number: Vector3d.Lerp( ref this.APosition' ref this.BPosition' 0.5' out CenterAB );
Magic Number,Examples.Shapes,TetrahedronFace,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\TetrahedronFace.cs,SubdivideKoch,The following statement contains a magic number: Vector3d.Lerp( ref this.BPosition' ref this.CPosition' 0.5' out CenterBC );
Magic Number,Examples.Shapes,TetrahedronFace,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\TetrahedronFace.cs,SubdivideKoch,The following statement contains a magic number: Vector3d.Lerp( ref this.CPosition' ref this.APosition' 0.5' out CenterCA );
Magic Number,Examples.Shapes,TetrahedronFace,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\TetrahedronFace.cs,SubdivideKoch,The following statement contains a magic number: CenterD /= 3.0;
Magic Number,Examples.Shapes,TetrahedronFace,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\TetrahedronFace.cs,SubdivideKoch,The following statement contains a magic number: Vector3d E = CenterD + ( this.Normal * 0.5 );
Magic Number,Examples.Shapes,TetrahedronFace,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\TetrahedronFace.cs,SubdivideKoch,The following statement contains a magic number: Vector2d.Lerp( ref this.ATexCoord' ref this.BTexCoord' 0.5' out TexCoordAB );
Magic Number,Examples.Shapes,TetrahedronFace,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\TetrahedronFace.cs,SubdivideKoch,The following statement contains a magic number: Vector2d.Lerp( ref this.BTexCoord' ref this.CTexCoord' 0.5' out TexCoordBC );
Magic Number,Examples.Shapes,TetrahedronFace,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\TetrahedronFace.cs,SubdivideKoch,The following statement contains a magic number: Vector2d.Lerp( ref this.CTexCoord' ref this.ATexCoord' 0.5' out TexCoordCA );
Magic Number,Examples.Shapes,TetrahedronFace,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\TetrahedronFace.cs,SubdivideKoch,The following statement contains a magic number: TexCoordD /= 3.0;
Magic Number,Examples.Shapes,TetrahedronFace,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\TetrahedronFace.cs,SubdivideKoch,The following statement contains a magic number: temp /= 3.0;
Magic Number,Examples.Shapes,TetrahedronFace,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\TetrahedronFace.cs,SubdivideKoch,The following statement contains a magic number: temp /=  3.0;
Magic Number,Examples.Shapes,TetrahedronFace,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Helpers\TetrahedronFace.cs,SubdivideKoch,The following statement contains a magic number: temp /= 3.0;
Magic Number,Examples.WinForms,FontRenderingBasic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Fonts\FontRenderingBasic.cs,glControl1_Paint,The following statement contains a magic number: foreach (Font font in fonts)              {                  //printer.Print(textBox1.Text' font' Color.White);                  GL.Translate(0' font.Height + 5' 0);              }
Magic Number,Examples.WinForms,FontRenderingBasic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Fonts\FontRenderingBasic.cs,InitializeComponent,The following statement contains a magic number: this.glControl1.Location = new System.Drawing.Point(0' 40);
Magic Number,Examples.WinForms,FontRenderingBasic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Fonts\FontRenderingBasic.cs,InitializeComponent,The following statement contains a magic number: this.glControl1.Size = new System.Drawing.Size(700' 521);
Magic Number,Examples.WinForms,FontRenderingBasic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Fonts\FontRenderingBasic.cs,InitializeComponent,The following statement contains a magic number: this.glControl1.Size = new System.Drawing.Size(700' 521);
Magic Number,Examples.WinForms,FontRenderingBasic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Fonts\FontRenderingBasic.cs,InitializeComponent,The following statement contains a magic number: this.changeFont.Location = new System.Drawing.Point(568' 10);
Magic Number,Examples.WinForms,FontRenderingBasic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Fonts\FontRenderingBasic.cs,InitializeComponent,The following statement contains a magic number: this.changeFont.Location = new System.Drawing.Point(568' 10);
Magic Number,Examples.WinForms,FontRenderingBasic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Fonts\FontRenderingBasic.cs,InitializeComponent,The following statement contains a magic number: this.changeFont.Size = new System.Drawing.Size(120' 23);
Magic Number,Examples.WinForms,FontRenderingBasic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Fonts\FontRenderingBasic.cs,InitializeComponent,The following statement contains a magic number: this.changeFont.Size = new System.Drawing.Size(120' 23);
Magic Number,Examples.WinForms,FontRenderingBasic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Fonts\FontRenderingBasic.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Location = new System.Drawing.Point(12' 11);
Magic Number,Examples.WinForms,FontRenderingBasic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Fonts\FontRenderingBasic.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Location = new System.Drawing.Point(12' 11);
Magic Number,Examples.WinForms,FontRenderingBasic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Fonts\FontRenderingBasic.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Size = new System.Drawing.Size(550' 22);
Magic Number,Examples.WinForms,FontRenderingBasic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Fonts\FontRenderingBasic.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Size = new System.Drawing.Size(550' 22);
Magic Number,Examples.WinForms,FontRenderingBasic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Fonts\FontRenderingBasic.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.TabIndex = 2;
Magic Number,Examples.WinForms,FontRenderingBasic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Fonts\FontRenderingBasic.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(700' 561);
Magic Number,Examples.WinForms,FontRenderingBasic,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Fonts\FontRenderingBasic.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(700' 561);
Magic Number,Examples.WinForms,SimpleForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\GLControlSimple.cs,InitializeComponent,The following statement contains a magic number: this.redButton.Location = new System.Drawing.Point(639' 13);
Magic Number,Examples.WinForms,SimpleForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\GLControlSimple.cs,InitializeComponent,The following statement contains a magic number: this.redButton.Location = new System.Drawing.Point(639' 13);
Magic Number,Examples.WinForms,SimpleForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\GLControlSimple.cs,InitializeComponent,The following statement contains a magic number: this.redButton.Size = new System.Drawing.Size(133' 23);
Magic Number,Examples.WinForms,SimpleForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\GLControlSimple.cs,InitializeComponent,The following statement contains a magic number: this.redButton.Size = new System.Drawing.Size(133' 23);
Magic Number,Examples.WinForms,SimpleForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\GLControlSimple.cs,InitializeComponent,The following statement contains a magic number: this.greenButton.Location = new System.Drawing.Point(639' 43);
Magic Number,Examples.WinForms,SimpleForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\GLControlSimple.cs,InitializeComponent,The following statement contains a magic number: this.greenButton.Location = new System.Drawing.Point(639' 43);
Magic Number,Examples.WinForms,SimpleForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\GLControlSimple.cs,InitializeComponent,The following statement contains a magic number: this.greenButton.Size = new System.Drawing.Size(133' 23);
Magic Number,Examples.WinForms,SimpleForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\GLControlSimple.cs,InitializeComponent,The following statement contains a magic number: this.greenButton.Size = new System.Drawing.Size(133' 23);
Magic Number,Examples.WinForms,SimpleForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\GLControlSimple.cs,InitializeComponent,The following statement contains a magic number: this.greenButton.TabIndex = 2;
Magic Number,Examples.WinForms,SimpleForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\GLControlSimple.cs,InitializeComponent,The following statement contains a magic number: this.blueButton.Location = new System.Drawing.Point(639' 73);
Magic Number,Examples.WinForms,SimpleForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\GLControlSimple.cs,InitializeComponent,The following statement contains a magic number: this.blueButton.Location = new System.Drawing.Point(639' 73);
Magic Number,Examples.WinForms,SimpleForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\GLControlSimple.cs,InitializeComponent,The following statement contains a magic number: this.blueButton.Size = new System.Drawing.Size(133' 23);
Magic Number,Examples.WinForms,SimpleForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\GLControlSimple.cs,InitializeComponent,The following statement contains a magic number: this.blueButton.Size = new System.Drawing.Size(133' 23);
Magic Number,Examples.WinForms,SimpleForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\GLControlSimple.cs,InitializeComponent,The following statement contains a magic number: this.blueButton.TabIndex = 3;
Magic Number,Examples.WinForms,SimpleForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\GLControlSimple.cs,InitializeComponent,The following statement contains a magic number: this.glControl1.Size = new System.Drawing.Size(629' 565);
Magic Number,Examples.WinForms,SimpleForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\GLControlSimple.cs,InitializeComponent,The following statement contains a magic number: this.glControl1.Size = new System.Drawing.Size(629' 565);
Magic Number,Examples.WinForms,SimpleForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\GLControlSimple.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(781' 564);
Magic Number,Examples.WinForms,SimpleForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\GLControlSimple.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(781' 564);
Magic Number,Examples.WinForms,MultipleGLControlsForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\MultipleGLControls.cs,InitializeComponent,The following statement contains a magic number: this.derivedGLControl1.Location = new System.Drawing.Point(12' 12);
Magic Number,Examples.WinForms,MultipleGLControlsForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\MultipleGLControls.cs,InitializeComponent,The following statement contains a magic number: this.derivedGLControl1.Location = new System.Drawing.Point(12' 12);
Magic Number,Examples.WinForms,MultipleGLControlsForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\MultipleGLControls.cs,InitializeComponent,The following statement contains a magic number: this.derivedGLControl1.Size = new System.Drawing.Size(300' 225);
Magic Number,Examples.WinForms,MultipleGLControlsForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\MultipleGLControls.cs,InitializeComponent,The following statement contains a magic number: this.derivedGLControl1.Size = new System.Drawing.Size(300' 225);
Magic Number,Examples.WinForms,MultipleGLControlsForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\MultipleGLControls.cs,InitializeComponent,The following statement contains a magic number: this.derivedGLControl2.ClearColor = System.Drawing.Color.FromArgb(((int)(((byte)(255))))' ((int)(((byte)(255))))' ((int)(((byte)(192)))));
Magic Number,Examples.WinForms,MultipleGLControlsForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\MultipleGLControls.cs,InitializeComponent,The following statement contains a magic number: this.derivedGLControl2.ClearColor = System.Drawing.Color.FromArgb(((int)(((byte)(255))))' ((int)(((byte)(255))))' ((int)(((byte)(192)))));
Magic Number,Examples.WinForms,MultipleGLControlsForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\MultipleGLControls.cs,InitializeComponent,The following statement contains a magic number: this.derivedGLControl2.ClearColor = System.Drawing.Color.FromArgb(((int)(((byte)(255))))' ((int)(((byte)(255))))' ((int)(((byte)(192)))));
Magic Number,Examples.WinForms,MultipleGLControlsForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\MultipleGLControls.cs,InitializeComponent,The following statement contains a magic number: this.derivedGLControl2.Location = new System.Drawing.Point(319' 13);
Magic Number,Examples.WinForms,MultipleGLControlsForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\MultipleGLControls.cs,InitializeComponent,The following statement contains a magic number: this.derivedGLControl2.Location = new System.Drawing.Point(319' 13);
Magic Number,Examples.WinForms,MultipleGLControlsForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\MultipleGLControls.cs,InitializeComponent,The following statement contains a magic number: this.derivedGLControl2.Size = new System.Drawing.Size(293' 224);
Magic Number,Examples.WinForms,MultipleGLControlsForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\MultipleGLControls.cs,InitializeComponent,The following statement contains a magic number: this.derivedGLControl2.Size = new System.Drawing.Size(293' 224);
Magic Number,Examples.WinForms,MultipleGLControlsForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\MultipleGLControls.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(624' 444);
Magic Number,Examples.WinForms,MultipleGLControlsForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\MultipleGLControls.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(624' 444);
Magic Number,Examples.WinForms,GameLoopForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\GLControlGameLoop.cs,glControl_Resize,The following statement contains a magic number: Matrix4 perpective = Matrix4.CreatePerspectiveFieldOfView(MathHelper.PiOver4' aspect_ratio' 1' 64);
Magic Number,Examples.WinForms,GameLoopForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\GLControlGameLoop.cs,Render,The following statement contains a magic number: Matrix4 lookat = Matrix4.LookAt(0' 5' 5' 0' 0' 0' 0' 1' 0);
Magic Number,Examples.WinForms,GameLoopForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\GLControlGameLoop.cs,Render,The following statement contains a magic number: Matrix4 lookat = Matrix4.LookAt(0' 5' 5' 0' 0' 0' 0' 1' 0);
Magic Number,Examples.WinForms,GameLoopForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\GLControlGameLoop.cs,InitializeComponent,The following statement contains a magic number: this.glControl.Size = new System.Drawing.Size(784' 564);
Magic Number,Examples.WinForms,GameLoopForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\GLControlGameLoop.cs,InitializeComponent,The following statement contains a magic number: this.glControl.Size = new System.Drawing.Size(784' 564);
Magic Number,Examples.WinForms,GameLoopForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\GLControlGameLoop.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(784' 564);
Magic Number,Examples.WinForms,GameLoopForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\GLControlGameLoop.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(784' 564);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,StartAsync,The following statement contains a magic number: using (INativeWindow window = new OpenTK.NativeWindow())              using (IGraphicsContext context = new GraphicsContext(GraphicsMode.Default' window.WindowInfo' 3' 0' GraphicsContextFlags.Default))              {                  window.ProcessEvents();                  context.MakeCurrent(window.WindowInfo);                  (context as IGraphicsContextInternal).LoadAll();                    TextBoxVendor.Text = GL.GetString(StringName.Vendor);                  TextBoxRenderer.Text = GL.GetString(StringName.Renderer);                  TextBoxVersion.Text = GL.GetString(StringName.Version);              }
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,backgroundWorker1_RunWorkerCompleted,The following statement contains a magic number: foreach (Function f in functions.Keys)              {                  dataGridView1.Rows.Add(functions[f]' f.Name' f.Category' f.Version' f.Extension' f.EntryPoint);                  int index = dataGridView1.Rows.Count - 1;                    // Some simple coloring to make the GridView easier on the eyes.                  // Supported functions are green' unsupported are redish.                  dataGridView1.Rows[index].DefaultCellStyle.BackColor =                      functions[f] ?                      (index % 2 != 0 ? Color.FromArgb(128' 255' 192) : Color.FromArgb(192' 255' 192)) :                      (index % 2 != 0 ? Color.FromArgb(255' 192' 160) : Color.FromArgb(255' 200' 160));              }
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,backgroundWorker1_RunWorkerCompleted,The following statement contains a magic number: foreach (Function f in functions.Keys)              {                  dataGridView1.Rows.Add(functions[f]' f.Name' f.Category' f.Version' f.Extension' f.EntryPoint);                  int index = dataGridView1.Rows.Count - 1;                    // Some simple coloring to make the GridView easier on the eyes.                  // Supported functions are green' unsupported are redish.                  dataGridView1.Rows[index].DefaultCellStyle.BackColor =                      functions[f] ?                      (index % 2 != 0 ? Color.FromArgb(128' 255' 192) : Color.FromArgb(192' 255' 192)) :                      (index % 2 != 0 ? Color.FromArgb(255' 192' 160) : Color.FromArgb(255' 200' 160));              }
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,backgroundWorker1_RunWorkerCompleted,The following statement contains a magic number: foreach (Function f in functions.Keys)              {                  dataGridView1.Rows.Add(functions[f]' f.Name' f.Category' f.Version' f.Extension' f.EntryPoint);                  int index = dataGridView1.Rows.Count - 1;                    // Some simple coloring to make the GridView easier on the eyes.                  // Supported functions are green' unsupported are redish.                  dataGridView1.Rows[index].DefaultCellStyle.BackColor =                      functions[f] ?                      (index % 2 != 0 ? Color.FromArgb(128' 255' 192) : Color.FromArgb(192' 255' 192)) :                      (index % 2 != 0 ? Color.FromArgb(255' 192' 160) : Color.FromArgb(255' 200' 160));              }
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,backgroundWorker1_RunWorkerCompleted,The following statement contains a magic number: foreach (Function f in functions.Keys)              {                  dataGridView1.Rows.Add(functions[f]' f.Name' f.Category' f.Version' f.Extension' f.EntryPoint);                  int index = dataGridView1.Rows.Count - 1;                    // Some simple coloring to make the GridView easier on the eyes.                  // Supported functions are green' unsupported are redish.                  dataGridView1.Rows[index].DefaultCellStyle.BackColor =                      functions[f] ?                      (index % 2 != 0 ? Color.FromArgb(128' 255' 192) : Color.FromArgb(192' 255' 192)) :                      (index % 2 != 0 ? Color.FromArgb(255' 192' 160) : Color.FromArgb(255' 200' 160));              }
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,backgroundWorker1_RunWorkerCompleted,The following statement contains a magic number: foreach (Function f in functions.Keys)              {                  dataGridView1.Rows.Add(functions[f]' f.Name' f.Category' f.Version' f.Extension' f.EntryPoint);                  int index = dataGridView1.Rows.Count - 1;                    // Some simple coloring to make the GridView easier on the eyes.                  // Supported functions are green' unsupported are redish.                  dataGridView1.Rows[index].DefaultCellStyle.BackColor =                      functions[f] ?                      (index % 2 != 0 ? Color.FromArgb(128' 255' 192) : Color.FromArgb(192' 255' 192)) :                      (index % 2 != 0 ? Color.FromArgb(255' 192' 160) : Color.FromArgb(255' 200' 160));              }
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,backgroundWorker1_RunWorkerCompleted,The following statement contains a magic number: foreach (Function f in functions.Keys)              {                  dataGridView1.Rows.Add(functions[f]' f.Name' f.Category' f.Version' f.Extension' f.EntryPoint);                  int index = dataGridView1.Rows.Count - 1;                    // Some simple coloring to make the GridView easier on the eyes.                  // Supported functions are green' unsupported are redish.                  dataGridView1.Rows[index].DefaultCellStyle.BackColor =                      functions[f] ?                      (index % 2 != 0 ? Color.FromArgb(128' 255' 192) : Color.FromArgb(192' 255' 192)) :                      (index % 2 != 0 ? Color.FromArgb(255' 192' 160) : Color.FromArgb(255' 200' 160));              }
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,backgroundWorker1_RunWorkerCompleted,The following statement contains a magic number: foreach (Function f in functions.Keys)              {                  dataGridView1.Rows.Add(functions[f]' f.Name' f.Category' f.Version' f.Extension' f.EntryPoint);                  int index = dataGridView1.Rows.Count - 1;                    // Some simple coloring to make the GridView easier on the eyes.                  // Supported functions are green' unsupported are redish.                  dataGridView1.Rows[index].DefaultCellStyle.BackColor =                      functions[f] ?                      (index % 2 != 0 ? Color.FromArgb(128' 255' 192) : Color.FromArgb(192' 255' 192)) :                      (index % 2 != 0 ? Color.FromArgb(255' 192' 160) : Color.FromArgb(255' 200' 160));              }
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,backgroundWorker1_RunWorkerCompleted,The following statement contains a magic number: foreach (Function f in functions.Keys)              {                  dataGridView1.Rows.Add(functions[f]' f.Name' f.Category' f.Version' f.Extension' f.EntryPoint);                  int index = dataGridView1.Rows.Count - 1;                    // Some simple coloring to make the GridView easier on the eyes.                  // Supported functions are green' unsupported are redish.                  dataGridView1.Rows[index].DefaultCellStyle.BackColor =                      functions[f] ?                      (index % 2 != 0 ? Color.FromArgb(128' 255' 192) : Color.FromArgb(192' 255' 192)) :                      (index % 2 != 0 ? Color.FromArgb(255' 192' 160) : Color.FromArgb(255' 200' 160));              }
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,backgroundWorker1_RunWorkerCompleted,The following statement contains a magic number: foreach (Function f in functions.Keys)              {                  dataGridView1.Rows.Add(functions[f]' f.Name' f.Category' f.Version' f.Extension' f.EntryPoint);                  int index = dataGridView1.Rows.Count - 1;                    // Some simple coloring to make the GridView easier on the eyes.                  // Supported functions are green' unsupported are redish.                  dataGridView1.Rows[index].DefaultCellStyle.BackColor =                      functions[f] ?                      (index % 2 != 0 ? Color.FromArgb(128' 255' 192) : Color.FromArgb(192' 255' 192)) :                      (index % 2 != 0 ? Color.FromArgb(255' 192' 160) : Color.FromArgb(255' 200' 160));              }
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,backgroundWorker1_RunWorkerCompleted,The following statement contains a magic number: foreach (Function f in functions.Keys)              {                  dataGridView1.Rows.Add(functions[f]' f.Name' f.Category' f.Version' f.Extension' f.EntryPoint);                  int index = dataGridView1.Rows.Count - 1;                    // Some simple coloring to make the GridView easier on the eyes.                  // Supported functions are green' unsupported are redish.                  dataGridView1.Rows[index].DefaultCellStyle.BackColor =                      functions[f] ?                      (index % 2 != 0 ? Color.FromArgb(128' 255' 192) : Color.FromArgb(192' 255' 192)) :                      (index % 2 != 0 ? Color.FromArgb(255' 192' 160) : Color.FromArgb(255' 200' 160));              }
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,backgroundWorker1_RunWorkerCompleted,The following statement contains a magic number: foreach (Function f in functions.Keys)              {                  dataGridView1.Rows.Add(functions[f]' f.Name' f.Category' f.Version' f.Extension' f.EntryPoint);                  int index = dataGridView1.Rows.Count - 1;                    // Some simple coloring to make the GridView easier on the eyes.                  // Supported functions are green' unsupported are redish.                  dataGridView1.Rows[index].DefaultCellStyle.BackColor =                      functions[f] ?                      (index % 2 != 0 ? Color.FromArgb(128' 255' 192) : Color.FromArgb(192' 255' 192)) :                      (index % 2 != 0 ? Color.FromArgb(255' 192' 160) : Color.FromArgb(255' 200' 160));              }
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,backgroundWorker1_RunWorkerCompleted,The following statement contains a magic number: foreach (Function f in functions.Keys)              {                  dataGridView1.Rows.Add(functions[f]' f.Name' f.Category' f.Version' f.Extension' f.EntryPoint);                  int index = dataGridView1.Rows.Count - 1;                    // Some simple coloring to make the GridView easier on the eyes.                  // Supported functions are green' unsupported are redish.                  dataGridView1.Rows[index].DefaultCellStyle.BackColor =                      functions[f] ?                      (index % 2 != 0 ? Color.FromArgb(128' 255' 192) : Color.FromArgb(192' 255' 192)) :                      (index % 2 != 0 ? Color.FromArgb(255' 192' 160) : Color.FromArgb(255' 200' 160));              }
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,backgroundWorker1_RunWorkerCompleted,The following statement contains a magic number: foreach (Function f in functions.Keys)              {                  dataGridView1.Rows.Add(functions[f]' f.Name' f.Category' f.Version' f.Extension' f.EntryPoint);                  int index = dataGridView1.Rows.Count - 1;                    // Some simple coloring to make the GridView easier on the eyes.                  // Supported functions are green' unsupported are redish.                  dataGridView1.Rows[index].DefaultCellStyle.BackColor =                      functions[f] ?                      (index % 2 != 0 ? Color.FromArgb(128' 255' 192) : Color.FromArgb(192' 255' 192)) :                      (index % 2 != 0 ? Color.FromArgb(255' 192' 160) : Color.FromArgb(255' 200' 160));              }
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,backgroundWorker1_RunWorkerCompleted,The following statement contains a magic number: foreach (Function f in functions.Keys)              {                  dataGridView1.Rows.Add(functions[f]' f.Name' f.Category' f.Version' f.Extension' f.EntryPoint);                  int index = dataGridView1.Rows.Count - 1;                    // Some simple coloring to make the GridView easier on the eyes.                  // Supported functions are green' unsupported are redish.                  dataGridView1.Rows[index].DefaultCellStyle.BackColor =                      functions[f] ?                      (index % 2 != 0 ? Color.FromArgb(128' 255' 192) : Color.FromArgb(192' 255' 192)) :                      (index % 2 != 0 ? Color.FromArgb(255' 192' 160) : Color.FromArgb(255' 200' 160));              }
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,backgroundWorker1_RunWorkerCompleted,The following statement contains a magic number: dataGridView1.Columns[1].Width = 450;
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,backgroundWorker1_RunWorkerCompleted,The following statement contains a magic number: this.Size = dataGridView1.GetPreferredSize(new System.Drawing.Size(2000' Height));
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.dataGridView1.Location = new System.Drawing.Point(0' 110);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.dataGridView1.Size = new System.Drawing.Size(939' 397);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.dataGridView1.Size = new System.Drawing.Size(939' 397);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.LabelVendor.Location = new System.Drawing.Point(12' 9);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.LabelVendor.Location = new System.Drawing.Point(12' 9);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.LabelVendor.Size = new System.Drawing.Size(41' 13);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.LabelVendor.Size = new System.Drawing.Size(41' 13);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.LabelVendor.TabIndex = 2;
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.LabelRenderer.Location = new System.Drawing.Point(12' 35);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.LabelRenderer.Location = new System.Drawing.Point(12' 35);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.LabelRenderer.Size = new System.Drawing.Size(51' 13);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.LabelRenderer.Size = new System.Drawing.Size(51' 13);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.LabelRenderer.TabIndex = 3;
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.LabelVersion.Location = new System.Drawing.Point(12' 61);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.LabelVersion.Location = new System.Drawing.Point(12' 61);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.LabelVersion.Size = new System.Drawing.Size(42' 13);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.LabelVersion.Size = new System.Drawing.Size(42' 13);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.LabelVersion.TabIndex = 4;
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.TextBoxVendor.Location = new System.Drawing.Point(70' 6);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.TextBoxVendor.Location = new System.Drawing.Point(70' 6);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.TextBoxVendor.Size = new System.Drawing.Size(856' 20);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.TextBoxVendor.Size = new System.Drawing.Size(856' 20);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.TextBoxVendor.TabIndex = 5;
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.TextBoxRenderer.Location = new System.Drawing.Point(70' 32);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.TextBoxRenderer.Location = new System.Drawing.Point(70' 32);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.TextBoxRenderer.Size = new System.Drawing.Size(856' 20);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.TextBoxRenderer.Size = new System.Drawing.Size(856' 20);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.TextBoxRenderer.TabIndex = 6;
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.TextBoxVersion.Location = new System.Drawing.Point(70' 58);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.TextBoxVersion.Location = new System.Drawing.Point(70' 58);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.TextBoxVersion.Size = new System.Drawing.Size(856' 20);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.TextBoxVersion.Size = new System.Drawing.Size(856' 20);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.TextBoxVersion.TabIndex = 7;
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.LabelSupport.Location = new System.Drawing.Point(12' 87);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.LabelSupport.Location = new System.Drawing.Point(12' 87);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.LabelSupport.Size = new System.Drawing.Size(44' 13);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.LabelSupport.Size = new System.Drawing.Size(44' 13);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.LabelSupport.TabIndex = 8;
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.TextBoxSupport.Location = new System.Drawing.Point(70' 84);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.TextBoxSupport.Location = new System.Drawing.Point(70' 84);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.TextBoxSupport.Size = new System.Drawing.Size(856' 20);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.TextBoxSupport.Size = new System.Drawing.Size(856' 20);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.TextBoxSupport.TabIndex = 9;
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.SupportedColumn.Width = 24;
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.NameColumn.Width = 852;
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.CategoryColumn.Width = 5;
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.Version.Width = 5;
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.ExtensionColumn.Width = 5;
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.UnmanagedName.Width = 5;
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(938' 508);
Magic Number,Examples.WinForms,Extensions,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Extensions.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(938' 508);
Magic Number,Examples.Tests,Multithreading,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Multithreading.cs,Main,The following statement contains a magic number: const int ThreadCount = 2;
Magic Number,Examples.Tests,Multithreading,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\Multithreading.cs,RunGame,The following statement contains a magic number: using (Tutorial.T03_Immediate_Mode_Cube game = new Examples.Tutorial.T03_Immediate_Mode_Cube())              {                  Utilities.SetWindowTitle(game);                  game.Keyboard.KeyUp += delegate(object sender' OpenTK.Input.KeyboardKeyEventArgs e)                  {                      if (e.Key == OpenTK.Input.Key.F11)                      {                          if  (game.WindowState == OpenTK.WindowState.Fullscreen)                              game.WindowState = OpenTK.WindowState.Normal;                          else                              game.WindowState = OpenTK.WindowState.Fullscreen;                      }                  };                  game.Run(30.0);              }
Magic Number,Examples.Tests,TestResolutionChanges,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\TestResolutionChanges.cs,Main,The following statement contains a magic number: foreach (DisplayDevice dev in DisplayDevice.AvailableDisplays)              {                  Trace.WriteLine(dev.ToString());                  MessageBox.Show(dev.ToString());                  dev.ChangeResolution(dev.SelectResolution(640' 480' 32' 60.0f));                  Thread.Sleep(1000);                  MessageBox.Show(dev.ToString());                  dev.RestoreResolution();                  Thread.Sleep(1000);                  MessageBox.Show(dev.ToString());              }
Magic Number,Examples.Tests,TestResolutionChanges,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\TestResolutionChanges.cs,Main,The following statement contains a magic number: foreach (DisplayDevice dev in DisplayDevice.AvailableDisplays)              {                  Trace.WriteLine(dev.ToString());                  MessageBox.Show(dev.ToString());                  dev.ChangeResolution(dev.SelectResolution(640' 480' 32' 60.0f));                  Thread.Sleep(1000);                  MessageBox.Show(dev.ToString());                  dev.RestoreResolution();                  Thread.Sleep(1000);                  MessageBox.Show(dev.ToString());              }
Magic Number,Examples.Tests,TestResolutionChanges,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\TestResolutionChanges.cs,Main,The following statement contains a magic number: foreach (DisplayDevice dev in DisplayDevice.AvailableDisplays)              {                  Trace.WriteLine(dev.ToString());                  MessageBox.Show(dev.ToString());                  dev.ChangeResolution(dev.SelectResolution(640' 480' 32' 60.0f));                  Thread.Sleep(1000);                  MessageBox.Show(dev.ToString());                  dev.RestoreResolution();                  Thread.Sleep(1000);                  MessageBox.Show(dev.ToString());              }
Magic Number,Examples.Tests,TestResolutionChanges,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\TestResolutionChanges.cs,Main,The following statement contains a magic number: foreach (DisplayDevice dev in DisplayDevice.AvailableDisplays)              {                  Trace.WriteLine(dev.ToString());                  MessageBox.Show(dev.ToString());                  dev.ChangeResolution(dev.SelectResolution(640' 480' 32' 60.0f));                  Thread.Sleep(1000);                  MessageBox.Show(dev.ToString());                  dev.RestoreResolution();                  Thread.Sleep(1000);                  MessageBox.Show(dev.ToString());              }
Magic Number,Examples.Tests,TestResolutionChanges,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\TestResolutionChanges.cs,Main,The following statement contains a magic number: foreach (DisplayDevice dev in DisplayDevice.AvailableDisplays)              {                  Trace.WriteLine(dev.ToString());                  MessageBox.Show(dev.ToString());                  dev.ChangeResolution(dev.SelectResolution(640' 480' 32' 60.0f));                  Thread.Sleep(1000);                  MessageBox.Show(dev.ToString());                  dev.RestoreResolution();                  Thread.Sleep(1000);                  MessageBox.Show(dev.ToString());              }
Magic Number,Examples.Tests,GameWindowStates,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\GameWindowStates.cs,KeyDownHandler,The following statement contains a magic number: switch (e.Key)              {                  case OpenTK.Input.Key.Escape:                      if (!CursorVisible)                          CursorVisible = true;                      else                          Exit();                      break;                    case Key.Number1: WindowState = WindowState.Normal; break;                  case Key.Number2: WindowState = WindowState.Maximized; break;                  case Key.Number3: WindowState = WindowState.Fullscreen; break;                  case Key.Number4: WindowState = WindowState.Minimized; break;                    case Key.Number5: WindowBorder = WindowBorder.Resizable; break;                  case Key.Number6: WindowBorder = WindowBorder.Fixed; break;                  case Key.Number7: WindowBorder = WindowBorder.Hidden; break;                    case Key.Left: X = X - 16; break;                  case Key.Right: X = X + 16; break;                  case Key.Up: Y = Y - 16; break;                  case Key.Down: Y = Y + 16; break;                    case Key.KeypadPlus:                  case Key.Plus: Size += new Size(16' 16); break;                    case Key.KeypadMinus:                  case Key.Minus: Size -= new Size(16' 16); break;              }
Magic Number,Examples.Tests,GameWindowStates,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\GameWindowStates.cs,KeyDownHandler,The following statement contains a magic number: switch (e.Key)              {                  case OpenTK.Input.Key.Escape:                      if (!CursorVisible)                          CursorVisible = true;                      else                          Exit();                      break;                    case Key.Number1: WindowState = WindowState.Normal; break;                  case Key.Number2: WindowState = WindowState.Maximized; break;                  case Key.Number3: WindowState = WindowState.Fullscreen; break;                  case Key.Number4: WindowState = WindowState.Minimized; break;                    case Key.Number5: WindowBorder = WindowBorder.Resizable; break;                  case Key.Number6: WindowBorder = WindowBorder.Fixed; break;                  case Key.Number7: WindowBorder = WindowBorder.Hidden; break;                    case Key.Left: X = X - 16; break;                  case Key.Right: X = X + 16; break;                  case Key.Up: Y = Y - 16; break;                  case Key.Down: Y = Y + 16; break;                    case Key.KeypadPlus:                  case Key.Plus: Size += new Size(16' 16); break;                    case Key.KeypadMinus:                  case Key.Minus: Size -= new Size(16' 16); break;              }
Magic Number,Examples.Tests,GameWindowStates,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\GameWindowStates.cs,KeyDownHandler,The following statement contains a magic number: switch (e.Key)              {                  case OpenTK.Input.Key.Escape:                      if (!CursorVisible)                          CursorVisible = true;                      else                          Exit();                      break;                    case Key.Number1: WindowState = WindowState.Normal; break;                  case Key.Number2: WindowState = WindowState.Maximized; break;                  case Key.Number3: WindowState = WindowState.Fullscreen; break;                  case Key.Number4: WindowState = WindowState.Minimized; break;                    case Key.Number5: WindowBorder = WindowBorder.Resizable; break;                  case Key.Number6: WindowBorder = WindowBorder.Fixed; break;                  case Key.Number7: WindowBorder = WindowBorder.Hidden; break;                    case Key.Left: X = X - 16; break;                  case Key.Right: X = X + 16; break;                  case Key.Up: Y = Y - 16; break;                  case Key.Down: Y = Y + 16; break;                    case Key.KeypadPlus:                  case Key.Plus: Size += new Size(16' 16); break;                    case Key.KeypadMinus:                  case Key.Minus: Size -= new Size(16' 16); break;              }
Magic Number,Examples.Tests,GameWindowStates,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\GameWindowStates.cs,KeyDownHandler,The following statement contains a magic number: switch (e.Key)              {                  case OpenTK.Input.Key.Escape:                      if (!CursorVisible)                          CursorVisible = true;                      else                          Exit();                      break;                    case Key.Number1: WindowState = WindowState.Normal; break;                  case Key.Number2: WindowState = WindowState.Maximized; break;                  case Key.Number3: WindowState = WindowState.Fullscreen; break;                  case Key.Number4: WindowState = WindowState.Minimized; break;                    case Key.Number5: WindowBorder = WindowBorder.Resizable; break;                  case Key.Number6: WindowBorder = WindowBorder.Fixed; break;                  case Key.Number7: WindowBorder = WindowBorder.Hidden; break;                    case Key.Left: X = X - 16; break;                  case Key.Right: X = X + 16; break;                  case Key.Up: Y = Y - 16; break;                  case Key.Down: Y = Y + 16; break;                    case Key.KeypadPlus:                  case Key.Plus: Size += new Size(16' 16); break;                    case Key.KeypadMinus:                  case Key.Minus: Size -= new Size(16' 16); break;              }
Magic Number,Examples.Tests,GameWindowStates,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\GameWindowStates.cs,KeyDownHandler,The following statement contains a magic number: switch (e.Key)              {                  case OpenTK.Input.Key.Escape:                      if (!CursorVisible)                          CursorVisible = true;                      else                          Exit();                      break;                    case Key.Number1: WindowState = WindowState.Normal; break;                  case Key.Number2: WindowState = WindowState.Maximized; break;                  case Key.Number3: WindowState = WindowState.Fullscreen; break;                  case Key.Number4: WindowState = WindowState.Minimized; break;                    case Key.Number5: WindowBorder = WindowBorder.Resizable; break;                  case Key.Number6: WindowBorder = WindowBorder.Fixed; break;                  case Key.Number7: WindowBorder = WindowBorder.Hidden; break;                    case Key.Left: X = X - 16; break;                  case Key.Right: X = X + 16; break;                  case Key.Up: Y = Y - 16; break;                  case Key.Down: Y = Y + 16; break;                    case Key.KeypadPlus:                  case Key.Plus: Size += new Size(16' 16); break;                    case Key.KeypadMinus:                  case Key.Minus: Size -= new Size(16' 16); break;              }
Magic Number,Examples.Tests,GameWindowStates,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\GameWindowStates.cs,KeyDownHandler,The following statement contains a magic number: switch (e.Key)              {                  case OpenTK.Input.Key.Escape:                      if (!CursorVisible)                          CursorVisible = true;                      else                          Exit();                      break;                    case Key.Number1: WindowState = WindowState.Normal; break;                  case Key.Number2: WindowState = WindowState.Maximized; break;                  case Key.Number3: WindowState = WindowState.Fullscreen; break;                  case Key.Number4: WindowState = WindowState.Minimized; break;                    case Key.Number5: WindowBorder = WindowBorder.Resizable; break;                  case Key.Number6: WindowBorder = WindowBorder.Fixed; break;                  case Key.Number7: WindowBorder = WindowBorder.Hidden; break;                    case Key.Left: X = X - 16; break;                  case Key.Right: X = X + 16; break;                  case Key.Up: Y = Y - 16; break;                  case Key.Down: Y = Y + 16; break;                    case Key.KeypadPlus:                  case Key.Plus: Size += new Size(16' 16); break;                    case Key.KeypadMinus:                  case Key.Minus: Size -= new Size(16' 16); break;              }
Magic Number,Examples.Tests,GameWindowStates,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\GameWindowStates.cs,KeyDownHandler,The following statement contains a magic number: switch (e.Key)              {                  case OpenTK.Input.Key.Escape:                      if (!CursorVisible)                          CursorVisible = true;                      else                          Exit();                      break;                    case Key.Number1: WindowState = WindowState.Normal; break;                  case Key.Number2: WindowState = WindowState.Maximized; break;                  case Key.Number3: WindowState = WindowState.Fullscreen; break;                  case Key.Number4: WindowState = WindowState.Minimized; break;                    case Key.Number5: WindowBorder = WindowBorder.Resizable; break;                  case Key.Number6: WindowBorder = WindowBorder.Fixed; break;                  case Key.Number7: WindowBorder = WindowBorder.Hidden; break;                    case Key.Left: X = X - 16; break;                  case Key.Right: X = X + 16; break;                  case Key.Up: Y = Y - 16; break;                  case Key.Down: Y = Y + 16; break;                    case Key.KeypadPlus:                  case Key.Plus: Size += new Size(16' 16); break;                    case Key.KeypadMinus:                  case Key.Minus: Size -= new Size(16' 16); break;              }
Magic Number,Examples.Tests,GameWindowStates,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\GameWindowStates.cs,KeyDownHandler,The following statement contains a magic number: switch (e.Key)              {                  case OpenTK.Input.Key.Escape:                      if (!CursorVisible)                          CursorVisible = true;                      else                          Exit();                      break;                    case Key.Number1: WindowState = WindowState.Normal; break;                  case Key.Number2: WindowState = WindowState.Maximized; break;                  case Key.Number3: WindowState = WindowState.Fullscreen; break;                  case Key.Number4: WindowState = WindowState.Minimized; break;                    case Key.Number5: WindowBorder = WindowBorder.Resizable; break;                  case Key.Number6: WindowBorder = WindowBorder.Fixed; break;                  case Key.Number7: WindowBorder = WindowBorder.Hidden; break;                    case Key.Left: X = X - 16; break;                  case Key.Right: X = X + 16; break;                  case Key.Up: Y = Y - 16; break;                  case Key.Down: Y = Y + 16; break;                    case Key.KeypadPlus:                  case Key.Plus: Size += new Size(16' 16); break;                    case Key.KeypadMinus:                  case Key.Minus: Size -= new Size(16' 16); break;              }
Magic Number,Examples.Tests,GameWindowStates,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\GameWindowStates.cs,Main,The following statement contains a magic number: using (GameWindowStates ex = new GameWindowStates())              {                  Utilities.SetWindowTitle(ex);                  ex.Run(30.0);              }
Magic Number,Examples.Tests,TestGraphicsModes,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\TestGraphicsModes.cs,Main,The following statement contains a magic number: foreach (ColorFormat color in new ColorFormat[] { 32' 24' 16' 8 })                  foreach (int depth in new int[] { 24' 16 })                      foreach (int stencil in new int[] { 8' 0 })                          foreach (int samples in new int[] { 0' 2' 4' 6' 8' 16 })                                  foreach (bool stereo in new bool[] { false' true })                                  {                                      try                                      {                                          GraphicsMode mode = new GraphicsMode(color' depth' stencil' samples' 0' 2' stereo);                                          if (!modes.ContainsKey(mode))                                              modes.Add(mode' mode);                                      }                                      catch                                      { }                                  }
Magic Number,Examples.Tests,TestGraphicsModes,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\TestGraphicsModes.cs,Main,The following statement contains a magic number: foreach (ColorFormat color in new ColorFormat[] { 32' 24' 16' 8 })                  foreach (int depth in new int[] { 24' 16 })                      foreach (int stencil in new int[] { 8' 0 })                          foreach (int samples in new int[] { 0' 2' 4' 6' 8' 16 })                                  foreach (bool stereo in new bool[] { false' true })                                  {                                      try                                      {                                          GraphicsMode mode = new GraphicsMode(color' depth' stencil' samples' 0' 2' stereo);                                          if (!modes.ContainsKey(mode))                                              modes.Add(mode' mode);                                      }                                      catch                                      { }                                  }
Magic Number,Examples.Tests,TestGraphicsModes,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\TestGraphicsModes.cs,Main,The following statement contains a magic number: foreach (ColorFormat color in new ColorFormat[] { 32' 24' 16' 8 })                  foreach (int depth in new int[] { 24' 16 })                      foreach (int stencil in new int[] { 8' 0 })                          foreach (int samples in new int[] { 0' 2' 4' 6' 8' 16 })                                  foreach (bool stereo in new bool[] { false' true })                                  {                                      try                                      {                                          GraphicsMode mode = new GraphicsMode(color' depth' stencil' samples' 0' 2' stereo);                                          if (!modes.ContainsKey(mode))                                              modes.Add(mode' mode);                                      }                                      catch                                      { }                                  }
Magic Number,Examples.Tests,TestGraphicsModes,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\TestGraphicsModes.cs,Main,The following statement contains a magic number: foreach (ColorFormat color in new ColorFormat[] { 32' 24' 16' 8 })                  foreach (int depth in new int[] { 24' 16 })                      foreach (int stencil in new int[] { 8' 0 })                          foreach (int samples in new int[] { 0' 2' 4' 6' 8' 16 })                                  foreach (bool stereo in new bool[] { false' true })                                  {                                      try                                      {                                          GraphicsMode mode = new GraphicsMode(color' depth' stencil' samples' 0' 2' stereo);                                          if (!modes.ContainsKey(mode))                                              modes.Add(mode' mode);                                      }                                      catch                                      { }                                  }
Magic Number,Examples.Tests,TestGraphicsModes,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\TestGraphicsModes.cs,Main,The following statement contains a magic number: foreach (ColorFormat color in new ColorFormat[] { 32' 24' 16' 8 })                  foreach (int depth in new int[] { 24' 16 })                      foreach (int stencil in new int[] { 8' 0 })                          foreach (int samples in new int[] { 0' 2' 4' 6' 8' 16 })                                  foreach (bool stereo in new bool[] { false' true })                                  {                                      try                                      {                                          GraphicsMode mode = new GraphicsMode(color' depth' stencil' samples' 0' 2' stereo);                                          if (!modes.ContainsKey(mode))                                              modes.Add(mode' mode);                                      }                                      catch                                      { }                                  }
Magic Number,Examples.Tests,TestGraphicsModes,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\TestGraphicsModes.cs,Main,The following statement contains a magic number: foreach (ColorFormat color in new ColorFormat[] { 32' 24' 16' 8 })                  foreach (int depth in new int[] { 24' 16 })                      foreach (int stencil in new int[] { 8' 0 })                          foreach (int samples in new int[] { 0' 2' 4' 6' 8' 16 })                                  foreach (bool stereo in new bool[] { false' true })                                  {                                      try                                      {                                          GraphicsMode mode = new GraphicsMode(color' depth' stencil' samples' 0' 2' stereo);                                          if (!modes.ContainsKey(mode))                                              modes.Add(mode' mode);                                      }                                      catch                                      { }                                  }
Magic Number,Examples.Tests,TestGraphicsModes,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\TestGraphicsModes.cs,Main,The following statement contains a magic number: foreach (ColorFormat color in new ColorFormat[] { 32' 24' 16' 8 })                  foreach (int depth in new int[] { 24' 16 })                      foreach (int stencil in new int[] { 8' 0 })                          foreach (int samples in new int[] { 0' 2' 4' 6' 8' 16 })                                  foreach (bool stereo in new bool[] { false' true })                                  {                                      try                                      {                                          GraphicsMode mode = new GraphicsMode(color' depth' stencil' samples' 0' 2' stereo);                                          if (!modes.ContainsKey(mode))                                              modes.Add(mode' mode);                                      }                                      catch                                      { }                                  }
Magic Number,Examples.Tests,TestGraphicsModes,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\TestGraphicsModes.cs,Main,The following statement contains a magic number: foreach (ColorFormat color in new ColorFormat[] { 32' 24' 16' 8 })                  foreach (int depth in new int[] { 24' 16 })                      foreach (int stencil in new int[] { 8' 0 })                          foreach (int samples in new int[] { 0' 2' 4' 6' 8' 16 })                                  foreach (bool stereo in new bool[] { false' true })                                  {                                      try                                      {                                          GraphicsMode mode = new GraphicsMode(color' depth' stencil' samples' 0' 2' stereo);                                          if (!modes.ContainsKey(mode))                                              modes.Add(mode' mode);                                      }                                      catch                                      { }                                  }
Magic Number,Examples.Tests,TestGraphicsModes,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\TestGraphicsModes.cs,Main,The following statement contains a magic number: foreach (ColorFormat color in new ColorFormat[] { 32' 24' 16' 8 })                  foreach (int depth in new int[] { 24' 16 })                      foreach (int stencil in new int[] { 8' 0 })                          foreach (int samples in new int[] { 0' 2' 4' 6' 8' 16 })                                  foreach (bool stereo in new bool[] { false' true })                                  {                                      try                                      {                                          GraphicsMode mode = new GraphicsMode(color' depth' stencil' samples' 0' 2' stereo);                                          if (!modes.ContainsKey(mode))                                              modes.Add(mode' mode);                                      }                                      catch                                      { }                                  }
Magic Number,Examples.Tests,TestGraphicsModes,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\TestGraphicsModes.cs,Main,The following statement contains a magic number: foreach (ColorFormat color in new ColorFormat[] { 32' 24' 16' 8 })                  foreach (int depth in new int[] { 24' 16 })                      foreach (int stencil in new int[] { 8' 0 })                          foreach (int samples in new int[] { 0' 2' 4' 6' 8' 16 })                                  foreach (bool stereo in new bool[] { false' true })                                  {                                      try                                      {                                          GraphicsMode mode = new GraphicsMode(color' depth' stencil' samples' 0' 2' stereo);                                          if (!modes.ContainsKey(mode))                                              modes.Add(mode' mode);                                      }                                      catch                                      { }                                  }
Magic Number,Examples.Tests,TestGraphicsModes,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\TestGraphicsModes.cs,Main,The following statement contains a magic number: foreach (ColorFormat color in new ColorFormat[] { 32' 24' 16' 8 })                  foreach (int depth in new int[] { 24' 16 })                      foreach (int stencil in new int[] { 8' 0 })                          foreach (int samples in new int[] { 0' 2' 4' 6' 8' 16 })                                  foreach (bool stereo in new bool[] { false' true })                                  {                                      try                                      {                                          GraphicsMode mode = new GraphicsMode(color' depth' stencil' samples' 0' 2' stereo);                                          if (!modes.ContainsKey(mode))                                              modes.Add(mode' mode);                                      }                                      catch                                      { }                                  }
Magic Number,Examples.Tests,TestGraphicsModes,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\TestGraphicsModes.cs,Main,The following statement contains a magic number: foreach (ColorFormat color in new ColorFormat[] { 32' 24' 16' 8 })                  foreach (int depth in new int[] { 24' 16 })                      foreach (int stencil in new int[] { 8' 0 })                          foreach (int samples in new int[] { 0' 2' 4' 6' 8' 16 })                                  foreach (bool stereo in new bool[] { false' true })                                  {                                      try                                      {                                          GraphicsMode mode = new GraphicsMode(color' depth' stencil' samples' 0' 2' stereo);                                          if (!modes.ContainsKey(mode))                                              modes.Add(mode' mode);                                      }                                      catch                                      { }                                  }
Magic Number,Examples.Tests,TestGraphicsModes,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\TestGraphicsModes.cs,Main,The following statement contains a magic number: foreach (ColorFormat color in new ColorFormat[] { 32' 24' 16' 8 })                  foreach (int depth in new int[] { 24' 16 })                      foreach (int stencil in new int[] { 8' 0 })                          foreach (int samples in new int[] { 0' 2' 4' 6' 8' 16 })                                  foreach (bool stereo in new bool[] { false' true })                                  {                                      try                                      {                                          GraphicsMode mode = new GraphicsMode(color' depth' stencil' samples' 0' 2' stereo);                                          if (!modes.ContainsKey(mode))                                              modes.Add(mode' mode);                                      }                                      catch                                      { }                                  }
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,LaunchGameWindow,The following statement contains a magic number: hidden = new GameWindow(320' 240' GraphicsMode.Default' "OpenTK | Hidden input window");
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,LaunchGameWindow,The following statement contains a magic number: hidden = new GameWindow(320' 240' GraphicsMode.Default' "OpenTK | Hidden input window");
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,LaunchGameWindow,The following statement contains a magic number: hidden.Run(60.0' 0.0);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,OnLoad,The following statement contains a magic number: while (!start)                  Thread.Sleep(100);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,OnClosing,The following statement contains a magic number: while (hidden.Exists)                  Thread.Sleep(100);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.tabControl.Size = new System.Drawing.Size(432' 379);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.tabControl.Size = new System.Drawing.Size(432' 379);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.Keyboard.Location = new System.Drawing.Point(4' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.Keyboard.Location = new System.Drawing.Point(4' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.Keyboard.Padding = new System.Windows.Forms.Padding(3);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.Keyboard.Size = new System.Drawing.Size(424' 352);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.Keyboard.Size = new System.Drawing.Size(424' 352);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(207' 180);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(207' 180);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(64' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(64' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.label4.TabIndex = 7;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(6' 180);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(6' 180);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(64' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(64' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 6;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(207' 3);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(207' 3);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(64' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(64' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 5;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(8' 3);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(8' 3);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(64' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(64' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.label1.TabIndex = 4;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.listBox4.Location = new System.Drawing.Point(210' 197);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.listBox4.Location = new System.Drawing.Point(210' 197);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.listBox4.Size = new System.Drawing.Size(206' 147);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.listBox4.Size = new System.Drawing.Size(206' 147);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.listBox4.TabIndex = 3;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.listBox3.Location = new System.Drawing.Point(9' 197);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.listBox3.Location = new System.Drawing.Point(9' 197);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.listBox3.Size = new System.Drawing.Size(195' 147);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.listBox3.Size = new System.Drawing.Size(195' 147);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.listBox3.TabIndex = 2;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.listBox2.Location = new System.Drawing.Point(210' 20);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.listBox2.Location = new System.Drawing.Point(210' 20);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.listBox2.Size = new System.Drawing.Size(206' 147);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.listBox2.Size = new System.Drawing.Size(206' 147);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.listBox1.Location = new System.Drawing.Point(9' 20);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.listBox1.Location = new System.Drawing.Point(9' 20);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.listBox1.Size = new System.Drawing.Size(195' 147);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.listBox1.Size = new System.Drawing.Size(195' 147);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.Mouse.Location = new System.Drawing.Point(4' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.Mouse.Location = new System.Drawing.Point(4' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.Mouse.Padding = new System.Windows.Forms.Padding(3);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.Mouse.Size = new System.Drawing.Size(424' 353);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.Mouse.Size = new System.Drawing.Size(424' 353);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.WindowY.Location = new System.Drawing.Point(4' 239);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.WindowY.Location = new System.Drawing.Point(4' 239);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.WindowY.Size = new System.Drawing.Size(62' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.WindowY.Size = new System.Drawing.Size(62' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.WindowY.TabIndex = 17;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.WindowX.Location = new System.Drawing.Point(4' 212);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.WindowX.Location = new System.Drawing.Point(4' 212);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.WindowX.Size = new System.Drawing.Size(63' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.WindowX.Size = new System.Drawing.Size(63' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.WindowX.TabIndex = 16;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseYWindow.Location = new System.Drawing.Point(80' 232);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseYWindow.Location = new System.Drawing.Point(80' 232);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseYWindow.Size = new System.Drawing.Size(73' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseYWindow.Size = new System.Drawing.Size(73' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseYWindow.TabIndex = 15;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseXWindow.Location = new System.Drawing.Point(80' 205);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseXWindow.Location = new System.Drawing.Point(80' 205);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseXWindow.Size = new System.Drawing.Size(73' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseXWindow.Size = new System.Drawing.Size(73' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseXWindow.TabIndex = 14;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseWheelDelta.Location = new System.Drawing.Point(80' 178);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseWheelDelta.Location = new System.Drawing.Point(80' 178);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseWheelDelta.Size = new System.Drawing.Size(73' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseWheelDelta.Size = new System.Drawing.Size(73' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseWheelDelta.TabIndex = 13;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.WheelDelta.Location = new System.Drawing.Point(4' 185);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.WheelDelta.Location = new System.Drawing.Point(4' 185);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.WheelDelta.Size = new System.Drawing.Size(73' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.WheelDelta.Size = new System.Drawing.Size(73' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.WheelDelta.TabIndex = 12;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseWheelText.Location = new System.Drawing.Point(80' 152);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseWheelText.Location = new System.Drawing.Point(80' 152);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseWheelText.Size = new System.Drawing.Size(73' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseWheelText.Size = new System.Drawing.Size(73' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseWheelText.TabIndex = 11;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseWheelLabel.Location = new System.Drawing.Point(4' 159);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseWheelLabel.Location = new System.Drawing.Point(4' 159);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseWheelLabel.Size = new System.Drawing.Size(43' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseWheelLabel.Size = new System.Drawing.Size(43' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseWheelLabel.TabIndex = 10;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseDeltaY.Location = new System.Drawing.Point(4' 132);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseDeltaY.Location = new System.Drawing.Point(4' 132);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseDeltaY.Size = new System.Drawing.Size(45' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseDeltaY.Size = new System.Drawing.Size(45' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseDeltaY.TabIndex = 9;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseDeltaX.Location = new System.Drawing.Point(4' 105);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseDeltaX.Location = new System.Drawing.Point(4' 105);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseDeltaX.Size = new System.Drawing.Size(46' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseDeltaX.Size = new System.Drawing.Size(46' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseDeltaX.TabIndex = 8;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseY.Location = new System.Drawing.Point(4' 78);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseY.Location = new System.Drawing.Point(4' 78);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseY.Size = new System.Drawing.Size(60' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseY.Size = new System.Drawing.Size(60' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseY.TabIndex = 7;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseX.Location = new System.Drawing.Point(4' 51);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseX.Location = new System.Drawing.Point(4' 51);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseX.Size = new System.Drawing.Size(61' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseX.Size = new System.Drawing.Size(61' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseX.TabIndex = 6;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseDYText.Location = new System.Drawing.Point(80' 125);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseDYText.Location = new System.Drawing.Point(80' 125);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseDYText.Size = new System.Drawing.Size(73' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseDYText.Size = new System.Drawing.Size(73' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseDYText.TabIndex = 5;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseDXText.Location = new System.Drawing.Point(80' 98);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseDXText.Location = new System.Drawing.Point(80' 98);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseDXText.Size = new System.Drawing.Size(73' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseDXText.Size = new System.Drawing.Size(73' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseDXText.TabIndex = 4;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseYText.Location = new System.Drawing.Point(80' 71);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseYText.Location = new System.Drawing.Point(80' 71);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseYText.Size = new System.Drawing.Size(73' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseYText.Size = new System.Drawing.Size(73' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseYText.TabIndex = 3;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseXText.Location = new System.Drawing.Point(80' 44);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseXText.Location = new System.Drawing.Point(80' 44);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseXText.Size = new System.Drawing.Size(73' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseXText.Size = new System.Drawing.Size(73' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseXText.TabIndex = 2;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseButtonsBox.Location = new System.Drawing.Point(190' 44);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseButtonsBox.Location = new System.Drawing.Point(190' 44);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseButtonsBox.Size = new System.Drawing.Size(226' 303);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.MouseButtonsBox.Size = new System.Drawing.Size(226' 303);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.ChooseMouse.Location = new System.Drawing.Point(7' 7);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.ChooseMouse.Location = new System.Drawing.Point(7' 7);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.ChooseMouse.Size = new System.Drawing.Size(409' 21);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.ChooseMouse.Size = new System.Drawing.Size(409' 21);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.HID.Location = new System.Drawing.Point(4' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.HID.Location = new System.Drawing.Point(4' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.HID.Padding = new System.Windows.Forms.Padding(3);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.HID.Size = new System.Drawing.Size(424' 353);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.HID.Size = new System.Drawing.Size(424' 353);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.HID.TabIndex = 2;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.PollTimer.Interval = 10;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxActiveJoystick.Location = new System.Drawing.Point(7' 7);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxActiveJoystick.Location = new System.Drawing.Point(7' 7);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxActiveJoystick.Size = new System.Drawing.Size(409' 21);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxActiveJoystick.Size = new System.Drawing.Size(409' 21);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis1.Location = new System.Drawing.Point(55' 43);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis1.Location = new System.Drawing.Point(55' 43);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis1.Size = new System.Drawing.Size(129' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis1.Size = new System.Drawing.Size(129' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis1.TabIndex = 2;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis2.Location = new System.Drawing.Point(55' 72);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis2.Location = new System.Drawing.Point(55' 72);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis2.Size = new System.Drawing.Size(129' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis2.Size = new System.Drawing.Size(129' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis2.TabIndex = 3;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis3.Location = new System.Drawing.Point(55' 101);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis3.Location = new System.Drawing.Point(55' 101);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis3.Size = new System.Drawing.Size(129' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis3.Size = new System.Drawing.Size(129' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis3.TabIndex = 4;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis4.Location = new System.Drawing.Point(55' 130);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis4.Location = new System.Drawing.Point(55' 130);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis4.Size = new System.Drawing.Size(129' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis4.Size = new System.Drawing.Size(129' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis4.TabIndex = 5;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis5.Location = new System.Drawing.Point(55' 158);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis5.Location = new System.Drawing.Point(55' 158);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis5.Size = new System.Drawing.Size(129' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis5.Size = new System.Drawing.Size(129' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis5.TabIndex = 6;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis6.Location = new System.Drawing.Point(55' 186);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis6.Location = new System.Drawing.Point(55' 186);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis6.Size = new System.Drawing.Size(129' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis6.Size = new System.Drawing.Size(129' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis6.TabIndex = 7;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis7.Location = new System.Drawing.Point(55' 214);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis7.Location = new System.Drawing.Point(55' 214);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis7.Size = new System.Drawing.Size(129' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis7.Size = new System.Drawing.Size(129' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis7.TabIndex = 8;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis8.Location = new System.Drawing.Point(55' 242);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis8.Location = new System.Drawing.Point(55' 242);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis8.Size = new System.Drawing.Size(129' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis8.Size = new System.Drawing.Size(129' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis8.TabIndex = 9;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis9.Location = new System.Drawing.Point(55' 270);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis9.Location = new System.Drawing.Point(55' 270);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis9.Size = new System.Drawing.Size(129' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis9.Size = new System.Drawing.Size(129' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis9.TabIndex = 10;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis10.Location = new System.Drawing.Point(55' 298);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis10.Location = new System.Drawing.Point(55' 298);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis10.Size = new System.Drawing.Size(129' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis10.Size = new System.Drawing.Size(129' 22);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.textBoxAxis10.TabIndex = 11;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis1.Location = new System.Drawing.Point(4' 46);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis1.Location = new System.Drawing.Point(4' 46);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis1.Size = new System.Drawing.Size(39' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis1.Size = new System.Drawing.Size(39' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis1.TabIndex = 12;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis2.Location = new System.Drawing.Point(4' 75);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis2.Location = new System.Drawing.Point(4' 75);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis2.Size = new System.Drawing.Size(39' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis2.Size = new System.Drawing.Size(39' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis2.TabIndex = 13;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis3.Location = new System.Drawing.Point(4' 104);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis3.Location = new System.Drawing.Point(4' 104);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis3.Size = new System.Drawing.Size(39' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis3.Size = new System.Drawing.Size(39' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis3.TabIndex = 14;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis4.Location = new System.Drawing.Point(4' 133);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis4.Location = new System.Drawing.Point(4' 133);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis4.Size = new System.Drawing.Size(39' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis4.Size = new System.Drawing.Size(39' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis4.TabIndex = 15;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis5.Location = new System.Drawing.Point(4' 161);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis5.Location = new System.Drawing.Point(4' 161);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis5.Size = new System.Drawing.Size(39' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis5.Size = new System.Drawing.Size(39' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis5.TabIndex = 16;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis6.Location = new System.Drawing.Point(4' 189);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis6.Location = new System.Drawing.Point(4' 189);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis6.Size = new System.Drawing.Size(39' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis6.Size = new System.Drawing.Size(39' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis6.TabIndex = 17;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis7.Location = new System.Drawing.Point(4' 217);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis7.Location = new System.Drawing.Point(4' 217);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis7.Size = new System.Drawing.Size(39' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis7.Size = new System.Drawing.Size(39' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis7.TabIndex = 18;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis8.Location = new System.Drawing.Point(4' 245);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis8.Location = new System.Drawing.Point(4' 245);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis8.Size = new System.Drawing.Size(39' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis8.Size = new System.Drawing.Size(39' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis8.TabIndex = 18;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis9.Location = new System.Drawing.Point(4' 273);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis9.Location = new System.Drawing.Point(4' 273);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis9.Size = new System.Drawing.Size(39' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis9.Size = new System.Drawing.Size(39' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis9.TabIndex = 19;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis10.Location = new System.Drawing.Point(4' 301);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis10.Location = new System.Drawing.Point(4' 301);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis10.Size = new System.Drawing.Size(45' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis10.Size = new System.Drawing.Size(45' 13);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.labelAxis10.TabIndex = 20;
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.JoystickButtonsBox.Location = new System.Drawing.Point(190' 43);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.JoystickButtonsBox.Location = new System.Drawing.Point(190' 43);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.JoystickButtonsBox.Size = new System.Drawing.Size(226' 303);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.JoystickButtonsBox.Size = new System.Drawing.Size(226' 303);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(432' 379);
Magic Number,Examples.Tests,InputLogger,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\InputLogger.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(432' 379);
Missing Default,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,treeViewSamples_KeyDown,The following switch statement is missing a default case: switch (e.KeyCode)              {                  case Keys.Enter:                      ActivateNode(treeViewSamples.SelectedNode);                      e.Handled = true;                      e.SuppressKeyPress = true;                      break;              }
Missing Default,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,treeViewSamples_MouseDown,The following switch statement is missing a default case: switch (e.Button)              {                  case MouseButtons.Middle:                      ActivateNode(node);                      break;                    case MouseButtons.Right:                      treeViewSamples.ContextMenuStrip.Show(sender as Control' e.Location);                      break;              }
Missing Default,Examples,ExampleBrowser,C:\repos\lachesis_scallion\opentk\Source\Examples\ExampleBrowser.cs,contextMenuStripSamples_ItemClicked,The following switch statement is missing a default case: switch (e.ClickedItem.Text)              {                  case "&Run Sample": RunSample(this' (ExampleInfo)treeViewSamples.SelectedNode.Tag); break;                  case "View Description": tabControlSample.SelectedTab = tabDescription; break;                  case "View Source Code": tabControlSample.SelectedTab = tabSource; break;              }
Missing Default,Examples.Tutorial,StencilCSG,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenGL\1.x\StencilCSG.cs,StencilCSG,The following switch statement is missing a default case: switch (e.Key)                  {                      case Key.Escape: this.Exit(); break;                      case Key.Space: ShowDebugWireFrame = !ShowDebugWireFrame; break;                  }
Missing Default,Examples.Shapes,Capsule,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Capsule.cs,Capsule,The following switch statement is missing a default case: switch ( subdivs )              {              case eSubdivisions.None:                  spheresubdivs = SlicedSphere.eSubdivisions.Zero;                  HoseSubDivs = 0;                  break;              case eSubdivisions.One:                  spheresubdivs = SlicedSphere.eSubdivisions.One;                  HoseSubDivs = 1;                  break;              case eSubdivisions.Two:                  spheresubdivs = SlicedSphere.eSubdivisions.Two;                  HoseSubDivs = 3;                  break;              case eSubdivisions.Three:                  spheresubdivs = SlicedSphere.eSubdivisions.Three;                  HoseSubDivs = 7;                  break;              case eSubdivisions.Four:                  spheresubdivs = SlicedSphere.eSubdivisions.Four;                  HoseSubDivs = 15;                  break;              }
Missing Default,Examples.Shapes,Capsule,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\Capsule.cs,Capsule,The following switch statement is missing a default case: switch ( i )                  {                  case 0:                      tempSide = SlicedHose.eSide.FrontBottom;                      break;                  case 1:                      tempSide = SlicedHose.eSide.BackBottom;                      break;                  case 2:                      tempSide = SlicedHose.eSide.BackTop;                      break;                  case 3:                      tempSide = SlicedHose.eSide.FrontTop;                      break;                  }
Missing Default,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following switch statement is missing a default case: switch ( subdivs )              {              case SubDivs.Zero:                  sphereSubDivs = SlicedSphere.eSubdivisions.Zero;                  hoseSubDivs = 0;                  break;              case SubDivs.One:                  sphereSubDivs = SlicedSphere.eSubdivisions.One;                  hoseSubDivs = 1;                  break;              case SubDivs.Two:                  sphereSubDivs = SlicedSphere.eSubdivisions.Two;                  hoseSubDivs = 3;                  break;              case SubDivs.Three:                  sphereSubDivs = SlicedSphere.eSubdivisions.Three;                  hoseSubDivs = 7;                  break;              case SubDivs.Four:                  sphereSubDivs = SlicedSphere.eSubdivisions.Four;                  hoseSubDivs = 15;                  break;              }
Missing Default,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following switch statement is missing a default case: switch ( i )                  {                  case 0:                      tempVector = FrontTopRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontTopRight };                      break;                  case 1:                      tempVector = FrontTopLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontTopLeft };                      break;                  case 2:                      tempVector = FrontBottomRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontBottomRight };                      break;                  case 3:                      tempVector = FrontBottomLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.FrontBottomLeft };                      break;                  case 4:                      tempVector = BackBottomRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackBottomRight };                      break;                  case 5:                      tempVector = BackBottomLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackBottomLeft };                      break;                  case 6:                      tempVector = BackTopRightEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackTopRight };                      break;                  case 7:                      tempVector = BackTopLeftEdge;                      tempEdge = new SlicedSphere.eDir[] { SlicedSphere.eDir.BackTopLeft };                      break;                  }
Missing Default,Examples.Shapes,ChamferCube,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\ChamferCube.cs,ChamferCube,The following switch statement is missing a default case: switch ( i )                  {                  #region Around X Axis                  case 0:                      tempSide = SlicedHose.eSide.BottomRight;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = FrontBottomRightEdge;                      break;                  case 1:                      tempSide = SlicedHose.eSide.TopRight;                      tempHoseStart = BackTopRightEdge;                      tempHoseEnd = FrontTopRightEdge;                      break;                  case 2:                      tempSide = SlicedHose.eSide.TopLeft;                      tempHoseStart = BackTopLeftEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  case 3:                      tempSide = SlicedHose.eSide.BottomLeft;                      tempHoseStart = BackBottomLeftEdge;                      tempHoseEnd = FrontBottomLeftEdge;                      break;                  #endregion Around X Axis                  #region Around Y Axis                  case 4:                      tempSide = SlicedHose.eSide.FrontRight;                      tempHoseStart = FrontBottomRightEdge;                      tempHoseEnd = FrontTopRightEdge;                      break;                  case 5:                      tempSide = SlicedHose.eSide.BackRight;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = BackTopRightEdge;                      break;                  case 6:                      tempSide = SlicedHose.eSide.BackLeft;                      tempHoseStart = BackBottomLeftEdge;                      tempHoseEnd = BackTopLeftEdge;                      break;                  case 7:                      tempSide = SlicedHose.eSide.FrontLeft;                      tempHoseStart = FrontBottomLeftEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  #endregion Around Y Axis                  #region Around Z Axis                  case 8:                      tempSide = SlicedHose.eSide.FrontTop;                      tempHoseStart = FrontTopRightEdge;                      tempHoseEnd = FrontTopLeftEdge;                      break;                  case 9:                      tempSide = SlicedHose.eSide.BackTop;                      tempHoseStart = BackTopRightEdge;                      tempHoseEnd = BackTopLeftEdge;                      break;                  case 10:                      tempSide = SlicedHose.eSide.BackBottom;                      tempHoseStart = BackBottomRightEdge;                      tempHoseEnd = BackBottomLeftEdge;                      break;                  case 11:                      tempSide = SlicedHose.eSide.FrontBottom;                      tempHoseStart = FrontBottomRightEdge;                      tempHoseEnd = FrontBottomLeftEdge;                      break;                  #endregion Around Z Axis                  }
Missing Default,Examples.Shapes,SlicedHose,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedHose.cs,SlicedHose,The following switch statement is missing a default case: switch ( side )              {              #region Around X Axis              case eSide.BottomRight:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.TopRight:                  start = Vector3d.UnitZ;                  end = Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.TopLeft:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.BottomLeft:                  start = -Vector3d.UnitZ;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;              #endregion Around X Axis              #region Around Y Axis              case eSide.FrontRight:                  start = Vector3d.UnitX;                  end = Vector3d.UnitZ;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackRight:                  start = Vector3d.UnitZ;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackLeft:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitZ;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontLeft:                  start = -Vector3d.UnitZ;                  end = Vector3d.UnitX;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Y Axis              #region Around Z Axis              case eSide.FrontBottom:                  start = -Vector3d.UnitY;                  end = Vector3d.UnitX;                  TexCoordStart = 0.0;                  TexCoordEnd = 0.25;                  break;              case eSide.BackBottom:                  start = -Vector3d.UnitX;                  end = -Vector3d.UnitY;                  TexCoordStart = 0.25;                  TexCoordEnd = 0.5;                  break;              case eSide.BackTop:                  start = Vector3d.UnitY;                  end = -Vector3d.UnitX;                  TexCoordStart = 0.5;                  TexCoordEnd = 0.75;                  break;              case eSide.FrontTop:                  start = Vector3d.UnitX;                  end = Vector3d.UnitY;                  TexCoordStart = 0.75;                  TexCoordEnd = 1.0;                  break;  #endregion Around Z Axis                }
Missing Default,Examples.Shapes,SlicedSphere,C:\repos\lachesis_scallion\opentk\Source\Examples\Shapes\SlicedSphere.cs,GetDefaultVertices,The following switch statement is missing a default case: switch ( s )              {              case eDir.FrontTopRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  break;              case eDir.FrontBottomRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  break;              case eDir.FrontBottomLeft:                   t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  break;              case eDir.FrontTopLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.5' 0.0 )' Vector3d.UnitX' Vector3d.UnitX * scale );                  break;              case eDir.BackTopRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  break;              case eDir.BackBottomRight:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 0.0' 0.0 )' Vector3d.UnitZ' Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 0.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  break;              case eDir.BackBottomLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' -Vector3d.UnitY' -Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 1.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  break;              case eDir.BackTopLeft:                  t1 = new VertexT2dN3dV3d( new Vector2d( 0.5' 1.0 )' Vector3d.UnitY' Vector3d.UnitY * scale );                  t2 = new VertexT2dN3dV3d( new Vector2d( 1.0' 0.0 )' -Vector3d.UnitZ' -Vector3d.UnitZ * scale );                  t3 = new VertexT2dN3dV3d( new Vector2d( 1.0' 1.0 )' -Vector3d.UnitX' -Vector3d.UnitX * scale );                  break;              }
Missing Default,Examples.WinForms,SimpleForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\GLControlSimple.cs,glControl1_KeyDown,The following switch statement is missing a default case: switch (e.KeyData)              {                  case Keys.Escape:                      this.Close();                      break;              }
Missing Default,Examples.WinForms,GameLoopForm,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\GLControl\GLControlGameLoop.cs,glControl_KeyDown,The following switch statement is missing a default case: switch (e.KeyData)              {                  case Keys.Escape:                      this.Close();                      break;              }
Missing Default,Examples.Tests,GameWindowStates,C:\repos\lachesis_scallion\opentk\Source\Examples\OpenTK\Test\GameWindowStates.cs,KeyDownHandler,The following switch statement is missing a default case: switch (e.Key)              {                  case OpenTK.Input.Key.Escape:                      if (!CursorVisible)                          CursorVisible = true;                      else                          Exit();                      break;                    case Key.Number1: WindowState = WindowState.Normal; break;                  case Key.Number2: WindowState = WindowState.Maximized; break;                  case Key.Number3: WindowState = WindowState.Fullscreen; break;                  case Key.Number4: WindowState = WindowState.Minimized; break;                    case Key.Number5: WindowBorder = WindowBorder.Resizable; break;                  case Key.Number6: WindowBorder = WindowBorder.Fixed; break;                  case Key.Number7: WindowBorder = WindowBorder.Hidden; break;                    case Key.Left: X = X - 16; break;                  case Key.Right: X = X + 16; break;                  case Key.Up: Y = Y - 16; break;                  case Key.Down: Y = Y + 16; break;                    case Key.KeypadPlus:                  case Key.Plus: Size += new Size(16' 16); break;                    case Key.KeypadMinus:                  case Key.Minus: Size -= new Size(16' 16); break;              }
