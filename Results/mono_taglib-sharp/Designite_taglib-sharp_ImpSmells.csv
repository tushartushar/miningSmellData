Implementation smell,Namespace,Class,File,Method,Description
Long Method,TagLib.Matroska,File,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\File.cs,ReadWriteSegment,The method has 102 lines of code.
Long Method,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,CreateIFDEntry,The method has 136 lines of code.
Long Method,TagLib.Id3v2,FrameFactory,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameFactory.cs,CreateFrame,The method has 130 lines of code.
Long Method,TagLib.Id3v2,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Tag.cs,Parse,The method has 115 lines of code.
Long Method,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Read,The method has 183 lines of code.
Complex Method,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,Find,Cyclomatic complexity of the method is 13
Complex Method,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,RFind,Cyclomatic complexity of the method is 11
Complex Method,TagLib,File,C:\repos\mono_taglib-sharp\src\TagLib\File.cs,Find,Cyclomatic complexity of the method is 8
Complex Method,TagLib,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Tag.cs,CopyTo,Cyclomatic complexity of the method is 22
Complex Method,TagLib.Matroska,EBMLreader,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\EBMLreader.cs,Read,Cyclomatic complexity of the method is 13
Complex Method,TagLib.Matroska,Tags,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\Tags.cs,InsertItem,Cyclomatic complexity of the method is 8
Complex Method,TagLib.Matroska,File,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\File.cs,ReadWriteSegment,Cyclomatic complexity of the method is 8
Complex Method,TagLib.Matroska,File,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\File.cs,ReadCreateSegmentInfo,Cyclomatic complexity of the method is 8
Complex Method,TagLib.Matroska,File,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\File.cs,ReadSeekHead,Cyclomatic complexity of the method is 10
Complex Method,TagLib.Matroska,File,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\File.cs,ReadTargets,Cyclomatic complexity of the method is 8
Complex Method,TagLib.Matroska,File,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\File.cs,WriteSegment,Cyclomatic complexity of the method is 11
Complex Method,TagLib.Matroska,File,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\File.cs,WriteEBML,Cyclomatic complexity of the method is 10
Complex Method,TagLib.Matroska,File,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\File.cs,UpdateSegmentsMergeVoids,Cyclomatic complexity of the method is 13
Complex Method,TagLib.Matroska,File,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\File.cs,CreateTags,Cyclomatic complexity of the method is 8
Complex Method,TagLib.Matroska,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\Tag.cs,Remove,Cyclomatic complexity of the method is 10
Complex Method,TagLib.Matroska,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\Tag.cs,Get,Cyclomatic complexity of the method is 8
Complex Method,TagLib.Aiff,File,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\File.cs,Read,Cyclomatic complexity of the method is 8
Complex Method,TagLib.Ape,Item,C:\repos\mono_taglib-sharp\src\TagLib\Ape\Item.cs,Render,Cyclomatic complexity of the method is 8
Complex Method,TagLib.Asf,File,C:\repos\mono_taglib-sharp\src\TagLib\Asf\File.cs,ReadObject,Cyclomatic complexity of the method is 8
Complex Method,TagLib.Flac,File,C:\repos\mono_taglib-sharp\src\TagLib\Flac\File.cs,Save,Cyclomatic complexity of the method is 9
Complex Method,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,CreateIFDEntry,Cyclomatic complexity of the method is 41
Complex Method,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,FixupDirectory,Cyclomatic complexity of the method is 8
Complex Method,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,Cyclomatic complexity of the method is 12
Complex Method,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseIFDEntry,Cyclomatic complexity of the method is 8
Complex Method,TagLib.IFD.Entries,UserCommentIFDEntry,C:\repos\mono_taglib-sharp\src\TagLib\IFD\Entries\UserCommentIFDEntry.cs,UserCommentIFDEntry,Cyclomatic complexity of the method is 8
Complex Method,TagLib.Id3v2,Footer,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Footer.cs,Footer,Cyclomatic complexity of the method is 9
Complex Method,TagLib.Id3v2,Frame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frame.cs,Render,Cyclomatic complexity of the method is 11
Complex Method,TagLib.Id3v2,Frame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frame.cs,FieldData,Cyclomatic complexity of the method is 11
Complex Method,TagLib.Id3v2,FrameFactory,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameFactory.cs,CreateFrame,Cyclomatic complexity of the method is 25
Complex Method,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,ConvertId,Cyclomatic complexity of the method is 11
Complex Method,TagLib.Id3v2,Header,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Header.cs,Header,Cyclomatic complexity of the method is 9
Complex Method,TagLib.Id3v2,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Tag.cs,SetTextFrame,Cyclomatic complexity of the method is 8
Complex Method,TagLib.Id3v2,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Tag.cs,Render,Cyclomatic complexity of the method is 14
Complex Method,TagLib.Id3v2,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Tag.cs,Parse,Cyclomatic complexity of the method is 17
Complex Method,TagLib.Id3v2,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Tag.cs,CopyTo,Cyclomatic complexity of the method is 8
Complex Method,TagLib.Id3v2,SynchronisedLyricsFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\SynchronizedLyricsFrame.cs,GetPreferred,Cyclomatic complexity of the method is 8
Complex Method,TagLib.Id3v2,TextInformationFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\TextIdentificationFrame.cs,RenderFields,Cyclomatic complexity of the method is 8
Complex Method,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadDQTSegment,Cyclomatic complexity of the method is 8
Complex Method,TagLib.Mpeg4,BoxHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\BoxHeader.cs,BoxHeader,Cyclomatic complexity of the method is 8
Complex Method,TagLib.Mpeg4,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\File.cs,Save,Cyclomatic complexity of the method is 9
Complex Method,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,Cyclomatic complexity of the method is 10
Complex Method,TagLib.Ogg,Page,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Page.cs,OverwriteSequenceNumbers,Cyclomatic complexity of the method is 10
Complex Method,TagLib.Ogg,PageHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\PageHeader.cs,PageHeader,Cyclomatic complexity of the method is 8
Complex Method,TagLib.Ogg,Paginator,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Paginator.cs,Paginate,Cyclomatic complexity of the method is 9
Complex Method,TagLib.Riff,AviHeaderList,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviHeaderList.cs,AviHeaderList,Cyclomatic complexity of the method is 8
Complex Method,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Save,Cyclomatic complexity of the method is 11
Complex Method,TagLib.Xmp,XmpTag,C:\repos\mono_taglib-sharp\src\TagLib\Xmp\XmpTag.cs,ParseNodeElement,Cyclomatic complexity of the method is 9
Complex Method,TagLib.Xmp,XmpTag,C:\repos\mono_taglib-sharp\src\TagLib\Xmp\XmpTag.cs,ParseResourcePropertyElement,Cyclomatic complexity of the method is 8
Long Parameter List,TagLib.Aac,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aac\AudioHeader.cs,AudioHeader,The method has 5 parameters. Parameters: channels' bitrate' samplerate' numberofsamples' numberofframes
Long Parameter List,TagLib.Aiff,File,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\File.cs,Read,The method has 5 parameters. Parameters: read_tags' style' aiff_size' tag_start' tag_end
Long Parameter List,TagLib.Dsf,File,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\File.cs,Read,The method has 5 parameters. Parameters: read_tags' style' dsf_size' tag_start' tag_end
Long Parameter List,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,IFDReader,The method has 6 parameters. Parameters: file' is_bigendian' structure' base_offset' ifd_offset' max_offset
Long Parameter List,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,CreateIFDEntry,The method has 6 parameters. Parameters: tag' type' count' base_offset' offset_data' max_offset
Long Parameter List,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The method has 5 parameters. Parameters: tag' type' count' base_offset' offset
Long Parameter List,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseIFDEntry,The method has 5 parameters. Parameters: tag' type' count' base_offset' offset
Long Parameter List,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,CreateSubIFDReader,The method has 6 parameters. Parameters: file' is_bigendian' structure' base_offset' offset' max_offset
Long Parameter List,TagLib.IFD,IFDRenderer,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDRenderer.cs,RenderEntry,The method has 5 parameters. Parameters: entry_data' tag' type' count' offset
Long Parameter List,TagLib.IFD.Entries,MakernoteIFDEntry,C:\repos\mono_taglib-sharp\src\TagLib\IFD\Entries\MakernoteIFDEntry.cs,MakernoteIFDEntry,The method has 7 parameters. Parameters: tag' structure' makernote_type' prefix' ifd_offset' absolute_offset' is_bigendian
Long Parameter List,TagLib.IFD.Makernotes,Nikon3MakernoteReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\Makernotes\Nikon3MakernoteReader.cs,Nikon3MakernoteReader,The method has 6 parameters. Parameters: file' is_bigendian' structure' base_offset' ifd_offset' max_offset
Long Parameter List,TagLib.IFD.Makernotes,Nikon3MakernoteReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\Makernotes\Nikon3MakernoteReader.cs,ParseIFDEntry,The method has 5 parameters. Parameters: tag' type' count' base_offset' offset
Long Parameter List,TagLib.Id3v2,SynchronisedLyricsFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\SynchronizedLyricsFrame.cs,Get,The method has 5 parameters. Parameters: tag' description' language' type' create
Long Parameter List,TagLib.Id3v2,UserTextInformationFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\TextIdentificationFrame.cs,Get,The method has 5 parameters. Parameters: tag' description' type' create' caseSensitive
Long Parameter List,TagLib.Mpeg4,BoxFactory,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\BoxFactory.cs,CreateBox,The method has 5 parameters. Parameters: file' header' parent' handler' index
Long Parameter List,TagLib.Mpeg4,BoxFactory,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\BoxFactory.cs,CreateBox,The method has 5 parameters. Parameters: file' position' parent' handler' index
Long Parameter List,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Read,The method has 5 parameters. Parameters: read_tags' style' riff_size' tag_start' tag_end
Long Parameter List,TagLib.Tiff,BaseTiffFile,C:\repos\mono_taglib-sharp\src\TagLib\Tiff\BaseTiffFile.cs,CreateIFDReader,The method has 6 parameters. Parameters: file' is_bigendian' structure' base_offset' ifd_offset' max_offset
Long Parameter List,TagLib.Tiff.Rw2,File,C:\repos\mono_taglib-sharp\src\TagLib\Tiff\Rw2\File.cs,CreateIFDReader,The method has 6 parameters. Parameters: file' is_bigendian' structure' base_offset' ifd_offset' max_offset
Long Parameter List,TagLib.Tiff.Rw2,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\Tiff\Rw2\IFDReader.cs,IFDReader,The method has 6 parameters. Parameters: file' is_bigendian' structure' base_offset' ifd_offset' max_offset
Long Parameter List,TagLib.Tiff.Rw2,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\Tiff\Rw2\IFDReader.cs,ParseIFDEntry,The method has 5 parameters. Parameters: tag' type' count' base_offset' offset
Long Identifier,TagLib.Asf,Guid,C:\repos\mono_taglib-sharp\src\TagLib\Asf\Guid.cs,,The length of the parameter AsfExtendedContentDescriptionObject is 35.
Long Identifier,TagLib.Jpeg,Table,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\Table.cs,,The length of the parameter StandardChrominanceQuantization is 31.
Long Identifier,TagLib.Ogg,Bitstream,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Bitstream.cs,,The length of the parameter first_absolute_granular_position is 32.
Long Statement,TagLib,Picture,C:\repos\mono_taglib-sharp\src\TagLib\Picture.cs,FillInMimeFromExt,The length of the statement  "				case ".odp": mime_type = "application/vnd.oasis.opendocument.presentation"; break; // OpenDocuemnt presentation document " is 120.
Long Statement,TagLib,Picture,C:\repos\mono_taglib-sharp\src\TagLib\Picture.cs,FillInMimeFromExt,The length of the statement  "				case ".xlsx": mime_type = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"; break; // excel 2007 application " is 127.
Long Statement,TagLib.Matroska,Tags,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\Tags.cs,InsertItem,The length of the statement  "			if (index < 0 || index >= this.Count || this[index].TargetTypeValue < tag.TargetTypeValue || (index + 1 < this.Count && this[index + 1].TargetTypeValue > tag.TargetTypeValue)) " is 175.
Long Statement,TagLib.Matroska,File,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\File.cs,WriteSegment,The length of the statement  "				segm_list[0] = new EBMLreader(ebml_segm' ebml_segm.DataOffset' MatroskaID.Void' (ulong)((long)segm_list[0].Size - poffset) ); " is 125.
Long Statement,TagLib.Gif,File,C:\repos\mono_taglib-sharp\src\TagLib\Gif\File.cs,ReadHeader,The length of the statement  "				throw new CorruptFileException (String.Format ("Expected a GIF signature at start of file' but found: {0}"' data.Mid (0' 3).ToString ())); " is 138.
Long Statement,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,FixupDirectory,The length of the statement  "				directory.Add (strip_offsets_tag' new StripOffsetsIFDEntry (strip_offsets_tag' strip_offsets' strip_byte_counts' file)); " is 120.
Long Statement,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The length of the statement  "						return new MakernoteIFDEntry (tag' ifd_structure' MakernoteType.Nikon3' header.Mid (0' 18)' 8' false' makernote_endian); " is 120.
Long Statement,TagLib.IFD,IFDRenderer,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDRenderer.cs,RenderIFD,The length of the statement  "				throw new Exception (String.Format ("Expected IFD data size was {0} but is {1}"' data_offset - ifd_offset' entry_data.Count)); " is 126.
Long Statement,TagLib.Image,CombinedImageTag,C:\repos\mono_taglib-sharp\src\TagLib\Image\CombinedImageTag.cs,AddTag,The length of the statement  "				throw new Exception (String.Format ("Attempted to add {0} to an image' but the only allowed types are {1}"' tag.TagTypes' AllowedTypes)); " is 137.
Complex Conditional,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,ContainsAt,The conditional expression  "patternLength > this.data.Count ||  				offset >= this.data.Count ||  				patternOffset >= pattern.Count ||  				patternLength <= 0 || offset < 0"  is complex.
Complex Conditional,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,FromStream,The conditional expression  "(bytes_read == stream.Length && stream.Length > 0) ||   					(n < read_size && stream.Length <= 0)"  is complex.
Complex Conditional,TagLib,Genres,C:\repos\mono_taglib-sharp\src\TagLib\Genres.cs,StringToByte,The conditional expression  "text != null && text.Length > 2 && text [0] == '('  				&& (last_pos = text.IndexOf (')')) != -1  				&& byte.TryParse (text.Substring (1'  					last_pos - 1)' out value)"  is complex.
Complex Conditional,TagLib,Picture,C:\repos\mono_taglib-sharp\src\TagLib\Picture.cs,FillInMimeFromData,The conditional expression  "Data[0] == 0xFF && Data[1] == 0xD8 && Data[2] == 0xFF && Data[3] == 0xE0"  is complex.
Complex Conditional,TagLib.Matroska,UIDElement,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\IUIDElement.cs,UIDElement,The conditional expression  "type == MatroskaID.TagTrackUID     			|| type == MatroskaID.TagEditionUID     			|| type == MatroskaID.TagChapterUID     			|| type == MatroskaID.TagAttachmentUID"  is complex.
Complex Conditional,TagLib.Matroska,Tags,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\Tags.cs,InsertItem,The conditional expression  "index < 0 || index >= this.Count || this[index].TargetTypeValue < tag.TargetTypeValue || (index + 1 < this.Count && this[index + 1].TargetTypeValue > tag.TargetTypeValue)"  is complex.
Complex Conditional,TagLib.Matroska,File,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\File.cs,CreateSeekHead,The conditional expression  "segm.ID != MatroskaID.Void   					&& segm.ID != MatroskaID.CRC32  					&& (segm.ID != MatroskaID.Cluster || refCluster)"  is complex.
Complex Conditional,TagLib.Flac,File,C:\repos\mono_taglib-sharp\src\TagLib\Flac\File.cs,Save,The conditional expression  "block.Type != BlockType.StreamInfo &&  						block.Type != BlockType.XiphComment &&  						block.Type != BlockType.Picture &&  						block.Type != BlockType.Padding"  is complex.
Complex Conditional,TagLib.Flac,File,C:\repos\mono_taglib-sharp\src\TagLib\Flac\File.cs,ReadBlocks,The conditional expression  "(mode == BlockMode.Whitelist && found) ||  					(mode == BlockMode.Blacklist && !found)"  is complex.
Complex Conditional,TagLib.Id3v2,FrameFactory,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameFactory.cs,CreateFrame,The conditional expression  "(c < 'A' || c > 'Z') &&  						(c < '0' || c > '9')"  is complex.
Complex Conditional,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,ConvertId,The conditional expression  "!toVersion && (id == FrameType.EQUA ||  				id == FrameType.RVAD || id == FrameType.TRDA ||  				id == FrameType.TSIZ)"  is complex.
Complex Conditional,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,ConvertId,The conditional expression  "(id.Count != 4 && version > 2) ||  				(id.Count != 3 && version == 2)"  is complex.
Complex Conditional,TagLib.Id3v2,SynchronisedLyricsFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\SynchronizedLyricsFrame.cs,Get,The conditional expression  "lyr.Description == description &&  					(language == null ||  						language == lyr.Language) &&  					type == lyr.Type"  is complex.
Complex Conditional,TagLib.Id3v2,TextInformationFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\TextIdentificationFrame.cs,ParseRawData,The conditional expression  "FrameId == FrameType.TCOM ||  					FrameId == FrameType.TEXT ||  					FrameId == FrameType.TMCL ||  					FrameId == FrameType.TOLY ||  					FrameId == FrameType.TOPE ||  					FrameId == FrameType.TPE1 ||  					FrameId == FrameType.TPE2 ||  					FrameId == FrameType.TPE3 ||  					FrameId == FrameType.TPE4"  is complex.
Complex Conditional,TagLib.Mpeg4,AppleTag,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\AppleTag.cs,DataBoxes,The conditional expression  "mean_box == null || name_box == null ||  					mean_box.Text != mean ||  					name_box.Text != name"  is complex.
Complex Conditional,TagLib.Mpeg4,AppleTag,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\AppleTag.cs,GetDashAtoms,The conditional expression  "mean_box == null || name_box == null ||  					mean_box.Text != meanstring ||  					name_box.Text != namestring"  is complex.
Complex Conditional,TagLib.Mpeg4,AppleTag,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\AppleTag.cs,GetParentDashBox,The conditional expression  "mean_box == null || name_box == null ||  					mean_box.Text != meanstring ||  					name_box.Text != namestring"  is complex.
Complex Conditional,TagLib.Mpeg4,FileParser,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\FileParser.cs,ParseBoxHeaders,The conditional expression  "header.BoxType == BoxType.Mdia ||  					header.BoxType == BoxType.Minf ||  					header.BoxType == BoxType.Stbl ||  					header.BoxType == BoxType.Trak"  is complex.
Complex Conditional,TagLib.Mpeg4,FileParser,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\FileParser.cs,ParseTag,The conditional expression  "header.BoxType == BoxType.Mdia ||  					header.BoxType == BoxType.Minf ||  					header.BoxType == BoxType.Stbl ||  					header.BoxType == BoxType.Trak"  is complex.
Complex Conditional,TagLib.Mpeg4,FileParser,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\FileParser.cs,ParseTagAndProperties,The conditional expression  "type == BoxType.Mdia ||  					type == BoxType.Minf ||  					type == BoxType.Stbl ||  					type == BoxType.Trak"  is complex.
Complex Conditional,TagLib.Mpeg4,FileParser,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\FileParser.cs,ParseChunkOffsets,The conditional expression  "header.BoxType == BoxType.Moov ||  					header.BoxType == BoxType.Mdia ||  					header.BoxType == BoxType.Minf ||  					header.BoxType == BoxType.Stbl ||  					header.BoxType == BoxType.Trak"  is complex.
Complex Conditional,TagLib.Xmp,XmpNode,C:\repos\mono_taglib-sharp\src\TagLib\Xmp\XmpNode.cs,XmpNode,The conditional expression  "ns != String.Empty && ns != XmpTag.XML_NS && !ns.EndsWith ("/") && !ns.EndsWith ("#")"  is complex.
Empty Catch Block,TagLib.Aac,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aac\AudioHeader.cs,Find,The method has an empty catch block.
Empty Catch Block,TagLib.Ape,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Ape\Tag.cs,Parse,The method has an empty catch block.
Empty Catch Block,TagLib.Audible,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Audible\Tag.cs,Parse,The method has an empty catch block.
Empty Catch Block,TagLib.IFD,IFDStructure,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDStructure.cs,GetDateTimeValue,The method has an empty catch block.
Empty Catch Block,TagLib.Id3v2,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Tag.cs,Render,The method has an empty catch block.
Empty Catch Block,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadSegmentSize,The method has an empty catch block.
Empty Catch Block,TagLib.Mpeg,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\AudioHeader.cs,Find,The method has an empty catch block.
Empty Catch Block,TagLib.NonContainer,EndTag,C:\repos\mono_taglib-sharp\src\TagLib\NonContainer\EndTag.cs,ReadTag,The method has an empty catch block.
Empty Catch Block,TagLib.NonContainer,EndTag,C:\repos\mono_taglib-sharp\src\TagLib\NonContainer\EndTag.cs,ReadTagInfo,The method has an empty catch block.
Empty Catch Block,TagLib.NonContainer,StartTag,C:\repos\mono_taglib-sharp\src\TagLib\NonContainer\StartTag.cs,ReadTagInfo,The method has an empty catch block.
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,Find,The following statement contains a magic number: int [] last_occurrence = new int [256];
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,Find,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  				last_occurrence [i] = pattern.Count;
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,RFind,The following statement contains a magic number: int [] first_occurrence = new int [256];
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,RFind,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  				first_occurrence [i] = pattern.Count;
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,ToInt,The following statement contains a magic number: int last = Count > 4 ? 3 : Count - 1;
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,ToInt,The following statement contains a magic number: int last = Count > 4 ? 3 : Count - 1;
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,ToInt,The following statement contains a magic number: for (int i = 0; i <= last; i++) {  				int offset = mostSignificantByteFirst ? last-i : i;  				unchecked {  					sum |= (int) this[i] << (offset * 8);  				}  			}
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,ToUInt,The following statement contains a magic number: int last = Count > 4 ? 3 : Count - 1;
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,ToUInt,The following statement contains a magic number: int last = Count > 4 ? 3 : Count - 1;
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,ToUInt,The following statement contains a magic number: for (int i = 0; i <= last; i++) {  				int offset = mostSignificantByteFirst ? last-i : i;  				sum |= (uint) this[i] << (offset * 8);  			}
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,ToShort,The following statement contains a magic number: int last = Count > 2 ? 1 : Count - 1;
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,ToShort,The following statement contains a magic number: for (int i = 0; i <= last; i++) {  				int offset = mostSignificantByteFirst ? last-i : i;  				unchecked {  					sum |= (short)(this[i] << (offset * 8));  				}  			}
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,ToUShort,The following statement contains a magic number: int last = Count > 2 ? 1 : Count - 1;
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,ToUShort,The following statement contains a magic number: for (int i = 0; i <= last; i++) {  				int offset = mostSignificantByteFirst ? last-i : i;  				sum |= (ushort)(this[i] << (offset * 8));  			}
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,ToLong,The following statement contains a magic number: int last = Count > 8 ? 7 : Count - 1;
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,ToLong,The following statement contains a magic number: int last = Count > 8 ? 7 : Count - 1;
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,ToLong,The following statement contains a magic number: for(int i = 0; i <= last; i++) {  				int offset = mostSignificantByteFirst ? last-i : i;  				unchecked {  					sum |= (long) this[i] << (offset * 8);  				}  			}
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,ToULong,The following statement contains a magic number: int last = Count > 8 ? 7 : Count - 1;
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,ToULong,The following statement contains a magic number: int last = Count > 8 ? 7 : Count - 1;
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,ToULong,The following statement contains a magic number: for(int i = 0; i <= last; i++) {  				int offset = mostSignificantByteFirst ? last-i : i;  				sum |= (ulong) this[i] << (offset * 8);  			}
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,ToString,The following statement contains a magic number: ByteVector bom = type == StringType.UTF16 &&  				this.data.Count - offset > 1 ? Mid (offset' 2) : null;
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,FromInt,The following statement contains a magic number: for(int i = 0; i < 4; i++) {  				int offset = mostSignificantByteFirst ? 3-i : i;  				vector.Add ((byte)(value >> (offset * 8) & 0xFF));  			}
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,FromInt,The following statement contains a magic number: for(int i = 0; i < 4; i++) {  				int offset = mostSignificantByteFirst ? 3-i : i;  				vector.Add ((byte)(value >> (offset * 8) & 0xFF));  			}
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,FromInt,The following statement contains a magic number: for(int i = 0; i < 4; i++) {  				int offset = mostSignificantByteFirst ? 3-i : i;  				vector.Add ((byte)(value >> (offset * 8) & 0xFF));  			}
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,FromUInt,The following statement contains a magic number: for(int i = 0; i < 4; i++) {  				int offset = mostSignificantByteFirst ? 3-i : i;  				vector.Add ((byte)(value >> (offset * 8) & 0xFF));  			}
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,FromUInt,The following statement contains a magic number: for(int i = 0; i < 4; i++) {  				int offset = mostSignificantByteFirst ? 3-i : i;  				vector.Add ((byte)(value >> (offset * 8) & 0xFF));  			}
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,FromUInt,The following statement contains a magic number: for(int i = 0; i < 4; i++) {  				int offset = mostSignificantByteFirst ? 3-i : i;  				vector.Add ((byte)(value >> (offset * 8) & 0xFF));  			}
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,FromShort,The following statement contains a magic number: for(int i = 0; i < 2; i++) {  				int offset = mostSignificantByteFirst ? 1-i : i;  				vector.Add ((byte)(value >> (offset * 8) & 0xFF));  			}
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,FromShort,The following statement contains a magic number: for(int i = 0; i < 2; i++) {  				int offset = mostSignificantByteFirst ? 1-i : i;  				vector.Add ((byte)(value >> (offset * 8) & 0xFF));  			}
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,FromUShort,The following statement contains a magic number: for(int i = 0; i < 2; i++) {  				int offset = mostSignificantByteFirst ? 1-i : i;  				vector.Add ((byte)(value >> (offset * 8) & 0xFF));  			}
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,FromUShort,The following statement contains a magic number: for(int i = 0; i < 2; i++) {  				int offset = mostSignificantByteFirst ? 1-i : i;  				vector.Add ((byte)(value >> (offset * 8) & 0xFF));  			}
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,FromLong,The following statement contains a magic number: for(int i = 0; i < 8; i++) {  				int offset = mostSignificantByteFirst ? 7-i : i;  				vector.Add ((byte)(value >> (offset * 8) & 0xFF));  			}
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,FromLong,The following statement contains a magic number: for(int i = 0; i < 8; i++) {  				int offset = mostSignificantByteFirst ? 7-i : i;  				vector.Add ((byte)(value >> (offset * 8) & 0xFF));  			}
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,FromLong,The following statement contains a magic number: for(int i = 0; i < 8; i++) {  				int offset = mostSignificantByteFirst ? 7-i : i;  				vector.Add ((byte)(value >> (offset * 8) & 0xFF));  			}
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,FromULong,The following statement contains a magic number: for(int i = 0; i < 8; i++) {  				int offset = mostSignificantByteFirst ? 7-i : i;  				vector.Add ((byte)(value >> (offset * 8) & 0xFF));  			}
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,FromULong,The following statement contains a magic number: for(int i = 0; i < 8; i++) {  				int offset = mostSignificantByteFirst ? 7-i : i;  				vector.Add ((byte)(value >> (offset * 8) & 0xFF));  			}
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,FromULong,The following statement contains a magic number: for(int i = 0; i < 8; i++) {  				int offset = mostSignificantByteFirst ? 7-i : i;  				vector.Add ((byte)(value >> (offset * 8) & 0xFF));  			}
Magic Number,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,FromStream,The following statement contains a magic number: byte [] bytes = new byte[4096];
Magic Number,TagLib,Debugger,C:\repos\mono_taglib-sharp\src\TagLib\Debugger.cs,DumpHex,The following statement contains a magic number: int cols = 16;
Magic Number,TagLib,Genres,C:\repos\mono_taglib-sharp\src\TagLib\Genres.cs,AudioToIndex,The following statement contains a magic number: return 255;
Magic Number,TagLib,Genres,C:\repos\mono_taglib-sharp\src\TagLib\Genres.cs,VideoToIndex,The following statement contains a magic number: return 255;
Magic Number,TagLib,Genres,C:\repos\mono_taglib-sharp\src\TagLib\Genres.cs,StringToByte,The following statement contains a magic number: if (text != null && text.Length > 2 && text [0] == '('  				&& (last_pos = text.IndexOf (')')) != -1  				&& byte.TryParse (text.Substring (1'  					last_pos - 1)' out value))  				return value;
Magic Number,TagLib,Genres,C:\repos\mono_taglib-sharp\src\TagLib\Genres.cs,StringToByte,The following statement contains a magic number: return 255;
Magic Number,TagLib,Picture,C:\repos\mono_taglib-sharp\src\TagLib\Picture.cs,FillInMimeFromData,The following statement contains a magic number: if (Data.Count >= 4)  			{  				if (Data[1] == 'P' && Data[2] == 'N' && Data[3] == 'G')  				{  					mimetype = "image/png";  					ext = "png";  				}  				else if (Data[0] == 'G' && Data[1] == 'I' && Data[2] == 'F')  				{  					mimetype = "image/gif";  					ext = "gif";  				}  				else if (Data[0] == 'B' && Data[1] == 'M')  				{  					mimetype = "image/bmp";  					ext = "bmp";  				}  				else if (Data[0] == 0xFF && Data[1] == 0xD8 && Data[2] == 0xFF && Data[3] == 0xE0 )  				{  					mimetype = "image/jpeg";  					ext = "jpg";  				}    			}
Magic Number,TagLib,Picture,C:\repos\mono_taglib-sharp\src\TagLib\Picture.cs,FillInMimeFromData,The following statement contains a magic number: if (Data.Count >= 4)  			{  				if (Data[1] == 'P' && Data[2] == 'N' && Data[3] == 'G')  				{  					mimetype = "image/png";  					ext = "png";  				}  				else if (Data[0] == 'G' && Data[1] == 'I' && Data[2] == 'F')  				{  					mimetype = "image/gif";  					ext = "gif";  				}  				else if (Data[0] == 'B' && Data[1] == 'M')  				{  					mimetype = "image/bmp";  					ext = "bmp";  				}  				else if (Data[0] == 0xFF && Data[1] == 0xD8 && Data[2] == 0xFF && Data[3] == 0xE0 )  				{  					mimetype = "image/jpeg";  					ext = "jpg";  				}    			}
Magic Number,TagLib,Picture,C:\repos\mono_taglib-sharp\src\TagLib\Picture.cs,FillInMimeFromData,The following statement contains a magic number: if (Data.Count >= 4)  			{  				if (Data[1] == 'P' && Data[2] == 'N' && Data[3] == 'G')  				{  					mimetype = "image/png";  					ext = "png";  				}  				else if (Data[0] == 'G' && Data[1] == 'I' && Data[2] == 'F')  				{  					mimetype = "image/gif";  					ext = "gif";  				}  				else if (Data[0] == 'B' && Data[1] == 'M')  				{  					mimetype = "image/bmp";  					ext = "bmp";  				}  				else if (Data[0] == 0xFF && Data[1] == 0xD8 && Data[2] == 0xFF && Data[3] == 0xE0 )  				{  					mimetype = "image/jpeg";  					ext = "jpg";  				}    			}
Magic Number,TagLib,Picture,C:\repos\mono_taglib-sharp\src\TagLib\Picture.cs,FillInMimeFromData,The following statement contains a magic number: if (Data.Count >= 4)  			{  				if (Data[1] == 'P' && Data[2] == 'N' && Data[3] == 'G')  				{  					mimetype = "image/png";  					ext = "png";  				}  				else if (Data[0] == 'G' && Data[1] == 'I' && Data[2] == 'F')  				{  					mimetype = "image/gif";  					ext = "gif";  				}  				else if (Data[0] == 'B' && Data[1] == 'M')  				{  					mimetype = "image/bmp";  					ext = "bmp";  				}  				else if (Data[0] == 0xFF && Data[1] == 0xD8 && Data[2] == 0xFF && Data[3] == 0xE0 )  				{  					mimetype = "image/jpeg";  					ext = "jpg";  				}    			}
Magic Number,TagLib,Picture,C:\repos\mono_taglib-sharp\src\TagLib\Picture.cs,FillInMimeFromData,The following statement contains a magic number: if (Data.Count >= 4)  			{  				if (Data[1] == 'P' && Data[2] == 'N' && Data[3] == 'G')  				{  					mimetype = "image/png";  					ext = "png";  				}  				else if (Data[0] == 'G' && Data[1] == 'I' && Data[2] == 'F')  				{  					mimetype = "image/gif";  					ext = "gif";  				}  				else if (Data[0] == 'B' && Data[1] == 'M')  				{  					mimetype = "image/bmp";  					ext = "bmp";  				}  				else if (Data[0] == 0xFF && Data[1] == 0xD8 && Data[2] == 0xFF && Data[3] == 0xE0 )  				{  					mimetype = "image/jpeg";  					ext = "jpg";  				}    			}
Magic Number,TagLib,Picture,C:\repos\mono_taglib-sharp\src\TagLib\Picture.cs,FillInMimeFromData,The following statement contains a magic number: if (Data.Count >= 4)  			{  				if (Data[1] == 'P' && Data[2] == 'N' && Data[3] == 'G')  				{  					mimetype = "image/png";  					ext = "png";  				}  				else if (Data[0] == 'G' && Data[1] == 'I' && Data[2] == 'F')  				{  					mimetype = "image/gif";  					ext = "gif";  				}  				else if (Data[0] == 'B' && Data[1] == 'M')  				{  					mimetype = "image/bmp";  					ext = "bmp";  				}  				else if (Data[0] == 0xFF && Data[1] == 0xD8 && Data[2] == 0xFF && Data[3] == 0xE0 )  				{  					mimetype = "image/jpeg";  					ext = "jpg";  				}    			}
Magic Number,TagLib.Matroska,Attachment,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\Attachment.cs,SetFilenameFromType,The following statement contains a magic number: if (ext == null && MimeType != null && MimeType.StartsWith("image/") ) ext = "." + MimeType.Substring(6);
Magic Number,TagLib.Matroska,Attachment,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\Attachment.cs,SetFilenameFromType,The following statement contains a magic number: if (ext == null || ext.Length<2) ext = "";
Magic Number,TagLib.Matroska,EBMLreader,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\EBMLreader.cs,Read,The following statement contains a magic number: try  			{  				var ex = new InvalidOperationException("Invalid EBML format Read");    				if (offset >= (ulong)(file.Length) - 1) throw ex;    				// Prepare for Consitency check  				uint ebml_id_check = ebml_id;  				ulong ebml_size_check = Size;      				file.Seek((long)offset);    				// Get the header byte  				ByteVector vector = file.ReadBlock(1);  				byte header_byte = vector[0];  				// Define a mask  				byte mask = 0x80' id_length = 1;  				// Figure out the size in bytes  				while (id_length <= 4 && (header_byte & mask) == 0)  				{  					id_length++;  					mask >>= 1;  				}  				if (id_length > 4) throw ex;    				// Now read the rest of the EBML ID  				if (id_length > 1)  				{  					vector.Add(file.ReadBlock(id_length - 1));  				}    				ebml_id = vector.ToUInt();    				vector.Clear();    				// Get the size length  				vector = file.ReadBlock(1);  				header_byte = vector[0];  				mask = 0x80;  				Byte size_length = 1;    				// Iterate through various possibilities  				while (size_length <= 8 && (header_byte & mask) == 0)  				{  					size_length++;  					mask >>= 1;  				}      				if (size_length > 8)  					size_length = 1; // Special: Empty element (all zero state)  				else  					vector[0] &= (Byte)(mask - 1);  // Clear the marker bit      				// Now read the rest of the EBML element size  				if (size_length > 1)  				{  					vector.Add(file.ReadBlock(size_length - 1));  				}    				ebml_size = vector.ToULong();    				// Special: Auto-size (0xFF byte)  				if (size_length == 1 && ebml_size == 0x7F)  				{  					// Resolve auto-size to fill in to its containing element  					ulong bound = parent == null ? (ulong)file.Length : parent.Offset + parent.Size;  					ebml_size = bound - offset - (ulong)(id_length + size_length);  				}    				data_offset = offset + id_length + size_length;    				// Consistency check: Detect descrepencies between read data and abstract data   				if (ebml_id_check != 0 && ebml_id_check != ebml_id) throw ex;  				if (ebml_size_check != 0 && ebml_size_check != Size) throw ex;    				return true;    			}  			catch (Exception ex)  			{  				if (throwException) throw ex;  				return false;  			}
Magic Number,TagLib.Matroska,EBMLreader,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\EBMLreader.cs,Read,The following statement contains a magic number: try  			{  				var ex = new InvalidOperationException("Invalid EBML format Read");    				if (offset >= (ulong)(file.Length) - 1) throw ex;    				// Prepare for Consitency check  				uint ebml_id_check = ebml_id;  				ulong ebml_size_check = Size;      				file.Seek((long)offset);    				// Get the header byte  				ByteVector vector = file.ReadBlock(1);  				byte header_byte = vector[0];  				// Define a mask  				byte mask = 0x80' id_length = 1;  				// Figure out the size in bytes  				while (id_length <= 4 && (header_byte & mask) == 0)  				{  					id_length++;  					mask >>= 1;  				}  				if (id_length > 4) throw ex;    				// Now read the rest of the EBML ID  				if (id_length > 1)  				{  					vector.Add(file.ReadBlock(id_length - 1));  				}    				ebml_id = vector.ToUInt();    				vector.Clear();    				// Get the size length  				vector = file.ReadBlock(1);  				header_byte = vector[0];  				mask = 0x80;  				Byte size_length = 1;    				// Iterate through various possibilities  				while (size_length <= 8 && (header_byte & mask) == 0)  				{  					size_length++;  					mask >>= 1;  				}      				if (size_length > 8)  					size_length = 1; // Special: Empty element (all zero state)  				else  					vector[0] &= (Byte)(mask - 1);  // Clear the marker bit      				// Now read the rest of the EBML element size  				if (size_length > 1)  				{  					vector.Add(file.ReadBlock(size_length - 1));  				}    				ebml_size = vector.ToULong();    				// Special: Auto-size (0xFF byte)  				if (size_length == 1 && ebml_size == 0x7F)  				{  					// Resolve auto-size to fill in to its containing element  					ulong bound = parent == null ? (ulong)file.Length : parent.Offset + parent.Size;  					ebml_size = bound - offset - (ulong)(id_length + size_length);  				}    				data_offset = offset + id_length + size_length;    				// Consistency check: Detect descrepencies between read data and abstract data   				if (ebml_id_check != 0 && ebml_id_check != ebml_id) throw ex;  				if (ebml_size_check != 0 && ebml_size_check != Size) throw ex;    				return true;    			}  			catch (Exception ex)  			{  				if (throwException) throw ex;  				return false;  			}
Magic Number,TagLib.Matroska,EBMLreader,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\EBMLreader.cs,Read,The following statement contains a magic number: try  			{  				var ex = new InvalidOperationException("Invalid EBML format Read");    				if (offset >= (ulong)(file.Length) - 1) throw ex;    				// Prepare for Consitency check  				uint ebml_id_check = ebml_id;  				ulong ebml_size_check = Size;      				file.Seek((long)offset);    				// Get the header byte  				ByteVector vector = file.ReadBlock(1);  				byte header_byte = vector[0];  				// Define a mask  				byte mask = 0x80' id_length = 1;  				// Figure out the size in bytes  				while (id_length <= 4 && (header_byte & mask) == 0)  				{  					id_length++;  					mask >>= 1;  				}  				if (id_length > 4) throw ex;    				// Now read the rest of the EBML ID  				if (id_length > 1)  				{  					vector.Add(file.ReadBlock(id_length - 1));  				}    				ebml_id = vector.ToUInt();    				vector.Clear();    				// Get the size length  				vector = file.ReadBlock(1);  				header_byte = vector[0];  				mask = 0x80;  				Byte size_length = 1;    				// Iterate through various possibilities  				while (size_length <= 8 && (header_byte & mask) == 0)  				{  					size_length++;  					mask >>= 1;  				}      				if (size_length > 8)  					size_length = 1; // Special: Empty element (all zero state)  				else  					vector[0] &= (Byte)(mask - 1);  // Clear the marker bit      				// Now read the rest of the EBML element size  				if (size_length > 1)  				{  					vector.Add(file.ReadBlock(size_length - 1));  				}    				ebml_size = vector.ToULong();    				// Special: Auto-size (0xFF byte)  				if (size_length == 1 && ebml_size == 0x7F)  				{  					// Resolve auto-size to fill in to its containing element  					ulong bound = parent == null ? (ulong)file.Length : parent.Offset + parent.Size;  					ebml_size = bound - offset - (ulong)(id_length + size_length);  				}    				data_offset = offset + id_length + size_length;    				// Consistency check: Detect descrepencies between read data and abstract data   				if (ebml_id_check != 0 && ebml_id_check != ebml_id) throw ex;  				if (ebml_size_check != 0 && ebml_size_check != Size) throw ex;    				return true;    			}  			catch (Exception ex)  			{  				if (throwException) throw ex;  				return false;  			}
Magic Number,TagLib.Matroska,EBMLreader,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\EBMLreader.cs,Read,The following statement contains a magic number: try  			{  				var ex = new InvalidOperationException("Invalid EBML format Read");    				if (offset >= (ulong)(file.Length) - 1) throw ex;    				// Prepare for Consitency check  				uint ebml_id_check = ebml_id;  				ulong ebml_size_check = Size;      				file.Seek((long)offset);    				// Get the header byte  				ByteVector vector = file.ReadBlock(1);  				byte header_byte = vector[0];  				// Define a mask  				byte mask = 0x80' id_length = 1;  				// Figure out the size in bytes  				while (id_length <= 4 && (header_byte & mask) == 0)  				{  					id_length++;  					mask >>= 1;  				}  				if (id_length > 4) throw ex;    				// Now read the rest of the EBML ID  				if (id_length > 1)  				{  					vector.Add(file.ReadBlock(id_length - 1));  				}    				ebml_id = vector.ToUInt();    				vector.Clear();    				// Get the size length  				vector = file.ReadBlock(1);  				header_byte = vector[0];  				mask = 0x80;  				Byte size_length = 1;    				// Iterate through various possibilities  				while (size_length <= 8 && (header_byte & mask) == 0)  				{  					size_length++;  					mask >>= 1;  				}      				if (size_length > 8)  					size_length = 1; // Special: Empty element (all zero state)  				else  					vector[0] &= (Byte)(mask - 1);  // Clear the marker bit      				// Now read the rest of the EBML element size  				if (size_length > 1)  				{  					vector.Add(file.ReadBlock(size_length - 1));  				}    				ebml_size = vector.ToULong();    				// Special: Auto-size (0xFF byte)  				if (size_length == 1 && ebml_size == 0x7F)  				{  					// Resolve auto-size to fill in to its containing element  					ulong bound = parent == null ? (ulong)file.Length : parent.Offset + parent.Size;  					ebml_size = bound - offset - (ulong)(id_length + size_length);  				}    				data_offset = offset + id_length + size_length;    				// Consistency check: Detect descrepencies between read data and abstract data   				if (ebml_id_check != 0 && ebml_id_check != ebml_id) throw ex;  				if (ebml_size_check != 0 && ebml_size_check != Size) throw ex;    				return true;    			}  			catch (Exception ex)  			{  				if (throwException) throw ex;  				return false;  			}
Magic Number,TagLib.Matroska,EBMLreader,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\EBMLreader.cs,WriteDataSize,The following statement contains a magic number: const ulong newsize_length = 8;
Magic Number,TagLib.Matroska,EBMLreader,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\EBMLreader.cs,WriteDataSize,The following statement contains a magic number: ulong mask = 0xFF000000' id_length = 4;
Magic Number,TagLib.Matroska,EBMLreader,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\EBMLreader.cs,WriteDataSize,The following statement contains a magic number: while (id_length > 0 && (ebml_id & mask) == 0)  			{  				id_length--;  				mask >>= 8;  			}
Magic Number,TagLib.Matroska,EBMLreader,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\EBMLreader.cs,WriteDataSize,The following statement contains a magic number: if (size_length > 8)  				throw new CorruptFileException("invalid EBML element size");
Magic Number,TagLib.Matroska,EBMLreader,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\EBMLreader.cs,WriteDataSize,The following statement contains a magic number: for (int i = (int)newsize_length - 1; i >= 0; i--)  			{  				vector[i] = (byte)(mask & 0xFF);  				mask >>= 8;  			}
Magic Number,TagLib.Matroska,EBMLreader,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\EBMLreader.cs,WriteVoid,The following statement contains a magic number: if (Size < 2) throw new ArgumentOutOfRangeException("WriteVoid Size < 2");
Magic Number,TagLib.Matroska,EBMLreader,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\EBMLreader.cs,WriteVoid,The following statement contains a magic number: if (Size < 100)  			{  				vector = new ByteVector(2);  				datasize = (int)Size - 2;  				vector[0] = (byte)MatroskaID.Void; // size = 1  				vector[1] = (byte)(0x80 | datasize); // Marker + data-size  			}  			else  			{  				vector = new ByteVector(9);  				datasize = (int)Size - 9;  				vector[0] = (byte)MatroskaID.Void; // size = 1  				vector[1] = 0x01; // set marker    				// Set data size  				int mask = datasize;  				for (int i = 8; i > 1; i--)  				{  					vector[i] = (byte)(mask & 0xFF);  					mask >>= 8;  				}  			}
Magic Number,TagLib.Matroska,EBMLreader,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\EBMLreader.cs,WriteVoid,The following statement contains a magic number: if (Size < 100)  			{  				vector = new ByteVector(2);  				datasize = (int)Size - 2;  				vector[0] = (byte)MatroskaID.Void; // size = 1  				vector[1] = (byte)(0x80 | datasize); // Marker + data-size  			}  			else  			{  				vector = new ByteVector(9);  				datasize = (int)Size - 9;  				vector[0] = (byte)MatroskaID.Void; // size = 1  				vector[1] = 0x01; // set marker    				// Set data size  				int mask = datasize;  				for (int i = 8; i > 1; i--)  				{  					vector[i] = (byte)(mask & 0xFF);  					mask >>= 8;  				}  			}
Magic Number,TagLib.Matroska,EBMLreader,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\EBMLreader.cs,WriteVoid,The following statement contains a magic number: if (Size < 100)  			{  				vector = new ByteVector(2);  				datasize = (int)Size - 2;  				vector[0] = (byte)MatroskaID.Void; // size = 1  				vector[1] = (byte)(0x80 | datasize); // Marker + data-size  			}  			else  			{  				vector = new ByteVector(9);  				datasize = (int)Size - 9;  				vector[0] = (byte)MatroskaID.Void; // size = 1  				vector[1] = 0x01; // set marker    				// Set data size  				int mask = datasize;  				for (int i = 8; i > 1; i--)  				{  					vector[i] = (byte)(mask & 0xFF);  					mask >>= 8;  				}  			}
Magic Number,TagLib.Matroska,EBMLreader,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\EBMLreader.cs,WriteVoid,The following statement contains a magic number: if (Size < 100)  			{  				vector = new ByteVector(2);  				datasize = (int)Size - 2;  				vector[0] = (byte)MatroskaID.Void; // size = 1  				vector[1] = (byte)(0x80 | datasize); // Marker + data-size  			}  			else  			{  				vector = new ByteVector(9);  				datasize = (int)Size - 9;  				vector[0] = (byte)MatroskaID.Void; // size = 1  				vector[1] = 0x01; // set marker    				// Set data size  				int mask = datasize;  				for (int i = 8; i > 1; i--)  				{  					vector[i] = (byte)(mask & 0xFF);  					mask >>= 8;  				}  			}
Magic Number,TagLib.Matroska,EBMLreader,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\EBMLreader.cs,WriteVoid,The following statement contains a magic number: if (Size < 100)  			{  				vector = new ByteVector(2);  				datasize = (int)Size - 2;  				vector[0] = (byte)MatroskaID.Void; // size = 1  				vector[1] = (byte)(0x80 | datasize); // Marker + data-size  			}  			else  			{  				vector = new ByteVector(9);  				datasize = (int)Size - 9;  				vector[0] = (byte)MatroskaID.Void; // size = 1  				vector[1] = 0x01; // set marker    				// Set data size  				int mask = datasize;  				for (int i = 8; i > 1; i--)  				{  					vector[i] = (byte)(mask & 0xFF);  					mask >>= 8;  				}  			}
Magic Number,TagLib.Matroska,EBMLreader,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\EBMLreader.cs,WriteVoid,The following statement contains a magic number: if (Size < 100)  			{  				vector = new ByteVector(2);  				datasize = (int)Size - 2;  				vector[0] = (byte)MatroskaID.Void; // size = 1  				vector[1] = (byte)(0x80 | datasize); // Marker + data-size  			}  			else  			{  				vector = new ByteVector(9);  				datasize = (int)Size - 9;  				vector[0] = (byte)MatroskaID.Void; // size = 1  				vector[1] = 0x01; // set marker    				// Set data size  				int mask = datasize;  				for (int i = 8; i > 1; i--)  				{  					vector[i] = (byte)(mask & 0xFF);  					mask >>= 8;  				}  			}
Magic Number,TagLib.Matroska,EBMLreader,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\EBMLreader.cs,WriteVoid,The following statement contains a magic number: if (Size < 100)  			{  				vector = new ByteVector(2);  				datasize = (int)Size - 2;  				vector[0] = (byte)MatroskaID.Void; // size = 1  				vector[1] = (byte)(0x80 | datasize); // Marker + data-size  			}  			else  			{  				vector = new ByteVector(9);  				datasize = (int)Size - 9;  				vector[0] = (byte)MatroskaID.Void; // size = 1  				vector[1] = 0x01; // set marker    				// Set data size  				int mask = datasize;  				for (int i = 8; i > 1; i--)  				{  					vector[i] = (byte)(mask & 0xFF);  					mask >>= 8;  				}  			}
Magic Number,TagLib.Matroska,UIDElement,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\IUIDElement.cs,GenUID,The following statement contains a magic number: while (ret == 0)  			{  				ret = ((ulong)random.Next()) << 32;  				ret |= (uint)random.Next();  			}
Magic Number,TagLib.Matroska,Tags,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\Tags.cs,Get,The following statement contains a magic number: targetTypeValue = (ushort)   				(targetTypeValue > 70 ? 70  				: targetTypeValue < 10 ? 10  				: (targetTypeValue / 10) * 10  				);
Magic Number,TagLib.Matroska,Tags,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\Tags.cs,Get,The following statement contains a magic number: targetTypeValue = (ushort)   				(targetTypeValue > 70 ? 70  				: targetTypeValue < 10 ? 10  				: (targetTypeValue / 10) * 10  				);
Magic Number,TagLib.Matroska,Tags,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\Tags.cs,Get,The following statement contains a magic number: targetTypeValue = (ushort)   				(targetTypeValue > 70 ? 70  				: targetTypeValue < 10 ? 10  				: (targetTypeValue / 10) * 10  				);
Magic Number,TagLib.Matroska,Tags,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\Tags.cs,Get,The following statement contains a magic number: targetTypeValue = (ushort)   				(targetTypeValue > 70 ? 70  				: targetTypeValue < 10 ? 10  				: (targetTypeValue / 10) * 10  				);
Magic Number,TagLib.Matroska,Tags,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\Tags.cs,Get,The following statement contains a magic number: targetTypeValue = (ushort)   				(targetTypeValue > 70 ? 70  				: targetTypeValue < 10 ? 10  				: (targetTypeValue / 10) * 10  				);
Magic Number,TagLib.Matroska,Tags,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\Tags.cs,Get,The following statement contains a magic number: targetTypeValue = (ushort)   				(targetTypeValue > 70 ? 70  				: targetTypeValue < 10 ? 10  				: (targetTypeValue / 10) * 10  				);
Magic Number,TagLib.Matroska,EBMLelement,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\EBMLElement.cs,IncrementSize,The following statement contains a magic number: if ( !IncSize && DataSizeSize < 8)  			{  				return IncSize = true;  			}
Magic Number,TagLib.Matroska,EBMLelement,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\EBMLElement.cs,EBMLByteSize,The following statement contains a magic number: if (value == 0x7F)  			{  				// Special case: Avoid element-size reserved word of 0xFF (all ones)  				size_length = 2;  			}  			else  			{  				size_length = 8;  				ulong mask = (ulong)0x7F << (7*7);  				while (size_length > 1 && (value & mask) == 0)  				{  					size_length--;  					mask >>= 7;  				}  			}
Magic Number,TagLib.Matroska,EBMLelement,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\EBMLElement.cs,EBMLByteSize,The following statement contains a magic number: if (value == 0x7F)  			{  				// Special case: Avoid element-size reserved word of 0xFF (all ones)  				size_length = 2;  			}  			else  			{  				size_length = 8;  				ulong mask = (ulong)0x7F << (7*7);  				while (size_length > 1 && (value & mask) == 0)  				{  					size_length--;  					mask >>= 7;  				}  			}
Magic Number,TagLib.Matroska,EBMLelement,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\EBMLElement.cs,EBMLByteSize,The following statement contains a magic number: if (value == 0x7F)  			{  				// Special case: Avoid element-size reserved word of 0xFF (all ones)  				size_length = 2;  			}  			else  			{  				size_length = 8;  				ulong mask = (ulong)0x7F << (7*7);  				while (size_length > 1 && (value & mask) == 0)  				{  					size_length--;  					mask >>= 7;  				}  			}
Magic Number,TagLib.Matroska,EBMLelement,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\EBMLElement.cs,EBMLByteSize,The following statement contains a magic number: if (value == 0x7F)  			{  				// Special case: Avoid element-size reserved word of 0xFF (all ones)  				size_length = 2;  			}  			else  			{  				size_length = 8;  				ulong mask = (ulong)0x7F << (7*7);  				while (size_length > 1 && (value & mask) == 0)  				{  					size_length--;  					mask >>= 7;  				}  			}
Magic Number,TagLib.Matroska,EBMLelement,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\EBMLElement.cs,EBMLByteSize,The following statement contains a magic number: if (value == 0x7F)  			{  				// Special case: Avoid element-size reserved word of 0xFF (all ones)  				size_length = 2;  			}  			else  			{  				size_length = 8;  				ulong mask = (ulong)0x7F << (7*7);  				while (size_length > 1 && (value & mask) == 0)  				{  					size_length--;  					mask >>= 7;  				}  			}
Magic Number,TagLib.Matroska,EBMLelement,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\EBMLElement.cs,GetDouble,The following statement contains a magic number: if (Data.Count == 4) {  				result = (double)Data.ToFloat();  			}  			else if (Data.Count == 8) {  				result = Data.ToDouble();  			}  			else  			{  				throw new UnsupportedFormatException("Can not read a Double with sizes differing from 4 or 8");  			}
Magic Number,TagLib.Matroska,EBMLelement,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\EBMLElement.cs,GetDouble,The following statement contains a magic number: if (Data.Count == 4) {  				result = (double)Data.ToFloat();  			}  			else if (Data.Count == 8) {  				result = Data.ToDouble();  			}  			else  			{  				throw new UnsupportedFormatException("Can not read a Double with sizes differing from 4 or 8");  			}
Magic Number,TagLib.Matroska,EBMLelement,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\EBMLElement.cs,SetData,The following statement contains a magic number: ByteVector vector = new ByteVector(isLong ? 8 : 4);
Magic Number,TagLib.Matroska,EBMLelement,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\EBMLElement.cs,SetData,The following statement contains a magic number: ByteVector vector = new ByteVector(isLong ? 8 : 4);
Magic Number,TagLib.Matroska,EBMLelement,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\EBMLElement.cs,SetData,The following statement contains a magic number: for (int i = vector.Count - 1; i >= 0; i--)  			{  				vector[i] = (byte)(data & 0xff);  				data >>= 8;  			}
Magic Number,TagLib.Matroska,File,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\File.cs,ReadCreateSegmentInfo,The following statement contains a magic number: while (i < element.DataSize)  			{  				EBMLreader child = new EBMLreader(element' element.DataOffset + i);  				MatroskaID matroska_id = child.ID;    				if (Mode == AccessMode.Write)  				{  					// Store raw data to represent the SegmentInfo content  					if (matroska_id != MatroskaID.CRC32) // Ignore CRC-32  					{  						var ebml = new EBMLelement(matroska_id' child.ReadBytes());  						ebml_sinfo.Children.Add(ebml);  						if (matroska_id == MatroskaID.Title) ebml_title = ebml;  					}  				}  				else  				{  					switch (matroska_id)  					{  						case MatroskaID.Duration:  							duration_unscaled = child.ReadDouble();  							if (time_scale > 0)  							{  								duration = TimeSpan.FromMilliseconds(duration_unscaled * time_scale / 1000000);  							}  							break;  						case MatroskaID.TimeCodeScale:  							time_scale = child.ReadULong();  							if (duration_unscaled > 0)  							{  								duration = TimeSpan.FromMilliseconds(duration_unscaled * time_scale / 1000000);  							}  							break;  						case MatroskaID.Title:  							tags.Title = child.ReadString();  							break;  						default:  							break;  					}  				}    				i += child.Size;  			}
Magic Number,TagLib.Matroska,File,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\File.cs,ReadCreateSegmentInfo,The following statement contains a magic number: while (i < element.DataSize)  			{  				EBMLreader child = new EBMLreader(element' element.DataOffset + i);  				MatroskaID matroska_id = child.ID;    				if (Mode == AccessMode.Write)  				{  					// Store raw data to represent the SegmentInfo content  					if (matroska_id != MatroskaID.CRC32) // Ignore CRC-32  					{  						var ebml = new EBMLelement(matroska_id' child.ReadBytes());  						ebml_sinfo.Children.Add(ebml);  						if (matroska_id == MatroskaID.Title) ebml_title = ebml;  					}  				}  				else  				{  					switch (matroska_id)  					{  						case MatroskaID.Duration:  							duration_unscaled = child.ReadDouble();  							if (time_scale > 0)  							{  								duration = TimeSpan.FromMilliseconds(duration_unscaled * time_scale / 1000000);  							}  							break;  						case MatroskaID.TimeCodeScale:  							time_scale = child.ReadULong();  							if (duration_unscaled > 0)  							{  								duration = TimeSpan.FromMilliseconds(duration_unscaled * time_scale / 1000000);  							}  							break;  						case MatroskaID.Title:  							tags.Title = child.ReadString();  							break;  						default:  							break;  					}  				}    				i += child.Size;  			}
Magic Number,TagLib.Matroska,File,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\File.cs,ReadLeadText,The following statement contains a magic number: const int buffer_size = 64;
Magic Number,TagLib.Matroska,File,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\File.cs,ReadSegments,The following statement contains a magic number: var segm_list = new List<EBMLreader>(10);
Magic Number,TagLib.Matroska,File,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\File.cs,ReadSegments,The following statement contains a magic number: while (i < element.DataSize)  			{  				EBMLreader child = new EBMLreader(element' element.DataOffset + i);    				MatroskaID matroska_id = child.ID;  				bool refInSeekHead = false;    				switch (matroska_id)  				{  					case MatroskaID.SeekHead:  						if (allowSeekHead)  						{  							// Take only the first SeekHead into account  							var ebml_seek = new List<EBMLreader>(10) { child };  							ReadSeekHead(child' ebml_seek);  							if (ebml_seek.Count > 0)  							{  								// Always reference the first element  								if (ebml_seek[0].Offset > element.DataOffset)  									ebml_seek.Insert(0' segm_list[0]);    								segm_list = ebml_seek;  								i = element.DataSize; // Exit the loop: we got what we need  							}  						}  						else  						{  							refInSeekHead = true;  						}  						break;    					case MatroskaID.Void: // extend SeekHead space to following void  						if (Mode == AccessMode.Write) refInSeekHead = true; // This will serve optimization  						break;    					case MatroskaID.Cluster: // reference first Cluster only (too many)  						refInSeekHead = !foundCluster;  						foundCluster = true;  						break;    					// Reference the following elements  					case MatroskaID.Cues:  					case MatroskaID.Tracks:  					case MatroskaID.SegmentInfo:  					case MatroskaID.Tags:  					case MatroskaID.Attachments:  					default:  						refInSeekHead = true;  						break;  				}    				i += child.Size;    				if (refInSeekHead || i==0) segm_list.Add(child);  			}
Magic Number,TagLib.Matroska,File,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\File.cs,ReadSimpleTag,The following statement contains a magic number: if (key != null)   			{  				key = key.ToUpper();    				List<SimpleTag> list = null;    				if (tag != null)  				{  					if (tag.SimpleTags == null)  						tag.SimpleTags = new Dictionary<string' List<SimpleTag>>(StringComparer.OrdinalIgnoreCase);  					else  						tag.SimpleTags.TryGetValue(key' out list);    					if (list == null)  						tag.SimpleTags[key] = list = new List<SimpleTag>(6);  				}  				else  				{  					if (simpletag.SimpleTags == null)  						simpletag.SimpleTags = new Dictionary<string' List<SimpleTag>>(StringComparer.OrdinalIgnoreCase);  					else  						simpletag.SimpleTags.TryGetValue(key' out list);    					if (list == null)  						simpletag.SimpleTags[key] = list = new List<SimpleTag>(1);  				}    				list.Add(stag);  			}
Magic Number,TagLib.Matroska,File,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\File.cs,WriteSegment,The following statement contains a magic number: var ebml_alloc = new List<EBMLelement>(3);
Magic Number,TagLib.Matroska,File,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\File.cs,WriteSegment,The following statement contains a magic number: if (ebml_alloc.Count==2 && ebml_alloc[0].Size < ebml_alloc[1].Size)  			{  				var swap = ebml_alloc[0];  				ebml_alloc[0] = ebml_alloc[1];  				ebml_alloc[1] = swap;  			}
Magic Number,TagLib.Matroska,File,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\File.cs,WriteReservedEBML,The following statement contains a magic number: long margin = 40;
Magic Number,TagLib.Matroska,File,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\File.cs,WriteReservedEBML,The following statement contains a magic number: if (segm_list[0].Offset != (ulong)pos || segm_list[0].ID != MatroskaID.Void)  			{  				margin *= 3;  				reserved += margin;  				Insert(reserved' pos);  				woffset += reserved;  				segm_list.Insert(0' new EBMLreader(ebml_segm' (ulong)pos' MatroskaID.Void' (ulong)reserved));  			}  			else if (segm_list[0].Size < (ulong)reserved)  			{  				margin *= 3;  				reserved += margin;  				Insert(reserved - (long)segm_list[0].Size' pos + (long)segm_list[0].Size);  				woffset += reserved - (long)segm_list[0].Size;  				segm_list[0] = new EBMLreader(ebml_segm' (ulong)pos' MatroskaID.Void' (ulong)reserved);  			}
Magic Number,TagLib.Matroska,File,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\File.cs,WriteReservedEBML,The following statement contains a magic number: if (segm_list[0].Offset != (ulong)pos || segm_list[0].ID != MatroskaID.Void)  			{  				margin *= 3;  				reserved += margin;  				Insert(reserved' pos);  				woffset += reserved;  				segm_list.Insert(0' new EBMLreader(ebml_segm' (ulong)pos' MatroskaID.Void' (ulong)reserved));  			}  			else if (segm_list[0].Size < (ulong)reserved)  			{  				margin *= 3;  				reserved += margin;  				Insert(reserved - (long)segm_list[0].Size' pos + (long)segm_list[0].Size);  				woffset += reserved - (long)segm_list[0].Size;  				segm_list[0] = new EBMLreader(ebml_segm' (ulong)pos' MatroskaID.Void' (ulong)reserved);  			}
Magic Number,TagLib.Matroska,File,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\File.cs,UpdateSegmentsMergeVoids,The following statement contains a magic number: ulong maxbound = ebml_segm.Offset + ebml_segm.Size - 2;
Magic Number,TagLib.Matroska,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\Tag.cs,MakeTargetType,The following statement contains a magic number: switch (targetTypeValue)  			{  				case 70: ret = TargetType.COLLECTION; break;  				case 60: ret = IsVideo ? TargetType.SEASON : TargetType.VOLUME; break;  				case 50: ret = IsVideo ? TargetType.MOVIE : TargetType.ALBUM; break;  				case 40: ret = TargetType.PART; break;  				case 30: ret = IsVideo ? TargetType.CHAPTER : TargetType.TRACK; break;  				case 20: ret = IsVideo ? TargetType.SCENE : TargetType.MOVEMENT; break;  				case 10: ret = TargetType.SHOT; break;  			}
Magic Number,TagLib.Matroska,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\Tag.cs,MakeTargetType,The following statement contains a magic number: switch (targetTypeValue)  			{  				case 70: ret = TargetType.COLLECTION; break;  				case 60: ret = IsVideo ? TargetType.SEASON : TargetType.VOLUME; break;  				case 50: ret = IsVideo ? TargetType.MOVIE : TargetType.ALBUM; break;  				case 40: ret = TargetType.PART; break;  				case 30: ret = IsVideo ? TargetType.CHAPTER : TargetType.TRACK; break;  				case 20: ret = IsVideo ? TargetType.SCENE : TargetType.MOVEMENT; break;  				case 10: ret = TargetType.SHOT; break;  			}
Magic Number,TagLib.Matroska,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\Tag.cs,MakeTargetType,The following statement contains a magic number: switch (targetTypeValue)  			{  				case 70: ret = TargetType.COLLECTION; break;  				case 60: ret = IsVideo ? TargetType.SEASON : TargetType.VOLUME; break;  				case 50: ret = IsVideo ? TargetType.MOVIE : TargetType.ALBUM; break;  				case 40: ret = TargetType.PART; break;  				case 30: ret = IsVideo ? TargetType.CHAPTER : TargetType.TRACK; break;  				case 20: ret = IsVideo ? TargetType.SCENE : TargetType.MOVEMENT; break;  				case 10: ret = TargetType.SHOT; break;  			}
Magic Number,TagLib.Matroska,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\Tag.cs,MakeTargetType,The following statement contains a magic number: switch (targetTypeValue)  			{  				case 70: ret = TargetType.COLLECTION; break;  				case 60: ret = IsVideo ? TargetType.SEASON : TargetType.VOLUME; break;  				case 50: ret = IsVideo ? TargetType.MOVIE : TargetType.ALBUM; break;  				case 40: ret = TargetType.PART; break;  				case 30: ret = IsVideo ? TargetType.CHAPTER : TargetType.TRACK; break;  				case 20: ret = IsVideo ? TargetType.SCENE : TargetType.MOVEMENT; break;  				case 10: ret = TargetType.SHOT; break;  			}
Magic Number,TagLib.Matroska,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\Tag.cs,MakeTargetType,The following statement contains a magic number: switch (targetTypeValue)  			{  				case 70: ret = TargetType.COLLECTION; break;  				case 60: ret = IsVideo ? TargetType.SEASON : TargetType.VOLUME; break;  				case 50: ret = IsVideo ? TargetType.MOVIE : TargetType.ALBUM; break;  				case 40: ret = TargetType.PART; break;  				case 30: ret = IsVideo ? TargetType.CHAPTER : TargetType.TRACK; break;  				case 20: ret = IsVideo ? TargetType.SCENE : TargetType.MOVEMENT; break;  				case 10: ret = TargetType.SHOT; break;  			}
Magic Number,TagLib.Matroska,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\Tag.cs,MakeTargetType,The following statement contains a magic number: switch (targetTypeValue)  			{  				case 70: ret = TargetType.COLLECTION; break;  				case 60: ret = IsVideo ? TargetType.SEASON : TargetType.VOLUME; break;  				case 50: ret = IsVideo ? TargetType.MOVIE : TargetType.ALBUM; break;  				case 40: ret = TargetType.PART; break;  				case 30: ret = IsVideo ? TargetType.CHAPTER : TargetType.TRACK; break;  				case 20: ret = IsVideo ? TargetType.SCENE : TargetType.MOVEMENT; break;  				case 10: ret = TargetType.SHOT; break;  			}
Magic Number,TagLib.Matroska,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\Tag.cs,MakeTargetType,The following statement contains a magic number: switch (targetTypeValue)  			{  				case 70: ret = TargetType.COLLECTION; break;  				case 60: ret = IsVideo ? TargetType.SEASON : TargetType.VOLUME; break;  				case 50: ret = IsVideo ? TargetType.MOVIE : TargetType.ALBUM; break;  				case 40: ret = TargetType.PART; break;  				case 30: ret = IsVideo ? TargetType.CHAPTER : TargetType.TRACK; break;  				case 20: ret = IsVideo ? TargetType.SCENE : TargetType.MOVEMENT; break;  				case 10: ret = TargetType.SHOT; break;  			}
Magic Number,TagLib.Matroska,VideoTrack,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\VideoTrack.cs,VideoTrack,The following statement contains a magic number: foreach (EBMLreader elem in base.UnknownElements) {  				matroska_id = (MatroskaID) elem.ID;      				switch (matroska_id)  				{  					case MatroskaID.TrackVideo:  						{  							ulong i = 0;    							while (i < elem.DataSize)  							{  								EBMLreader child = new EBMLreader(_file' elem.DataOffset + i);    								matroska_id = (MatroskaID)child.ID;    								switch (matroska_id)  								{  									case MatroskaID.VideoDisplayWidth:  										disp_width = child.ReadULong();  										break;  									case MatroskaID.VideoDisplayHeight:  										disp_height = child.ReadULong();  										break;  									case MatroskaID.VideoPixelWidth:  										width = child.ReadULong();  										break;  									case MatroskaID.VideoPixelHeight:  										height = child.ReadULong();  										break;  									case MatroskaID.VideoFrameRate:  										framerate = child.ReadDouble();  										break;  									case MatroskaID.VideoFlagInterlaced:  										interlaced = child.ReadBool();  										break;  									case MatroskaID.VideoAspectRatioType:  										ratio_type = (VideoAspectRatioType)child.ReadULong();  										break;  									case MatroskaID.VideoColourSpace:  										fourcc = child.ReadBytes();  										break;  									default:  										unknown_elems.Add(child);  										break;  								}    								i += child.Size;  							}  							break;  						}    					case MatroskaID.TrackDefaultDuration:  						ulong tmp = elem.ReadULong();  						framerate = 1000000000.0 / (double)tmp;  						break;    					default:  						unknown_elems.Add(elem);  						break;  				}  				  			}
Magic Number,TagLib.Aac,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aac\AudioHeader.cs,SetStreamLength,The following statement contains a magic number: duration = TimeSpan.FromSeconds(((double)this.stream_length) * 8.0 / ((double)this.audiobitrate));
Magic Number,TagLib.Aac,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aac\AudioHeader.cs,Find,The following statement contains a magic number: ByteVector buffer = file.ReadBlock(3);
Magic Number,TagLib.Aac,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aac\AudioHeader.cs,Find,The following statement contains a magic number: if (buffer.Count < 3)  				return false;
Magic Number,TagLib.Aac,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aac\AudioHeader.cs,Find,The following statement contains a magic number: do  			{  				file.Seek(position + 3);  				buffer = buffer.Mid(buffer.Count - 3);  				buffer.Add(file.ReadBlock(  					(int)File.BufferSize));    				for (int i = 0; i < buffer.Count - 3 &&  					(length < 0 || position + i < end); i++)  					if (buffer[i] == 0xFF  						&& buffer[i+1] >= 0xF0) // 0xFFF  						try  						{                              							BitStream bits = new BitStream(buffer.Mid(i' 7).Data);    							// 12 bits sync header   							bits.ReadInt32(12);    							// 1 bit mpeg 2/4  							bits.ReadInt32(1);    							// 2 bits layer  							bits.ReadInt32(2);    							// 1 bit protection absent    							bits.ReadInt32(1);  						    							// 2 bits profile object type  							bits.ReadInt32(2);    							// 4 bits sampling frequency index                              							int samplerateindex = bits.ReadInt32(4);  							if(samplerateindex >= sample_rates.Length)  								return false;  							long samplerate = sample_rates[samplerateindex];    							// 1 bit private bit  							bits.ReadInt32(1);    							// 3 bits channel configuration  							int channelconfigindex = bits.ReadInt32(3);  							if (channelconfigindex >= channels.Length)  								return false;                                							// 4 copyright bits  							bits.ReadInt32(4);    							// 13 bits frame length  							long framelength = bits.ReadInt32(13); // double check framelength  								if (framelength < 7)  								return false;    							// 11 bits buffer fullness  							bits.ReadInt32(11);    							// 2 bits number of raw data blocks in frame  							int numberofframes = bits.ReadInt32(2) + 1;    							long numberofsamples = numberofframes * 1024;  							long bitrate = framelength * 8 * samplerate / numberofsamples;                                							header = new AudioHeader(channels[channelconfigindex]'  								(int)bitrate'  								(int)samplerate'  								(int)numberofsamples'  								numberofframes);                                							return true;  						}  						catch (CorruptFileException)  						{  						}    				position += File.BufferSize;  			} while (buffer.Count > 3 && (length < 0 || position < end));
Magic Number,TagLib.Aac,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aac\AudioHeader.cs,Find,The following statement contains a magic number: do  			{  				file.Seek(position + 3);  				buffer = buffer.Mid(buffer.Count - 3);  				buffer.Add(file.ReadBlock(  					(int)File.BufferSize));    				for (int i = 0; i < buffer.Count - 3 &&  					(length < 0 || position + i < end); i++)  					if (buffer[i] == 0xFF  						&& buffer[i+1] >= 0xF0) // 0xFFF  						try  						{                              							BitStream bits = new BitStream(buffer.Mid(i' 7).Data);    							// 12 bits sync header   							bits.ReadInt32(12);    							// 1 bit mpeg 2/4  							bits.ReadInt32(1);    							// 2 bits layer  							bits.ReadInt32(2);    							// 1 bit protection absent    							bits.ReadInt32(1);  						    							// 2 bits profile object type  							bits.ReadInt32(2);    							// 4 bits sampling frequency index                              							int samplerateindex = bits.ReadInt32(4);  							if(samplerateindex >= sample_rates.Length)  								return false;  							long samplerate = sample_rates[samplerateindex];    							// 1 bit private bit  							bits.ReadInt32(1);    							// 3 bits channel configuration  							int channelconfigindex = bits.ReadInt32(3);  							if (channelconfigindex >= channels.Length)  								return false;                                							// 4 copyright bits  							bits.ReadInt32(4);    							// 13 bits frame length  							long framelength = bits.ReadInt32(13); // double check framelength  								if (framelength < 7)  								return false;    							// 11 bits buffer fullness  							bits.ReadInt32(11);    							// 2 bits number of raw data blocks in frame  							int numberofframes = bits.ReadInt32(2) + 1;    							long numberofsamples = numberofframes * 1024;  							long bitrate = framelength * 8 * samplerate / numberofsamples;                                							header = new AudioHeader(channels[channelconfigindex]'  								(int)bitrate'  								(int)samplerate'  								(int)numberofsamples'  								numberofframes);                                							return true;  						}  						catch (CorruptFileException)  						{  						}    				position += File.BufferSize;  			} while (buffer.Count > 3 && (length < 0 || position < end));
Magic Number,TagLib.Aac,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aac\AudioHeader.cs,Find,The following statement contains a magic number: do  			{  				file.Seek(position + 3);  				buffer = buffer.Mid(buffer.Count - 3);  				buffer.Add(file.ReadBlock(  					(int)File.BufferSize));    				for (int i = 0; i < buffer.Count - 3 &&  					(length < 0 || position + i < end); i++)  					if (buffer[i] == 0xFF  						&& buffer[i+1] >= 0xF0) // 0xFFF  						try  						{                              							BitStream bits = new BitStream(buffer.Mid(i' 7).Data);    							// 12 bits sync header   							bits.ReadInt32(12);    							// 1 bit mpeg 2/4  							bits.ReadInt32(1);    							// 2 bits layer  							bits.ReadInt32(2);    							// 1 bit protection absent    							bits.ReadInt32(1);  						    							// 2 bits profile object type  							bits.ReadInt32(2);    							// 4 bits sampling frequency index                              							int samplerateindex = bits.ReadInt32(4);  							if(samplerateindex >= sample_rates.Length)  								return false;  							long samplerate = sample_rates[samplerateindex];    							// 1 bit private bit  							bits.ReadInt32(1);    							// 3 bits channel configuration  							int channelconfigindex = bits.ReadInt32(3);  							if (channelconfigindex >= channels.Length)  								return false;                                							// 4 copyright bits  							bits.ReadInt32(4);    							// 13 bits frame length  							long framelength = bits.ReadInt32(13); // double check framelength  								if (framelength < 7)  								return false;    							// 11 bits buffer fullness  							bits.ReadInt32(11);    							// 2 bits number of raw data blocks in frame  							int numberofframes = bits.ReadInt32(2) + 1;    							long numberofsamples = numberofframes * 1024;  							long bitrate = framelength * 8 * samplerate / numberofsamples;                                							header = new AudioHeader(channels[channelconfigindex]'  								(int)bitrate'  								(int)samplerate'  								(int)numberofsamples'  								numberofframes);                                							return true;  						}  						catch (CorruptFileException)  						{  						}    				position += File.BufferSize;  			} while (buffer.Count > 3 && (length < 0 || position < end));
Magic Number,TagLib.Aac,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aac\AudioHeader.cs,Find,The following statement contains a magic number: do  			{  				file.Seek(position + 3);  				buffer = buffer.Mid(buffer.Count - 3);  				buffer.Add(file.ReadBlock(  					(int)File.BufferSize));    				for (int i = 0; i < buffer.Count - 3 &&  					(length < 0 || position + i < end); i++)  					if (buffer[i] == 0xFF  						&& buffer[i+1] >= 0xF0) // 0xFFF  						try  						{                              							BitStream bits = new BitStream(buffer.Mid(i' 7).Data);    							// 12 bits sync header   							bits.ReadInt32(12);    							// 1 bit mpeg 2/4  							bits.ReadInt32(1);    							// 2 bits layer  							bits.ReadInt32(2);    							// 1 bit protection absent    							bits.ReadInt32(1);  						    							// 2 bits profile object type  							bits.ReadInt32(2);    							// 4 bits sampling frequency index                              							int samplerateindex = bits.ReadInt32(4);  							if(samplerateindex >= sample_rates.Length)  								return false;  							long samplerate = sample_rates[samplerateindex];    							// 1 bit private bit  							bits.ReadInt32(1);    							// 3 bits channel configuration  							int channelconfigindex = bits.ReadInt32(3);  							if (channelconfigindex >= channels.Length)  								return false;                                							// 4 copyright bits  							bits.ReadInt32(4);    							// 13 bits frame length  							long framelength = bits.ReadInt32(13); // double check framelength  								if (framelength < 7)  								return false;    							// 11 bits buffer fullness  							bits.ReadInt32(11);    							// 2 bits number of raw data blocks in frame  							int numberofframes = bits.ReadInt32(2) + 1;    							long numberofsamples = numberofframes * 1024;  							long bitrate = framelength * 8 * samplerate / numberofsamples;                                							header = new AudioHeader(channels[channelconfigindex]'  								(int)bitrate'  								(int)samplerate'  								(int)numberofsamples'  								numberofframes);                                							return true;  						}  						catch (CorruptFileException)  						{  						}    				position += File.BufferSize;  			} while (buffer.Count > 3 && (length < 0 || position < end));
Magic Number,TagLib.Aac,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aac\AudioHeader.cs,Find,The following statement contains a magic number: do  			{  				file.Seek(position + 3);  				buffer = buffer.Mid(buffer.Count - 3);  				buffer.Add(file.ReadBlock(  					(int)File.BufferSize));    				for (int i = 0; i < buffer.Count - 3 &&  					(length < 0 || position + i < end); i++)  					if (buffer[i] == 0xFF  						&& buffer[i+1] >= 0xF0) // 0xFFF  						try  						{                              							BitStream bits = new BitStream(buffer.Mid(i' 7).Data);    							// 12 bits sync header   							bits.ReadInt32(12);    							// 1 bit mpeg 2/4  							bits.ReadInt32(1);    							// 2 bits layer  							bits.ReadInt32(2);    							// 1 bit protection absent    							bits.ReadInt32(1);  						    							// 2 bits profile object type  							bits.ReadInt32(2);    							// 4 bits sampling frequency index                              							int samplerateindex = bits.ReadInt32(4);  							if(samplerateindex >= sample_rates.Length)  								return false;  							long samplerate = sample_rates[samplerateindex];    							// 1 bit private bit  							bits.ReadInt32(1);    							// 3 bits channel configuration  							int channelconfigindex = bits.ReadInt32(3);  							if (channelconfigindex >= channels.Length)  								return false;                                							// 4 copyright bits  							bits.ReadInt32(4);    							// 13 bits frame length  							long framelength = bits.ReadInt32(13); // double check framelength  								if (framelength < 7)  								return false;    							// 11 bits buffer fullness  							bits.ReadInt32(11);    							// 2 bits number of raw data blocks in frame  							int numberofframes = bits.ReadInt32(2) + 1;    							long numberofsamples = numberofframes * 1024;  							long bitrate = framelength * 8 * samplerate / numberofsamples;                                							header = new AudioHeader(channels[channelconfigindex]'  								(int)bitrate'  								(int)samplerate'  								(int)numberofsamples'  								numberofframes);                                							return true;  						}  						catch (CorruptFileException)  						{  						}    				position += File.BufferSize;  			} while (buffer.Count > 3 && (length < 0 || position < end));
Magic Number,TagLib.Aac,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aac\AudioHeader.cs,Find,The following statement contains a magic number: do  			{  				file.Seek(position + 3);  				buffer = buffer.Mid(buffer.Count - 3);  				buffer.Add(file.ReadBlock(  					(int)File.BufferSize));    				for (int i = 0; i < buffer.Count - 3 &&  					(length < 0 || position + i < end); i++)  					if (buffer[i] == 0xFF  						&& buffer[i+1] >= 0xF0) // 0xFFF  						try  						{                              							BitStream bits = new BitStream(buffer.Mid(i' 7).Data);    							// 12 bits sync header   							bits.ReadInt32(12);    							// 1 bit mpeg 2/4  							bits.ReadInt32(1);    							// 2 bits layer  							bits.ReadInt32(2);    							// 1 bit protection absent    							bits.ReadInt32(1);  						    							// 2 bits profile object type  							bits.ReadInt32(2);    							// 4 bits sampling frequency index                              							int samplerateindex = bits.ReadInt32(4);  							if(samplerateindex >= sample_rates.Length)  								return false;  							long samplerate = sample_rates[samplerateindex];    							// 1 bit private bit  							bits.ReadInt32(1);    							// 3 bits channel configuration  							int channelconfigindex = bits.ReadInt32(3);  							if (channelconfigindex >= channels.Length)  								return false;                                							// 4 copyright bits  							bits.ReadInt32(4);    							// 13 bits frame length  							long framelength = bits.ReadInt32(13); // double check framelength  								if (framelength < 7)  								return false;    							// 11 bits buffer fullness  							bits.ReadInt32(11);    							// 2 bits number of raw data blocks in frame  							int numberofframes = bits.ReadInt32(2) + 1;    							long numberofsamples = numberofframes * 1024;  							long bitrate = framelength * 8 * samplerate / numberofsamples;                                							header = new AudioHeader(channels[channelconfigindex]'  								(int)bitrate'  								(int)samplerate'  								(int)numberofsamples'  								numberofframes);                                							return true;  						}  						catch (CorruptFileException)  						{  						}    				position += File.BufferSize;  			} while (buffer.Count > 3 && (length < 0 || position < end));
Magic Number,TagLib.Aac,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aac\AudioHeader.cs,Find,The following statement contains a magic number: do  			{  				file.Seek(position + 3);  				buffer = buffer.Mid(buffer.Count - 3);  				buffer.Add(file.ReadBlock(  					(int)File.BufferSize));    				for (int i = 0; i < buffer.Count - 3 &&  					(length < 0 || position + i < end); i++)  					if (buffer[i] == 0xFF  						&& buffer[i+1] >= 0xF0) // 0xFFF  						try  						{                              							BitStream bits = new BitStream(buffer.Mid(i' 7).Data);    							// 12 bits sync header   							bits.ReadInt32(12);    							// 1 bit mpeg 2/4  							bits.ReadInt32(1);    							// 2 bits layer  							bits.ReadInt32(2);    							// 1 bit protection absent    							bits.ReadInt32(1);  						    							// 2 bits profile object type  							bits.ReadInt32(2);    							// 4 bits sampling frequency index                              							int samplerateindex = bits.ReadInt32(4);  							if(samplerateindex >= sample_rates.Length)  								return false;  							long samplerate = sample_rates[samplerateindex];    							// 1 bit private bit  							bits.ReadInt32(1);    							// 3 bits channel configuration  							int channelconfigindex = bits.ReadInt32(3);  							if (channelconfigindex >= channels.Length)  								return false;                                							// 4 copyright bits  							bits.ReadInt32(4);    							// 13 bits frame length  							long framelength = bits.ReadInt32(13); // double check framelength  								if (framelength < 7)  								return false;    							// 11 bits buffer fullness  							bits.ReadInt32(11);    							// 2 bits number of raw data blocks in frame  							int numberofframes = bits.ReadInt32(2) + 1;    							long numberofsamples = numberofframes * 1024;  							long bitrate = framelength * 8 * samplerate / numberofsamples;                                							header = new AudioHeader(channels[channelconfigindex]'  								(int)bitrate'  								(int)samplerate'  								(int)numberofsamples'  								numberofframes);                                							return true;  						}  						catch (CorruptFileException)  						{  						}    				position += File.BufferSize;  			} while (buffer.Count > 3 && (length < 0 || position < end));
Magic Number,TagLib.Aac,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aac\AudioHeader.cs,Find,The following statement contains a magic number: do  			{  				file.Seek(position + 3);  				buffer = buffer.Mid(buffer.Count - 3);  				buffer.Add(file.ReadBlock(  					(int)File.BufferSize));    				for (int i = 0; i < buffer.Count - 3 &&  					(length < 0 || position + i < end); i++)  					if (buffer[i] == 0xFF  						&& buffer[i+1] >= 0xF0) // 0xFFF  						try  						{                              							BitStream bits = new BitStream(buffer.Mid(i' 7).Data);    							// 12 bits sync header   							bits.ReadInt32(12);    							// 1 bit mpeg 2/4  							bits.ReadInt32(1);    							// 2 bits layer  							bits.ReadInt32(2);    							// 1 bit protection absent    							bits.ReadInt32(1);  						    							// 2 bits profile object type  							bits.ReadInt32(2);    							// 4 bits sampling frequency index                              							int samplerateindex = bits.ReadInt32(4);  							if(samplerateindex >= sample_rates.Length)  								return false;  							long samplerate = sample_rates[samplerateindex];    							// 1 bit private bit  							bits.ReadInt32(1);    							// 3 bits channel configuration  							int channelconfigindex = bits.ReadInt32(3);  							if (channelconfigindex >= channels.Length)  								return false;                                							// 4 copyright bits  							bits.ReadInt32(4);    							// 13 bits frame length  							long framelength = bits.ReadInt32(13); // double check framelength  								if (framelength < 7)  								return false;    							// 11 bits buffer fullness  							bits.ReadInt32(11);    							// 2 bits number of raw data blocks in frame  							int numberofframes = bits.ReadInt32(2) + 1;    							long numberofsamples = numberofframes * 1024;  							long bitrate = framelength * 8 * samplerate / numberofsamples;                                							header = new AudioHeader(channels[channelconfigindex]'  								(int)bitrate'  								(int)samplerate'  								(int)numberofsamples'  								numberofframes);                                							return true;  						}  						catch (CorruptFileException)  						{  						}    				position += File.BufferSize;  			} while (buffer.Count > 3 && (length < 0 || position < end));
Magic Number,TagLib.Aac,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aac\AudioHeader.cs,Find,The following statement contains a magic number: do  			{  				file.Seek(position + 3);  				buffer = buffer.Mid(buffer.Count - 3);  				buffer.Add(file.ReadBlock(  					(int)File.BufferSize));    				for (int i = 0; i < buffer.Count - 3 &&  					(length < 0 || position + i < end); i++)  					if (buffer[i] == 0xFF  						&& buffer[i+1] >= 0xF0) // 0xFFF  						try  						{                              							BitStream bits = new BitStream(buffer.Mid(i' 7).Data);    							// 12 bits sync header   							bits.ReadInt32(12);    							// 1 bit mpeg 2/4  							bits.ReadInt32(1);    							// 2 bits layer  							bits.ReadInt32(2);    							// 1 bit protection absent    							bits.ReadInt32(1);  						    							// 2 bits profile object type  							bits.ReadInt32(2);    							// 4 bits sampling frequency index                              							int samplerateindex = bits.ReadInt32(4);  							if(samplerateindex >= sample_rates.Length)  								return false;  							long samplerate = sample_rates[samplerateindex];    							// 1 bit private bit  							bits.ReadInt32(1);    							// 3 bits channel configuration  							int channelconfigindex = bits.ReadInt32(3);  							if (channelconfigindex >= channels.Length)  								return false;                                							// 4 copyright bits  							bits.ReadInt32(4);    							// 13 bits frame length  							long framelength = bits.ReadInt32(13); // double check framelength  								if (framelength < 7)  								return false;    							// 11 bits buffer fullness  							bits.ReadInt32(11);    							// 2 bits number of raw data blocks in frame  							int numberofframes = bits.ReadInt32(2) + 1;    							long numberofsamples = numberofframes * 1024;  							long bitrate = framelength * 8 * samplerate / numberofsamples;                                							header = new AudioHeader(channels[channelconfigindex]'  								(int)bitrate'  								(int)samplerate'  								(int)numberofsamples'  								numberofframes);                                							return true;  						}  						catch (CorruptFileException)  						{  						}    				position += File.BufferSize;  			} while (buffer.Count > 3 && (length < 0 || position < end));
Magic Number,TagLib.Aac,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aac\AudioHeader.cs,Find,The following statement contains a magic number: do  			{  				file.Seek(position + 3);  				buffer = buffer.Mid(buffer.Count - 3);  				buffer.Add(file.ReadBlock(  					(int)File.BufferSize));    				for (int i = 0; i < buffer.Count - 3 &&  					(length < 0 || position + i < end); i++)  					if (buffer[i] == 0xFF  						&& buffer[i+1] >= 0xF0) // 0xFFF  						try  						{                              							BitStream bits = new BitStream(buffer.Mid(i' 7).Data);    							// 12 bits sync header   							bits.ReadInt32(12);    							// 1 bit mpeg 2/4  							bits.ReadInt32(1);    							// 2 bits layer  							bits.ReadInt32(2);    							// 1 bit protection absent    							bits.ReadInt32(1);  						    							// 2 bits profile object type  							bits.ReadInt32(2);    							// 4 bits sampling frequency index                              							int samplerateindex = bits.ReadInt32(4);  							if(samplerateindex >= sample_rates.Length)  								return false;  							long samplerate = sample_rates[samplerateindex];    							// 1 bit private bit  							bits.ReadInt32(1);    							// 3 bits channel configuration  							int channelconfigindex = bits.ReadInt32(3);  							if (channelconfigindex >= channels.Length)  								return false;                                							// 4 copyright bits  							bits.ReadInt32(4);    							// 13 bits frame length  							long framelength = bits.ReadInt32(13); // double check framelength  								if (framelength < 7)  								return false;    							// 11 bits buffer fullness  							bits.ReadInt32(11);    							// 2 bits number of raw data blocks in frame  							int numberofframes = bits.ReadInt32(2) + 1;    							long numberofsamples = numberofframes * 1024;  							long bitrate = framelength * 8 * samplerate / numberofsamples;                                							header = new AudioHeader(channels[channelconfigindex]'  								(int)bitrate'  								(int)samplerate'  								(int)numberofsamples'  								numberofframes);                                							return true;  						}  						catch (CorruptFileException)  						{  						}    				position += File.BufferSize;  			} while (buffer.Count > 3 && (length < 0 || position < end));
Magic Number,TagLib.Aac,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aac\AudioHeader.cs,Find,The following statement contains a magic number: do  			{  				file.Seek(position + 3);  				buffer = buffer.Mid(buffer.Count - 3);  				buffer.Add(file.ReadBlock(  					(int)File.BufferSize));    				for (int i = 0; i < buffer.Count - 3 &&  					(length < 0 || position + i < end); i++)  					if (buffer[i] == 0xFF  						&& buffer[i+1] >= 0xF0) // 0xFFF  						try  						{                              							BitStream bits = new BitStream(buffer.Mid(i' 7).Data);    							// 12 bits sync header   							bits.ReadInt32(12);    							// 1 bit mpeg 2/4  							bits.ReadInt32(1);    							// 2 bits layer  							bits.ReadInt32(2);    							// 1 bit protection absent    							bits.ReadInt32(1);  						    							// 2 bits profile object type  							bits.ReadInt32(2);    							// 4 bits sampling frequency index                              							int samplerateindex = bits.ReadInt32(4);  							if(samplerateindex >= sample_rates.Length)  								return false;  							long samplerate = sample_rates[samplerateindex];    							// 1 bit private bit  							bits.ReadInt32(1);    							// 3 bits channel configuration  							int channelconfigindex = bits.ReadInt32(3);  							if (channelconfigindex >= channels.Length)  								return false;                                							// 4 copyright bits  							bits.ReadInt32(4);    							// 13 bits frame length  							long framelength = bits.ReadInt32(13); // double check framelength  								if (framelength < 7)  								return false;    							// 11 bits buffer fullness  							bits.ReadInt32(11);    							// 2 bits number of raw data blocks in frame  							int numberofframes = bits.ReadInt32(2) + 1;    							long numberofsamples = numberofframes * 1024;  							long bitrate = framelength * 8 * samplerate / numberofsamples;                                							header = new AudioHeader(channels[channelconfigindex]'  								(int)bitrate'  								(int)samplerate'  								(int)numberofsamples'  								numberofframes);                                							return true;  						}  						catch (CorruptFileException)  						{  						}    				position += File.BufferSize;  			} while (buffer.Count > 3 && (length < 0 || position < end));
Magic Number,TagLib.Aac,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aac\AudioHeader.cs,Find,The following statement contains a magic number: do  			{  				file.Seek(position + 3);  				buffer = buffer.Mid(buffer.Count - 3);  				buffer.Add(file.ReadBlock(  					(int)File.BufferSize));    				for (int i = 0; i < buffer.Count - 3 &&  					(length < 0 || position + i < end); i++)  					if (buffer[i] == 0xFF  						&& buffer[i+1] >= 0xF0) // 0xFFF  						try  						{                              							BitStream bits = new BitStream(buffer.Mid(i' 7).Data);    							// 12 bits sync header   							bits.ReadInt32(12);    							// 1 bit mpeg 2/4  							bits.ReadInt32(1);    							// 2 bits layer  							bits.ReadInt32(2);    							// 1 bit protection absent    							bits.ReadInt32(1);  						    							// 2 bits profile object type  							bits.ReadInt32(2);    							// 4 bits sampling frequency index                              							int samplerateindex = bits.ReadInt32(4);  							if(samplerateindex >= sample_rates.Length)  								return false;  							long samplerate = sample_rates[samplerateindex];    							// 1 bit private bit  							bits.ReadInt32(1);    							// 3 bits channel configuration  							int channelconfigindex = bits.ReadInt32(3);  							if (channelconfigindex >= channels.Length)  								return false;                                							// 4 copyright bits  							bits.ReadInt32(4);    							// 13 bits frame length  							long framelength = bits.ReadInt32(13); // double check framelength  								if (framelength < 7)  								return false;    							// 11 bits buffer fullness  							bits.ReadInt32(11);    							// 2 bits number of raw data blocks in frame  							int numberofframes = bits.ReadInt32(2) + 1;    							long numberofsamples = numberofframes * 1024;  							long bitrate = framelength * 8 * samplerate / numberofsamples;                                							header = new AudioHeader(channels[channelconfigindex]'  								(int)bitrate'  								(int)samplerate'  								(int)numberofsamples'  								numberofframes);                                							return true;  						}  						catch (CorruptFileException)  						{  						}    				position += File.BufferSize;  			} while (buffer.Count > 3 && (length < 0 || position < end));
Magic Number,TagLib.Aac,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aac\AudioHeader.cs,Find,The following statement contains a magic number: do  			{  				file.Seek(position + 3);  				buffer = buffer.Mid(buffer.Count - 3);  				buffer.Add(file.ReadBlock(  					(int)File.BufferSize));    				for (int i = 0; i < buffer.Count - 3 &&  					(length < 0 || position + i < end); i++)  					if (buffer[i] == 0xFF  						&& buffer[i+1] >= 0xF0) // 0xFFF  						try  						{                              							BitStream bits = new BitStream(buffer.Mid(i' 7).Data);    							// 12 bits sync header   							bits.ReadInt32(12);    							// 1 bit mpeg 2/4  							bits.ReadInt32(1);    							// 2 bits layer  							bits.ReadInt32(2);    							// 1 bit protection absent    							bits.ReadInt32(1);  						    							// 2 bits profile object type  							bits.ReadInt32(2);    							// 4 bits sampling frequency index                              							int samplerateindex = bits.ReadInt32(4);  							if(samplerateindex >= sample_rates.Length)  								return false;  							long samplerate = sample_rates[samplerateindex];    							// 1 bit private bit  							bits.ReadInt32(1);    							// 3 bits channel configuration  							int channelconfigindex = bits.ReadInt32(3);  							if (channelconfigindex >= channels.Length)  								return false;                                							// 4 copyright bits  							bits.ReadInt32(4);    							// 13 bits frame length  							long framelength = bits.ReadInt32(13); // double check framelength  								if (framelength < 7)  								return false;    							// 11 bits buffer fullness  							bits.ReadInt32(11);    							// 2 bits number of raw data blocks in frame  							int numberofframes = bits.ReadInt32(2) + 1;    							long numberofsamples = numberofframes * 1024;  							long bitrate = framelength * 8 * samplerate / numberofsamples;                                							header = new AudioHeader(channels[channelconfigindex]'  								(int)bitrate'  								(int)samplerate'  								(int)numberofsamples'  								numberofframes);                                							return true;  						}  						catch (CorruptFileException)  						{  						}    				position += File.BufferSize;  			} while (buffer.Count > 3 && (length < 0 || position < end));
Magic Number,TagLib.Aac,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aac\AudioHeader.cs,Find,The following statement contains a magic number: do  			{  				file.Seek(position + 3);  				buffer = buffer.Mid(buffer.Count - 3);  				buffer.Add(file.ReadBlock(  					(int)File.BufferSize));    				for (int i = 0; i < buffer.Count - 3 &&  					(length < 0 || position + i < end); i++)  					if (buffer[i] == 0xFF  						&& buffer[i+1] >= 0xF0) // 0xFFF  						try  						{                              							BitStream bits = new BitStream(buffer.Mid(i' 7).Data);    							// 12 bits sync header   							bits.ReadInt32(12);    							// 1 bit mpeg 2/4  							bits.ReadInt32(1);    							// 2 bits layer  							bits.ReadInt32(2);    							// 1 bit protection absent    							bits.ReadInt32(1);  						    							// 2 bits profile object type  							bits.ReadInt32(2);    							// 4 bits sampling frequency index                              							int samplerateindex = bits.ReadInt32(4);  							if(samplerateindex >= sample_rates.Length)  								return false;  							long samplerate = sample_rates[samplerateindex];    							// 1 bit private bit  							bits.ReadInt32(1);    							// 3 bits channel configuration  							int channelconfigindex = bits.ReadInt32(3);  							if (channelconfigindex >= channels.Length)  								return false;                                							// 4 copyright bits  							bits.ReadInt32(4);    							// 13 bits frame length  							long framelength = bits.ReadInt32(13); // double check framelength  								if (framelength < 7)  								return false;    							// 11 bits buffer fullness  							bits.ReadInt32(11);    							// 2 bits number of raw data blocks in frame  							int numberofframes = bits.ReadInt32(2) + 1;    							long numberofsamples = numberofframes * 1024;  							long bitrate = framelength * 8 * samplerate / numberofsamples;                                							header = new AudioHeader(channels[channelconfigindex]'  								(int)bitrate'  								(int)samplerate'  								(int)numberofsamples'  								numberofframes);                                							return true;  						}  						catch (CorruptFileException)  						{  						}    				position += File.BufferSize;  			} while (buffer.Count > 3 && (length < 0 || position < end));
Magic Number,TagLib.Aac,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aac\AudioHeader.cs,Find,The following statement contains a magic number: do  			{  				file.Seek(position + 3);  				buffer = buffer.Mid(buffer.Count - 3);  				buffer.Add(file.ReadBlock(  					(int)File.BufferSize));    				for (int i = 0; i < buffer.Count - 3 &&  					(length < 0 || position + i < end); i++)  					if (buffer[i] == 0xFF  						&& buffer[i+1] >= 0xF0) // 0xFFF  						try  						{                              							BitStream bits = new BitStream(buffer.Mid(i' 7).Data);    							// 12 bits sync header   							bits.ReadInt32(12);    							// 1 bit mpeg 2/4  							bits.ReadInt32(1);    							// 2 bits layer  							bits.ReadInt32(2);    							// 1 bit protection absent    							bits.ReadInt32(1);  						    							// 2 bits profile object type  							bits.ReadInt32(2);    							// 4 bits sampling frequency index                              							int samplerateindex = bits.ReadInt32(4);  							if(samplerateindex >= sample_rates.Length)  								return false;  							long samplerate = sample_rates[samplerateindex];    							// 1 bit private bit  							bits.ReadInt32(1);    							// 3 bits channel configuration  							int channelconfigindex = bits.ReadInt32(3);  							if (channelconfigindex >= channels.Length)  								return false;                                							// 4 copyright bits  							bits.ReadInt32(4);    							// 13 bits frame length  							long framelength = bits.ReadInt32(13); // double check framelength  								if (framelength < 7)  								return false;    							// 11 bits buffer fullness  							bits.ReadInt32(11);    							// 2 bits number of raw data blocks in frame  							int numberofframes = bits.ReadInt32(2) + 1;    							long numberofsamples = numberofframes * 1024;  							long bitrate = framelength * 8 * samplerate / numberofsamples;                                							header = new AudioHeader(channels[channelconfigindex]'  								(int)bitrate'  								(int)samplerate'  								(int)numberofsamples'  								numberofframes);                                							return true;  						}  						catch (CorruptFileException)  						{  						}    				position += File.BufferSize;  			} while (buffer.Count > 3 && (length < 0 || position < end));
Magic Number,TagLib.Aac,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aac\AudioHeader.cs,Find,The following statement contains a magic number: do  			{  				file.Seek(position + 3);  				buffer = buffer.Mid(buffer.Count - 3);  				buffer.Add(file.ReadBlock(  					(int)File.BufferSize));    				for (int i = 0; i < buffer.Count - 3 &&  					(length < 0 || position + i < end); i++)  					if (buffer[i] == 0xFF  						&& buffer[i+1] >= 0xF0) // 0xFFF  						try  						{                              							BitStream bits = new BitStream(buffer.Mid(i' 7).Data);    							// 12 bits sync header   							bits.ReadInt32(12);    							// 1 bit mpeg 2/4  							bits.ReadInt32(1);    							// 2 bits layer  							bits.ReadInt32(2);    							// 1 bit protection absent    							bits.ReadInt32(1);  						    							// 2 bits profile object type  							bits.ReadInt32(2);    							// 4 bits sampling frequency index                              							int samplerateindex = bits.ReadInt32(4);  							if(samplerateindex >= sample_rates.Length)  								return false;  							long samplerate = sample_rates[samplerateindex];    							// 1 bit private bit  							bits.ReadInt32(1);    							// 3 bits channel configuration  							int channelconfigindex = bits.ReadInt32(3);  							if (channelconfigindex >= channels.Length)  								return false;                                							// 4 copyright bits  							bits.ReadInt32(4);    							// 13 bits frame length  							long framelength = bits.ReadInt32(13); // double check framelength  								if (framelength < 7)  								return false;    							// 11 bits buffer fullness  							bits.ReadInt32(11);    							// 2 bits number of raw data blocks in frame  							int numberofframes = bits.ReadInt32(2) + 1;    							long numberofsamples = numberofframes * 1024;  							long bitrate = framelength * 8 * samplerate / numberofsamples;                                							header = new AudioHeader(channels[channelconfigindex]'  								(int)bitrate'  								(int)samplerate'  								(int)numberofsamples'  								numberofframes);                                							return true;  						}  						catch (CorruptFileException)  						{  						}    				position += File.BufferSize;  			} while (buffer.Count > 3 && (length < 0 || position < end));
Magic Number,TagLib.Aac,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aac\AudioHeader.cs,Find,The following statement contains a magic number: do  			{  				file.Seek(position + 3);  				buffer = buffer.Mid(buffer.Count - 3);  				buffer.Add(file.ReadBlock(  					(int)File.BufferSize));    				for (int i = 0; i < buffer.Count - 3 &&  					(length < 0 || position + i < end); i++)  					if (buffer[i] == 0xFF  						&& buffer[i+1] >= 0xF0) // 0xFFF  						try  						{                              							BitStream bits = new BitStream(buffer.Mid(i' 7).Data);    							// 12 bits sync header   							bits.ReadInt32(12);    							// 1 bit mpeg 2/4  							bits.ReadInt32(1);    							// 2 bits layer  							bits.ReadInt32(2);    							// 1 bit protection absent    							bits.ReadInt32(1);  						    							// 2 bits profile object type  							bits.ReadInt32(2);    							// 4 bits sampling frequency index                              							int samplerateindex = bits.ReadInt32(4);  							if(samplerateindex >= sample_rates.Length)  								return false;  							long samplerate = sample_rates[samplerateindex];    							// 1 bit private bit  							bits.ReadInt32(1);    							// 3 bits channel configuration  							int channelconfigindex = bits.ReadInt32(3);  							if (channelconfigindex >= channels.Length)  								return false;                                							// 4 copyright bits  							bits.ReadInt32(4);    							// 13 bits frame length  							long framelength = bits.ReadInt32(13); // double check framelength  								if (framelength < 7)  								return false;    							// 11 bits buffer fullness  							bits.ReadInt32(11);    							// 2 bits number of raw data blocks in frame  							int numberofframes = bits.ReadInt32(2) + 1;    							long numberofsamples = numberofframes * 1024;  							long bitrate = framelength * 8 * samplerate / numberofsamples;                                							header = new AudioHeader(channels[channelconfigindex]'  								(int)bitrate'  								(int)samplerate'  								(int)numberofsamples'  								numberofframes);                                							return true;  						}  						catch (CorruptFileException)  						{  						}    				position += File.BufferSize;  			} while (buffer.Count > 3 && (length < 0 || position < end));
Magic Number,TagLib.Aac,BitStream,C:\repos\mono_taglib-sharp\src\TagLib\Aac\BitStream.cs,BitStream,The following statement contains a magic number: Debug.Assert(buffer.Length == 7' "buffer.Length == 7"' "buffer size invalid");
Magic Number,TagLib.Aac,BitStream,C:\repos\mono_taglib-sharp\src\TagLib\Aac\BitStream.cs,BitStream,The following statement contains a magic number: if (buffer.Length != 7)  				throw new ArgumentException("Buffer size must be 7 bytes");
Magic Number,TagLib.Aac,BitStream,C:\repos\mono_taglib-sharp\src\TagLib\Aac\BitStream.cs,BitStream,The following statement contains a magic number: bits = new BitArray(buffer.Length * 8);
Magic Number,TagLib.Aac,BitStream,C:\repos\mono_taglib-sharp\src\TagLib\Aac\BitStream.cs,BitStream,The following statement contains a magic number: for (int i = 0; i < buffer.Length; i++)  			{  				for (int y = 0; y < 8; y++)  				{  					bits[i * 8 + y] = ((buffer[i] & (1 << (7 - y))) > 0);  				}  			}
Magic Number,TagLib.Aac,BitStream,C:\repos\mono_taglib-sharp\src\TagLib\Aac\BitStream.cs,BitStream,The following statement contains a magic number: for (int i = 0; i < buffer.Length; i++)  			{  				for (int y = 0; y < 8; y++)  				{  					bits[i * 8 + y] = ((buffer[i] & (1 << (7 - y))) > 0);  				}  			}
Magic Number,TagLib.Aac,BitStream,C:\repos\mono_taglib-sharp\src\TagLib\Aac\BitStream.cs,BitStream,The following statement contains a magic number: for (int i = 0; i < buffer.Length; i++)  			{  				for (int y = 0; y < 8; y++)  				{  					bits[i * 8 + y] = ((buffer[i] & (1 << (7 - y))) > 0);  				}  			}
Magic Number,TagLib.Aac,BitStream,C:\repos\mono_taglib-sharp\src\TagLib\Aac\BitStream.cs,ReadInt32,The following statement contains a magic number: Debug.Assert(numberOfBits <= 32' "numberOfBits <= 32");
Magic Number,TagLib.Aac,BitStream,C:\repos\mono_taglib-sharp\src\TagLib\Aac\BitStream.cs,ReadInt32,The following statement contains a magic number: if (numberOfBits > 32)  				throw new ArgumentException("Number of bits to read must be <= 32");
Magic Number,TagLib.Aiff,File,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\File.cs,Save,The following statement contains a magic number: try  			{  				ByteVector data = new ByteVector();    				// Add the ID3 chunk and ID32 tag to the vector  				if (tag != null)  				{  					ByteVector tag_data = tag.Render();  					if (tag_data.Count > 10)  					{  						if (tag_data.Count%2 == 1)  							tag_data.Add(0);    						data.Add("ID3 ");  						data.Add(ByteVector.FromUInt(  						         	(uint) tag_data.Count'  						         	true));  						data.Add(tag_data);  					}  				}    				// Read the file to determine the current AIFF  				// size and the area tagging is in.  				uint aiff_size;  				long tag_start' tag_end;  				Read(false' ReadStyle.None' out aiff_size'  				     out tag_start' out tag_end);    				// If tagging info cannot be found' place it at  				// the end of the file.  				if (tag_start < 12 || tag_end < tag_start)  					tag_start = tag_end = Length;    				int length = (int) (tag_end - tag_start + 8);    				// Insert the tagging data.  				Insert(data' tag_start' length);    				// If the data size changed update the aiff size.  				if (data.Count - length != 0 &&  				    tag_start <= aiff_size)  				{  					// Depending' if a Tag has been added or removed'   					// the length needs to be adjusted  					if (tag == null)  					{  						length -= 16;  					}  					else  					{  						length -= 8;  					}    					Insert(ByteVector.FromUInt((uint)  					                           (aiff_size + data.Count - length)'  					                           true)' 4' 4);  				}  				// Update the tag types.  				TagTypesOnDisk = TagTypes;  			}  			finally  			{  				Mode = AccessMode.Closed;  			}
Magic Number,TagLib.Aiff,File,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\File.cs,Save,The following statement contains a magic number: try  			{  				ByteVector data = new ByteVector();    				// Add the ID3 chunk and ID32 tag to the vector  				if (tag != null)  				{  					ByteVector tag_data = tag.Render();  					if (tag_data.Count > 10)  					{  						if (tag_data.Count%2 == 1)  							tag_data.Add(0);    						data.Add("ID3 ");  						data.Add(ByteVector.FromUInt(  						         	(uint) tag_data.Count'  						         	true));  						data.Add(tag_data);  					}  				}    				// Read the file to determine the current AIFF  				// size and the area tagging is in.  				uint aiff_size;  				long tag_start' tag_end;  				Read(false' ReadStyle.None' out aiff_size'  				     out tag_start' out tag_end);    				// If tagging info cannot be found' place it at  				// the end of the file.  				if (tag_start < 12 || tag_end < tag_start)  					tag_start = tag_end = Length;    				int length = (int) (tag_end - tag_start + 8);    				// Insert the tagging data.  				Insert(data' tag_start' length);    				// If the data size changed update the aiff size.  				if (data.Count - length != 0 &&  				    tag_start <= aiff_size)  				{  					// Depending' if a Tag has been added or removed'   					// the length needs to be adjusted  					if (tag == null)  					{  						length -= 16;  					}  					else  					{  						length -= 8;  					}    					Insert(ByteVector.FromUInt((uint)  					                           (aiff_size + data.Count - length)'  					                           true)' 4' 4);  				}  				// Update the tag types.  				TagTypesOnDisk = TagTypes;  			}  			finally  			{  				Mode = AccessMode.Closed;  			}
Magic Number,TagLib.Aiff,File,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\File.cs,Save,The following statement contains a magic number: try  			{  				ByteVector data = new ByteVector();    				// Add the ID3 chunk and ID32 tag to the vector  				if (tag != null)  				{  					ByteVector tag_data = tag.Render();  					if (tag_data.Count > 10)  					{  						if (tag_data.Count%2 == 1)  							tag_data.Add(0);    						data.Add("ID3 ");  						data.Add(ByteVector.FromUInt(  						         	(uint) tag_data.Count'  						         	true));  						data.Add(tag_data);  					}  				}    				// Read the file to determine the current AIFF  				// size and the area tagging is in.  				uint aiff_size;  				long tag_start' tag_end;  				Read(false' ReadStyle.None' out aiff_size'  				     out tag_start' out tag_end);    				// If tagging info cannot be found' place it at  				// the end of the file.  				if (tag_start < 12 || tag_end < tag_start)  					tag_start = tag_end = Length;    				int length = (int) (tag_end - tag_start + 8);    				// Insert the tagging data.  				Insert(data' tag_start' length);    				// If the data size changed update the aiff size.  				if (data.Count - length != 0 &&  				    tag_start <= aiff_size)  				{  					// Depending' if a Tag has been added or removed'   					// the length needs to be adjusted  					if (tag == null)  					{  						length -= 16;  					}  					else  					{  						length -= 8;  					}    					Insert(ByteVector.FromUInt((uint)  					                           (aiff_size + data.Count - length)'  					                           true)' 4' 4);  				}  				// Update the tag types.  				TagTypesOnDisk = TagTypes;  			}  			finally  			{  				Mode = AccessMode.Closed;  			}
Magic Number,TagLib.Aiff,File,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\File.cs,Save,The following statement contains a magic number: try  			{  				ByteVector data = new ByteVector();    				// Add the ID3 chunk and ID32 tag to the vector  				if (tag != null)  				{  					ByteVector tag_data = tag.Render();  					if (tag_data.Count > 10)  					{  						if (tag_data.Count%2 == 1)  							tag_data.Add(0);    						data.Add("ID3 ");  						data.Add(ByteVector.FromUInt(  						         	(uint) tag_data.Count'  						         	true));  						data.Add(tag_data);  					}  				}    				// Read the file to determine the current AIFF  				// size and the area tagging is in.  				uint aiff_size;  				long tag_start' tag_end;  				Read(false' ReadStyle.None' out aiff_size'  				     out tag_start' out tag_end);    				// If tagging info cannot be found' place it at  				// the end of the file.  				if (tag_start < 12 || tag_end < tag_start)  					tag_start = tag_end = Length;    				int length = (int) (tag_end - tag_start + 8);    				// Insert the tagging data.  				Insert(data' tag_start' length);    				// If the data size changed update the aiff size.  				if (data.Count - length != 0 &&  				    tag_start <= aiff_size)  				{  					// Depending' if a Tag has been added or removed'   					// the length needs to be adjusted  					if (tag == null)  					{  						length -= 16;  					}  					else  					{  						length -= 8;  					}    					Insert(ByteVector.FromUInt((uint)  					                           (aiff_size + data.Count - length)'  					                           true)' 4' 4);  				}  				// Update the tag types.  				TagTypesOnDisk = TagTypes;  			}  			finally  			{  				Mode = AccessMode.Closed;  			}
Magic Number,TagLib.Aiff,File,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\File.cs,Save,The following statement contains a magic number: try  			{  				ByteVector data = new ByteVector();    				// Add the ID3 chunk and ID32 tag to the vector  				if (tag != null)  				{  					ByteVector tag_data = tag.Render();  					if (tag_data.Count > 10)  					{  						if (tag_data.Count%2 == 1)  							tag_data.Add(0);    						data.Add("ID3 ");  						data.Add(ByteVector.FromUInt(  						         	(uint) tag_data.Count'  						         	true));  						data.Add(tag_data);  					}  				}    				// Read the file to determine the current AIFF  				// size and the area tagging is in.  				uint aiff_size;  				long tag_start' tag_end;  				Read(false' ReadStyle.None' out aiff_size'  				     out tag_start' out tag_end);    				// If tagging info cannot be found' place it at  				// the end of the file.  				if (tag_start < 12 || tag_end < tag_start)  					tag_start = tag_end = Length;    				int length = (int) (tag_end - tag_start + 8);    				// Insert the tagging data.  				Insert(data' tag_start' length);    				// If the data size changed update the aiff size.  				if (data.Count - length != 0 &&  				    tag_start <= aiff_size)  				{  					// Depending' if a Tag has been added or removed'   					// the length needs to be adjusted  					if (tag == null)  					{  						length -= 16;  					}  					else  					{  						length -= 8;  					}    					Insert(ByteVector.FromUInt((uint)  					                           (aiff_size + data.Count - length)'  					                           true)' 4' 4);  				}  				// Update the tag types.  				TagTypesOnDisk = TagTypes;  			}  			finally  			{  				Mode = AccessMode.Closed;  			}
Magic Number,TagLib.Aiff,File,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\File.cs,Save,The following statement contains a magic number: try  			{  				ByteVector data = new ByteVector();    				// Add the ID3 chunk and ID32 tag to the vector  				if (tag != null)  				{  					ByteVector tag_data = tag.Render();  					if (tag_data.Count > 10)  					{  						if (tag_data.Count%2 == 1)  							tag_data.Add(0);    						data.Add("ID3 ");  						data.Add(ByteVector.FromUInt(  						         	(uint) tag_data.Count'  						         	true));  						data.Add(tag_data);  					}  				}    				// Read the file to determine the current AIFF  				// size and the area tagging is in.  				uint aiff_size;  				long tag_start' tag_end;  				Read(false' ReadStyle.None' out aiff_size'  				     out tag_start' out tag_end);    				// If tagging info cannot be found' place it at  				// the end of the file.  				if (tag_start < 12 || tag_end < tag_start)  					tag_start = tag_end = Length;    				int length = (int) (tag_end - tag_start + 8);    				// Insert the tagging data.  				Insert(data' tag_start' length);    				// If the data size changed update the aiff size.  				if (data.Count - length != 0 &&  				    tag_start <= aiff_size)  				{  					// Depending' if a Tag has been added or removed'   					// the length needs to be adjusted  					if (tag == null)  					{  						length -= 16;  					}  					else  					{  						length -= 8;  					}    					Insert(ByteVector.FromUInt((uint)  					                           (aiff_size + data.Count - length)'  					                           true)' 4' 4);  				}  				// Update the tag types.  				TagTypesOnDisk = TagTypes;  			}  			finally  			{  				Mode = AccessMode.Closed;  			}
Magic Number,TagLib.Aiff,File,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\File.cs,Save,The following statement contains a magic number: try  			{  				ByteVector data = new ByteVector();    				// Add the ID3 chunk and ID32 tag to the vector  				if (tag != null)  				{  					ByteVector tag_data = tag.Render();  					if (tag_data.Count > 10)  					{  						if (tag_data.Count%2 == 1)  							tag_data.Add(0);    						data.Add("ID3 ");  						data.Add(ByteVector.FromUInt(  						         	(uint) tag_data.Count'  						         	true));  						data.Add(tag_data);  					}  				}    				// Read the file to determine the current AIFF  				// size and the area tagging is in.  				uint aiff_size;  				long tag_start' tag_end;  				Read(false' ReadStyle.None' out aiff_size'  				     out tag_start' out tag_end);    				// If tagging info cannot be found' place it at  				// the end of the file.  				if (tag_start < 12 || tag_end < tag_start)  					tag_start = tag_end = Length;    				int length = (int) (tag_end - tag_start + 8);    				// Insert the tagging data.  				Insert(data' tag_start' length);    				// If the data size changed update the aiff size.  				if (data.Count - length != 0 &&  				    tag_start <= aiff_size)  				{  					// Depending' if a Tag has been added or removed'   					// the length needs to be adjusted  					if (tag == null)  					{  						length -= 16;  					}  					else  					{  						length -= 8;  					}    					Insert(ByteVector.FromUInt((uint)  					                           (aiff_size + data.Count - length)'  					                           true)' 4' 4);  				}  				// Update the tag types.  				TagTypesOnDisk = TagTypes;  			}  			finally  			{  				Mode = AccessMode.Closed;  			}
Magic Number,TagLib.Aiff,File,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\File.cs,Save,The following statement contains a magic number: try  			{  				ByteVector data = new ByteVector();    				// Add the ID3 chunk and ID32 tag to the vector  				if (tag != null)  				{  					ByteVector tag_data = tag.Render();  					if (tag_data.Count > 10)  					{  						if (tag_data.Count%2 == 1)  							tag_data.Add(0);    						data.Add("ID3 ");  						data.Add(ByteVector.FromUInt(  						         	(uint) tag_data.Count'  						         	true));  						data.Add(tag_data);  					}  				}    				// Read the file to determine the current AIFF  				// size and the area tagging is in.  				uint aiff_size;  				long tag_start' tag_end;  				Read(false' ReadStyle.None' out aiff_size'  				     out tag_start' out tag_end);    				// If tagging info cannot be found' place it at  				// the end of the file.  				if (tag_start < 12 || tag_end < tag_start)  					tag_start = tag_end = Length;    				int length = (int) (tag_end - tag_start + 8);    				// Insert the tagging data.  				Insert(data' tag_start' length);    				// If the data size changed update the aiff size.  				if (data.Count - length != 0 &&  				    tag_start <= aiff_size)  				{  					// Depending' if a Tag has been added or removed'   					// the length needs to be adjusted  					if (tag == null)  					{  						length -= 16;  					}  					else  					{  						length -= 8;  					}    					Insert(ByteVector.FromUInt((uint)  					                           (aiff_size + data.Count - length)'  					                           true)' 4' 4);  				}  				// Update the tag types.  				TagTypesOnDisk = TagTypes;  			}  			finally  			{  				Mode = AccessMode.Closed;  			}
Magic Number,TagLib.Aiff,File,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\File.cs,GetTag,The following statement contains a magic number: switch (type)  			{  				case TagTypes.Id3v2:  					if (tag == null && create)  					{  						tag = new Id3v2.Tag();  						tag.Version = 2;  					}    					id32_tag = tag;  					break;  			}
Magic Number,TagLib.Aiff,File,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\File.cs,FindChunk,The following statement contains a magic number: try  			{  				// Start at the given position  				Seek(startPos);    				// While not eof  				while (Tell < Length)  				{  					// Read 4-byte chunk name  					ByteVector chunkHeader = ReadBlock(4);    					if (chunkHeader == chunkName)  					{  						// We found a matching chunk' return the position  						// of the header start  						return Tell - 4;  					}  					else  					{  						// This chunk is not the one we are looking for  						// Continue the search' seeking over the chunk  						uint chunkSize = ReadBlock(4).ToUInt();  						// Seek forward "chunkSize" bytes  						Seek(chunkSize' System.IO.SeekOrigin.Current);  					}  				}    				// We did not find the chunk  				return -1;  			}  			finally  			{  				Seek(initialPos);  			}
Magic Number,TagLib.Aiff,File,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\File.cs,FindChunk,The following statement contains a magic number: try  			{  				// Start at the given position  				Seek(startPos);    				// While not eof  				while (Tell < Length)  				{  					// Read 4-byte chunk name  					ByteVector chunkHeader = ReadBlock(4);    					if (chunkHeader == chunkName)  					{  						// We found a matching chunk' return the position  						// of the header start  						return Tell - 4;  					}  					else  					{  						// This chunk is not the one we are looking for  						// Continue the search' seeking over the chunk  						uint chunkSize = ReadBlock(4).ToUInt();  						// Seek forward "chunkSize" bytes  						Seek(chunkSize' System.IO.SeekOrigin.Current);  					}  				}    				// We did not find the chunk  				return -1;  			}  			finally  			{  				Seek(initialPos);  			}
Magic Number,TagLib.Aiff,File,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\File.cs,FindChunk,The following statement contains a magic number: try  			{  				// Start at the given position  				Seek(startPos);    				// While not eof  				while (Tell < Length)  				{  					// Read 4-byte chunk name  					ByteVector chunkHeader = ReadBlock(4);    					if (chunkHeader == chunkName)  					{  						// We found a matching chunk' return the position  						// of the header start  						return Tell - 4;  					}  					else  					{  						// This chunk is not the one we are looking for  						// Continue the search' seeking over the chunk  						uint chunkSize = ReadBlock(4).ToUInt();  						// Seek forward "chunkSize" bytes  						Seek(chunkSize' System.IO.SeekOrigin.Current);  					}  				}    				// We did not find the chunk  				return -1;  			}  			finally  			{  				Seek(initialPos);  			}
Magic Number,TagLib.Aiff,File,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\File.cs,Read,The following statement contains a magic number: if (ReadBlock(4) != FileIdentifier)  				throw new CorruptFileException(  					"File does not begin with AIFF identifier");
Magic Number,TagLib.Aiff,File,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\File.cs,Read,The following statement contains a magic number: aiff_size = ReadBlock(4).ToUInt(true);
Magic Number,TagLib.Aiff,File,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\File.cs,Read,The following statement contains a magic number: if (ReadBlock(4) != AIFFFormType)  				throw new CorruptFileException(  					"File form type is not AIFF");
Magic Number,TagLib.Aiff,File,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\File.cs,Read,The following statement contains a magic number: Seek(sound_chunk_pos + 4);
Magic Number,TagLib.Aiff,File,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\File.cs,Read,The following statement contains a magic number: if (id3_chunk_pos > -1)  			{  				if (read_tags && tag == null)  				{  					tag = new Id3v2.Tag(this'  					                    id3_chunk_pos + 8);  				}    				// Get the length of the tag out of the ID3 chunk  				Seek(id3_chunk_pos + 4);  				uint tag_size = ReadBlock(4).ToUInt(true) + 8;    				tag_start = InvariantStartPosition = id3_chunk_pos;  				tag_end = InvariantEndPosition = tag_start + tag_size;  			}
Magic Number,TagLib.Aiff,File,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\File.cs,Read,The following statement contains a magic number: if (id3_chunk_pos > -1)  			{  				if (read_tags && tag == null)  				{  					tag = new Id3v2.Tag(this'  					                    id3_chunk_pos + 8);  				}    				// Get the length of the tag out of the ID3 chunk  				Seek(id3_chunk_pos + 4);  				uint tag_size = ReadBlock(4).ToUInt(true) + 8;    				tag_start = InvariantStartPosition = id3_chunk_pos;  				tag_end = InvariantEndPosition = tag_start + tag_size;  			}
Magic Number,TagLib.Aiff,File,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\File.cs,Read,The following statement contains a magic number: if (id3_chunk_pos > -1)  			{  				if (read_tags && tag == null)  				{  					tag = new Id3v2.Tag(this'  					                    id3_chunk_pos + 8);  				}    				// Get the length of the tag out of the ID3 chunk  				Seek(id3_chunk_pos + 4);  				uint tag_size = ReadBlock(4).ToUInt(true) + 8;    				tag_start = InvariantStartPosition = id3_chunk_pos;  				tag_end = InvariantEndPosition = tag_start + tag_size;  			}
Magic Number,TagLib.Aiff,File,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\File.cs,Read,The following statement contains a magic number: if (id3_chunk_pos > -1)  			{  				if (read_tags && tag == null)  				{  					tag = new Id3v2.Tag(this'  					                    id3_chunk_pos + 8);  				}    				// Get the length of the tag out of the ID3 chunk  				Seek(id3_chunk_pos + 4);  				uint tag_size = ReadBlock(4).ToUInt(true) + 8;    				tag_start = InvariantStartPosition = id3_chunk_pos;  				tag_end = InvariantEndPosition = tag_start + tag_size;  			}
Magic Number,TagLib.Aiff,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\StreamHeader.cs,StreamHeader,The following statement contains a magic number: channels = data.Mid(8' 2).ToUShort(true);
Magic Number,TagLib.Aiff,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\StreamHeader.cs,StreamHeader,The following statement contains a magic number: channels = data.Mid(8' 2).ToUShort(true);
Magic Number,TagLib.Aiff,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\StreamHeader.cs,StreamHeader,The following statement contains a magic number: total_frames = data.Mid(10' 4).ToULong(true);
Magic Number,TagLib.Aiff,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\StreamHeader.cs,StreamHeader,The following statement contains a magic number: total_frames = data.Mid(10' 4).ToULong(true);
Magic Number,TagLib.Aiff,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\StreamHeader.cs,StreamHeader,The following statement contains a magic number: bits_per_sample = data.Mid(14' 2).ToUShort(true);
Magic Number,TagLib.Aiff,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\StreamHeader.cs,StreamHeader,The following statement contains a magic number: bits_per_sample = data.Mid(14' 2).ToUShort(true);
Magic Number,TagLib.Aiff,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\StreamHeader.cs,StreamHeader,The following statement contains a magic number: ByteVector sample_rate_indicator = data.Mid(17' 1);
Magic Number,TagLib.Aiff,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\StreamHeader.cs,StreamHeader,The following statement contains a magic number: ulong sample_rate_tmp = data.Mid(18' 2).ToULong(true);
Magic Number,TagLib.Aiff,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\StreamHeader.cs,StreamHeader,The following statement contains a magic number: ulong sample_rate_tmp = data.Mid(18' 2).ToULong(true);
Magic Number,TagLib.Aiff,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\StreamHeader.cs,StreamHeader,The following statement contains a magic number: sample_rate = 44100;
Magic Number,TagLib.Aiff,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\StreamHeader.cs,StreamHeader,The following statement contains a magic number: switch (sample_rate_tmp)  			{  				case 44100:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 44100;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22050;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11025;  					}  					break;    				case 48000:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 48000;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 24000;  					}  					break;    				case 64000:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 32000;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 16000;  					}  					else if (sample_rate_indicator == 0x0B)  					{  						sample_rate = 8000;  					}  					break;    				case 44510:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22255;  					}  					break;    				case 44508:  					if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11127;  					}  					break;  			}
Magic Number,TagLib.Aiff,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\StreamHeader.cs,StreamHeader,The following statement contains a magic number: switch (sample_rate_tmp)  			{  				case 44100:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 44100;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22050;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11025;  					}  					break;    				case 48000:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 48000;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 24000;  					}  					break;    				case 64000:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 32000;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 16000;  					}  					else if (sample_rate_indicator == 0x0B)  					{  						sample_rate = 8000;  					}  					break;    				case 44510:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22255;  					}  					break;    				case 44508:  					if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11127;  					}  					break;  			}
Magic Number,TagLib.Aiff,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\StreamHeader.cs,StreamHeader,The following statement contains a magic number: switch (sample_rate_tmp)  			{  				case 44100:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 44100;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22050;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11025;  					}  					break;    				case 48000:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 48000;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 24000;  					}  					break;    				case 64000:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 32000;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 16000;  					}  					else if (sample_rate_indicator == 0x0B)  					{  						sample_rate = 8000;  					}  					break;    				case 44510:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22255;  					}  					break;    				case 44508:  					if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11127;  					}  					break;  			}
Magic Number,TagLib.Aiff,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\StreamHeader.cs,StreamHeader,The following statement contains a magic number: switch (sample_rate_tmp)  			{  				case 44100:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 44100;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22050;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11025;  					}  					break;    				case 48000:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 48000;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 24000;  					}  					break;    				case 64000:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 32000;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 16000;  					}  					else if (sample_rate_indicator == 0x0B)  					{  						sample_rate = 8000;  					}  					break;    				case 44510:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22255;  					}  					break;    				case 44508:  					if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11127;  					}  					break;  			}
Magic Number,TagLib.Aiff,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\StreamHeader.cs,StreamHeader,The following statement contains a magic number: switch (sample_rate_tmp)  			{  				case 44100:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 44100;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22050;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11025;  					}  					break;    				case 48000:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 48000;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 24000;  					}  					break;    				case 64000:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 32000;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 16000;  					}  					else if (sample_rate_indicator == 0x0B)  					{  						sample_rate = 8000;  					}  					break;    				case 44510:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22255;  					}  					break;    				case 44508:  					if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11127;  					}  					break;  			}
Magic Number,TagLib.Aiff,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\StreamHeader.cs,StreamHeader,The following statement contains a magic number: switch (sample_rate_tmp)  			{  				case 44100:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 44100;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22050;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11025;  					}  					break;    				case 48000:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 48000;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 24000;  					}  					break;    				case 64000:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 32000;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 16000;  					}  					else if (sample_rate_indicator == 0x0B)  					{  						sample_rate = 8000;  					}  					break;    				case 44510:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22255;  					}  					break;    				case 44508:  					if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11127;  					}  					break;  			}
Magic Number,TagLib.Aiff,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\StreamHeader.cs,StreamHeader,The following statement contains a magic number: switch (sample_rate_tmp)  			{  				case 44100:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 44100;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22050;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11025;  					}  					break;    				case 48000:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 48000;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 24000;  					}  					break;    				case 64000:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 32000;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 16000;  					}  					else if (sample_rate_indicator == 0x0B)  					{  						sample_rate = 8000;  					}  					break;    				case 44510:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22255;  					}  					break;    				case 44508:  					if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11127;  					}  					break;  			}
Magic Number,TagLib.Aiff,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\StreamHeader.cs,StreamHeader,The following statement contains a magic number: switch (sample_rate_tmp)  			{  				case 44100:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 44100;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22050;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11025;  					}  					break;    				case 48000:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 48000;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 24000;  					}  					break;    				case 64000:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 32000;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 16000;  					}  					else if (sample_rate_indicator == 0x0B)  					{  						sample_rate = 8000;  					}  					break;    				case 44510:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22255;  					}  					break;    				case 44508:  					if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11127;  					}  					break;  			}
Magic Number,TagLib.Aiff,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\StreamHeader.cs,StreamHeader,The following statement contains a magic number: switch (sample_rate_tmp)  			{  				case 44100:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 44100;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22050;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11025;  					}  					break;    				case 48000:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 48000;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 24000;  					}  					break;    				case 64000:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 32000;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 16000;  					}  					else if (sample_rate_indicator == 0x0B)  					{  						sample_rate = 8000;  					}  					break;    				case 44510:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22255;  					}  					break;    				case 44508:  					if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11127;  					}  					break;  			}
Magic Number,TagLib.Aiff,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\StreamHeader.cs,StreamHeader,The following statement contains a magic number: switch (sample_rate_tmp)  			{  				case 44100:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 44100;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22050;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11025;  					}  					break;    				case 48000:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 48000;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 24000;  					}  					break;    				case 64000:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 32000;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 16000;  					}  					else if (sample_rate_indicator == 0x0B)  					{  						sample_rate = 8000;  					}  					break;    				case 44510:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22255;  					}  					break;    				case 44508:  					if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11127;  					}  					break;  			}
Magic Number,TagLib.Aiff,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\StreamHeader.cs,StreamHeader,The following statement contains a magic number: switch (sample_rate_tmp)  			{  				case 44100:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 44100;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22050;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11025;  					}  					break;    				case 48000:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 48000;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 24000;  					}  					break;    				case 64000:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 32000;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 16000;  					}  					else if (sample_rate_indicator == 0x0B)  					{  						sample_rate = 8000;  					}  					break;    				case 44510:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22255;  					}  					break;    				case 44508:  					if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11127;  					}  					break;  			}
Magic Number,TagLib.Aiff,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\StreamHeader.cs,StreamHeader,The following statement contains a magic number: switch (sample_rate_tmp)  			{  				case 44100:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 44100;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22050;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11025;  					}  					break;    				case 48000:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 48000;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 24000;  					}  					break;    				case 64000:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 32000;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 16000;  					}  					else if (sample_rate_indicator == 0x0B)  					{  						sample_rate = 8000;  					}  					break;    				case 44510:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22255;  					}  					break;    				case 44508:  					if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11127;  					}  					break;  			}
Magic Number,TagLib.Aiff,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\StreamHeader.cs,StreamHeader,The following statement contains a magic number: switch (sample_rate_tmp)  			{  				case 44100:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 44100;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22050;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11025;  					}  					break;    				case 48000:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 48000;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 24000;  					}  					break;    				case 64000:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 32000;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 16000;  					}  					else if (sample_rate_indicator == 0x0B)  					{  						sample_rate = 8000;  					}  					break;    				case 44510:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22255;  					}  					break;    				case 44508:  					if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11127;  					}  					break;  			}
Magic Number,TagLib.Aiff,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\StreamHeader.cs,StreamHeader,The following statement contains a magic number: switch (sample_rate_tmp)  			{  				case 44100:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 44100;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22050;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11025;  					}  					break;    				case 48000:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 48000;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 24000;  					}  					break;    				case 64000:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 32000;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 16000;  					}  					else if (sample_rate_indicator == 0x0B)  					{  						sample_rate = 8000;  					}  					break;    				case 44510:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22255;  					}  					break;    				case 44508:  					if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11127;  					}  					break;  			}
Magic Number,TagLib.Aiff,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\StreamHeader.cs,StreamHeader,The following statement contains a magic number: switch (sample_rate_tmp)  			{  				case 44100:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 44100;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22050;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11025;  					}  					break;    				case 48000:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 48000;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 24000;  					}  					break;    				case 64000:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 32000;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 16000;  					}  					else if (sample_rate_indicator == 0x0B)  					{  						sample_rate = 8000;  					}  					break;    				case 44510:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22255;  					}  					break;    				case 44508:  					if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11127;  					}  					break;  			}
Magic Number,TagLib.Ape,Footer,C:\repos\mono_taglib-sharp\src\TagLib\Ape\Footer.cs,Footer,The following statement contains a magic number: version = data.Mid (8' 4).ToUInt (false);
Magic Number,TagLib.Ape,Footer,C:\repos\mono_taglib-sharp\src\TagLib\Ape\Footer.cs,Footer,The following statement contains a magic number: version = data.Mid (8' 4).ToUInt (false);
Magic Number,TagLib.Ape,Footer,C:\repos\mono_taglib-sharp\src\TagLib\Ape\Footer.cs,Footer,The following statement contains a magic number: tag_size = data.Mid (12' 4).ToUInt (false);
Magic Number,TagLib.Ape,Footer,C:\repos\mono_taglib-sharp\src\TagLib\Ape\Footer.cs,Footer,The following statement contains a magic number: tag_size = data.Mid (12' 4).ToUInt (false);
Magic Number,TagLib.Ape,Footer,C:\repos\mono_taglib-sharp\src\TagLib\Ape\Footer.cs,Footer,The following statement contains a magic number: item_count = data.Mid (16' 4).ToUInt (false);
Magic Number,TagLib.Ape,Footer,C:\repos\mono_taglib-sharp\src\TagLib\Ape\Footer.cs,Footer,The following statement contains a magic number: item_count = data.Mid (16' 4).ToUInt (false);
Magic Number,TagLib.Ape,Footer,C:\repos\mono_taglib-sharp\src\TagLib\Ape\Footer.cs,Footer,The following statement contains a magic number: flags = (FooterFlags) data.Mid (20' 4).ToUInt (false);
Magic Number,TagLib.Ape,Footer,C:\repos\mono_taglib-sharp\src\TagLib\Ape\Footer.cs,Footer,The following statement contains a magic number: flags = (FooterFlags) data.Mid (20' 4).ToUInt (false);
Magic Number,TagLib.Ape,Footer,C:\repos\mono_taglib-sharp\src\TagLib\Ape\Footer.cs,Render,The following statement contains a magic number: v.Add (ByteVector.FromUInt (2000' false));
Magic Number,TagLib.Ape,Item,C:\repos\mono_taglib-sharp\src\TagLib\Ape\Item.cs,Parse,The following statement contains a magic number: if(data.Count < offset + 11)  				throw new CorruptFileException (  					"Not enough data for APE Item");
Magic Number,TagLib.Ape,Item,C:\repos\mono_taglib-sharp\src\TagLib\Ape\Item.cs,Parse,The following statement contains a magic number: uint value_length = data.Mid (offset' 4).ToUInt (false);
Magic Number,TagLib.Ape,Item,C:\repos\mono_taglib-sharp\src\TagLib\Ape\Item.cs,Parse,The following statement contains a magic number: uint flags = data.Mid (offset + 4' 4).ToUInt (false);
Magic Number,TagLib.Ape,Item,C:\repos\mono_taglib-sharp\src\TagLib\Ape\Item.cs,Parse,The following statement contains a magic number: uint flags = data.Mid (offset + 4' 4).ToUInt (false);
Magic Number,TagLib.Ape,Item,C:\repos\mono_taglib-sharp\src\TagLib\Ape\Item.cs,Parse,The following statement contains a magic number: Type = (ItemType) ((flags >> 1) & 3);
Magic Number,TagLib.Ape,Item,C:\repos\mono_taglib-sharp\src\TagLib\Ape\Item.cs,Parse,The following statement contains a magic number: int pos = data.Find (ByteVector.TextDelimiter (  				StringType.UTF8)' offset + 8);
Magic Number,TagLib.Ape,Item,C:\repos\mono_taglib-sharp\src\TagLib\Ape\Item.cs,Parse,The following statement contains a magic number: key = data.ToString (StringType.UTF8'  				offset + 8' pos - offset - 8);
Magic Number,TagLib.Ape,Item,C:\repos\mono_taglib-sharp\src\TagLib\Ape\Item.cs,Parse,The following statement contains a magic number: key = data.ToString (StringType.UTF8'  				offset + 8' pos - offset - 8);
Magic Number,TagLib.Ape,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ape\StreamHeader.cs,StreamHeader,The following statement contains a magic number: version = data.Mid (4' 2).ToUShort(false);
Magic Number,TagLib.Ape,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ape\StreamHeader.cs,StreamHeader,The following statement contains a magic number: version = data.Mid (4' 2).ToUShort(false);
Magic Number,TagLib.Ape,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ape\StreamHeader.cs,StreamHeader,The following statement contains a magic number: compression_level = (CompressionLevel) data.Mid(52' 2) 				.ToUShort(false);
Magic Number,TagLib.Ape,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ape\StreamHeader.cs,StreamHeader,The following statement contains a magic number: compression_level = (CompressionLevel) data.Mid(52' 2) 				.ToUShort(false);
Magic Number,TagLib.Ape,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ape\StreamHeader.cs,StreamHeader,The following statement contains a magic number: blocks_per_frame = data.Mid(56' 4).ToUInt(false);
Magic Number,TagLib.Ape,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ape\StreamHeader.cs,StreamHeader,The following statement contains a magic number: blocks_per_frame = data.Mid(56' 4).ToUInt(false);
Magic Number,TagLib.Ape,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ape\StreamHeader.cs,StreamHeader,The following statement contains a magic number: final_frame_blocks = data.Mid(60' 4).ToUInt(false);
Magic Number,TagLib.Ape,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ape\StreamHeader.cs,StreamHeader,The following statement contains a magic number: final_frame_blocks = data.Mid(60' 4).ToUInt(false);
Magic Number,TagLib.Ape,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ape\StreamHeader.cs,StreamHeader,The following statement contains a magic number: total_frames = data.Mid(64' 4).ToUInt(false);
Magic Number,TagLib.Ape,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ape\StreamHeader.cs,StreamHeader,The following statement contains a magic number: total_frames = data.Mid(64' 4).ToUInt(false);
Magic Number,TagLib.Ape,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ape\StreamHeader.cs,StreamHeader,The following statement contains a magic number: bits_per_sample = data.Mid(68' 2).ToUShort(false);
Magic Number,TagLib.Ape,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ape\StreamHeader.cs,StreamHeader,The following statement contains a magic number: bits_per_sample = data.Mid(68' 2).ToUShort(false);
Magic Number,TagLib.Ape,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ape\StreamHeader.cs,StreamHeader,The following statement contains a magic number: channels = data.Mid(70' 2).ToUShort(false);
Magic Number,TagLib.Ape,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ape\StreamHeader.cs,StreamHeader,The following statement contains a magic number: channels = data.Mid(70' 2).ToUShort(false);
Magic Number,TagLib.Ape,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ape\StreamHeader.cs,StreamHeader,The following statement contains a magic number: sample_rate = data.Mid(72' 4).ToUInt(false);
Magic Number,TagLib.Ape,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ape\StreamHeader.cs,StreamHeader,The following statement contains a magic number: sample_rate = data.Mid(72' 4).ToUInt(false);
Magic Number,TagLib.Ape,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Ape\Tag.cs,Parse,The following statement contains a magic number: try {  				// 11 bytes is the minimum size for an APE item  				for (uint i = 0; i < footer.ItemCount &&  					pos <= data.Count - 11; i++) {  					Item item = new Item (data' pos);  					SetItem (item);  					pos += item.Size;  				}  			} catch (CorruptFileException) {  				// A corrupt item was encountered' considered  				// the tag finished with what has been read.  			}
Magic Number,TagLib.Ape,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Ape\Tag.cs,GetItemAsUInt32,The following statement contains a magic number: string [] values = text.Split (new char [] {'/'}'  				index + 2);
Magic Number,TagLib.Asf,ContentDescriptionObject,C:\repos\mono_taglib-sharp\src\TagLib\Asf\ContentDescriptionObject.cs,ContentDescriptionObject,The following statement contains a magic number: if (OriginalSize < 34)  				throw new CorruptFileException (  					"Object size too small.");
Magic Number,TagLib.Asf,ExtendedContentDescriptionObject,C:\repos\mono_taglib-sharp\src\TagLib\Asf\ExtendedContentDescriptionObject.cs,ExtendedContentDescriptionObject,The following statement contains a magic number: if (OriginalSize < 26)  				throw new CorruptFileException (  					"Object size too small.");
Magic Number,TagLib.Asf,File,C:\repos\mono_taglib-sharp\src\TagLib\Asf\File.cs,ReadWord,The following statement contains a magic number: return ReadBlock (2).ToUShort (false);
Magic Number,TagLib.Asf,File,C:\repos\mono_taglib-sharp\src\TagLib\Asf\File.cs,ReadDWord,The following statement contains a magic number: return ReadBlock (4).ToUInt (false);
Magic Number,TagLib.Asf,File,C:\repos\mono_taglib-sharp\src\TagLib\Asf\File.cs,ReadQWord,The following statement contains a magic number: return ReadBlock (8).ToULong (false);
Magic Number,TagLib.Asf,File,C:\repos\mono_taglib-sharp\src\TagLib\Asf\File.cs,ReadGuid,The following statement contains a magic number: return new System.Guid (ReadBlock (16).Data);
Magic Number,TagLib.Asf,FilePropertiesObject,C:\repos\mono_taglib-sharp\src\TagLib\Asf\FilePropertiesObject.cs,FilePropertiesObject,The following statement contains a magic number: if (OriginalSize < 104)  				throw new CorruptFileException (  					"Object size too small.");
Magic Number,TagLib.Asf,HeaderExtensionObject,C:\repos\mono_taglib-sharp\src\TagLib\Asf\HeaderExtensionObject.cs,HeaderExtensionObject,The following statement contains a magic number: if (file.ReadWord () != 6)  				throw new CorruptFileException (  					"Invalid reserved WORD. Expected '6'.");
Magic Number,TagLib.Asf,HeaderExtensionObject,C:\repos\mono_taglib-sharp\src\TagLib\Asf\HeaderExtensionObject.cs,HeaderExtensionObject,The following statement contains a magic number: position += 0x170 / 8;
Magic Number,TagLib.Asf,HeaderExtensionObject,C:\repos\mono_taglib-sharp\src\TagLib\Asf\HeaderExtensionObject.cs,Render,The following statement contains a magic number: output.Insert (0' RenderWord (6));
Magic Number,TagLib.Asf,HeaderObject,C:\repos\mono_taglib-sharp\src\TagLib\Asf\HeaderObject.cs,HeaderObject,The following statement contains a magic number: if (OriginalSize < 26)  				throw new CorruptFileException (  					"Object size too small.");
Magic Number,TagLib.Asf,HeaderObject,C:\repos\mono_taglib-sharp\src\TagLib\Asf\HeaderObject.cs,HeaderObject,The following statement contains a magic number: reserved = file.ReadBlock (2);
Magic Number,TagLib.Asf,HeaderObject,C:\repos\mono_taglib-sharp\src\TagLib\Asf\HeaderObject.cs,Render,The following statement contains a magic number: long size_diff = (long) output.Count + 30 -  				(long) OriginalSize;
Magic Number,TagLib.Asf,HeaderObject,C:\repos\mono_taglib-sharp\src\TagLib\Asf\HeaderObject.cs,Render,The following statement contains a magic number: if (size_diff != 0) {  				PaddingObject obj = new PaddingObject ((uint)  					(size_diff > 0 ? 4096 : - size_diff));  				  				output.Add (obj.Render ());  				child_count ++;  			}
Magic Number,TagLib.Asf,MetadataLibraryObject,C:\repos\mono_taglib-sharp\src\TagLib\Asf\MetadataLibraryObject.cs,MetadataLibraryObject,The following statement contains a magic number: if (OriginalSize < 26)  				throw new CorruptFileException (  					"Object size too small.");
Magic Number,TagLib.Asf,Object,C:\repos\mono_taglib-sharp\src\TagLib\Asf\Object.cs,Object,The following statement contains a magic number: if (position < 0 ||  				position > file.Length - 24)  				throw new ArgumentOutOfRangeException (  					"position");
Magic Number,TagLib.Asf,Object,C:\repos\mono_taglib-sharp\src\TagLib\Asf\Object.cs,Render,The following statement contains a magic number: ulong length = (ulong)  				((data != null ? data.Count : 0) + 24);
Magic Number,TagLib.Asf,PaddingObject,C:\repos\mono_taglib-sharp\src\TagLib\Asf\PaddingObject.cs,PaddingObject,The following statement contains a magic number: if (OriginalSize < 24)  				throw new CorruptFileException (  					"Object size too small.");
Magic Number,TagLib.Asf,PaddingObject,C:\repos\mono_taglib-sharp\src\TagLib\Asf\PaddingObject.cs,Render,The following statement contains a magic number: return Render (new ByteVector ((int) (size - 24)));
Magic Number,TagLib.Asf,StreamPropertiesObject,C:\repos\mono_taglib-sharp\src\TagLib\Asf\StreamPropertiesObject.cs,StreamPropertiesObject,The following statement contains a magic number: if (OriginalSize < 78)  				throw new CorruptFileException (  					"Object size too small.");
Magic Number,TagLib.Asf,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Asf\Tag.cs,PictureFromData,The following statement contains a magic number: if (data.Count < 9)  				return null;
Magic Number,TagLib.Asf,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Asf\Tag.cs,PictureFromData,The following statement contains a magic number: int size = (int) data.Mid (offset' 4).ToUInt (false);
Magic Number,TagLib.Asf,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Asf\Tag.cs,PictureFromData,The following statement contains a magic number: offset += 4;
Magic Number,TagLib.Asf,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Asf\Tag.cs,PictureFromData,The following statement contains a magic number: int found = data.Find (ByteVector.TextDelimiter (  				StringType.UTF16LE)' offset' 2);
Magic Number,TagLib.Asf,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Asf\Tag.cs,PictureFromData,The following statement contains a magic number: offset = found + 2;
Magic Number,TagLib.Asf,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Asf\Tag.cs,PictureFromData,The following statement contains a magic number: found = data.Find (ByteVector.TextDelimiter (  				StringType.UTF16LE)' offset' 2);
Magic Number,TagLib.Asf,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Asf\Tag.cs,PictureFromData,The following statement contains a magic number: offset = found + 2;
Magic Number,TagLib.Asf,UnknownObject,C:\repos\mono_taglib-sharp\src\TagLib\Asf\UnknownObject.cs,UnknownObject,The following statement contains a magic number: data = file.ReadBlock ((int) (OriginalSize - 24));
Magic Number,TagLib.Audible,File,C:\repos\mono_taglib-sharp\src\TagLib\Audible\File.cs,File,The following statement contains a magic number: try {  				// get the pointer to the end of the tag block  				// and calculate the tag block length  				Seek (OffsetToEndTagPointer);  				int tagLen = ( (int) ReadBlock(4).ToUInt(true) ) - TagBlockOffset;  				  				// read the whole tag and send to Tag class  				Seek (TagBlockOffset);  				ByteVector bv = ReadBlock(tagLen);  				  				tag = new  TagLib.Audible.Tag( bv );  				  			} finally {  				Mode = AccessMode.Closed;  			}
Magic Number,TagLib.Audible,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Audible\Tag.cs,Parse,The following statement contains a magic number: try  			{  				do  				{  					keyLen = (int) data.ToUInt(true);  					data.RemoveRange (0' 4);  					valueLen = (int) data.ToUInt(true);  					data.RemoveRange (0' 4);  					currentKey = data.ToString ( TagLib.StringType.UTF8' 0' keyLen );  					data.RemoveRange (0' keyLen);  					currentValue = data.ToString ( TagLib.StringType.UTF8' 0' valueLen );  					data.RemoveRange (0' valueLen);  					  					tags.Add( new KeyValuePair<string' string>(currentKey' currentValue) );  					  					//StringHandle (currentKey' currentValue);  					  					// if it is not the last item remove the end byte (null terminated)  					if (data.Count != 0)  						data.RemoveRange(0'1);  				}  				while (data.Count >= 4);  			}  			catch (Exception)  			{  				//  			}
Magic Number,TagLib.Audible,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Audible\Tag.cs,Parse,The following statement contains a magic number: try  			{  				do  				{  					keyLen = (int) data.ToUInt(true);  					data.RemoveRange (0' 4);  					valueLen = (int) data.ToUInt(true);  					data.RemoveRange (0' 4);  					currentKey = data.ToString ( TagLib.StringType.UTF8' 0' keyLen );  					data.RemoveRange (0' keyLen);  					currentValue = data.ToString ( TagLib.StringType.UTF8' 0' valueLen );  					data.RemoveRange (0' valueLen);  					  					tags.Add( new KeyValuePair<string' string>(currentKey' currentValue) );  					  					//StringHandle (currentKey' currentValue);  					  					// if it is not the last item remove the end byte (null terminated)  					if (data.Count != 0)  						data.RemoveRange(0'1);  				}  				while (data.Count >= 4);  			}  			catch (Exception)  			{  				//  			}
Magic Number,TagLib.Audible,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Audible\Tag.cs,Parse,The following statement contains a magic number: try  			{  				do  				{  					keyLen = (int) data.ToUInt(true);  					data.RemoveRange (0' 4);  					valueLen = (int) data.ToUInt(true);  					data.RemoveRange (0' 4);  					currentKey = data.ToString ( TagLib.StringType.UTF8' 0' keyLen );  					data.RemoveRange (0' keyLen);  					currentValue = data.ToString ( TagLib.StringType.UTF8' 0' valueLen );  					data.RemoveRange (0' valueLen);  					  					tags.Add( new KeyValuePair<string' string>(currentKey' currentValue) );  					  					//StringHandle (currentKey' currentValue);  					  					// if it is not the last item remove the end byte (null terminated)  					if (data.Count != 0)  						data.RemoveRange(0'1);  				}  				while (data.Count >= 4);  			}  			catch (Exception)  			{  				//  			}
Magic Number,TagLib.Dsf,File,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\File.cs,Save,The following statement contains a magic number: try  			{  				long original_tag_length = tag_end - tag_start;  				ByteVector data = new ByteVector();    				if (tag == null)  				{  					// The tag has been removed  					RemoveBlock(tag_start' original_tag_length);  					Insert(ByteVector.FromULong((ulong)(0)'  												false)' 20' 8);  				}  				else  				{  					data = tag.Render();    				// If tagging info cannot be found' place it at  				// the end of the file.  				if (tag_start == 0 || tag_end < tag_start)  				{  					tag_start = tag_end = Length;  					// Update the New Tag start  					Insert(ByteVector.FromULong((ulong)(tag_start)'  												false)' 20' 8);  				}    				// Insert the tagging data.  				Insert(data' tag_start' data.Count);  				}    				long length = dsf_size + data.Count - original_tag_length;    				// If the data size changed update the dsf  size.  				if (data.Count - original_tag_length != 0 &&  					tag_start <= dsf_size)  				{  					Insert(ByteVector.FromULong((ulong)(length)'  												false)' 12' 8);  				}  				// Update the tag types.  				TagTypesOnDisk = TagTypes;  			}  			finally  			{  				Mode = AccessMode.Closed;  			}
Magic Number,TagLib.Dsf,File,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\File.cs,Save,The following statement contains a magic number: try  			{  				long original_tag_length = tag_end - tag_start;  				ByteVector data = new ByteVector();    				if (tag == null)  				{  					// The tag has been removed  					RemoveBlock(tag_start' original_tag_length);  					Insert(ByteVector.FromULong((ulong)(0)'  												false)' 20' 8);  				}  				else  				{  					data = tag.Render();    				// If tagging info cannot be found' place it at  				// the end of the file.  				if (tag_start == 0 || tag_end < tag_start)  				{  					tag_start = tag_end = Length;  					// Update the New Tag start  					Insert(ByteVector.FromULong((ulong)(tag_start)'  												false)' 20' 8);  				}    				// Insert the tagging data.  				Insert(data' tag_start' data.Count);  				}    				long length = dsf_size + data.Count - original_tag_length;    				// If the data size changed update the dsf  size.  				if (data.Count - original_tag_length != 0 &&  					tag_start <= dsf_size)  				{  					Insert(ByteVector.FromULong((ulong)(length)'  												false)' 12' 8);  				}  				// Update the tag types.  				TagTypesOnDisk = TagTypes;  			}  			finally  			{  				Mode = AccessMode.Closed;  			}
Magic Number,TagLib.Dsf,File,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\File.cs,Save,The following statement contains a magic number: try  			{  				long original_tag_length = tag_end - tag_start;  				ByteVector data = new ByteVector();    				if (tag == null)  				{  					// The tag has been removed  					RemoveBlock(tag_start' original_tag_length);  					Insert(ByteVector.FromULong((ulong)(0)'  												false)' 20' 8);  				}  				else  				{  					data = tag.Render();    				// If tagging info cannot be found' place it at  				// the end of the file.  				if (tag_start == 0 || tag_end < tag_start)  				{  					tag_start = tag_end = Length;  					// Update the New Tag start  					Insert(ByteVector.FromULong((ulong)(tag_start)'  												false)' 20' 8);  				}    				// Insert the tagging data.  				Insert(data' tag_start' data.Count);  				}    				long length = dsf_size + data.Count - original_tag_length;    				// If the data size changed update the dsf  size.  				if (data.Count - original_tag_length != 0 &&  					tag_start <= dsf_size)  				{  					Insert(ByteVector.FromULong((ulong)(length)'  												false)' 12' 8);  				}  				// Update the tag types.  				TagTypesOnDisk = TagTypes;  			}  			finally  			{  				Mode = AccessMode.Closed;  			}
Magic Number,TagLib.Dsf,File,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\File.cs,Save,The following statement contains a magic number: try  			{  				long original_tag_length = tag_end - tag_start;  				ByteVector data = new ByteVector();    				if (tag == null)  				{  					// The tag has been removed  					RemoveBlock(tag_start' original_tag_length);  					Insert(ByteVector.FromULong((ulong)(0)'  												false)' 20' 8);  				}  				else  				{  					data = tag.Render();    				// If tagging info cannot be found' place it at  				// the end of the file.  				if (tag_start == 0 || tag_end < tag_start)  				{  					tag_start = tag_end = Length;  					// Update the New Tag start  					Insert(ByteVector.FromULong((ulong)(tag_start)'  												false)' 20' 8);  				}    				// Insert the tagging data.  				Insert(data' tag_start' data.Count);  				}    				long length = dsf_size + data.Count - original_tag_length;    				// If the data size changed update the dsf  size.  				if (data.Count - original_tag_length != 0 &&  					tag_start <= dsf_size)  				{  					Insert(ByteVector.FromULong((ulong)(length)'  												false)' 12' 8);  				}  				// Update the tag types.  				TagTypesOnDisk = TagTypes;  			}  			finally  			{  				Mode = AccessMode.Closed;  			}
Magic Number,TagLib.Dsf,File,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\File.cs,Save,The following statement contains a magic number: try  			{  				long original_tag_length = tag_end - tag_start;  				ByteVector data = new ByteVector();    				if (tag == null)  				{  					// The tag has been removed  					RemoveBlock(tag_start' original_tag_length);  					Insert(ByteVector.FromULong((ulong)(0)'  												false)' 20' 8);  				}  				else  				{  					data = tag.Render();    				// If tagging info cannot be found' place it at  				// the end of the file.  				if (tag_start == 0 || tag_end < tag_start)  				{  					tag_start = tag_end = Length;  					// Update the New Tag start  					Insert(ByteVector.FromULong((ulong)(tag_start)'  												false)' 20' 8);  				}    				// Insert the tagging data.  				Insert(data' tag_start' data.Count);  				}    				long length = dsf_size + data.Count - original_tag_length;    				// If the data size changed update the dsf  size.  				if (data.Count - original_tag_length != 0 &&  					tag_start <= dsf_size)  				{  					Insert(ByteVector.FromULong((ulong)(length)'  												false)' 12' 8);  				}  				// Update the tag types.  				TagTypesOnDisk = TagTypes;  			}  			finally  			{  				Mode = AccessMode.Closed;  			}
Magic Number,TagLib.Dsf,File,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\File.cs,Save,The following statement contains a magic number: try  			{  				long original_tag_length = tag_end - tag_start;  				ByteVector data = new ByteVector();    				if (tag == null)  				{  					// The tag has been removed  					RemoveBlock(tag_start' original_tag_length);  					Insert(ByteVector.FromULong((ulong)(0)'  												false)' 20' 8);  				}  				else  				{  					data = tag.Render();    				// If tagging info cannot be found' place it at  				// the end of the file.  				if (tag_start == 0 || tag_end < tag_start)  				{  					tag_start = tag_end = Length;  					// Update the New Tag start  					Insert(ByteVector.FromULong((ulong)(tag_start)'  												false)' 20' 8);  				}    				// Insert the tagging data.  				Insert(data' tag_start' data.Count);  				}    				long length = dsf_size + data.Count - original_tag_length;    				// If the data size changed update the dsf  size.  				if (data.Count - original_tag_length != 0 &&  					tag_start <= dsf_size)  				{  					Insert(ByteVector.FromULong((ulong)(length)'  												false)' 12' 8);  				}  				// Update the tag types.  				TagTypesOnDisk = TagTypes;  			}  			finally  			{  				Mode = AccessMode.Closed;  			}
Magic Number,TagLib.Dsf,File,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\File.cs,GetTag,The following statement contains a magic number: switch (type)  			{  				case TagTypes.Id3v2:  					if (tag == null && create)  					{  						tag = new Id3v2.Tag();  						tag.Version = 2;  					}    					id32_tag = tag;  					break;  			}
Magic Number,TagLib.Dsf,File,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\File.cs,Read,The following statement contains a magic number: if (ReadBlock(4) != FileIdentifier)  				throw new CorruptFileException(  					"File does not begin with DSF identifier");
Magic Number,TagLib.Dsf,File,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\File.cs,Read,The following statement contains a magic number: Seek(12);
Magic Number,TagLib.Dsf,File,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\File.cs,Read,The following statement contains a magic number: dsf_size = ReadBlock(8).ToUInt(false);
Magic Number,TagLib.Dsf,File,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\File.cs,Read,The following statement contains a magic number: tag_start = (long)ReadBlock(8).ToULong(false);
Magic Number,TagLib.Dsf,File,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\File.cs,Read,The following statement contains a magic number: if (tag_start > 0)  			{  				Seek(tag_start);  				if (ReadBlock(3) == ID3Identifier)  				{  					if (read_tags && tag == null)  					{  						tag = new Id3v2.Tag(this' tag_start);  					}    					// Get the length of the tag out of the ID3 chunk  					Seek(tag_start + 6);  					uint tag_size = SynchData.ToUInt(ReadBlock(4)) + 10;    					InvariantStartPosition = tag_start;  					tag_end = InvariantEndPosition = tag_start + tag_size;  				}  			}
Magic Number,TagLib.Dsf,File,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\File.cs,Read,The following statement contains a magic number: if (tag_start > 0)  			{  				Seek(tag_start);  				if (ReadBlock(3) == ID3Identifier)  				{  					if (read_tags && tag == null)  					{  						tag = new Id3v2.Tag(this' tag_start);  					}    					// Get the length of the tag out of the ID3 chunk  					Seek(tag_start + 6);  					uint tag_size = SynchData.ToUInt(ReadBlock(4)) + 10;    					InvariantStartPosition = tag_start;  					tag_end = InvariantEndPosition = tag_start + tag_size;  				}  			}
Magic Number,TagLib.Dsf,File,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\File.cs,Read,The following statement contains a magic number: if (tag_start > 0)  			{  				Seek(tag_start);  				if (ReadBlock(3) == ID3Identifier)  				{  					if (read_tags && tag == null)  					{  						tag = new Id3v2.Tag(this' tag_start);  					}    					// Get the length of the tag out of the ID3 chunk  					Seek(tag_start + 6);  					uint tag_size = SynchData.ToUInt(ReadBlock(4)) + 10;    					InvariantStartPosition = tag_start;  					tag_end = InvariantEndPosition = tag_start + tag_size;  				}  			}
Magic Number,TagLib.Dsf,File,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\File.cs,Read,The following statement contains a magic number: if (tag_start > 0)  			{  				Seek(tag_start);  				if (ReadBlock(3) == ID3Identifier)  				{  					if (read_tags && tag == null)  					{  						tag = new Id3v2.Tag(this' tag_start);  					}    					// Get the length of the tag out of the ID3 chunk  					Seek(tag_start + 6);  					uint tag_size = SynchData.ToUInt(ReadBlock(4)) + 10;    					InvariantStartPosition = tag_start;  					tag_end = InvariantEndPosition = tag_start + tag_size;  				}  			}
Magic Number,TagLib.Dsf,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\StreamHeader.cs,StreamHeader,The following statement contains a magic number: version = data.Mid(12' 4).ToUShort(false);
Magic Number,TagLib.Dsf,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\StreamHeader.cs,StreamHeader,The following statement contains a magic number: version = data.Mid(12' 4).ToUShort(false);
Magic Number,TagLib.Dsf,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\StreamHeader.cs,StreamHeader,The following statement contains a magic number: format_id = data.Mid(16' 4).ToUShort(false);
Magic Number,TagLib.Dsf,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\StreamHeader.cs,StreamHeader,The following statement contains a magic number: format_id = data.Mid(16' 4).ToUShort(false);
Magic Number,TagLib.Dsf,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\StreamHeader.cs,StreamHeader,The following statement contains a magic number: channel_type = data.Mid(20' 4).ToUShort(false);
Magic Number,TagLib.Dsf,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\StreamHeader.cs,StreamHeader,The following statement contains a magic number: channel_type = data.Mid(20' 4).ToUShort(false);
Magic Number,TagLib.Dsf,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\StreamHeader.cs,StreamHeader,The following statement contains a magic number: channels = data.Mid(24' 4).ToUShort(false);
Magic Number,TagLib.Dsf,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\StreamHeader.cs,StreamHeader,The following statement contains a magic number: channels = data.Mid(24' 4).ToUShort(false);
Magic Number,TagLib.Dsf,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\StreamHeader.cs,StreamHeader,The following statement contains a magic number: sample_rate = data.Mid(28' 4).ToULong(false);
Magic Number,TagLib.Dsf,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\StreamHeader.cs,StreamHeader,The following statement contains a magic number: sample_rate = data.Mid(28' 4).ToULong(false);
Magic Number,TagLib.Dsf,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\StreamHeader.cs,StreamHeader,The following statement contains a magic number: bits_per_sample = data.Mid(32' 4).ToUShort(false);
Magic Number,TagLib.Dsf,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\StreamHeader.cs,StreamHeader,The following statement contains a magic number: bits_per_sample = data.Mid(32' 4).ToUShort(false);
Magic Number,TagLib.Dsf,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\StreamHeader.cs,StreamHeader,The following statement contains a magic number: sample_count = data.Mid(36' 8).ToULong(false);
Magic Number,TagLib.Dsf,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\StreamHeader.cs,StreamHeader,The following statement contains a magic number: sample_count = data.Mid(36' 8).ToULong(false);
Magic Number,TagLib.Dsf,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\StreamHeader.cs,StreamHeader,The following statement contains a magic number: channel_blksize = data.Mid(44' 4).ToUShort(false);
Magic Number,TagLib.Dsf,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\StreamHeader.cs,StreamHeader,The following statement contains a magic number: channel_blksize = data.Mid(44' 4).ToUShort(false);
Magic Number,TagLib.Flac,BlockHeader,C:\repos\mono_taglib-sharp\src\TagLib\Flac\BlockHeader.cs,BlockHeader,The following statement contains a magic number: block_size = data.Mid (1'3).ToUInt ();
Magic Number,TagLib.Flac,File,C:\repos\mono_taglib-sharp\src\TagLib\Flac\File.cs,Save,The following statement contains a magic number: try {  				// Update the tags at the beginning of the file.  				long metadata_start = StartTag.Write ();  				long metadata_end;  				  				// Get all the blocks' but don't read the data for ones  				// we're filling with stored data.  				IList<Block> old_blocks = ReadBlocks (ref metadata_start'  					out metadata_end' BlockMode.Blacklist'  					BlockType.XiphComment' BlockType.Picture);  				  				// Create new vorbis comments is they don't exist.  				GetTag (TagTypes.Xiph' true);  				  				// Create new blocks and add the basics.  				List<Block> new_blocks = new List<Block> ();  				new_blocks.Add (old_blocks [0]);  				  				// Add blocks we don't deal with from the file.  				foreach (Block block in old_blocks)  					if (block.Type != BlockType.StreamInfo &&  						block.Type != BlockType.XiphComment &&  						block.Type != BlockType.Picture &&  						block.Type != BlockType.Padding)  						new_blocks.Add (block);  				  				new_blocks.Add (new Block (BlockType.XiphComment'  					(GetTag (TagTypes.Xiph' true) as  						Ogg.XiphComment).Render (false)));  				  				foreach (IPicture picture in metadata.Pictures) {  					if (picture == null)  						continue;  					  					new_blocks.Add (new Block (BlockType.Picture'  						new Picture (picture).Render ()));  				}  				  				// Get the length of the blocks.  				long length = 0;  				foreach (Block block in new_blocks)  					length += block.TotalSize;  				  				// Find the padding size to avoid trouble. If that fails  				// make some.  				long padding_size = metadata_end - metadata_start -  					BlockHeader.Size - length;  				if (padding_size < 0)  					padding_size = 1024 * 4;  				  				// Add a padding block.  				if (padding_size != 0)  					new_blocks.Add (new Block (BlockType.Padding'  						new ByteVector ((int) padding_size)));  				  				// Render the blocks.  				ByteVector block_data = new ByteVector ();  				for (int i = 0; i < new_blocks.Count; i ++)  					block_data.Add (new_blocks [i].Render (  						i == new_blocks.Count - 1));  				  				// Update the blocks.  				Insert (block_data' metadata_start' metadata_end -  					metadata_start);  				  				// Update the tags at the end of the file.  				EndTag.Write ();  				  				TagTypesOnDisk = TagTypes;  			} finally {  				Mode = AccessMode.Closed;  			}
Magic Number,TagLib.Flac,File,C:\repos\mono_taglib-sharp\src\TagLib\Flac\File.cs,Save,The following statement contains a magic number: try {  				// Update the tags at the beginning of the file.  				long metadata_start = StartTag.Write ();  				long metadata_end;  				  				// Get all the blocks' but don't read the data for ones  				// we're filling with stored data.  				IList<Block> old_blocks = ReadBlocks (ref metadata_start'  					out metadata_end' BlockMode.Blacklist'  					BlockType.XiphComment' BlockType.Picture);  				  				// Create new vorbis comments is they don't exist.  				GetTag (TagTypes.Xiph' true);  				  				// Create new blocks and add the basics.  				List<Block> new_blocks = new List<Block> ();  				new_blocks.Add (old_blocks [0]);  				  				// Add blocks we don't deal with from the file.  				foreach (Block block in old_blocks)  					if (block.Type != BlockType.StreamInfo &&  						block.Type != BlockType.XiphComment &&  						block.Type != BlockType.Picture &&  						block.Type != BlockType.Padding)  						new_blocks.Add (block);  				  				new_blocks.Add (new Block (BlockType.XiphComment'  					(GetTag (TagTypes.Xiph' true) as  						Ogg.XiphComment).Render (false)));  				  				foreach (IPicture picture in metadata.Pictures) {  					if (picture == null)  						continue;  					  					new_blocks.Add (new Block (BlockType.Picture'  						new Picture (picture).Render ()));  				}  				  				// Get the length of the blocks.  				long length = 0;  				foreach (Block block in new_blocks)  					length += block.TotalSize;  				  				// Find the padding size to avoid trouble. If that fails  				// make some.  				long padding_size = metadata_end - metadata_start -  					BlockHeader.Size - length;  				if (padding_size < 0)  					padding_size = 1024 * 4;  				  				// Add a padding block.  				if (padding_size != 0)  					new_blocks.Add (new Block (BlockType.Padding'  						new ByteVector ((int) padding_size)));  				  				// Render the blocks.  				ByteVector block_data = new ByteVector ();  				for (int i = 0; i < new_blocks.Count; i ++)  					block_data.Add (new_blocks [i].Render (  						i == new_blocks.Count - 1));  				  				// Update the blocks.  				Insert (block_data' metadata_start' metadata_end -  					metadata_start);  				  				// Update the tags at the end of the file.  				EndTag.Write ();  				  				TagTypesOnDisk = TagTypes;  			} finally {  				Mode = AccessMode.Closed;  			}
Magic Number,TagLib.Flac,File,C:\repos\mono_taglib-sharp\src\TagLib\Flac\File.cs,ReadBlocks,The following statement contains a magic number: end = start = start_position + 4;
Magic Number,TagLib.Flac,Picture,C:\repos\mono_taglib-sharp\src\TagLib\Flac\Picture.cs,Picture,The following statement contains a magic number: if (data.Count < 32)  				throw new CorruptFileException (  					"Data must be at least 32 bytes long");
Magic Number,TagLib.Flac,Picture,C:\repos\mono_taglib-sharp\src\TagLib\Flac\Picture.cs,Picture,The following statement contains a magic number: type = (PictureType) data.Mid (pos' 4).ToUInt ();
Magic Number,TagLib.Flac,Picture,C:\repos\mono_taglib-sharp\src\TagLib\Flac\Picture.cs,Picture,The following statement contains a magic number: pos += 4;
Magic Number,TagLib.Flac,Picture,C:\repos\mono_taglib-sharp\src\TagLib\Flac\Picture.cs,Picture,The following statement contains a magic number: int mimetype_length = (int) data.Mid (pos' 4).ToUInt ();
Magic Number,TagLib.Flac,Picture,C:\repos\mono_taglib-sharp\src\TagLib\Flac\Picture.cs,Picture,The following statement contains a magic number: pos += 4;
Magic Number,TagLib.Flac,Picture,C:\repos\mono_taglib-sharp\src\TagLib\Flac\Picture.cs,Picture,The following statement contains a magic number: int description_length = (int) data.Mid (pos' 4)  				.ToUInt ();
Magic Number,TagLib.Flac,Picture,C:\repos\mono_taglib-sharp\src\TagLib\Flac\Picture.cs,Picture,The following statement contains a magic number: pos += 4;
Magic Number,TagLib.Flac,Picture,C:\repos\mono_taglib-sharp\src\TagLib\Flac\Picture.cs,Picture,The following statement contains a magic number: width = (int) data.Mid (pos' 4).ToUInt ();
Magic Number,TagLib.Flac,Picture,C:\repos\mono_taglib-sharp\src\TagLib\Flac\Picture.cs,Picture,The following statement contains a magic number: pos += 4;
Magic Number,TagLib.Flac,Picture,C:\repos\mono_taglib-sharp\src\TagLib\Flac\Picture.cs,Picture,The following statement contains a magic number: height = (int) data.Mid (pos' 4).ToUInt ();
Magic Number,TagLib.Flac,Picture,C:\repos\mono_taglib-sharp\src\TagLib\Flac\Picture.cs,Picture,The following statement contains a magic number: pos += 4;
Magic Number,TagLib.Flac,Picture,C:\repos\mono_taglib-sharp\src\TagLib\Flac\Picture.cs,Picture,The following statement contains a magic number: color_depth = (int) data.Mid (pos' 4).ToUInt ();
Magic Number,TagLib.Flac,Picture,C:\repos\mono_taglib-sharp\src\TagLib\Flac\Picture.cs,Picture,The following statement contains a magic number: pos += 4;
Magic Number,TagLib.Flac,Picture,C:\repos\mono_taglib-sharp\src\TagLib\Flac\Picture.cs,Picture,The following statement contains a magic number: indexed_colors = (int) data.Mid (pos' 4).ToUInt ();
Magic Number,TagLib.Flac,Picture,C:\repos\mono_taglib-sharp\src\TagLib\Flac\Picture.cs,Picture,The following statement contains a magic number: pos += 4;
Magic Number,TagLib.Flac,Picture,C:\repos\mono_taglib-sharp\src\TagLib\Flac\Picture.cs,Picture,The following statement contains a magic number: int data_length = (int) data.Mid (pos' 4).ToUInt ();
Magic Number,TagLib.Flac,Picture,C:\repos\mono_taglib-sharp\src\TagLib\Flac\Picture.cs,Picture,The following statement contains a magic number: pos += 4;
Magic Number,TagLib.Flac,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Flac\StreamHeader.cs,StreamHeader,The following statement contains a magic number: if (data.Count < 18)  				throw new CorruptFileException (  				"Not enough data in FLAC header.");
Magic Number,TagLib.Flac,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Flac\StreamHeader.cs,StreamHeader,The following statement contains a magic number: this.flags = data.Mid (10' 4).ToUInt (true);
Magic Number,TagLib.Flac,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Flac\StreamHeader.cs,StreamHeader,The following statement contains a magic number: this.flags = data.Mid (10' 4).ToUInt (true);
Magic Number,TagLib.Flac,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Flac\StreamHeader.cs,StreamHeader,The following statement contains a magic number: low_length = data.Mid (14' 4).ToUInt (true);
Magic Number,TagLib.Flac,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Flac\StreamHeader.cs,StreamHeader,The following statement contains a magic number: low_length = data.Mid (14' 4).ToUInt (true);
Magic Number,TagLib.Gif,File,C:\repos\mono_taglib-sharp\src\TagLib\Gif\File.cs,ReadHeader,The following statement contains a magic number: ByteVector data = ReadBlock (13);
Magic Number,TagLib.Gif,File,C:\repos\mono_taglib-sharp\src\TagLib\Gif\File.cs,ReadHeader,The following statement contains a magic number: if (data.Count != 13)  				throw new CorruptFileException ("Unexpected end of Header");
Magic Number,TagLib.Gif,File,C:\repos\mono_taglib-sharp\src\TagLib\Gif\File.cs,ReadHeader,The following statement contains a magic number: if (data.Mid (0' 3).ToString () != SIGNATURE)  				throw new CorruptFileException (String.Format ("Expected a GIF signature at start of file' but found: {0}"' data.Mid (0' 3).ToString ()));
Magic Number,TagLib.Gif,File,C:\repos\mono_taglib-sharp\src\TagLib\Gif\File.cs,ReadHeader,The following statement contains a magic number: if (data.Mid (0' 3).ToString () != SIGNATURE)  				throw new CorruptFileException (String.Format ("Expected a GIF signature at start of file' but found: {0}"' data.Mid (0' 3).ToString ()));
Magic Number,TagLib.Gif,File,C:\repos\mono_taglib-sharp\src\TagLib\Gif\File.cs,ReadHeader,The following statement contains a magic number: var read_version = data.Mid (3' 3).ToString ();
Magic Number,TagLib.Gif,File,C:\repos\mono_taglib-sharp\src\TagLib\Gif\File.cs,ReadHeader,The following statement contains a magic number: var read_version = data.Mid (3' 3).ToString ();
Magic Number,TagLib.Gif,File,C:\repos\mono_taglib-sharp\src\TagLib\Gif\File.cs,ReadHeader,The following statement contains a magic number: width = data.Mid (6' 2).ToUShort (false);
Magic Number,TagLib.Gif,File,C:\repos\mono_taglib-sharp\src\TagLib\Gif\File.cs,ReadHeader,The following statement contains a magic number: width = data.Mid (6' 2).ToUShort (false);
Magic Number,TagLib.Gif,File,C:\repos\mono_taglib-sharp\src\TagLib\Gif\File.cs,ReadHeader,The following statement contains a magic number: height = data.Mid (8' 2).ToUShort (false);
Magic Number,TagLib.Gif,File,C:\repos\mono_taglib-sharp\src\TagLib\Gif\File.cs,ReadHeader,The following statement contains a magic number: height = data.Mid (8' 2).ToUShort (false);
Magic Number,TagLib.Gif,File,C:\repos\mono_taglib-sharp\src\TagLib\Gif\File.cs,ReadHeader,The following statement contains a magic number: SkipColorTable (data [10]);
Magic Number,TagLib.Gif,File,C:\repos\mono_taglib-sharp\src\TagLib\Gif\File.cs,ReadApplicationExtensionBlock,The following statement contains a magic number: ByteVector data = ReadBlock (12);
Magic Number,TagLib.Gif,File,C:\repos\mono_taglib-sharp\src\TagLib\Gif\File.cs,ReadApplicationExtensionBlock,The following statement contains a magic number: if (data.Count != 12)  				throw new CorruptFileException ("");
Magic Number,TagLib.Gif,File,C:\repos\mono_taglib-sharp\src\TagLib\Gif\File.cs,ReadApplicationExtensionBlock,The following statement contains a magic number: if (data.Mid (1' 8) == XMP_IDENTIFIER &&  			    data.Mid (9' 3) == XMP_AUTH_CODE) {  				// XMP Data is not organized in sub-blocks    				// start of xmp data  				long data_start = Tell;    				// start of trailer start  				// FIXME: Since File.Find is still buggy' the following call does not work to find the end of the  				// XMP data. Therfore' we use here a different way for now.  				//long xmp_trailer_start = Find (new ByteVector (0x00)' data_start);    				// Since searching just one byte is save' we search for the end of the xmp trailer which  				// consists of two 0x00 bytes and compute the expected start.  				long xmp_trailer_start = Find (new byte [] {0x00}' data_start) - XMP_MAGIC_TRAILER.Length + 2;    				Seek (data_start' SeekOrigin.Begin);    				if (xmp_trailer_start <= data_start)  					throw new CorruptFileException ("No End of XMP data found");    				// length of xmp data  				int data_length = (int) (xmp_trailer_start - data_start);    				ByteVector xmp_data = ReadBlock (data_length);  				ImageTag.AddTag (new XmpTag (xmp_data.ToString (StringType.UTF8)' this));    				// 2 bytes where read before  				AddMetadataBlock (position - 2' 14 + data_length + XMP_MAGIC_TRAILER.Length);    				// set position behind the XMP block  				Seek (xmp_trailer_start + XMP_MAGIC_TRAILER.Length' SeekOrigin.Begin);    			} else {  				SkipSubBlocks ();  			}
Magic Number,TagLib.Gif,File,C:\repos\mono_taglib-sharp\src\TagLib\Gif\File.cs,ReadApplicationExtensionBlock,The following statement contains a magic number: if (data.Mid (1' 8) == XMP_IDENTIFIER &&  			    data.Mid (9' 3) == XMP_AUTH_CODE) {  				// XMP Data is not organized in sub-blocks    				// start of xmp data  				long data_start = Tell;    				// start of trailer start  				// FIXME: Since File.Find is still buggy' the following call does not work to find the end of the  				// XMP data. Therfore' we use here a different way for now.  				//long xmp_trailer_start = Find (new ByteVector (0x00)' data_start);    				// Since searching just one byte is save' we search for the end of the xmp trailer which  				// consists of two 0x00 bytes and compute the expected start.  				long xmp_trailer_start = Find (new byte [] {0x00}' data_start) - XMP_MAGIC_TRAILER.Length + 2;    				Seek (data_start' SeekOrigin.Begin);    				if (xmp_trailer_start <= data_start)  					throw new CorruptFileException ("No End of XMP data found");    				// length of xmp data  				int data_length = (int) (xmp_trailer_start - data_start);    				ByteVector xmp_data = ReadBlock (data_length);  				ImageTag.AddTag (new XmpTag (xmp_data.ToString (StringType.UTF8)' this));    				// 2 bytes where read before  				AddMetadataBlock (position - 2' 14 + data_length + XMP_MAGIC_TRAILER.Length);    				// set position behind the XMP block  				Seek (xmp_trailer_start + XMP_MAGIC_TRAILER.Length' SeekOrigin.Begin);    			} else {  				SkipSubBlocks ();  			}
Magic Number,TagLib.Gif,File,C:\repos\mono_taglib-sharp\src\TagLib\Gif\File.cs,ReadApplicationExtensionBlock,The following statement contains a magic number: if (data.Mid (1' 8) == XMP_IDENTIFIER &&  			    data.Mid (9' 3) == XMP_AUTH_CODE) {  				// XMP Data is not organized in sub-blocks    				// start of xmp data  				long data_start = Tell;    				// start of trailer start  				// FIXME: Since File.Find is still buggy' the following call does not work to find the end of the  				// XMP data. Therfore' we use here a different way for now.  				//long xmp_trailer_start = Find (new ByteVector (0x00)' data_start);    				// Since searching just one byte is save' we search for the end of the xmp trailer which  				// consists of two 0x00 bytes and compute the expected start.  				long xmp_trailer_start = Find (new byte [] {0x00}' data_start) - XMP_MAGIC_TRAILER.Length + 2;    				Seek (data_start' SeekOrigin.Begin);    				if (xmp_trailer_start <= data_start)  					throw new CorruptFileException ("No End of XMP data found");    				// length of xmp data  				int data_length = (int) (xmp_trailer_start - data_start);    				ByteVector xmp_data = ReadBlock (data_length);  				ImageTag.AddTag (new XmpTag (xmp_data.ToString (StringType.UTF8)' this));    				// 2 bytes where read before  				AddMetadataBlock (position - 2' 14 + data_length + XMP_MAGIC_TRAILER.Length);    				// set position behind the XMP block  				Seek (xmp_trailer_start + XMP_MAGIC_TRAILER.Length' SeekOrigin.Begin);    			} else {  				SkipSubBlocks ();  			}
Magic Number,TagLib.Gif,File,C:\repos\mono_taglib-sharp\src\TagLib\Gif\File.cs,ReadApplicationExtensionBlock,The following statement contains a magic number: if (data.Mid (1' 8) == XMP_IDENTIFIER &&  			    data.Mid (9' 3) == XMP_AUTH_CODE) {  				// XMP Data is not organized in sub-blocks    				// start of xmp data  				long data_start = Tell;    				// start of trailer start  				// FIXME: Since File.Find is still buggy' the following call does not work to find the end of the  				// XMP data. Therfore' we use here a different way for now.  				//long xmp_trailer_start = Find (new ByteVector (0x00)' data_start);    				// Since searching just one byte is save' we search for the end of the xmp trailer which  				// consists of two 0x00 bytes and compute the expected start.  				long xmp_trailer_start = Find (new byte [] {0x00}' data_start) - XMP_MAGIC_TRAILER.Length + 2;    				Seek (data_start' SeekOrigin.Begin);    				if (xmp_trailer_start <= data_start)  					throw new CorruptFileException ("No End of XMP data found");    				// length of xmp data  				int data_length = (int) (xmp_trailer_start - data_start);    				ByteVector xmp_data = ReadBlock (data_length);  				ImageTag.AddTag (new XmpTag (xmp_data.ToString (StringType.UTF8)' this));    				// 2 bytes where read before  				AddMetadataBlock (position - 2' 14 + data_length + XMP_MAGIC_TRAILER.Length);    				// set position behind the XMP block  				Seek (xmp_trailer_start + XMP_MAGIC_TRAILER.Length' SeekOrigin.Begin);    			} else {  				SkipSubBlocks ();  			}
Magic Number,TagLib.Gif,File,C:\repos\mono_taglib-sharp\src\TagLib\Gif\File.cs,ReadApplicationExtensionBlock,The following statement contains a magic number: if (data.Mid (1' 8) == XMP_IDENTIFIER &&  			    data.Mid (9' 3) == XMP_AUTH_CODE) {  				// XMP Data is not organized in sub-blocks    				// start of xmp data  				long data_start = Tell;    				// start of trailer start  				// FIXME: Since File.Find is still buggy' the following call does not work to find the end of the  				// XMP data. Therfore' we use here a different way for now.  				//long xmp_trailer_start = Find (new ByteVector (0x00)' data_start);    				// Since searching just one byte is save' we search for the end of the xmp trailer which  				// consists of two 0x00 bytes and compute the expected start.  				long xmp_trailer_start = Find (new byte [] {0x00}' data_start) - XMP_MAGIC_TRAILER.Length + 2;    				Seek (data_start' SeekOrigin.Begin);    				if (xmp_trailer_start <= data_start)  					throw new CorruptFileException ("No End of XMP data found");    				// length of xmp data  				int data_length = (int) (xmp_trailer_start - data_start);    				ByteVector xmp_data = ReadBlock (data_length);  				ImageTag.AddTag (new XmpTag (xmp_data.ToString (StringType.UTF8)' this));    				// 2 bytes where read before  				AddMetadataBlock (position - 2' 14 + data_length + XMP_MAGIC_TRAILER.Length);    				// set position behind the XMP block  				Seek (xmp_trailer_start + XMP_MAGIC_TRAILER.Length' SeekOrigin.Begin);    			} else {  				SkipSubBlocks ();  			}
Magic Number,TagLib.Gif,File,C:\repos\mono_taglib-sharp\src\TagLib\Gif\File.cs,ReadApplicationExtensionBlock,The following statement contains a magic number: if (data.Mid (1' 8) == XMP_IDENTIFIER &&  			    data.Mid (9' 3) == XMP_AUTH_CODE) {  				// XMP Data is not organized in sub-blocks    				// start of xmp data  				long data_start = Tell;    				// start of trailer start  				// FIXME: Since File.Find is still buggy' the following call does not work to find the end of the  				// XMP data. Therfore' we use here a different way for now.  				//long xmp_trailer_start = Find (new ByteVector (0x00)' data_start);    				// Since searching just one byte is save' we search for the end of the xmp trailer which  				// consists of two 0x00 bytes and compute the expected start.  				long xmp_trailer_start = Find (new byte [] {0x00}' data_start) - XMP_MAGIC_TRAILER.Length + 2;    				Seek (data_start' SeekOrigin.Begin);    				if (xmp_trailer_start <= data_start)  					throw new CorruptFileException ("No End of XMP data found");    				// length of xmp data  				int data_length = (int) (xmp_trailer_start - data_start);    				ByteVector xmp_data = ReadBlock (data_length);  				ImageTag.AddTag (new XmpTag (xmp_data.ToString (StringType.UTF8)' this));    				// 2 bytes where read before  				AddMetadataBlock (position - 2' 14 + data_length + XMP_MAGIC_TRAILER.Length);    				// set position behind the XMP block  				Seek (xmp_trailer_start + XMP_MAGIC_TRAILER.Length' SeekOrigin.Begin);    			} else {  				SkipSubBlocks ();  			}
Magic Number,TagLib.Gif,File,C:\repos\mono_taglib-sharp\src\TagLib\Gif\File.cs,ReadCommentBlock,The following statement contains a magic number: if ((TagTypes & TagTypes.GifComment) == 0x00) {  				ImageTag.AddTag (new GifCommentTag (comment));    				// 2 bytes where read before  				AddMetadataBlock (position - 2' Tell - position + 2);  			}
Magic Number,TagLib.Gif,File,C:\repos\mono_taglib-sharp\src\TagLib\Gif\File.cs,ReadCommentBlock,The following statement contains a magic number: if ((TagTypes & TagTypes.GifComment) == 0x00) {  				ImageTag.AddTag (new GifCommentTag (comment));    				// 2 bytes where read before  				AddMetadataBlock (position - 2' Tell - position + 2);  			}
Magic Number,TagLib.Gif,File,C:\repos\mono_taglib-sharp\src\TagLib\Gif\File.cs,SkipColorTable,The following statement contains a magic number: if ((packed_data & 0x80) == 0x80) {  				// 2^(size + 1) for each color.  				int table_size = 3 * (1 << ((packed_data & 0x07) + 1));    				// and simply skip the color table  				ByteVector color_table = ReadBlock (table_size);    				if (color_table.Count != table_size)  					throw new CorruptFileException ("Unexpected end of Color Table");    			}
Magic Number,TagLib.Gif,File,C:\repos\mono_taglib-sharp\src\TagLib\Gif\File.cs,SkipImage,The following statement contains a magic number: ByteVector data = ReadBlock (9);
Magic Number,TagLib.Gif,File,C:\repos\mono_taglib-sharp\src\TagLib\Gif\File.cs,SkipImage,The following statement contains a magic number: if (data.Count != 9)  				throw new CorruptFileException ("Unexpected end of Image Descriptor");
Magic Number,TagLib.Gif,File,C:\repos\mono_taglib-sharp\src\TagLib\Gif\File.cs,SkipImage,The following statement contains a magic number: SkipColorTable (data [8]);
Magic Number,TagLib.Gif,File,C:\repos\mono_taglib-sharp\src\TagLib\Gif\File.cs,SaveMetadata,The following statement contains a magic number: if (comment_block != null && xmp_block != null && version != VERSION_89A) {  				Insert (VERSION_89A' 3' VERSION_89A.Length);  			}
Magic Number,TagLib.Gif,File,C:\repos\mono_taglib-sharp\src\TagLib\Gif\File.cs,RenderGifCommentBlock,The following statement contains a magic number: byte block_max = 255;
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ReadIFD,The following statement contains a magic number: try {  				length = file.Length;  			} catch (Exception) {  				// Use a safety-value of 4 gigabyte.  				length = 1073741824L * 4;  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ReadIFD,The following statement contains a magic number: if (file.Tell + 12 * entry_count > base_offset + max_offset) {  				file.MarkAsCorrupt ("Size of entries exceeds possible data size");  				return 0;  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ReadIFD,The following statement contains a magic number: ByteVector entry_datas = file.ReadBlock (12 * entry_count);
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ReadIFD,The following statement contains a magic number: for (int i = 0; i < entry_count; i++) {  				ByteVector entry_data = entry_datas.Mid (i * 12' 12);    				ushort entry_tag = entry_data.Mid (0' 2).ToUShort (is_bigendian);  				ushort type = entry_data.Mid (2' 2).ToUShort (is_bigendian);  				uint value_count = entry_data.Mid (4' 4).ToUInt (is_bigendian);  				ByteVector offset_data = entry_data.Mid (8' 4);    				IFDEntry entry = CreateIFDEntry (entry_tag' type' value_count' base_offset' offset_data' max_offset);    				if (entry == null)  					continue;    				if (directory.ContainsKey (entry.Tag))  					directory.Remove (entry.Tag);    				directory.Add (entry.Tag' entry);  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ReadIFD,The following statement contains a magic number: for (int i = 0; i < entry_count; i++) {  				ByteVector entry_data = entry_datas.Mid (i * 12' 12);    				ushort entry_tag = entry_data.Mid (0' 2).ToUShort (is_bigendian);  				ushort type = entry_data.Mid (2' 2).ToUShort (is_bigendian);  				uint value_count = entry_data.Mid (4' 4).ToUInt (is_bigendian);  				ByteVector offset_data = entry_data.Mid (8' 4);    				IFDEntry entry = CreateIFDEntry (entry_tag' type' value_count' base_offset' offset_data' max_offset);    				if (entry == null)  					continue;    				if (directory.ContainsKey (entry.Tag))  					directory.Remove (entry.Tag);    				directory.Add (entry.Tag' entry);  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ReadIFD,The following statement contains a magic number: for (int i = 0; i < entry_count; i++) {  				ByteVector entry_data = entry_datas.Mid (i * 12' 12);    				ushort entry_tag = entry_data.Mid (0' 2).ToUShort (is_bigendian);  				ushort type = entry_data.Mid (2' 2).ToUShort (is_bigendian);  				uint value_count = entry_data.Mid (4' 4).ToUInt (is_bigendian);  				ByteVector offset_data = entry_data.Mid (8' 4);    				IFDEntry entry = CreateIFDEntry (entry_tag' type' value_count' base_offset' offset_data' max_offset);    				if (entry == null)  					continue;    				if (directory.ContainsKey (entry.Tag))  					directory.Remove (entry.Tag);    				directory.Add (entry.Tag' entry);  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ReadIFD,The following statement contains a magic number: for (int i = 0; i < entry_count; i++) {  				ByteVector entry_data = entry_datas.Mid (i * 12' 12);    				ushort entry_tag = entry_data.Mid (0' 2).ToUShort (is_bigendian);  				ushort type = entry_data.Mid (2' 2).ToUShort (is_bigendian);  				uint value_count = entry_data.Mid (4' 4).ToUInt (is_bigendian);  				ByteVector offset_data = entry_data.Mid (8' 4);    				IFDEntry entry = CreateIFDEntry (entry_tag' type' value_count' base_offset' offset_data' max_offset);    				if (entry == null)  					continue;    				if (directory.ContainsKey (entry.Tag))  					directory.Remove (entry.Tag);    				directory.Add (entry.Tag' entry);  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ReadIFD,The following statement contains a magic number: for (int i = 0; i < entry_count; i++) {  				ByteVector entry_data = entry_datas.Mid (i * 12' 12);    				ushort entry_tag = entry_data.Mid (0' 2).ToUShort (is_bigendian);  				ushort type = entry_data.Mid (2' 2).ToUShort (is_bigendian);  				uint value_count = entry_data.Mid (4' 4).ToUInt (is_bigendian);  				ByteVector offset_data = entry_data.Mid (8' 4);    				IFDEntry entry = CreateIFDEntry (entry_tag' type' value_count' base_offset' offset_data' max_offset);    				if (entry == null)  					continue;    				if (directory.ContainsKey (entry.Tag))  					directory.Remove (entry.Tag);    				directory.Add (entry.Tag' entry);  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ReadIFD,The following statement contains a magic number: for (int i = 0; i < entry_count; i++) {  				ByteVector entry_data = entry_datas.Mid (i * 12' 12);    				ushort entry_tag = entry_data.Mid (0' 2).ToUShort (is_bigendian);  				ushort type = entry_data.Mid (2' 2).ToUShort (is_bigendian);  				uint value_count = entry_data.Mid (4' 4).ToUInt (is_bigendian);  				ByteVector offset_data = entry_data.Mid (8' 4);    				IFDEntry entry = CreateIFDEntry (entry_tag' type' value_count' base_offset' offset_data' max_offset);    				if (entry == null)  					continue;    				if (directory.ContainsKey (entry.Tag))  					directory.Remove (entry.Tag);    				directory.Add (entry.Tag' entry);  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ReadIFD,The following statement contains a magic number: for (int i = 0; i < entry_count; i++) {  				ByteVector entry_data = entry_datas.Mid (i * 12' 12);    				ushort entry_tag = entry_data.Mid (0' 2).ToUShort (is_bigendian);  				ushort type = entry_data.Mid (2' 2).ToUShort (is_bigendian);  				uint value_count = entry_data.Mid (4' 4).ToUInt (is_bigendian);  				ByteVector offset_data = entry_data.Mid (8' 4);    				IFDEntry entry = CreateIFDEntry (entry_tag' type' value_count' base_offset' offset_data' max_offset);    				if (entry == null)  					continue;    				if (directory.ContainsKey (entry.Tag))  					directory.Remove (entry.Tag);    				directory.Add (entry.Tag' entry);  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ReadIFD,The following statement contains a magic number: for (int i = 0; i < entry_count; i++) {  				ByteVector entry_data = entry_datas.Mid (i * 12' 12);    				ushort entry_tag = entry_data.Mid (0' 2).ToUShort (is_bigendian);  				ushort type = entry_data.Mid (2' 2).ToUShort (is_bigendian);  				uint value_count = entry_data.Mid (4' 4).ToUInt (is_bigendian);  				ByteVector offset_data = entry_data.Mid (8' 4);    				IFDEntry entry = CreateIFDEntry (entry_tag' type' value_count' base_offset' offset_data' max_offset);    				if (entry == null)  					continue;    				if (directory.ContainsKey (entry.Tag))  					directory.Remove (entry.Tag);    				directory.Add (entry.Tag' entry);  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ReadIFD,The following statement contains a magic number: for (int i = 0; i < entry_count; i++) {  				ByteVector entry_data = entry_datas.Mid (i * 12' 12);    				ushort entry_tag = entry_data.Mid (0' 2).ToUShort (is_bigendian);  				ushort type = entry_data.Mid (2' 2).ToUShort (is_bigendian);  				uint value_count = entry_data.Mid (4' 4).ToUInt (is_bigendian);  				ByteVector offset_data = entry_data.Mid (8' 4);    				IFDEntry entry = CreateIFDEntry (entry_tag' type' value_count' base_offset' offset_data' max_offset);    				if (entry == null)  					continue;    				if (directory.ContainsKey (entry.Tag))  					directory.Remove (entry.Tag);    				directory.Add (entry.Tag' entry);  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,CreateIFDEntry,The following statement contains a magic number: if (count == 1) {  				if (type == (ushort) IFDEntryType.Byte)  					return new ByteIFDEntry (tag' offset_data[0]);    				if (type == (ushort) IFDEntryType.SByte)  					return new SByteIFDEntry (tag' (sbyte)offset_data[0]);    				if (type == (ushort) IFDEntryType.Short)  					return new ShortIFDEntry (tag' offset_data.Mid (0' 2).ToUShort (is_bigendian));    				if (type == (ushort) IFDEntryType.SShort)  					return new SShortIFDEntry (tag' (ushort) offset_data.Mid (0' 2).ToUShort (is_bigendian));    				if (type == (ushort) IFDEntryType.Long)  					return new LongIFDEntry (tag' offset_data.ToUInt (is_bigendian));    				if (type == (ushort) IFDEntryType.SLong)  					return new SLongIFDEntry (tag' offset_data.ToInt (is_bigendian));    			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,CreateIFDEntry,The following statement contains a magic number: if (count == 1) {  				if (type == (ushort) IFDEntryType.Byte)  					return new ByteIFDEntry (tag' offset_data[0]);    				if (type == (ushort) IFDEntryType.SByte)  					return new SByteIFDEntry (tag' (sbyte)offset_data[0]);    				if (type == (ushort) IFDEntryType.Short)  					return new ShortIFDEntry (tag' offset_data.Mid (0' 2).ToUShort (is_bigendian));    				if (type == (ushort) IFDEntryType.SShort)  					return new SShortIFDEntry (tag' (ushort) offset_data.Mid (0' 2).ToUShort (is_bigendian));    				if (type == (ushort) IFDEntryType.Long)  					return new LongIFDEntry (tag' offset_data.ToUInt (is_bigendian));    				if (type == (ushort) IFDEntryType.SLong)  					return new SLongIFDEntry (tag' offset_data.ToInt (is_bigendian));    			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,CreateIFDEntry,The following statement contains a magic number: if (count == 2) {  				if (type == (ushort) IFDEntryType.Short) {  					ushort [] data = new ushort [] {  						offset_data.Mid (0' 2).ToUShort (is_bigendian)'  						offset_data.Mid (2' 2).ToUShort (is_bigendian)  					};    					return new ShortArrayIFDEntry (tag' data);  				}    				if (type == (ushort) IFDEntryType.SShort) {  					short [] data = new short [] {  						(short) offset_data.Mid (0' 2).ToUShort (is_bigendian)'  						(short) offset_data.Mid (2' 2).ToUShort (is_bigendian)  					};    					return new SShortArrayIFDEntry (tag' data);  				}  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,CreateIFDEntry,The following statement contains a magic number: if (count == 2) {  				if (type == (ushort) IFDEntryType.Short) {  					ushort [] data = new ushort [] {  						offset_data.Mid (0' 2).ToUShort (is_bigendian)'  						offset_data.Mid (2' 2).ToUShort (is_bigendian)  					};    					return new ShortArrayIFDEntry (tag' data);  				}    				if (type == (ushort) IFDEntryType.SShort) {  					short [] data = new short [] {  						(short) offset_data.Mid (0' 2).ToUShort (is_bigendian)'  						(short) offset_data.Mid (2' 2).ToUShort (is_bigendian)  					};    					return new SShortArrayIFDEntry (tag' data);  				}  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,CreateIFDEntry,The following statement contains a magic number: if (count == 2) {  				if (type == (ushort) IFDEntryType.Short) {  					ushort [] data = new ushort [] {  						offset_data.Mid (0' 2).ToUShort (is_bigendian)'  						offset_data.Mid (2' 2).ToUShort (is_bigendian)  					};    					return new ShortArrayIFDEntry (tag' data);  				}    				if (type == (ushort) IFDEntryType.SShort) {  					short [] data = new short [] {  						(short) offset_data.Mid (0' 2).ToUShort (is_bigendian)'  						(short) offset_data.Mid (2' 2).ToUShort (is_bigendian)  					};    					return new SShortArrayIFDEntry (tag' data);  				}  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,CreateIFDEntry,The following statement contains a magic number: if (count == 2) {  				if (type == (ushort) IFDEntryType.Short) {  					ushort [] data = new ushort [] {  						offset_data.Mid (0' 2).ToUShort (is_bigendian)'  						offset_data.Mid (2' 2).ToUShort (is_bigendian)  					};    					return new ShortArrayIFDEntry (tag' data);  				}    				if (type == (ushort) IFDEntryType.SShort) {  					short [] data = new short [] {  						(short) offset_data.Mid (0' 2).ToUShort (is_bigendian)'  						(short) offset_data.Mid (2' 2).ToUShort (is_bigendian)  					};    					return new SShortArrayIFDEntry (tag' data);  				}  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,CreateIFDEntry,The following statement contains a magic number: if (count == 2) {  				if (type == (ushort) IFDEntryType.Short) {  					ushort [] data = new ushort [] {  						offset_data.Mid (0' 2).ToUShort (is_bigendian)'  						offset_data.Mid (2' 2).ToUShort (is_bigendian)  					};    					return new ShortArrayIFDEntry (tag' data);  				}    				if (type == (ushort) IFDEntryType.SShort) {  					short [] data = new short [] {  						(short) offset_data.Mid (0' 2).ToUShort (is_bigendian)'  						(short) offset_data.Mid (2' 2).ToUShort (is_bigendian)  					};    					return new SShortArrayIFDEntry (tag' data);  				}  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,CreateIFDEntry,The following statement contains a magic number: if (count == 2) {  				if (type == (ushort) IFDEntryType.Short) {  					ushort [] data = new ushort [] {  						offset_data.Mid (0' 2).ToUShort (is_bigendian)'  						offset_data.Mid (2' 2).ToUShort (is_bigendian)  					};    					return new ShortArrayIFDEntry (tag' data);  				}    				if (type == (ushort) IFDEntryType.SShort) {  					short [] data = new short [] {  						(short) offset_data.Mid (0' 2).ToUShort (is_bigendian)'  						(short) offset_data.Mid (2' 2).ToUShort (is_bigendian)  					};    					return new SShortArrayIFDEntry (tag' data);  				}  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,CreateIFDEntry,The following statement contains a magic number: if (count == 2) {  				if (type == (ushort) IFDEntryType.Short) {  					ushort [] data = new ushort [] {  						offset_data.Mid (0' 2).ToUShort (is_bigendian)'  						offset_data.Mid (2' 2).ToUShort (is_bigendian)  					};    					return new ShortArrayIFDEntry (tag' data);  				}    				if (type == (ushort) IFDEntryType.SShort) {  					short [] data = new short [] {  						(short) offset_data.Mid (0' 2).ToUShort (is_bigendian)'  						(short) offset_data.Mid (2' 2).ToUShort (is_bigendian)  					};    					return new SShortArrayIFDEntry (tag' data);  				}  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,CreateIFDEntry,The following statement contains a magic number: if (count <= 4) {  				if (type == (ushort) IFDEntryType.Undefined)  					return new UndefinedIFDEntry (tag' offset_data.Mid (0' (int)count));    				if (type == (ushort) IFDEntryType.Ascii) {  					string data = offset_data.Mid (0' (int)count).ToString ();  					int term = data.IndexOf ('\0');    					if (term > -1)  						data = data.Substring (0' term);    					return new StringIFDEntry (tag' data);  				}    				if (type == (ushort) IFDEntryType.Byte)  					return new ByteVectorIFDEntry (tag' offset_data.Mid (0' (int)count));  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,CreateIFDEntry,The following statement contains a magic number: if (count > 2) {  				if (type == (ushort) IFDEntryType.Short) {  					ushort [] data = ReadUShortArray (count);    					return new ShortArrayIFDEntry (tag' data);  				}    				if (type == (ushort) IFDEntryType.SShort) {  					short [] data = ReadShortArray (count);    					return new SShortArrayIFDEntry (tag' data);  				}  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,CreateIFDEntry,The following statement contains a magic number: if (count > 4) {  				if (type == (ushort) IFDEntryType.Long) {  					uint [] data = ReadUIntArray (count);    					return new LongArrayIFDEntry (tag' data);  				}    				if (type == (ushort) IFDEntryType.Byte) {  					ByteVector data = file.ReadBlock ((int) count);    					return new ByteVectorIFDEntry (tag' data);  				}    				if (type == (ushort) IFDEntryType.Ascii) {  					string data = ReadAsciiString ((int) count);    					return new StringIFDEntry (tag' data);  				}    				if (tag == (ushort) ExifEntryTag.UserComment) {  					ByteVector data = file.ReadBlock ((int) count);    					return new UserCommentIFDEntry (tag' data' file);  				}    				if (type == (ushort) IFDEntryType.Undefined) {  					ByteVector data = file.ReadBlock ((int) count);    					return new UndefinedIFDEntry (tag' data);  				}  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,CreateIFDEntry,The following statement contains a magic number: if (type == 0 || type > 12) {  				// Invalid type  				file.MarkAsCorrupt ("Invalid item type");  				return null;  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ReadShort,The following statement contains a magic number: return file.ReadBlock (2).ToShort (is_bigendian);
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ReadUShort,The following statement contains a magic number: return file.ReadBlock (2).ToUShort (is_bigendian);
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ReadInt,The following statement contains a magic number: return file.ReadBlock (4).ToInt (is_bigendian);
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ReadUInt,The following statement contains a magic number: return file.ReadBlock (4).ToUInt (is_bigendian);
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: int header_size = 18;
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: try {  				length = file.Length;  			} catch (Exception) {  				// Use a safety-value of 4 gigabyte.  				length = 1073741824L * 4;  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: if (header.StartsWith (PANASONIC_HEADER)) {  				IFDReader reader =  					new IFDReader (file' is_bigendian' ifd_structure' base_offset' offset + 12' max_offset);    				reader.ReadIFD (base_offset' offset + 12' max_offset);  				return new MakernoteIFDEntry (tag' ifd_structure' MakernoteType.Panasonic' PANASONIC_HEADER' 12' true' null);  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: if (header.StartsWith (PANASONIC_HEADER)) {  				IFDReader reader =  					new IFDReader (file' is_bigendian' ifd_structure' base_offset' offset + 12' max_offset);    				reader.ReadIFD (base_offset' offset + 12' max_offset);  				return new MakernoteIFDEntry (tag' ifd_structure' MakernoteType.Panasonic' PANASONIC_HEADER' 12' true' null);  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: if (header.StartsWith (PANASONIC_HEADER)) {  				IFDReader reader =  					new IFDReader (file' is_bigendian' ifd_structure' base_offset' offset + 12' max_offset);    				reader.ReadIFD (base_offset' offset + 12' max_offset);  				return new MakernoteIFDEntry (tag' ifd_structure' MakernoteType.Panasonic' PANASONIC_HEADER' 12' true' null);  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: if (header.StartsWith (PENTAX_HEADER)) {  				IFDReader reader =  					new IFDReader (file' is_bigendian' ifd_structure' base_offset' offset + 6' max_offset);    				reader.ReadIFD (base_offset' offset + 6' max_offset);  				return new MakernoteIFDEntry (tag' ifd_structure' MakernoteType.Pentax' header.Mid (0' 6)' 6' true' null);  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: if (header.StartsWith (PENTAX_HEADER)) {  				IFDReader reader =  					new IFDReader (file' is_bigendian' ifd_structure' base_offset' offset + 6' max_offset);    				reader.ReadIFD (base_offset' offset + 6' max_offset);  				return new MakernoteIFDEntry (tag' ifd_structure' MakernoteType.Pentax' header.Mid (0' 6)' 6' true' null);  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: if (header.StartsWith (PENTAX_HEADER)) {  				IFDReader reader =  					new IFDReader (file' is_bigendian' ifd_structure' base_offset' offset + 6' max_offset);    				reader.ReadIFD (base_offset' offset + 6' max_offset);  				return new MakernoteIFDEntry (tag' ifd_structure' MakernoteType.Pentax' header.Mid (0' 6)' 6' true' null);  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: if (header.StartsWith (PENTAX_HEADER)) {  				IFDReader reader =  					new IFDReader (file' is_bigendian' ifd_structure' base_offset' offset + 6' max_offset);    				reader.ReadIFD (base_offset' offset + 6' max_offset);  				return new MakernoteIFDEntry (tag' ifd_structure' MakernoteType.Pentax' header.Mid (0' 6)' 6' true' null);  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: if (header.StartsWith (OLYMPUS1_HEADER)) {  				IFDReader reader =  					new IFDReader (file' is_bigendian' ifd_structure' base_offset' offset + 8' max_offset);    				reader.Read ();  				return new MakernoteIFDEntry (tag' ifd_structure' MakernoteType.Olympus1' header.Mid (0' 8)' 8' true' null);  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: if (header.StartsWith (OLYMPUS1_HEADER)) {  				IFDReader reader =  					new IFDReader (file' is_bigendian' ifd_structure' base_offset' offset + 8' max_offset);    				reader.Read ();  				return new MakernoteIFDEntry (tag' ifd_structure' MakernoteType.Olympus1' header.Mid (0' 8)' 8' true' null);  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: if (header.StartsWith (OLYMPUS1_HEADER)) {  				IFDReader reader =  					new IFDReader (file' is_bigendian' ifd_structure' base_offset' offset + 8' max_offset);    				reader.Read ();  				return new MakernoteIFDEntry (tag' ifd_structure' MakernoteType.Olympus1' header.Mid (0' 8)' 8' true' null);  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: if (header.StartsWith (OLYMPUS2_HEADER)) {  				IFDReader reader =  					new IFDReader (file' is_bigendian' ifd_structure' makernote_offset' 12' count);    				reader.Read ();  				return new MakernoteIFDEntry (tag' ifd_structure' MakernoteType.Olympus2' header.Mid (0' 12)' 12' false' null);  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: if (header.StartsWith (OLYMPUS2_HEADER)) {  				IFDReader reader =  					new IFDReader (file' is_bigendian' ifd_structure' makernote_offset' 12' count);    				reader.Read ();  				return new MakernoteIFDEntry (tag' ifd_structure' MakernoteType.Olympus2' header.Mid (0' 12)' 12' false' null);  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: if (header.StartsWith (OLYMPUS2_HEADER)) {  				IFDReader reader =  					new IFDReader (file' is_bigendian' ifd_structure' makernote_offset' 12' count);    				reader.Read ();  				return new MakernoteIFDEntry (tag' ifd_structure' MakernoteType.Olympus2' header.Mid (0' 12)' 12' false' null);  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: if (header.StartsWith (SONY_HEADER)) {  				IFDReader reader =  					new IFDReader (file' is_bigendian' ifd_structure' base_offset' offset + 12' max_offset);    				reader.ReadIFD (base_offset' offset + 12' max_offset);  				return new MakernoteIFDEntry (tag' ifd_structure' MakernoteType.Sony' SONY_HEADER' 12' true' null);  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: if (header.StartsWith (SONY_HEADER)) {  				IFDReader reader =  					new IFDReader (file' is_bigendian' ifd_structure' base_offset' offset + 12' max_offset);    				reader.ReadIFD (base_offset' offset + 12' max_offset);  				return new MakernoteIFDEntry (tag' ifd_structure' MakernoteType.Sony' SONY_HEADER' 12' true' null);  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: if (header.StartsWith (SONY_HEADER)) {  				IFDReader reader =  					new IFDReader (file' is_bigendian' ifd_structure' base_offset' offset + 12' max_offset);    				reader.ReadIFD (base_offset' offset + 12' max_offset);  				return new MakernoteIFDEntry (tag' ifd_structure' MakernoteType.Sony' SONY_HEADER' 12' true' null);  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: if (header.StartsWith (NIKON_HEADER)) {    				ByteVector endian_bytes = header.Mid (10' 2);    				if (endian_bytes.ToString () == "II" || endian_bytes.ToString () == "MM") {    					bool makernote_endian = endian_bytes.ToString ().Equals ("MM");  					ushort magic = header.Mid (12' 2).ToUShort (is_bigendian);    					if (magic == 42) {    						// TODO: the max_offset value is not correct here. However' some nikon files have offsets to a sub-ifd  						// (preview image) which are not stored with the other makernote data. Therfore' we keep the max_offset  						// for now. (It is just an upper bound for some checks. So if it is too big' it doesn't matter)  						var reader =  							new Nikon3MakernoteReader (file' makernote_endian' ifd_structure' makernote_offset + 10' 8' max_offset - offset - 10);    						reader.Read ();  						return new MakernoteIFDEntry (tag' ifd_structure' MakernoteType.Nikon3' header.Mid (0' 18)' 8' false' makernote_endian);  					}  				}  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: if (header.StartsWith (NIKON_HEADER)) {    				ByteVector endian_bytes = header.Mid (10' 2);    				if (endian_bytes.ToString () == "II" || endian_bytes.ToString () == "MM") {    					bool makernote_endian = endian_bytes.ToString ().Equals ("MM");  					ushort magic = header.Mid (12' 2).ToUShort (is_bigendian);    					if (magic == 42) {    						// TODO: the max_offset value is not correct here. However' some nikon files have offsets to a sub-ifd  						// (preview image) which are not stored with the other makernote data. Therfore' we keep the max_offset  						// for now. (It is just an upper bound for some checks. So if it is too big' it doesn't matter)  						var reader =  							new Nikon3MakernoteReader (file' makernote_endian' ifd_structure' makernote_offset + 10' 8' max_offset - offset - 10);    						reader.Read ();  						return new MakernoteIFDEntry (tag' ifd_structure' MakernoteType.Nikon3' header.Mid (0' 18)' 8' false' makernote_endian);  					}  				}  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: if (header.StartsWith (NIKON_HEADER)) {    				ByteVector endian_bytes = header.Mid (10' 2);    				if (endian_bytes.ToString () == "II" || endian_bytes.ToString () == "MM") {    					bool makernote_endian = endian_bytes.ToString ().Equals ("MM");  					ushort magic = header.Mid (12' 2).ToUShort (is_bigendian);    					if (magic == 42) {    						// TODO: the max_offset value is not correct here. However' some nikon files have offsets to a sub-ifd  						// (preview image) which are not stored with the other makernote data. Therfore' we keep the max_offset  						// for now. (It is just an upper bound for some checks. So if it is too big' it doesn't matter)  						var reader =  							new Nikon3MakernoteReader (file' makernote_endian' ifd_structure' makernote_offset + 10' 8' max_offset - offset - 10);    						reader.Read ();  						return new MakernoteIFDEntry (tag' ifd_structure' MakernoteType.Nikon3' header.Mid (0' 18)' 8' false' makernote_endian);  					}  				}  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: if (header.StartsWith (NIKON_HEADER)) {    				ByteVector endian_bytes = header.Mid (10' 2);    				if (endian_bytes.ToString () == "II" || endian_bytes.ToString () == "MM") {    					bool makernote_endian = endian_bytes.ToString ().Equals ("MM");  					ushort magic = header.Mid (12' 2).ToUShort (is_bigendian);    					if (magic == 42) {    						// TODO: the max_offset value is not correct here. However' some nikon files have offsets to a sub-ifd  						// (preview image) which are not stored with the other makernote data. Therfore' we keep the max_offset  						// for now. (It is just an upper bound for some checks. So if it is too big' it doesn't matter)  						var reader =  							new Nikon3MakernoteReader (file' makernote_endian' ifd_structure' makernote_offset + 10' 8' max_offset - offset - 10);    						reader.Read ();  						return new MakernoteIFDEntry (tag' ifd_structure' MakernoteType.Nikon3' header.Mid (0' 18)' 8' false' makernote_endian);  					}  				}  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: if (header.StartsWith (NIKON_HEADER)) {    				ByteVector endian_bytes = header.Mid (10' 2);    				if (endian_bytes.ToString () == "II" || endian_bytes.ToString () == "MM") {    					bool makernote_endian = endian_bytes.ToString ().Equals ("MM");  					ushort magic = header.Mid (12' 2).ToUShort (is_bigendian);    					if (magic == 42) {    						// TODO: the max_offset value is not correct here. However' some nikon files have offsets to a sub-ifd  						// (preview image) which are not stored with the other makernote data. Therfore' we keep the max_offset  						// for now. (It is just an upper bound for some checks. So if it is too big' it doesn't matter)  						var reader =  							new Nikon3MakernoteReader (file' makernote_endian' ifd_structure' makernote_offset + 10' 8' max_offset - offset - 10);    						reader.Read ();  						return new MakernoteIFDEntry (tag' ifd_structure' MakernoteType.Nikon3' header.Mid (0' 18)' 8' false' makernote_endian);  					}  				}  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: if (header.StartsWith (NIKON_HEADER)) {    				ByteVector endian_bytes = header.Mid (10' 2);    				if (endian_bytes.ToString () == "II" || endian_bytes.ToString () == "MM") {    					bool makernote_endian = endian_bytes.ToString ().Equals ("MM");  					ushort magic = header.Mid (12' 2).ToUShort (is_bigendian);    					if (magic == 42) {    						// TODO: the max_offset value is not correct here. However' some nikon files have offsets to a sub-ifd  						// (preview image) which are not stored with the other makernote data. Therfore' we keep the max_offset  						// for now. (It is just an upper bound for some checks. So if it is too big' it doesn't matter)  						var reader =  							new Nikon3MakernoteReader (file' makernote_endian' ifd_structure' makernote_offset + 10' 8' max_offset - offset - 10);    						reader.Read ();  						return new MakernoteIFDEntry (tag' ifd_structure' MakernoteType.Nikon3' header.Mid (0' 18)' 8' false' makernote_endian);  					}  				}  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: if (header.StartsWith (NIKON_HEADER)) {    				ByteVector endian_bytes = header.Mid (10' 2);    				if (endian_bytes.ToString () == "II" || endian_bytes.ToString () == "MM") {    					bool makernote_endian = endian_bytes.ToString ().Equals ("MM");  					ushort magic = header.Mid (12' 2).ToUShort (is_bigendian);    					if (magic == 42) {    						// TODO: the max_offset value is not correct here. However' some nikon files have offsets to a sub-ifd  						// (preview image) which are not stored with the other makernote data. Therfore' we keep the max_offset  						// for now. (It is just an upper bound for some checks. So if it is too big' it doesn't matter)  						var reader =  							new Nikon3MakernoteReader (file' makernote_endian' ifd_structure' makernote_offset + 10' 8' max_offset - offset - 10);    						reader.Read ();  						return new MakernoteIFDEntry (tag' ifd_structure' MakernoteType.Nikon3' header.Mid (0' 18)' 8' false' makernote_endian);  					}  				}  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: if (header.StartsWith (NIKON_HEADER)) {    				ByteVector endian_bytes = header.Mid (10' 2);    				if (endian_bytes.ToString () == "II" || endian_bytes.ToString () == "MM") {    					bool makernote_endian = endian_bytes.ToString ().Equals ("MM");  					ushort magic = header.Mid (12' 2).ToUShort (is_bigendian);    					if (magic == 42) {    						// TODO: the max_offset value is not correct here. However' some nikon files have offsets to a sub-ifd  						// (preview image) which are not stored with the other makernote data. Therfore' we keep the max_offset  						// for now. (It is just an upper bound for some checks. So if it is too big' it doesn't matter)  						var reader =  							new Nikon3MakernoteReader (file' makernote_endian' ifd_structure' makernote_offset + 10' 8' max_offset - offset - 10);    						reader.Read ();  						return new MakernoteIFDEntry (tag' ifd_structure' MakernoteType.Nikon3' header.Mid (0' 18)' 8' false' makernote_endian);  					}  				}  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: if (header.StartsWith (NIKON_HEADER)) {    				ByteVector endian_bytes = header.Mid (10' 2);    				if (endian_bytes.ToString () == "II" || endian_bytes.ToString () == "MM") {    					bool makernote_endian = endian_bytes.ToString ().Equals ("MM");  					ushort magic = header.Mid (12' 2).ToUShort (is_bigendian);    					if (magic == 42) {    						// TODO: the max_offset value is not correct here. However' some nikon files have offsets to a sub-ifd  						// (preview image) which are not stored with the other makernote data. Therfore' we keep the max_offset  						// for now. (It is just an upper bound for some checks. So if it is too big' it doesn't matter)  						var reader =  							new Nikon3MakernoteReader (file' makernote_endian' ifd_structure' makernote_offset + 10' 8' max_offset - offset - 10);    						reader.Read ();  						return new MakernoteIFDEntry (tag' ifd_structure' MakernoteType.Nikon3' header.Mid (0' 18)' 8' false' makernote_endian);  					}  				}  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: if (header.StartsWith (NIKON_HEADER)) {    				ByteVector endian_bytes = header.Mid (10' 2);    				if (endian_bytes.ToString () == "II" || endian_bytes.ToString () == "MM") {    					bool makernote_endian = endian_bytes.ToString ().Equals ("MM");  					ushort magic = header.Mid (12' 2).ToUShort (is_bigendian);    					if (magic == 42) {    						// TODO: the max_offset value is not correct here. However' some nikon files have offsets to a sub-ifd  						// (preview image) which are not stored with the other makernote data. Therfore' we keep the max_offset  						// for now. (It is just an upper bound for some checks. So if it is too big' it doesn't matter)  						var reader =  							new Nikon3MakernoteReader (file' makernote_endian' ifd_structure' makernote_offset + 10' 8' max_offset - offset - 10);    						reader.Read ();  						return new MakernoteIFDEntry (tag' ifd_structure' MakernoteType.Nikon3' header.Mid (0' 18)' 8' false' makernote_endian);  					}  				}  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: if (header.StartsWith (LEICA_HEADER)) {  				IFDReader reader = new IFDReader (file' is_bigendian' ifd_structure' makernote_offset' 8' count);    				reader.Read ();  				return new MakernoteIFDEntry (tag' ifd_structure' MakernoteType.Leica' header.Mid (0' 8)' 10' false' null);  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: if (header.StartsWith (LEICA_HEADER)) {  				IFDReader reader = new IFDReader (file' is_bigendian' ifd_structure' makernote_offset' 8' count);    				reader.Read ();  				return new MakernoteIFDEntry (tag' ifd_structure' MakernoteType.Leica' header.Mid (0' 8)' 10' false' null);  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseMakernote,The following statement contains a magic number: if (header.StartsWith (LEICA_HEADER)) {  				IFDReader reader = new IFDReader (file' is_bigendian' ifd_structure' makernote_offset' 8' count);    				reader.Read ();  				return new MakernoteIFDEntry (tag' ifd_structure' MakernoteType.Leica' header.Mid (0' 8)' 10' false' null);  			}
Magic Number,TagLib.IFD,IFDReader,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDReader.cs,ParseIFDEntry,The following statement contains a magic number: if (tag == (ushort) IFDEntryTag.SubIFDs) {  				var entries = new List<IFDStructure> ();    				uint [] data;  				if (count >= 2) {    					// This is impossible right?  					if (base_offset + offset > file.Length) {  						file.MarkAsCorrupt ("Length of SubIFD is too long");  						return null;  					}    					file.Seek (base_offset + offset' SeekOrigin.Begin);  					data = ReadUIntArray (count);  				} else {  					data = new uint [] { offset };  				}    				foreach (var sub_offset in data) {  					var sub_structure = new IFDStructure ();  					var sub_reader = CreateSubIFDReader (file' is_bigendian' sub_structure' base_offset' sub_offset' max_offset);  					sub_reader.Read ();    					entries.Add (sub_structure);  				}  				return new SubIFDArrayEntry (tag' entries);  			}
Magic Number,TagLib.IFD,IFDRenderer,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDRenderer.cs,RenderIFD,The following statement contains a magic number: uint data_offset = ifd_offset + 2 + 12 * (uint) entry_count + 4;
Magic Number,TagLib.IFD,IFDRenderer,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDRenderer.cs,RenderIFD,The following statement contains a magic number: uint data_offset = ifd_offset + 2 + 12 * (uint) entry_count + 4;
Magic Number,TagLib.IFD,IFDRenderer,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDRenderer.cs,RenderIFD,The following statement contains a magic number: uint data_offset = ifd_offset + 2 + 12 * (uint) entry_count + 4;
Magic Number,TagLib.IFD,IFDRenderer,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDRenderer.cs,RenderEntryData,The following statement contains a magic number: if (data.Count <= 4) {    				while (data.Count < 4)  					data.Add ("\0");    				offset = data.ToUInt (is_bigendian);  				data = null;  			}
Magic Number,TagLib.IFD,IFDRenderer,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDRenderer.cs,RenderEntryData,The following statement contains a magic number: if (data.Count <= 4) {    				while (data.Count < 4)  					data.Add ("\0");    				offset = data.ToUInt (is_bigendian);  				data = null;  			}
Magic Number,TagLib.IFD,IFDRenderer,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDRenderer.cs,RenderEntryData,The following statement contains a magic number: if (data != null && data.Count % 2 != 0)  				data.Add ("\0");
Magic Number,TagLib.IFD,IFDTag,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDTag.cs,DegreeToRationals,The following statement contains a magic number: if (angle < 0.0 || angle > 180.0)  				throw new ArgumentException ("angle");
Magic Number,TagLib.IFD,IFDTag,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDTag.cs,DegreeToRationals,The following statement contains a magic number: uint min = (uint) ((angle - Math.Floor (angle)) * 60.0);
Magic Number,TagLib.IFD,IFDTag,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDTag.cs,DegreeToRationals,The following statement contains a magic number: uint sec = (uint) ((angle - Math.Floor (angle) - (min / 60.0))  * 360000000.0);
Magic Number,TagLib.IFD,IFDTag,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDTag.cs,DegreeToRationals,The following statement contains a magic number: uint sec = (uint) ((angle - Math.Floor (angle) - (min / 60.0))  * 360000000.0);
Magic Number,TagLib.IFD,IFDTag,C:\repos\mono_taglib-sharp\src\TagLib\IFD\IFDTag.cs,DegreeToRationals,The following statement contains a magic number: Rational[] rationals = new Rational [] {  				new Rational (deg' 1)'  				new Rational (min' 1)'  				new Rational (sec' 100000)  			};
Magic Number,TagLib.IFD.Entries,StripOffsetsIFDEntry,C:\repos\mono_taglib-sharp\src\TagLib\IFD\Entries\StripOffsetsIFDEntry.cs,Render,The following statement contains a magic number: uint data_offset = offset + (uint) (4 * Values.Length);
Magic Number,TagLib.IFD.Entries,StripOffsetsIFDEntry,C:\repos\mono_taglib-sharp\src\TagLib\IFD\Entries\StripOffsetsIFDEntry.cs,Render,The following statement contains a magic number: while (data.Count < 4)  				data.Add (0x00);
Magic Number,TagLib.IFD.Entries,UserCommentIFDEntry,C:\repos\mono_taglib-sharp\src\TagLib\IFD\Entries\UserCommentIFDEntry.cs,UserCommentIFDEntry,The following statement contains a magic number: if (data.StartsWith ((byte) 0x00) && data.Count >= 8) {    				// And CanonZoomBrowser fills some trailing bytes of the comment field  				// with '\0'. So we return only the characters before the first '\0'.  				int term = data.Find ("\0"' 8);  				if (term != -1) {  					Value = data.ToString (StringType.Latin1' 8' term - 8);  				} else {  					Value = data.ToString (StringType.Latin1' 8' data.Count - 8);  				}  				return;  			}
Magic Number,TagLib.IFD.Entries,UserCommentIFDEntry,C:\repos\mono_taglib-sharp\src\TagLib\IFD\Entries\UserCommentIFDEntry.cs,UserCommentIFDEntry,The following statement contains a magic number: if (data.StartsWith ((byte) 0x00) && data.Count >= 8) {    				// And CanonZoomBrowser fills some trailing bytes of the comment field  				// with '\0'. So we return only the characters before the first '\0'.  				int term = data.Find ("\0"' 8);  				if (term != -1) {  					Value = data.ToString (StringType.Latin1' 8' term - 8);  				} else {  					Value = data.ToString (StringType.Latin1' 8' data.Count - 8);  				}  				return;  			}
Magic Number,TagLib.IFD.Entries,UserCommentIFDEntry,C:\repos\mono_taglib-sharp\src\TagLib\IFD\Entries\UserCommentIFDEntry.cs,UserCommentIFDEntry,The following statement contains a magic number: if (data.StartsWith ((byte) 0x00) && data.Count >= 8) {    				// And CanonZoomBrowser fills some trailing bytes of the comment field  				// with '\0'. So we return only the characters before the first '\0'.  				int term = data.Find ("\0"' 8);  				if (term != -1) {  					Value = data.ToString (StringType.Latin1' 8' term - 8);  				} else {  					Value = data.ToString (StringType.Latin1' 8' data.Count - 8);  				}  				return;  			}
Magic Number,TagLib.IFD.Entries,UserCommentIFDEntry,C:\repos\mono_taglib-sharp\src\TagLib\IFD\Entries\UserCommentIFDEntry.cs,UserCommentIFDEntry,The following statement contains a magic number: if (data.StartsWith ((byte) 0x00) && data.Count >= 8) {    				// And CanonZoomBrowser fills some trailing bytes of the comment field  				// with '\0'. So we return only the characters before the first '\0'.  				int term = data.Find ("\0"' 8);  				if (term != -1) {  					Value = data.ToString (StringType.Latin1' 8' term - 8);  				} else {  					Value = data.ToString (StringType.Latin1' 8' data.Count - 8);  				}  				return;  			}
Magic Number,TagLib.IFD.Entries,UserCommentIFDEntry,C:\repos\mono_taglib-sharp\src\TagLib\IFD\Entries\UserCommentIFDEntry.cs,UserCommentIFDEntry,The following statement contains a magic number: if (data.StartsWith ((byte) 0x00) && data.Count >= 8) {    				// And CanonZoomBrowser fills some trailing bytes of the comment field  				// with '\0'. So we return only the characters before the first '\0'.  				int term = data.Find ("\0"' 8);  				if (term != -1) {  					Value = data.ToString (StringType.Latin1' 8' term - 8);  				} else {  					Value = data.ToString (StringType.Latin1' 8' data.Count - 8);  				}  				return;  			}
Magic Number,TagLib.IFD.Entries,UserCommentIFDEntry,C:\repos\mono_taglib-sharp\src\TagLib\IFD\Entries\UserCommentIFDEntry.cs,UserCommentIFDEntry,The following statement contains a magic number: if (data.StartsWith ((byte) 0x00) && data.Count >= 8) {    				// And CanonZoomBrowser fills some trailing bytes of the comment field  				// with '\0'. So we return only the characters before the first '\0'.  				int term = data.Find ("\0"' 8);  				if (term != -1) {  					Value = data.ToString (StringType.Latin1' 8' term - 8);  				} else {  					Value = data.ToString (StringType.Latin1' 8' data.Count - 8);  				}  				return;  			}
Magic Number,TagLib.IIM,IIMReader,C:\repos\mono_taglib-sharp\src\TagLib\IIM\IIMReader.cs,Process,The following statement contains a magic number: for (int i = Data.Find (IPTC_IIM_SEGMENT' findOffset); i >= findOffset; i = Data.Find (IPTC_IIM_SEGMENT' findOffset)) {  				count++;  				// skip over segment marker  				i += IPTC_IIM_SEGMENT.Length;    				int len = Data.Mid (i + 1).ToUShort ();    				// ENHANCE: enhance encoding used for string conversion. Unfortunately this is  				// not detectable from IIM data.  				switch (Data [i]) {  					case 5: // Object Name  						Tag.Title = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 25: // Keywords  						Tag.AddKeyword (Data.ToString (StringType.Latin1' i + 3' len));  						break;  					case 80: // By-line  						Tag.Creator = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 116: // Copyright notice  						Tag.Copyright = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 120: // Caption/Abstract  						Tag.Comment = Data.ToString (StringType.Latin1' i + 3' len);  						break;  				}  				findOffset = i + 3 + len;  			}
Magic Number,TagLib.IIM,IIMReader,C:\repos\mono_taglib-sharp\src\TagLib\IIM\IIMReader.cs,Process,The following statement contains a magic number: for (int i = Data.Find (IPTC_IIM_SEGMENT' findOffset); i >= findOffset; i = Data.Find (IPTC_IIM_SEGMENT' findOffset)) {  				count++;  				// skip over segment marker  				i += IPTC_IIM_SEGMENT.Length;    				int len = Data.Mid (i + 1).ToUShort ();    				// ENHANCE: enhance encoding used for string conversion. Unfortunately this is  				// not detectable from IIM data.  				switch (Data [i]) {  					case 5: // Object Name  						Tag.Title = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 25: // Keywords  						Tag.AddKeyword (Data.ToString (StringType.Latin1' i + 3' len));  						break;  					case 80: // By-line  						Tag.Creator = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 116: // Copyright notice  						Tag.Copyright = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 120: // Caption/Abstract  						Tag.Comment = Data.ToString (StringType.Latin1' i + 3' len);  						break;  				}  				findOffset = i + 3 + len;  			}
Magic Number,TagLib.IIM,IIMReader,C:\repos\mono_taglib-sharp\src\TagLib\IIM\IIMReader.cs,Process,The following statement contains a magic number: for (int i = Data.Find (IPTC_IIM_SEGMENT' findOffset); i >= findOffset; i = Data.Find (IPTC_IIM_SEGMENT' findOffset)) {  				count++;  				// skip over segment marker  				i += IPTC_IIM_SEGMENT.Length;    				int len = Data.Mid (i + 1).ToUShort ();    				// ENHANCE: enhance encoding used for string conversion. Unfortunately this is  				// not detectable from IIM data.  				switch (Data [i]) {  					case 5: // Object Name  						Tag.Title = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 25: // Keywords  						Tag.AddKeyword (Data.ToString (StringType.Latin1' i + 3' len));  						break;  					case 80: // By-line  						Tag.Creator = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 116: // Copyright notice  						Tag.Copyright = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 120: // Caption/Abstract  						Tag.Comment = Data.ToString (StringType.Latin1' i + 3' len);  						break;  				}  				findOffset = i + 3 + len;  			}
Magic Number,TagLib.IIM,IIMReader,C:\repos\mono_taglib-sharp\src\TagLib\IIM\IIMReader.cs,Process,The following statement contains a magic number: for (int i = Data.Find (IPTC_IIM_SEGMENT' findOffset); i >= findOffset; i = Data.Find (IPTC_IIM_SEGMENT' findOffset)) {  				count++;  				// skip over segment marker  				i += IPTC_IIM_SEGMENT.Length;    				int len = Data.Mid (i + 1).ToUShort ();    				// ENHANCE: enhance encoding used for string conversion. Unfortunately this is  				// not detectable from IIM data.  				switch (Data [i]) {  					case 5: // Object Name  						Tag.Title = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 25: // Keywords  						Tag.AddKeyword (Data.ToString (StringType.Latin1' i + 3' len));  						break;  					case 80: // By-line  						Tag.Creator = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 116: // Copyright notice  						Tag.Copyright = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 120: // Caption/Abstract  						Tag.Comment = Data.ToString (StringType.Latin1' i + 3' len);  						break;  				}  				findOffset = i + 3 + len;  			}
Magic Number,TagLib.IIM,IIMReader,C:\repos\mono_taglib-sharp\src\TagLib\IIM\IIMReader.cs,Process,The following statement contains a magic number: for (int i = Data.Find (IPTC_IIM_SEGMENT' findOffset); i >= findOffset; i = Data.Find (IPTC_IIM_SEGMENT' findOffset)) {  				count++;  				// skip over segment marker  				i += IPTC_IIM_SEGMENT.Length;    				int len = Data.Mid (i + 1).ToUShort ();    				// ENHANCE: enhance encoding used for string conversion. Unfortunately this is  				// not detectable from IIM data.  				switch (Data [i]) {  					case 5: // Object Name  						Tag.Title = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 25: // Keywords  						Tag.AddKeyword (Data.ToString (StringType.Latin1' i + 3' len));  						break;  					case 80: // By-line  						Tag.Creator = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 116: // Copyright notice  						Tag.Copyright = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 120: // Caption/Abstract  						Tag.Comment = Data.ToString (StringType.Latin1' i + 3' len);  						break;  				}  				findOffset = i + 3 + len;  			}
Magic Number,TagLib.IIM,IIMReader,C:\repos\mono_taglib-sharp\src\TagLib\IIM\IIMReader.cs,Process,The following statement contains a magic number: for (int i = Data.Find (IPTC_IIM_SEGMENT' findOffset); i >= findOffset; i = Data.Find (IPTC_IIM_SEGMENT' findOffset)) {  				count++;  				// skip over segment marker  				i += IPTC_IIM_SEGMENT.Length;    				int len = Data.Mid (i + 1).ToUShort ();    				// ENHANCE: enhance encoding used for string conversion. Unfortunately this is  				// not detectable from IIM data.  				switch (Data [i]) {  					case 5: // Object Name  						Tag.Title = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 25: // Keywords  						Tag.AddKeyword (Data.ToString (StringType.Latin1' i + 3' len));  						break;  					case 80: // By-line  						Tag.Creator = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 116: // Copyright notice  						Tag.Copyright = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 120: // Caption/Abstract  						Tag.Comment = Data.ToString (StringType.Latin1' i + 3' len);  						break;  				}  				findOffset = i + 3 + len;  			}
Magic Number,TagLib.IIM,IIMReader,C:\repos\mono_taglib-sharp\src\TagLib\IIM\IIMReader.cs,Process,The following statement contains a magic number: for (int i = Data.Find (IPTC_IIM_SEGMENT' findOffset); i >= findOffset; i = Data.Find (IPTC_IIM_SEGMENT' findOffset)) {  				count++;  				// skip over segment marker  				i += IPTC_IIM_SEGMENT.Length;    				int len = Data.Mid (i + 1).ToUShort ();    				// ENHANCE: enhance encoding used for string conversion. Unfortunately this is  				// not detectable from IIM data.  				switch (Data [i]) {  					case 5: // Object Name  						Tag.Title = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 25: // Keywords  						Tag.AddKeyword (Data.ToString (StringType.Latin1' i + 3' len));  						break;  					case 80: // By-line  						Tag.Creator = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 116: // Copyright notice  						Tag.Copyright = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 120: // Caption/Abstract  						Tag.Comment = Data.ToString (StringType.Latin1' i + 3' len);  						break;  				}  				findOffset = i + 3 + len;  			}
Magic Number,TagLib.IIM,IIMReader,C:\repos\mono_taglib-sharp\src\TagLib\IIM\IIMReader.cs,Process,The following statement contains a magic number: for (int i = Data.Find (IPTC_IIM_SEGMENT' findOffset); i >= findOffset; i = Data.Find (IPTC_IIM_SEGMENT' findOffset)) {  				count++;  				// skip over segment marker  				i += IPTC_IIM_SEGMENT.Length;    				int len = Data.Mid (i + 1).ToUShort ();    				// ENHANCE: enhance encoding used for string conversion. Unfortunately this is  				// not detectable from IIM data.  				switch (Data [i]) {  					case 5: // Object Name  						Tag.Title = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 25: // Keywords  						Tag.AddKeyword (Data.ToString (StringType.Latin1' i + 3' len));  						break;  					case 80: // By-line  						Tag.Creator = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 116: // Copyright notice  						Tag.Copyright = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 120: // Caption/Abstract  						Tag.Comment = Data.ToString (StringType.Latin1' i + 3' len);  						break;  				}  				findOffset = i + 3 + len;  			}
Magic Number,TagLib.IIM,IIMReader,C:\repos\mono_taglib-sharp\src\TagLib\IIM\IIMReader.cs,Process,The following statement contains a magic number: for (int i = Data.Find (IPTC_IIM_SEGMENT' findOffset); i >= findOffset; i = Data.Find (IPTC_IIM_SEGMENT' findOffset)) {  				count++;  				// skip over segment marker  				i += IPTC_IIM_SEGMENT.Length;    				int len = Data.Mid (i + 1).ToUShort ();    				// ENHANCE: enhance encoding used for string conversion. Unfortunately this is  				// not detectable from IIM data.  				switch (Data [i]) {  					case 5: // Object Name  						Tag.Title = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 25: // Keywords  						Tag.AddKeyword (Data.ToString (StringType.Latin1' i + 3' len));  						break;  					case 80: // By-line  						Tag.Creator = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 116: // Copyright notice  						Tag.Copyright = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 120: // Caption/Abstract  						Tag.Comment = Data.ToString (StringType.Latin1' i + 3' len);  						break;  				}  				findOffset = i + 3 + len;  			}
Magic Number,TagLib.IIM,IIMReader,C:\repos\mono_taglib-sharp\src\TagLib\IIM\IIMReader.cs,Process,The following statement contains a magic number: for (int i = Data.Find (IPTC_IIM_SEGMENT' findOffset); i >= findOffset; i = Data.Find (IPTC_IIM_SEGMENT' findOffset)) {  				count++;  				// skip over segment marker  				i += IPTC_IIM_SEGMENT.Length;    				int len = Data.Mid (i + 1).ToUShort ();    				// ENHANCE: enhance encoding used for string conversion. Unfortunately this is  				// not detectable from IIM data.  				switch (Data [i]) {  					case 5: // Object Name  						Tag.Title = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 25: // Keywords  						Tag.AddKeyword (Data.ToString (StringType.Latin1' i + 3' len));  						break;  					case 80: // By-line  						Tag.Creator = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 116: // Copyright notice  						Tag.Copyright = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 120: // Caption/Abstract  						Tag.Comment = Data.ToString (StringType.Latin1' i + 3' len);  						break;  				}  				findOffset = i + 3 + len;  			}
Magic Number,TagLib.IIM,IIMReader,C:\repos\mono_taglib-sharp\src\TagLib\IIM\IIMReader.cs,Process,The following statement contains a magic number: for (int i = Data.Find (IPTC_IIM_SEGMENT' findOffset); i >= findOffset; i = Data.Find (IPTC_IIM_SEGMENT' findOffset)) {  				count++;  				// skip over segment marker  				i += IPTC_IIM_SEGMENT.Length;    				int len = Data.Mid (i + 1).ToUShort ();    				// ENHANCE: enhance encoding used for string conversion. Unfortunately this is  				// not detectable from IIM data.  				switch (Data [i]) {  					case 5: // Object Name  						Tag.Title = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 25: // Keywords  						Tag.AddKeyword (Data.ToString (StringType.Latin1' i + 3' len));  						break;  					case 80: // By-line  						Tag.Creator = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 116: // Copyright notice  						Tag.Copyright = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 120: // Caption/Abstract  						Tag.Comment = Data.ToString (StringType.Latin1' i + 3' len);  						break;  				}  				findOffset = i + 3 + len;  			}
Magic Number,TagLib.Id3v1,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v1\Tag.cs,Render,The following statement contains a magic number: data.Add (string_handler.Render (title  ).Resize (30));
Magic Number,TagLib.Id3v1,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v1\Tag.cs,Render,The following statement contains a magic number: data.Add (string_handler.Render (artist ).Resize (30));
Magic Number,TagLib.Id3v1,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v1\Tag.cs,Render,The following statement contains a magic number: data.Add (string_handler.Render (album  ).Resize (30));
Magic Number,TagLib.Id3v1,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v1\Tag.cs,Render,The following statement contains a magic number: data.Add (string_handler.Render (year   ).Resize ( 4));
Magic Number,TagLib.Id3v1,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v1\Tag.cs,Render,The following statement contains a magic number: data.Add (string_handler.Render (comment).Resize (28));
Magic Number,TagLib.Id3v1,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v1\Tag.cs,Parse,The following statement contains a magic number: title  = string_handler.Parse (data.Mid ( 3' 30));
Magic Number,TagLib.Id3v1,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v1\Tag.cs,Parse,The following statement contains a magic number: title  = string_handler.Parse (data.Mid ( 3' 30));
Magic Number,TagLib.Id3v1,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v1\Tag.cs,Parse,The following statement contains a magic number: artist = string_handler.Parse (data.Mid (33' 30));
Magic Number,TagLib.Id3v1,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v1\Tag.cs,Parse,The following statement contains a magic number: artist = string_handler.Parse (data.Mid (33' 30));
Magic Number,TagLib.Id3v1,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v1\Tag.cs,Parse,The following statement contains a magic number: album  = string_handler.Parse (data.Mid (63' 30));
Magic Number,TagLib.Id3v1,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v1\Tag.cs,Parse,The following statement contains a magic number: album  = string_handler.Parse (data.Mid (63' 30));
Magic Number,TagLib.Id3v1,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v1\Tag.cs,Parse,The following statement contains a magic number: year   = string_handler.Parse (data.Mid (93'  4));
Magic Number,TagLib.Id3v1,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v1\Tag.cs,Parse,The following statement contains a magic number: year   = string_handler.Parse (data.Mid (93'  4));
Magic Number,TagLib.Id3v1,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v1\Tag.cs,Parse,The following statement contains a magic number: if (data [125] == 0 && data [126] != 0) {  				// ID3v1.1 detected  				comment = string_handler.Parse (data.Mid (97' 28));  				track = data [126];  			} else {  				comment = string_handler.Parse (data.Mid (97' 30));  			}
Magic Number,TagLib.Id3v1,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v1\Tag.cs,Parse,The following statement contains a magic number: if (data [125] == 0 && data [126] != 0) {  				// ID3v1.1 detected  				comment = string_handler.Parse (data.Mid (97' 28));  				track = data [126];  			} else {  				comment = string_handler.Parse (data.Mid (97' 30));  			}
Magic Number,TagLib.Id3v1,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v1\Tag.cs,Parse,The following statement contains a magic number: if (data [125] == 0 && data [126] != 0) {  				// ID3v1.1 detected  				comment = string_handler.Parse (data.Mid (97' 28));  				track = data [126];  			} else {  				comment = string_handler.Parse (data.Mid (97' 30));  			}
Magic Number,TagLib.Id3v1,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v1\Tag.cs,Parse,The following statement contains a magic number: if (data [125] == 0 && data [126] != 0) {  				// ID3v1.1 detected  				comment = string_handler.Parse (data.Mid (97' 28));  				track = data [126];  			} else {  				comment = string_handler.Parse (data.Mid (97' 30));  			}
Magic Number,TagLib.Id3v1,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v1\Tag.cs,Parse,The following statement contains a magic number: if (data [125] == 0 && data [126] != 0) {  				// ID3v1.1 detected  				comment = string_handler.Parse (data.Mid (97' 28));  				track = data [126];  			} else {  				comment = string_handler.Parse (data.Mid (97' 30));  			}
Magic Number,TagLib.Id3v1,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v1\Tag.cs,Parse,The following statement contains a magic number: if (data [125] == 0 && data [126] != 0) {  				// ID3v1.1 detected  				comment = string_handler.Parse (data.Mid (97' 28));  				track = data [126];  			} else {  				comment = string_handler.Parse (data.Mid (97' 30));  			}
Magic Number,TagLib.Id3v1,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v1\Tag.cs,Parse,The following statement contains a magic number: if (data [125] == 0 && data [126] != 0) {  				// ID3v1.1 detected  				comment = string_handler.Parse (data.Mid (97' 28));  				track = data [126];  			} else {  				comment = string_handler.Parse (data.Mid (97' 30));  			}
Magic Number,TagLib.Id3v1,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v1\Tag.cs,Parse,The following statement contains a magic number: genre = data [127];
Magic Number,TagLib.Id3v1,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v1\Tag.cs,Clear,The following statement contains a magic number: genre = 255;
Magic Number,TagLib.Id3v2,ExtendedHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\ExtendedHeader.cs,Parse,The following statement contains a magic number: size = (version == 3 ? 4u : 0u) + SynchData.ToUInt (data.Mid (0' 4));
Magic Number,TagLib.Id3v2,ExtendedHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\ExtendedHeader.cs,Parse,The following statement contains a magic number: size = (version == 3 ? 4u : 0u) + SynchData.ToUInt (data.Mid (0' 4));
Magic Number,TagLib.Id3v2,Footer,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Footer.cs,Footer,The following statement contains a magic number: major_version = data [3];
Magic Number,TagLib.Id3v2,Footer,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Footer.cs,Footer,The following statement contains a magic number: revision_number = data [4];
Magic Number,TagLib.Id3v2,Footer,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Footer.cs,Footer,The following statement contains a magic number: flags = (HeaderFlags) data [5];
Magic Number,TagLib.Id3v2,Footer,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Footer.cs,Footer,The following statement contains a magic number: if (major_version == 2 && ((int) flags & 127) != 0)  				throw new CorruptFileException (  					"Invalid flags set on version 2 tag.");
Magic Number,TagLib.Id3v2,Footer,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Footer.cs,Footer,The following statement contains a magic number: if (major_version == 2 && ((int) flags & 127) != 0)  				throw new CorruptFileException (  					"Invalid flags set on version 2 tag.");
Magic Number,TagLib.Id3v2,Footer,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Footer.cs,Footer,The following statement contains a magic number: if (major_version == 3 && ((int) flags & 15) != 0)  				throw new CorruptFileException (  					"Invalid flags set on version 3 tag.");
Magic Number,TagLib.Id3v2,Footer,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Footer.cs,Footer,The following statement contains a magic number: if (major_version == 3 && ((int) flags & 15) != 0)  				throw new CorruptFileException (  					"Invalid flags set on version 3 tag.");
Magic Number,TagLib.Id3v2,Footer,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Footer.cs,Footer,The following statement contains a magic number: if (major_version == 4 && ((int) flags & 7) != 0)  				throw new CorruptFileException (  					"Invalid flags set on version 4 tag.");
Magic Number,TagLib.Id3v2,Footer,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Footer.cs,Footer,The following statement contains a magic number: if (major_version == 4 && ((int) flags & 7) != 0)  				throw new CorruptFileException (  					"Invalid flags set on version 4 tag.");
Magic Number,TagLib.Id3v2,Footer,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Footer.cs,Footer,The following statement contains a magic number: for (int i = 6; i < 10; i ++)  				if (data [i] >= 128)  					throw new CorruptFileException (  						"One of the bytes in the header was greater than the allowed 128.");
Magic Number,TagLib.Id3v2,Footer,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Footer.cs,Footer,The following statement contains a magic number: for (int i = 6; i < 10; i ++)  				if (data [i] >= 128)  					throw new CorruptFileException (  						"One of the bytes in the header was greater than the allowed 128.");
Magic Number,TagLib.Id3v2,Footer,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Footer.cs,Footer,The following statement contains a magic number: for (int i = 6; i < 10; i ++)  				if (data [i] >= 128)  					throw new CorruptFileException (  						"One of the bytes in the header was greater than the allowed 128.");
Magic Number,TagLib.Id3v2,Footer,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Footer.cs,Footer,The following statement contains a magic number: tag_size = SynchData.ToUInt (data.Mid (6' 4));
Magic Number,TagLib.Id3v2,Footer,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Footer.cs,Footer,The following statement contains a magic number: tag_size = SynchData.ToUInt (data.Mid (6' 4));
Magic Number,TagLib.Id3v2,Frame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frame.cs,Frame,The following statement contains a magic number: if (data.Count < ((version < 3) ? 3 : 4))  				throw new ArgumentException (  					"Data contains an incomplete identifier."'  					"data");
Magic Number,TagLib.Id3v2,Frame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frame.cs,Frame,The following statement contains a magic number: if (data.Count < ((version < 3) ? 3 : 4))  				throw new ArgumentException (  					"Data contains an incomplete identifier."'  					"data");
Magic Number,TagLib.Id3v2,Frame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frame.cs,Frame,The following statement contains a magic number: if (data.Count < ((version < 3) ? 3 : 4))  				throw new ArgumentException (  					"Data contains an incomplete identifier."'  					"data");
Magic Number,TagLib.Id3v2,Frame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frame.cs,Render,The following statement contains a magic number: if (version < 4)  				Flags &= ~(FrameFlags.DataLengthIndicator |  					FrameFlags.Unsynchronisation);
Magic Number,TagLib.Id3v2,Frame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frame.cs,Render,The following statement contains a magic number: if (version < 3)  				Flags &= ~(FrameFlags.Compression |  					FrameFlags.Encryption |  					FrameFlags.FileAlterPreservation |  					FrameFlags.GroupingIdentity |  					FrameFlags.ReadOnly |  					FrameFlags.TagAlterPreservation);
Magic Number,TagLib.Id3v2,Frame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frame.cs,CorrectEncoding,The following statement contains a magic number: return (version < 4 && type == StringType.UTF8) ?  				StringType.UTF16 : type;
Magic Number,TagLib.Id3v2,Frame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frame.cs,FieldData,The following statement contains a magic number: if ((Flags & (FrameFlags.Compression |  				FrameFlags.DataLengthIndicator)) != 0) {  				data_offset += 4;  				data_length -= 4;  			}
Magic Number,TagLib.Id3v2,Frame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frame.cs,FieldData,The following statement contains a magic number: if ((Flags & (FrameFlags.Compression |  				FrameFlags.DataLengthIndicator)) != 0) {  				data_offset += 4;  				data_length -= 4;  			}
Magic Number,TagLib.Id3v2,Frame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frame.cs,Clone,The following statement contains a magic number: return FrameFactory.CreateFrame (Render (4)' ref index'  				4' false);
Magic Number,TagLib.Id3v2,Frame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frame.cs,Clone,The following statement contains a magic number: return FrameFactory.CreateFrame (Render (4)' ref index'  				4' false);
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,FrameHeader,The following statement contains a magic number: if (version < 2 || version > 4)  				throw new CorruptFileException (  					"Unsupported tag version.");
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,FrameHeader,The following statement contains a magic number: if (version < 2 || version > 4)  				throw new CorruptFileException (  					"Unsupported tag version.");
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,FrameHeader,The following statement contains a magic number: if (data.Count < (version == 2 ? 3 : 4))  				throw new CorruptFileException (  					"Data must contain at least a frame ID.");
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,FrameHeader,The following statement contains a magic number: if (data.Count < (version == 2 ? 3 : 4))  				throw new CorruptFileException (  					"Data must contain at least a frame ID.");
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,FrameHeader,The following statement contains a magic number: if (data.Count < (version == 2 ? 3 : 4))  				throw new CorruptFileException (  					"Data must contain at least a frame ID.");
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,FrameHeader,The following statement contains a magic number: switch (version)  			{  			case 2:  				// Set the frame ID -- the first three bytes  				frame_id = ConvertId (data.Mid (0' 3)' version'  					false);  			  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 6)  					return;  				  				frame_size = data.Mid (3' 3).ToUInt ();  				return;  			  			case 3:  				// Set the frame ID -- the first four bytes  				frame_id = ConvertId (data.Mid (0' 4)' version'  					false);  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				// Store the flags internally as version 2.4.  				frame_size = data.Mid (4' 4).ToUInt ();  				flags = (FrameFlags) (  					((data [8] << 7) & 0x7000) |  					((data [9] >> 4) & 0x000C) |  					((data [9] << 1) & 0x0040));  				  				return;  			  			case 4:  				// Set the frame ID -- the first four bytes  				frame_id = new ReadOnlyByteVector (  					data.Mid (0' 4));  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				frame_size = SynchData.ToUInt (data.Mid (4' 4));  				flags = (FrameFlags) data.Mid (8' 2).ToUShort ();  				  				return;  			  			default:  				throw new CorruptFileException (  					"Unsupported tag version.");  			}
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,FrameHeader,The following statement contains a magic number: switch (version)  			{  			case 2:  				// Set the frame ID -- the first three bytes  				frame_id = ConvertId (data.Mid (0' 3)' version'  					false);  			  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 6)  					return;  				  				frame_size = data.Mid (3' 3).ToUInt ();  				return;  			  			case 3:  				// Set the frame ID -- the first four bytes  				frame_id = ConvertId (data.Mid (0' 4)' version'  					false);  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				// Store the flags internally as version 2.4.  				frame_size = data.Mid (4' 4).ToUInt ();  				flags = (FrameFlags) (  					((data [8] << 7) & 0x7000) |  					((data [9] >> 4) & 0x000C) |  					((data [9] << 1) & 0x0040));  				  				return;  			  			case 4:  				// Set the frame ID -- the first four bytes  				frame_id = new ReadOnlyByteVector (  					data.Mid (0' 4));  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				frame_size = SynchData.ToUInt (data.Mid (4' 4));  				flags = (FrameFlags) data.Mid (8' 2).ToUShort ();  				  				return;  			  			default:  				throw new CorruptFileException (  					"Unsupported tag version.");  			}
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,FrameHeader,The following statement contains a magic number: switch (version)  			{  			case 2:  				// Set the frame ID -- the first three bytes  				frame_id = ConvertId (data.Mid (0' 3)' version'  					false);  			  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 6)  					return;  				  				frame_size = data.Mid (3' 3).ToUInt ();  				return;  			  			case 3:  				// Set the frame ID -- the first four bytes  				frame_id = ConvertId (data.Mid (0' 4)' version'  					false);  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				// Store the flags internally as version 2.4.  				frame_size = data.Mid (4' 4).ToUInt ();  				flags = (FrameFlags) (  					((data [8] << 7) & 0x7000) |  					((data [9] >> 4) & 0x000C) |  					((data [9] << 1) & 0x0040));  				  				return;  			  			case 4:  				// Set the frame ID -- the first four bytes  				frame_id = new ReadOnlyByteVector (  					data.Mid (0' 4));  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				frame_size = SynchData.ToUInt (data.Mid (4' 4));  				flags = (FrameFlags) data.Mid (8' 2).ToUShort ();  				  				return;  			  			default:  				throw new CorruptFileException (  					"Unsupported tag version.");  			}
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,FrameHeader,The following statement contains a magic number: switch (version)  			{  			case 2:  				// Set the frame ID -- the first three bytes  				frame_id = ConvertId (data.Mid (0' 3)' version'  					false);  			  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 6)  					return;  				  				frame_size = data.Mid (3' 3).ToUInt ();  				return;  			  			case 3:  				// Set the frame ID -- the first four bytes  				frame_id = ConvertId (data.Mid (0' 4)' version'  					false);  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				// Store the flags internally as version 2.4.  				frame_size = data.Mid (4' 4).ToUInt ();  				flags = (FrameFlags) (  					((data [8] << 7) & 0x7000) |  					((data [9] >> 4) & 0x000C) |  					((data [9] << 1) & 0x0040));  				  				return;  			  			case 4:  				// Set the frame ID -- the first four bytes  				frame_id = new ReadOnlyByteVector (  					data.Mid (0' 4));  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				frame_size = SynchData.ToUInt (data.Mid (4' 4));  				flags = (FrameFlags) data.Mid (8' 2).ToUShort ();  				  				return;  			  			default:  				throw new CorruptFileException (  					"Unsupported tag version.");  			}
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,FrameHeader,The following statement contains a magic number: switch (version)  			{  			case 2:  				// Set the frame ID -- the first three bytes  				frame_id = ConvertId (data.Mid (0' 3)' version'  					false);  			  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 6)  					return;  				  				frame_size = data.Mid (3' 3).ToUInt ();  				return;  			  			case 3:  				// Set the frame ID -- the first four bytes  				frame_id = ConvertId (data.Mid (0' 4)' version'  					false);  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				// Store the flags internally as version 2.4.  				frame_size = data.Mid (4' 4).ToUInt ();  				flags = (FrameFlags) (  					((data [8] << 7) & 0x7000) |  					((data [9] >> 4) & 0x000C) |  					((data [9] << 1) & 0x0040));  				  				return;  			  			case 4:  				// Set the frame ID -- the first four bytes  				frame_id = new ReadOnlyByteVector (  					data.Mid (0' 4));  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				frame_size = SynchData.ToUInt (data.Mid (4' 4));  				flags = (FrameFlags) data.Mid (8' 2).ToUShort ();  				  				return;  			  			default:  				throw new CorruptFileException (  					"Unsupported tag version.");  			}
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,FrameHeader,The following statement contains a magic number: switch (version)  			{  			case 2:  				// Set the frame ID -- the first three bytes  				frame_id = ConvertId (data.Mid (0' 3)' version'  					false);  			  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 6)  					return;  				  				frame_size = data.Mid (3' 3).ToUInt ();  				return;  			  			case 3:  				// Set the frame ID -- the first four bytes  				frame_id = ConvertId (data.Mid (0' 4)' version'  					false);  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				// Store the flags internally as version 2.4.  				frame_size = data.Mid (4' 4).ToUInt ();  				flags = (FrameFlags) (  					((data [8] << 7) & 0x7000) |  					((data [9] >> 4) & 0x000C) |  					((data [9] << 1) & 0x0040));  				  				return;  			  			case 4:  				// Set the frame ID -- the first four bytes  				frame_id = new ReadOnlyByteVector (  					data.Mid (0' 4));  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				frame_size = SynchData.ToUInt (data.Mid (4' 4));  				flags = (FrameFlags) data.Mid (8' 2).ToUShort ();  				  				return;  			  			default:  				throw new CorruptFileException (  					"Unsupported tag version.");  			}
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,FrameHeader,The following statement contains a magic number: switch (version)  			{  			case 2:  				// Set the frame ID -- the first three bytes  				frame_id = ConvertId (data.Mid (0' 3)' version'  					false);  			  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 6)  					return;  				  				frame_size = data.Mid (3' 3).ToUInt ();  				return;  			  			case 3:  				// Set the frame ID -- the first four bytes  				frame_id = ConvertId (data.Mid (0' 4)' version'  					false);  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				// Store the flags internally as version 2.4.  				frame_size = data.Mid (4' 4).ToUInt ();  				flags = (FrameFlags) (  					((data [8] << 7) & 0x7000) |  					((data [9] >> 4) & 0x000C) |  					((data [9] << 1) & 0x0040));  				  				return;  			  			case 4:  				// Set the frame ID -- the first four bytes  				frame_id = new ReadOnlyByteVector (  					data.Mid (0' 4));  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				frame_size = SynchData.ToUInt (data.Mid (4' 4));  				flags = (FrameFlags) data.Mid (8' 2).ToUShort ();  				  				return;  			  			default:  				throw new CorruptFileException (  					"Unsupported tag version.");  			}
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,FrameHeader,The following statement contains a magic number: switch (version)  			{  			case 2:  				// Set the frame ID -- the first three bytes  				frame_id = ConvertId (data.Mid (0' 3)' version'  					false);  			  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 6)  					return;  				  				frame_size = data.Mid (3' 3).ToUInt ();  				return;  			  			case 3:  				// Set the frame ID -- the first four bytes  				frame_id = ConvertId (data.Mid (0' 4)' version'  					false);  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				// Store the flags internally as version 2.4.  				frame_size = data.Mid (4' 4).ToUInt ();  				flags = (FrameFlags) (  					((data [8] << 7) & 0x7000) |  					((data [9] >> 4) & 0x000C) |  					((data [9] << 1) & 0x0040));  				  				return;  			  			case 4:  				// Set the frame ID -- the first four bytes  				frame_id = new ReadOnlyByteVector (  					data.Mid (0' 4));  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				frame_size = SynchData.ToUInt (data.Mid (4' 4));  				flags = (FrameFlags) data.Mid (8' 2).ToUShort ();  				  				return;  			  			default:  				throw new CorruptFileException (  					"Unsupported tag version.");  			}
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,FrameHeader,The following statement contains a magic number: switch (version)  			{  			case 2:  				// Set the frame ID -- the first three bytes  				frame_id = ConvertId (data.Mid (0' 3)' version'  					false);  			  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 6)  					return;  				  				frame_size = data.Mid (3' 3).ToUInt ();  				return;  			  			case 3:  				// Set the frame ID -- the first four bytes  				frame_id = ConvertId (data.Mid (0' 4)' version'  					false);  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				// Store the flags internally as version 2.4.  				frame_size = data.Mid (4' 4).ToUInt ();  				flags = (FrameFlags) (  					((data [8] << 7) & 0x7000) |  					((data [9] >> 4) & 0x000C) |  					((data [9] << 1) & 0x0040));  				  				return;  			  			case 4:  				// Set the frame ID -- the first four bytes  				frame_id = new ReadOnlyByteVector (  					data.Mid (0' 4));  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				frame_size = SynchData.ToUInt (data.Mid (4' 4));  				flags = (FrameFlags) data.Mid (8' 2).ToUShort ();  				  				return;  			  			default:  				throw new CorruptFileException (  					"Unsupported tag version.");  			}
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,FrameHeader,The following statement contains a magic number: switch (version)  			{  			case 2:  				// Set the frame ID -- the first three bytes  				frame_id = ConvertId (data.Mid (0' 3)' version'  					false);  			  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 6)  					return;  				  				frame_size = data.Mid (3' 3).ToUInt ();  				return;  			  			case 3:  				// Set the frame ID -- the first four bytes  				frame_id = ConvertId (data.Mid (0' 4)' version'  					false);  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				// Store the flags internally as version 2.4.  				frame_size = data.Mid (4' 4).ToUInt ();  				flags = (FrameFlags) (  					((data [8] << 7) & 0x7000) |  					((data [9] >> 4) & 0x000C) |  					((data [9] << 1) & 0x0040));  				  				return;  			  			case 4:  				// Set the frame ID -- the first four bytes  				frame_id = new ReadOnlyByteVector (  					data.Mid (0' 4));  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				frame_size = SynchData.ToUInt (data.Mid (4' 4));  				flags = (FrameFlags) data.Mid (8' 2).ToUShort ();  				  				return;  			  			default:  				throw new CorruptFileException (  					"Unsupported tag version.");  			}
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,FrameHeader,The following statement contains a magic number: switch (version)  			{  			case 2:  				// Set the frame ID -- the first three bytes  				frame_id = ConvertId (data.Mid (0' 3)' version'  					false);  			  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 6)  					return;  				  				frame_size = data.Mid (3' 3).ToUInt ();  				return;  			  			case 3:  				// Set the frame ID -- the first four bytes  				frame_id = ConvertId (data.Mid (0' 4)' version'  					false);  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				// Store the flags internally as version 2.4.  				frame_size = data.Mid (4' 4).ToUInt ();  				flags = (FrameFlags) (  					((data [8] << 7) & 0x7000) |  					((data [9] >> 4) & 0x000C) |  					((data [9] << 1) & 0x0040));  				  				return;  			  			case 4:  				// Set the frame ID -- the first four bytes  				frame_id = new ReadOnlyByteVector (  					data.Mid (0' 4));  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				frame_size = SynchData.ToUInt (data.Mid (4' 4));  				flags = (FrameFlags) data.Mid (8' 2).ToUShort ();  				  				return;  			  			default:  				throw new CorruptFileException (  					"Unsupported tag version.");  			}
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,FrameHeader,The following statement contains a magic number: switch (version)  			{  			case 2:  				// Set the frame ID -- the first three bytes  				frame_id = ConvertId (data.Mid (0' 3)' version'  					false);  			  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 6)  					return;  				  				frame_size = data.Mid (3' 3).ToUInt ();  				return;  			  			case 3:  				// Set the frame ID -- the first four bytes  				frame_id = ConvertId (data.Mid (0' 4)' version'  					false);  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				// Store the flags internally as version 2.4.  				frame_size = data.Mid (4' 4).ToUInt ();  				flags = (FrameFlags) (  					((data [8] << 7) & 0x7000) |  					((data [9] >> 4) & 0x000C) |  					((data [9] << 1) & 0x0040));  				  				return;  			  			case 4:  				// Set the frame ID -- the first four bytes  				frame_id = new ReadOnlyByteVector (  					data.Mid (0' 4));  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				frame_size = SynchData.ToUInt (data.Mid (4' 4));  				flags = (FrameFlags) data.Mid (8' 2).ToUShort ();  				  				return;  			  			default:  				throw new CorruptFileException (  					"Unsupported tag version.");  			}
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,FrameHeader,The following statement contains a magic number: switch (version)  			{  			case 2:  				// Set the frame ID -- the first three bytes  				frame_id = ConvertId (data.Mid (0' 3)' version'  					false);  			  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 6)  					return;  				  				frame_size = data.Mid (3' 3).ToUInt ();  				return;  			  			case 3:  				// Set the frame ID -- the first four bytes  				frame_id = ConvertId (data.Mid (0' 4)' version'  					false);  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				// Store the flags internally as version 2.4.  				frame_size = data.Mid (4' 4).ToUInt ();  				flags = (FrameFlags) (  					((data [8] << 7) & 0x7000) |  					((data [9] >> 4) & 0x000C) |  					((data [9] << 1) & 0x0040));  				  				return;  			  			case 4:  				// Set the frame ID -- the first four bytes  				frame_id = new ReadOnlyByteVector (  					data.Mid (0' 4));  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				frame_size = SynchData.ToUInt (data.Mid (4' 4));  				flags = (FrameFlags) data.Mid (8' 2).ToUShort ();  				  				return;  			  			default:  				throw new CorruptFileException (  					"Unsupported tag version.");  			}
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,FrameHeader,The following statement contains a magic number: switch (version)  			{  			case 2:  				// Set the frame ID -- the first three bytes  				frame_id = ConvertId (data.Mid (0' 3)' version'  					false);  			  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 6)  					return;  				  				frame_size = data.Mid (3' 3).ToUInt ();  				return;  			  			case 3:  				// Set the frame ID -- the first four bytes  				frame_id = ConvertId (data.Mid (0' 4)' version'  					false);  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				// Store the flags internally as version 2.4.  				frame_size = data.Mid (4' 4).ToUInt ();  				flags = (FrameFlags) (  					((data [8] << 7) & 0x7000) |  					((data [9] >> 4) & 0x000C) |  					((data [9] << 1) & 0x0040));  				  				return;  			  			case 4:  				// Set the frame ID -- the first four bytes  				frame_id = new ReadOnlyByteVector (  					data.Mid (0' 4));  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				frame_size = SynchData.ToUInt (data.Mid (4' 4));  				flags = (FrameFlags) data.Mid (8' 2).ToUShort ();  				  				return;  			  			default:  				throw new CorruptFileException (  					"Unsupported tag version.");  			}
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,FrameHeader,The following statement contains a magic number: switch (version)  			{  			case 2:  				// Set the frame ID -- the first three bytes  				frame_id = ConvertId (data.Mid (0' 3)' version'  					false);  			  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 6)  					return;  				  				frame_size = data.Mid (3' 3).ToUInt ();  				return;  			  			case 3:  				// Set the frame ID -- the first four bytes  				frame_id = ConvertId (data.Mid (0' 4)' version'  					false);  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				// Store the flags internally as version 2.4.  				frame_size = data.Mid (4' 4).ToUInt ();  				flags = (FrameFlags) (  					((data [8] << 7) & 0x7000) |  					((data [9] >> 4) & 0x000C) |  					((data [9] << 1) & 0x0040));  				  				return;  			  			case 4:  				// Set the frame ID -- the first four bytes  				frame_id = new ReadOnlyByteVector (  					data.Mid (0' 4));  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				frame_size = SynchData.ToUInt (data.Mid (4' 4));  				flags = (FrameFlags) data.Mid (8' 2).ToUShort ();  				  				return;  			  			default:  				throw new CorruptFileException (  					"Unsupported tag version.");  			}
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,FrameHeader,The following statement contains a magic number: switch (version)  			{  			case 2:  				// Set the frame ID -- the first three bytes  				frame_id = ConvertId (data.Mid (0' 3)' version'  					false);  			  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 6)  					return;  				  				frame_size = data.Mid (3' 3).ToUInt ();  				return;  			  			case 3:  				// Set the frame ID -- the first four bytes  				frame_id = ConvertId (data.Mid (0' 4)' version'  					false);  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				// Store the flags internally as version 2.4.  				frame_size = data.Mid (4' 4).ToUInt ();  				flags = (FrameFlags) (  					((data [8] << 7) & 0x7000) |  					((data [9] >> 4) & 0x000C) |  					((data [9] << 1) & 0x0040));  				  				return;  			  			case 4:  				// Set the frame ID -- the first four bytes  				frame_id = new ReadOnlyByteVector (  					data.Mid (0' 4));  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				frame_size = SynchData.ToUInt (data.Mid (4' 4));  				flags = (FrameFlags) data.Mid (8' 2).ToUShort ();  				  				return;  			  			default:  				throw new CorruptFileException (  					"Unsupported tag version.");  			}
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,FrameHeader,The following statement contains a magic number: switch (version)  			{  			case 2:  				// Set the frame ID -- the first three bytes  				frame_id = ConvertId (data.Mid (0' 3)' version'  					false);  			  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 6)  					return;  				  				frame_size = data.Mid (3' 3).ToUInt ();  				return;  			  			case 3:  				// Set the frame ID -- the first four bytes  				frame_id = ConvertId (data.Mid (0' 4)' version'  					false);  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				// Store the flags internally as version 2.4.  				frame_size = data.Mid (4' 4).ToUInt ();  				flags = (FrameFlags) (  					((data [8] << 7) & 0x7000) |  					((data [9] >> 4) & 0x000C) |  					((data [9] << 1) & 0x0040));  				  				return;  			  			case 4:  				// Set the frame ID -- the first four bytes  				frame_id = new ReadOnlyByteVector (  					data.Mid (0' 4));  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				frame_size = SynchData.ToUInt (data.Mid (4' 4));  				flags = (FrameFlags) data.Mid (8' 2).ToUShort ();  				  				return;  			  			default:  				throw new CorruptFileException (  					"Unsupported tag version.");  			}
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,FrameHeader,The following statement contains a magic number: switch (version)  			{  			case 2:  				// Set the frame ID -- the first three bytes  				frame_id = ConvertId (data.Mid (0' 3)' version'  					false);  			  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 6)  					return;  				  				frame_size = data.Mid (3' 3).ToUInt ();  				return;  			  			case 3:  				// Set the frame ID -- the first four bytes  				frame_id = ConvertId (data.Mid (0' 4)' version'  					false);  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				// Store the flags internally as version 2.4.  				frame_size = data.Mid (4' 4).ToUInt ();  				flags = (FrameFlags) (  					((data [8] << 7) & 0x7000) |  					((data [9] >> 4) & 0x000C) |  					((data [9] << 1) & 0x0040));  				  				return;  			  			case 4:  				// Set the frame ID -- the first four bytes  				frame_id = new ReadOnlyByteVector (  					data.Mid (0' 4));  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				frame_size = SynchData.ToUInt (data.Mid (4' 4));  				flags = (FrameFlags) data.Mid (8' 2).ToUShort ();  				  				return;  			  			default:  				throw new CorruptFileException (  					"Unsupported tag version.");  			}
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,FrameHeader,The following statement contains a magic number: switch (version)  			{  			case 2:  				// Set the frame ID -- the first three bytes  				frame_id = ConvertId (data.Mid (0' 3)' version'  					false);  			  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 6)  					return;  				  				frame_size = data.Mid (3' 3).ToUInt ();  				return;  			  			case 3:  				// Set the frame ID -- the first four bytes  				frame_id = ConvertId (data.Mid (0' 4)' version'  					false);  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				// Store the flags internally as version 2.4.  				frame_size = data.Mid (4' 4).ToUInt ();  				flags = (FrameFlags) (  					((data [8] << 7) & 0x7000) |  					((data [9] >> 4) & 0x000C) |  					((data [9] << 1) & 0x0040));  				  				return;  			  			case 4:  				// Set the frame ID -- the first four bytes  				frame_id = new ReadOnlyByteVector (  					data.Mid (0' 4));  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				frame_size = SynchData.ToUInt (data.Mid (4' 4));  				flags = (FrameFlags) data.Mid (8' 2).ToUShort ();  				  				return;  			  			default:  				throw new CorruptFileException (  					"Unsupported tag version.");  			}
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,FrameHeader,The following statement contains a magic number: switch (version)  			{  			case 2:  				// Set the frame ID -- the first three bytes  				frame_id = ConvertId (data.Mid (0' 3)' version'  					false);  			  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 6)  					return;  				  				frame_size = data.Mid (3' 3).ToUInt ();  				return;  			  			case 3:  				// Set the frame ID -- the first four bytes  				frame_id = ConvertId (data.Mid (0' 4)' version'  					false);  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				// Store the flags internally as version 2.4.  				frame_size = data.Mid (4' 4).ToUInt ();  				flags = (FrameFlags) (  					((data [8] << 7) & 0x7000) |  					((data [9] >> 4) & 0x000C) |  					((data [9] << 1) & 0x0040));  				  				return;  			  			case 4:  				// Set the frame ID -- the first four bytes  				frame_id = new ReadOnlyByteVector (  					data.Mid (0' 4));  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				frame_size = SynchData.ToUInt (data.Mid (4' 4));  				flags = (FrameFlags) data.Mid (8' 2).ToUShort ();  				  				return;  			  			default:  				throw new CorruptFileException (  					"Unsupported tag version.");  			}
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,FrameHeader,The following statement contains a magic number: switch (version)  			{  			case 2:  				// Set the frame ID -- the first three bytes  				frame_id = ConvertId (data.Mid (0' 3)' version'  					false);  			  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 6)  					return;  				  				frame_size = data.Mid (3' 3).ToUInt ();  				return;  			  			case 3:  				// Set the frame ID -- the first four bytes  				frame_id = ConvertId (data.Mid (0' 4)' version'  					false);  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				// Store the flags internally as version 2.4.  				frame_size = data.Mid (4' 4).ToUInt ();  				flags = (FrameFlags) (  					((data [8] << 7) & 0x7000) |  					((data [9] >> 4) & 0x000C) |  					((data [9] << 1) & 0x0040));  				  				return;  			  			case 4:  				// Set the frame ID -- the first four bytes  				frame_id = new ReadOnlyByteVector (  					data.Mid (0' 4));  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				frame_size = SynchData.ToUInt (data.Mid (4' 4));  				flags = (FrameFlags) data.Mid (8' 2).ToUShort ();  				  				return;  			  			default:  				throw new CorruptFileException (  					"Unsupported tag version.");  			}
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,FrameHeader,The following statement contains a magic number: switch (version)  			{  			case 2:  				// Set the frame ID -- the first three bytes  				frame_id = ConvertId (data.Mid (0' 3)' version'  					false);  			  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 6)  					return;  				  				frame_size = data.Mid (3' 3).ToUInt ();  				return;  			  			case 3:  				// Set the frame ID -- the first four bytes  				frame_id = ConvertId (data.Mid (0' 4)' version'  					false);  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				// Store the flags internally as version 2.4.  				frame_size = data.Mid (4' 4).ToUInt ();  				flags = (FrameFlags) (  					((data [8] << 7) & 0x7000) |  					((data [9] >> 4) & 0x000C) |  					((data [9] << 1) & 0x0040));  				  				return;  			  			case 4:  				// Set the frame ID -- the first four bytes  				frame_id = new ReadOnlyByteVector (  					data.Mid (0' 4));  				  				// If the full header information was not passed  				// in' do not continue to the steps to parse the  				// frame size and flags.  				if (data.Count < 10)  					return;  				  				frame_size = SynchData.ToUInt (data.Mid (4' 4));  				flags = (FrameFlags) data.Mid (8' 2).ToUShort ();  				  				return;  			  			default:  				throw new CorruptFileException (  					"Unsupported tag version.");  			}
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,Render,The following statement contains a magic number: switch (version)  			{  			case 2:  				data.Add (id);  				data.Add (ByteVector.FromUInt (frame_size)  					.Mid (1' 3));  				  				return data;  			  			case 3:  				ushort new_flags = (ushort) (  					(((ushort)flags << 1) & 0xE000) |  					(((ushort)flags << 4) & 0x00C0) |  					(((ushort)flags >> 1) & 0x0020));  				  				data.Add (id);  				data.Add (ByteVector.FromUInt (frame_size));  				data.Add (ByteVector.FromUShort (new_flags));  				  				return data;  			  			case 4:  				data.Add (id);  				data.Add (SynchData.FromUInt (frame_size));  				data.Add (ByteVector.FromUShort ((ushort) flags));  				  				return data;  			  			default:  				throw new NotImplementedException (  					"Unsupported tag version.");  			}
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,Render,The following statement contains a magic number: switch (version)  			{  			case 2:  				data.Add (id);  				data.Add (ByteVector.FromUInt (frame_size)  					.Mid (1' 3));  				  				return data;  			  			case 3:  				ushort new_flags = (ushort) (  					(((ushort)flags << 1) & 0xE000) |  					(((ushort)flags << 4) & 0x00C0) |  					(((ushort)flags >> 1) & 0x0020));  				  				data.Add (id);  				data.Add (ByteVector.FromUInt (frame_size));  				data.Add (ByteVector.FromUShort (new_flags));  				  				return data;  			  			case 4:  				data.Add (id);  				data.Add (SynchData.FromUInt (frame_size));  				data.Add (ByteVector.FromUShort ((ushort) flags));  				  				return data;  			  			default:  				throw new NotImplementedException (  					"Unsupported tag version.");  			}
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,Render,The following statement contains a magic number: switch (version)  			{  			case 2:  				data.Add (id);  				data.Add (ByteVector.FromUInt (frame_size)  					.Mid (1' 3));  				  				return data;  			  			case 3:  				ushort new_flags = (ushort) (  					(((ushort)flags << 1) & 0xE000) |  					(((ushort)flags << 4) & 0x00C0) |  					(((ushort)flags >> 1) & 0x0020));  				  				data.Add (id);  				data.Add (ByteVector.FromUInt (frame_size));  				data.Add (ByteVector.FromUShort (new_flags));  				  				return data;  			  			case 4:  				data.Add (id);  				data.Add (SynchData.FromUInt (frame_size));  				data.Add (ByteVector.FromUShort ((ushort) flags));  				  				return data;  			  			default:  				throw new NotImplementedException (  					"Unsupported tag version.");  			}
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,Render,The following statement contains a magic number: switch (version)  			{  			case 2:  				data.Add (id);  				data.Add (ByteVector.FromUInt (frame_size)  					.Mid (1' 3));  				  				return data;  			  			case 3:  				ushort new_flags = (ushort) (  					(((ushort)flags << 1) & 0xE000) |  					(((ushort)flags << 4) & 0x00C0) |  					(((ushort)flags >> 1) & 0x0020));  				  				data.Add (id);  				data.Add (ByteVector.FromUInt (frame_size));  				data.Add (ByteVector.FromUShort (new_flags));  				  				return data;  			  			case 4:  				data.Add (id);  				data.Add (SynchData.FromUInt (frame_size));  				data.Add (ByteVector.FromUShort ((ushort) flags));  				  				return data;  			  			default:  				throw new NotImplementedException (  					"Unsupported tag version.");  			}
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,Render,The following statement contains a magic number: switch (version)  			{  			case 2:  				data.Add (id);  				data.Add (ByteVector.FromUInt (frame_size)  					.Mid (1' 3));  				  				return data;  			  			case 3:  				ushort new_flags = (ushort) (  					(((ushort)flags << 1) & 0xE000) |  					(((ushort)flags << 4) & 0x00C0) |  					(((ushort)flags >> 1) & 0x0020));  				  				data.Add (id);  				data.Add (ByteVector.FromUInt (frame_size));  				data.Add (ByteVector.FromUShort (new_flags));  				  				return data;  			  			case 4:  				data.Add (id);  				data.Add (SynchData.FromUInt (frame_size));  				data.Add (ByteVector.FromUShort ((ushort) flags));  				  				return data;  			  			default:  				throw new NotImplementedException (  					"Unsupported tag version.");  			}
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,Size,The following statement contains a magic number: return (uint) (version < 3 ? 6 : 10);
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,Size,The following statement contains a magic number: return (uint) (version < 3 ? 6 : 10);
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,Size,The following statement contains a magic number: return (uint) (version < 3 ? 6 : 10);
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,ConvertId,The following statement contains a magic number: if (version >= 4) {  				ReadOnlyByteVector outid =  					id as ReadOnlyByteVector;  				  				return outid != null ?  					outid : new ReadOnlyByteVector (id);  			}
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,ConvertId,The following statement contains a magic number: if (id == null || version < 2)  				return null;
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,ConvertId,The following statement contains a magic number: if (version == 2)  				for (int i = 0; i < version2_frames.GetLength (0); i ++) {  					if (!version2_frames [i'  						toVersion ? 1 : 0].Equals (id))  						continue;  					  					return version2_frames [i'  						toVersion ? 0 : 1];  				}
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,ConvertId,The following statement contains a magic number: if (version == 3)  				for (int i = 0; i < version3_frames.GetLength (0); i ++) {  					if (!version3_frames [i'  						toVersion ? 1 : 0].Equals (id))  						continue;  					  					return version3_frames [i'  						toVersion ? 0 : 1];  				}
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,ConvertId,The following statement contains a magic number: if ((id.Count != 4 && version > 2) ||  				(id.Count != 3 && version == 2))  				return null;
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,ConvertId,The following statement contains a magic number: if ((id.Count != 4 && version > 2) ||  				(id.Count != 3 && version == 2))  				return null;
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,ConvertId,The following statement contains a magic number: if ((id.Count != 4 && version > 2) ||  				(id.Count != 3 && version == 2))  				return null;
Magic Number,TagLib.Id3v2,FrameHeader,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\FrameHeader.cs,ConvertId,The following statement contains a magic number: if ((id.Count != 4 && version > 2) ||  				(id.Count != 3 && version == 2))  				return null;
Magic Number,TagLib.Id3v2,Header,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Header.cs,Header,The following statement contains a magic number: major_version = data [3];
Magic Number,TagLib.Id3v2,Header,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Header.cs,Header,The following statement contains a magic number: revision_number = data [4];
Magic Number,TagLib.Id3v2,Header,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Header.cs,Header,The following statement contains a magic number: flags = (HeaderFlags) data [5];
Magic Number,TagLib.Id3v2,Header,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Header.cs,Header,The following statement contains a magic number: if (major_version == 2 && ((int) flags & 127) != 0)  				throw new CorruptFileException (  					"Invalid flags set on version 2 tag.");
Magic Number,TagLib.Id3v2,Header,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Header.cs,Header,The following statement contains a magic number: if (major_version == 2 && ((int) flags & 127) != 0)  				throw new CorruptFileException (  					"Invalid flags set on version 2 tag.");
Magic Number,TagLib.Id3v2,Header,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Header.cs,Header,The following statement contains a magic number: if (major_version == 3 && ((int) flags & 15) != 0)  				throw new CorruptFileException (  					"Invalid flags set on version 3 tag.");
Magic Number,TagLib.Id3v2,Header,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Header.cs,Header,The following statement contains a magic number: if (major_version == 3 && ((int) flags & 15) != 0)  				throw new CorruptFileException (  					"Invalid flags set on version 3 tag.");
Magic Number,TagLib.Id3v2,Header,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Header.cs,Header,The following statement contains a magic number: if (major_version == 4 && ((int) flags & 7) != 0)  				throw new CorruptFileException (  					"Invalid flags set on version 4 tag.");
Magic Number,TagLib.Id3v2,Header,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Header.cs,Header,The following statement contains a magic number: if (major_version == 4 && ((int) flags & 7) != 0)  				throw new CorruptFileException (  					"Invalid flags set on version 4 tag.");
Magic Number,TagLib.Id3v2,Header,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Header.cs,Header,The following statement contains a magic number: for (int i = 6; i < 10; i ++)  				if (data [i] >= 128)  					throw new CorruptFileException (  						"One of the bytes in the header was greater than the allowed 128.");
Magic Number,TagLib.Id3v2,Header,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Header.cs,Header,The following statement contains a magic number: for (int i = 6; i < 10; i ++)  				if (data [i] >= 128)  					throw new CorruptFileException (  						"One of the bytes in the header was greater than the allowed 128.");
Magic Number,TagLib.Id3v2,Header,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Header.cs,Header,The following statement contains a magic number: for (int i = 6; i < 10; i ++)  				if (data [i] >= 128)  					throw new CorruptFileException (  						"One of the bytes in the header was greater than the allowed 128.");
Magic Number,TagLib.Id3v2,Header,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Header.cs,Header,The following statement contains a magic number: tag_size = SynchData.ToUInt (data.Mid (6' 4));
Magic Number,TagLib.Id3v2,Header,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Header.cs,Header,The following statement contains a magic number: tag_size = SynchData.ToUInt (data.Mid (6' 4));
Magic Number,TagLib.Id3v2,SynchData,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\SynchData.cs,ToUInt,The following statement contains a magic number: int last = data.Count > 4 ? 3 : data.Count - 1;
Magic Number,TagLib.Id3v2,SynchData,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\SynchData.cs,ToUInt,The following statement contains a magic number: int last = data.Count > 4 ? 3 : data.Count - 1;
Magic Number,TagLib.Id3v2,SynchData,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\SynchData.cs,ToUInt,The following statement contains a magic number: for(int i = 0; i <= last; i++)  				sum |= (uint) (data [i] & 0x7f)  					<< ((last - i) * 7);
Magic Number,TagLib.Id3v2,SynchData,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\SynchData.cs,FromUInt,The following statement contains a magic number: if ((value >> 28) != 0)  				throw new ArgumentOutOfRangeException ("value"'  					"value must be less than 268435456.");
Magic Number,TagLib.Id3v2,SynchData,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\SynchData.cs,FromUInt,The following statement contains a magic number: ByteVector v = new ByteVector (4' 0);
Magic Number,TagLib.Id3v2,SynchData,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\SynchData.cs,FromUInt,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				v [i] = (byte) (value >> ((3 - i) * 7) & 0x7f);
Magic Number,TagLib.Id3v2,SynchData,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\SynchData.cs,FromUInt,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				v [i] = (byte) (value >> ((3 - i) * 7) & 0x7f);
Magic Number,TagLib.Id3v2,SynchData,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\SynchData.cs,FromUInt,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				v [i] = (byte) (value >> ((3 - i) * 7) & 0x7f);
Magic Number,TagLib.Id3v2,SynchData,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\SynchData.cs,UnsynchByteVector,The following statement contains a magic number: for (int i = data.Count - 2; i >= 0; i --)  				if (data [i] == 0xFF && (data [i+1] == 0 ||  					(data [i+1] & 0xE0) != 0))  					data.Insert (i+1' 0);
Magic Number,TagLib.Id3v2,SynchData,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\SynchData.cs,ResynchByteVector,The following statement contains a magic number: while (i < data.Count - 1) {  				if (i != j) {  					data[j] = data[i];  				}  				i += data[i] == 0xFF && data[i + 1] == 0 ? 2 : 1;  				j++;  			}
Magic Number,TagLib.Id3v2,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Tag.cs,GetFrames,The following statement contains a magic number: if (ident.Count != 4)  				throw new ArgumentException (  					"Identifier must be four bytes long."'  					"ident");
Magic Number,TagLib.Id3v2,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Tag.cs,GetFrames,The following statement contains a magic number: if (ident.Count != 4)  				throw new ArgumentException (  					"Identifier must be four bytes long."'  					"ident");
Magic Number,TagLib.Id3v2,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Tag.cs,RemoveFrames,The following statement contains a magic number: if (ident.Count != 4)  				throw new ArgumentException (  					"Identifier must be four bytes long."'  					"ident");
Magic Number,TagLib.Id3v2,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Tag.cs,SetTextFrame,The following statement contains a magic number: if (ident.Count != 4)  				throw new ArgumentException (  					"Identifier must be four bytes long."'  					"ident");
Magic Number,TagLib.Id3v2,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Tag.cs,SetNumberFrame,The following statement contains a magic number: if (ident.Count != 4)  				throw new ArgumentException (  					"Identifier must be four bytes long."'  					"ident");
Magic Number,TagLib.Id3v2,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Tag.cs,Render,The following statement contains a magic number: if (performers_role != null)  			{  				var map = new Dictionary<string' string>();  				for (int i = 0; i < performers_role.Length; i++)  				{  					var insts = performers_role[i];  					if (string.IsNullOrEmpty(insts))  						continue;    					var instlist = insts.Split(';');  					foreach (var iinst in instlist)  					{  						var inst = iinst.Trim();    						if (i < Performers.Length)  						{  							var perf = Performers[i];  							if (map.ContainsKey(inst))  							{  								map[inst] += "' " + perf;  							}  							else  							{  								map.Add(inst' perf);  							}  						}  					}  				}    				// Convert dictionary to array  				ret = new string[map.Count * 2];  				int j = 0;  				foreach (var dict in map)  				{  					ret[j++] = dict.Key;  					ret[j++] = dict.Value;  				}  			}
Magic Number,TagLib.Id3v2,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Tag.cs,Render,The following statement contains a magic number: bool unsynchAtFrameLevel = (header.Flags & HeaderFlags.Unsynchronisation) != 0 && Version >= 4;
Magic Number,TagLib.Id3v2,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Tag.cs,Render,The following statement contains a magic number: bool unsynchAtTagLevel = (header.Flags & HeaderFlags.Unsynchronisation) != 0 && Version < 4;
Magic Number,TagLib.Id3v2,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Tag.cs,Render,The following statement contains a magic number: header.MajorVersion = has_footer ? (byte) 4 : Version;
Magic Number,TagLib.Id3v2,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Tag.cs,Render,The following statement contains a magic number: if (!has_footer)  				tag_data.Add (new ByteVector ((int)  					((tag_data.Count < header.TagSize) ?   					(header.TagSize - tag_data.Count) :  					1024)));
Magic Number,TagLib.Id3v2,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Tag.cs,Parse,The following statement contains a magic number: bool fullTagUnsynch =  (header.MajorVersion < 4) && ((header.Flags & HeaderFlags.Unsynchronisation) != 0);
Magic Number,TagLib.Id3v2,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Tag.cs,Parse,The following statement contains a magic number: while (frame_data_position < frame_data_length -  				FrameHeader.Size (header.MajorVersion)) {  				  				// If the next data is position is 0' assume  				// that we've hit the padding portion of the  				// frame data.  				if(data [frame_data_position] == 0)  					break;    				Frame frame = null;    				try {  					frame = FrameFactory.CreateFrame(  						data'  						ref frame_data_position'  						header.MajorVersion'  						fullTagUnsynch);  				} catch (NotImplementedException) {  					continue;  				} catch (CorruptFileException) {  					continue;  				}    				if(frame == null)  					break;    				// Only add frames that contain data.  				if (frame.Size == 0)  					continue;  				  				AddFrame (frame);  				  				// If the tag is version 4' no post-processing  				// is needed.  				if (header.MajorVersion == 4)  					continue;  					  				// Load up the first instance of each' for  				// post-processing.  				  				if (tdrc == null &&  					frame.FrameId.Equals (FrameType.TDRC)) {  					tdrc = frame as TextInformationFrame;  				} else if (tyer == null &&  					frame.FrameId.Equals (FrameType.TYER)) {  					tyer = frame as TextInformationFrame;  				} else if (tdat == null &&  					frame.FrameId.Equals (FrameType.TDAT)) {  					tdat = frame as TextInformationFrame;  				} else if (time == null &&  					frame.FrameId.Equals (FrameType.TIME)) {  					time = frame as TextInformationFrame;  				}  			}
Magic Number,TagLib.Id3v2,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Tag.cs,Parse,The following statement contains a magic number: if (tdrc == null || tdat == null || tdrc.ToString ().Length > 4) {  				return;  			}
Magic Number,TagLib.Id3v2,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Tag.cs,Parse,The following statement contains a magic number: if (year.Length != 4)  				return;
Magic Number,TagLib.Id3v2,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Tag.cs,Parse,The following statement contains a magic number: if (tdat != null) {  				string tdat_text = tdat.ToString ();  				if (tdat_text.Length == 4) {  					tdrc_text.Append ("-").Append (tdat_text' 0' 2)  						.Append ("-").Append (tdat_text' 2' 2);    					// Add the time  					if (time != null) {  						string time_text = time.ToString ();  							  						if (time_text.Length == 4)  							tdrc_text.Append ("T").Append (time_text' 0' 2)  								.Append (":").Append (time_text' 2' 2);    						RemoveFrames (FrameType.TIME);  					}  				}    				RemoveFrames (FrameType.TDAT);  			}
Magic Number,TagLib.Id3v2,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Tag.cs,Parse,The following statement contains a magic number: if (tdat != null) {  				string tdat_text = tdat.ToString ();  				if (tdat_text.Length == 4) {  					tdrc_text.Append ("-").Append (tdat_text' 0' 2)  						.Append ("-").Append (tdat_text' 2' 2);    					// Add the time  					if (time != null) {  						string time_text = time.ToString ();  							  						if (time_text.Length == 4)  							tdrc_text.Append ("T").Append (time_text' 0' 2)  								.Append (":").Append (time_text' 2' 2);    						RemoveFrames (FrameType.TIME);  					}  				}    				RemoveFrames (FrameType.TDAT);  			}
Magic Number,TagLib.Id3v2,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Tag.cs,Parse,The following statement contains a magic number: if (tdat != null) {  				string tdat_text = tdat.ToString ();  				if (tdat_text.Length == 4) {  					tdrc_text.Append ("-").Append (tdat_text' 0' 2)  						.Append ("-").Append (tdat_text' 2' 2);    					// Add the time  					if (time != null) {  						string time_text = time.ToString ();  							  						if (time_text.Length == 4)  							tdrc_text.Append ("T").Append (time_text' 0' 2)  								.Append (":").Append (time_text' 2' 2);    						RemoveFrames (FrameType.TIME);  					}  				}    				RemoveFrames (FrameType.TDAT);  			}
Magic Number,TagLib.Id3v2,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Tag.cs,Parse,The following statement contains a magic number: if (tdat != null) {  				string tdat_text = tdat.ToString ();  				if (tdat_text.Length == 4) {  					tdrc_text.Append ("-").Append (tdat_text' 0' 2)  						.Append ("-").Append (tdat_text' 2' 2);    					// Add the time  					if (time != null) {  						string time_text = time.ToString ();  							  						if (time_text.Length == 4)  							tdrc_text.Append ("T").Append (time_text' 0' 2)  								.Append (":").Append (time_text' 2' 2);    						RemoveFrames (FrameType.TIME);  					}  				}    				RemoveFrames (FrameType.TDAT);  			}
Magic Number,TagLib.Id3v2,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Tag.cs,Parse,The following statement contains a magic number: if (tdat != null) {  				string tdat_text = tdat.ToString ();  				if (tdat_text.Length == 4) {  					tdrc_text.Append ("-").Append (tdat_text' 0' 2)  						.Append ("-").Append (tdat_text' 2' 2);    					// Add the time  					if (time != null) {  						string time_text = time.ToString ();  							  						if (time_text.Length == 4)  							tdrc_text.Append ("T").Append (time_text' 0' 2)  								.Append (":").Append (time_text' 2' 2);    						RemoveFrames (FrameType.TIME);  					}  				}    				RemoveFrames (FrameType.TDAT);  			}
Magic Number,TagLib.Id3v2,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Tag.cs,Parse,The following statement contains a magic number: if (tdat != null) {  				string tdat_text = tdat.ToString ();  				if (tdat_text.Length == 4) {  					tdrc_text.Append ("-").Append (tdat_text' 0' 2)  						.Append ("-").Append (tdat_text' 2' 2);    					// Add the time  					if (time != null) {  						string time_text = time.ToString ();  							  						if (time_text.Length == 4)  							tdrc_text.Append ("T").Append (time_text' 0' 2)  								.Append (":").Append (time_text' 2' 2);    						RemoveFrames (FrameType.TIME);  					}  				}    				RemoveFrames (FrameType.TDAT);  			}
Magic Number,TagLib.Id3v2,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Tag.cs,Parse,The following statement contains a magic number: if (tdat != null) {  				string tdat_text = tdat.ToString ();  				if (tdat_text.Length == 4) {  					tdrc_text.Append ("-").Append (tdat_text' 0' 2)  						.Append ("-").Append (tdat_text' 2' 2);    					// Add the time  					if (time != null) {  						string time_text = time.ToString ();  							  						if (time_text.Length == 4)  							tdrc_text.Append ("T").Append (time_text' 0' 2)  								.Append (":").Append (time_text' 2' 2);    						RemoveFrames (FrameType.TIME);  					}  				}    				RemoveFrames (FrameType.TDAT);  			}
Magic Number,TagLib.Id3v2,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Tag.cs,Parse,The following statement contains a magic number: if (tdat != null) {  				string tdat_text = tdat.ToString ();  				if (tdat_text.Length == 4) {  					tdrc_text.Append ("-").Append (tdat_text' 0' 2)  						.Append ("-").Append (tdat_text' 2' 2);    					// Add the time  					if (time != null) {  						string time_text = time.ToString ();  							  						if (time_text.Length == 4)  							tdrc_text.Append ("T").Append (time_text' 0' 2)  								.Append (":").Append (time_text' 2' 2);    						RemoveFrames (FrameType.TIME);  					}  				}    				RemoveFrames (FrameType.TDAT);  			}
Magic Number,TagLib.Id3v2,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Tag.cs,GetTextAsUInt32,The following statement contains a magic number: string [] values = text.Split (new char [] {'/'}'  				index + 2);
Magic Number,TagLib.Id3v2,AttachedPictureFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\AttachedPictureFrame.cs,ParseFields,The following statement contains a magic number: if (data.Count < 5)  				throw new CorruptFileException (  					"A picture frame must contain at least 5 bytes.");
Magic Number,TagLib.Id3v2,AttachedPictureFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\AttachedPictureFrame.cs,ParseRawData,The following statement contains a magic number: if (raw_version > 2) {  				offset = raw_data.Find (ByteVector.TextDelimiter (  					StringType.Latin1)' pos);  				  				if(offset < pos)  					return;  				  				mime_type = raw_data.ToString (  					StringType.Latin1' pos' offset - pos);  				pos = offset + 1;  			} else {  				ByteVector ext = raw_data.Mid (pos' 3);  				  				if (ext == "JPG")  					mime_type = "image/jpeg";  				else if (ext == "PNG")  					mime_type = "image/png";  				else  					mime_type = "image/unknown";  				  				pos += 3;  			}
Magic Number,TagLib.Id3v2,AttachedPictureFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\AttachedPictureFrame.cs,ParseRawData,The following statement contains a magic number: if (raw_version > 2) {  				offset = raw_data.Find (ByteVector.TextDelimiter (  					StringType.Latin1)' pos);  				  				if(offset < pos)  					return;  				  				mime_type = raw_data.ToString (  					StringType.Latin1' pos' offset - pos);  				pos = offset + 1;  			} else {  				ByteVector ext = raw_data.Mid (pos' 3);  				  				if (ext == "JPG")  					mime_type = "image/jpeg";  				else if (ext == "PNG")  					mime_type = "image/png";  				else  					mime_type = "image/unknown";  				  				pos += 3;  			}
Magic Number,TagLib.Id3v2,AttachedPictureFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\AttachedPictureFrame.cs,ParseRawData,The following statement contains a magic number: if (raw_version > 2) {  				offset = raw_data.Find (ByteVector.TextDelimiter (  					StringType.Latin1)' pos);  				  				if(offset < pos)  					return;  				  				mime_type = raw_data.ToString (  					StringType.Latin1' pos' offset - pos);  				pos = offset + 1;  			} else {  				ByteVector ext = raw_data.Mid (pos' 3);  				  				if (ext == "JPG")  					mime_type = "image/jpeg";  				else if (ext == "PNG")  					mime_type = "image/png";  				else  					mime_type = "image/unknown";  				  				pos += 3;  			}
Magic Number,TagLib.Id3v2,AttachedPictureFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\AttachedPictureFrame.cs,RenderFields,The following statement contains a magic number: if (version == 2) {  				switch (MimeType) {  				case "image/png":  					data.Add ("PNG");  					break;  				case "image/jpeg":  					data.Add ("JPG");  					break;  				default:  					data.Add ("XXX");  					break;  				}  			} else {  				data.Add (ByteVector.FromString (MimeType'  					StringType.Latin1));  				data.Add (ByteVector.TextDelimiter (  					StringType.Latin1));  			}
Magic Number,TagLib.Id3v2,CommentsFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\CommentsFrame.cs,GetPreferred,The following statement contains a magic number: foreach (Frame frame in tag.GetFrames (FrameType.COMM)) {  				CommentsFrame comm = frame as CommentsFrame;  				  				if (comm == null)  					continue;  				  				if (skip_itunes &&  					comm.Description.StartsWith ("iTun"))  					continue;  				  				bool same_name = comm.Description == description;  				bool same_lang = comm.Language == language;  				  				if (same_name && same_lang)  					return comm;  				  				int value = same_lang ? 2 : same_name ? 1 : 0;  				  				if (value <= best_value)  					continue;  				  				best_value = value;  				best_frame = comm;  			}
Magic Number,TagLib.Id3v2,CommentsFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\CommentsFrame.cs,ParseFields,The following statement contains a magic number: if (data.Count < 4)  				throw new CorruptFileException (  					"Not enough bytes in field.");
Magic Number,TagLib.Id3v2,CommentsFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\CommentsFrame.cs,ParseFields,The following statement contains a magic number: language = data.ToString (StringType.Latin1' 1' 3);
Magic Number,TagLib.Id3v2,CommentsFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\CommentsFrame.cs,ParseFields,The following statement contains a magic number: string [] split = data.ToStrings (encoding' 4' 3);
Magic Number,TagLib.Id3v2,CommentsFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\CommentsFrame.cs,ParseFields,The following statement contains a magic number: string [] split = data.ToStrings (encoding' 4' 3);
Magic Number,TagLib.Id3v2,GeneralEncapsulatedObjectFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\GeneralEncapsulatedObjectFrame.cs,ParseFields,The following statement contains a magic number: if (data.Count < 4)  				throw new CorruptFileException (  					"An object frame must contain at least 4 bytes.");
Magic Number,TagLib.Id3v2,PlayCountFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\PlayCountFrame.cs,RenderFields,The following statement contains a magic number: while (data.Count > 4 && data [0] == 0)  				data.RemoveAt (0);
Magic Number,TagLib.Id3v2,PopularimeterFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\PopularimeterFrame.cs,ParseFields,The following statement contains a magic number: if (index + 2 > data.Count)  				throw new CorruptFileException("Popularimeter is too short");
Magic Number,TagLib.Id3v2,PopularimeterFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\PopularimeterFrame.cs,ParseFields,The following statement contains a magic number: play_count = data.Mid (index + 2).ToULong ();
Magic Number,TagLib.Id3v2,PrivateFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\PrivateFrame.cs,ParseFields,The following statement contains a magic number: ByteVectorCollection l = ByteVectorCollection.Split (  				data'  				ByteVector.TextDelimiter (StringType.Latin1)'  				1' 2);
Magic Number,TagLib.Id3v2,PrivateFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\PrivateFrame.cs,ParseFields,The following statement contains a magic number: if (l.Count == 2) {  				this.owner = l [0].ToString (StringType.Latin1);  				this.data  = l [1];  			}
Magic Number,TagLib.Id3v2,PrivateFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\PrivateFrame.cs,RenderFields,The following statement contains a magic number: if (version < 3)  				throw new NotImplementedException ();
Magic Number,TagLib.Id3v2,RelativeVolumeFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\RelativeVolumeFrame.cs,ParseFields,The following statement contains a magic number: while (pos <= data.Count - 4) {  				int type = data [pos++];  				  				unchecked {  					channels [type].VolumeAdjustmentIndex =  						(short) data.Mid (pos'  							2).ToUShort ();  				}  				pos += 2;  				  				int bytes = BitsToBytes (data [pos++]);  				  				if (data.Count < pos + bytes)  					break;  				  				channels [type].PeakVolumeIndex = data.Mid (pos'  					bytes).ToULong ();  				pos += bytes;  			}
Magic Number,TagLib.Id3v2,RelativeVolumeFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\RelativeVolumeFrame.cs,ParseFields,The following statement contains a magic number: while (pos <= data.Count - 4) {  				int type = data [pos++];  				  				unchecked {  					channels [type].VolumeAdjustmentIndex =  						(short) data.Mid (pos'  							2).ToUShort ();  				}  				pos += 2;  				  				int bytes = BitsToBytes (data [pos++]);  				  				if (data.Count < pos + bytes)  					break;  				  				channels [type].PeakVolumeIndex = data.Mid (pos'  					bytes).ToULong ();  				pos += bytes;  			}
Magic Number,TagLib.Id3v2,RelativeVolumeFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\RelativeVolumeFrame.cs,ParseFields,The following statement contains a magic number: while (pos <= data.Count - 4) {  				int type = data [pos++];  				  				unchecked {  					channels [type].VolumeAdjustmentIndex =  						(short) data.Mid (pos'  							2).ToUShort ();  				}  				pos += 2;  				  				int bytes = BitsToBytes (data [pos++]);  				  				if (data.Count < pos + bytes)  					break;  				  				channels [type].PeakVolumeIndex = data.Mid (pos'  					bytes).ToULong ();  				pos += bytes;  			}
Magic Number,TagLib.Id3v2,RelativeVolumeFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\RelativeVolumeFrame.cs,RenderFields,The following statement contains a magic number: for (byte i = 0; i < 9; i ++) {  				if (!channels [i].IsSet)  					continue;  				  				data.Add (i);  				unchecked {  					data.Add (ByteVector.FromUShort (  						(ushort) channels [i]  							.VolumeAdjustmentIndex));  				}  				  				byte bits = 0;  				  				for (byte j = 0; j < 64; j ++)  					if ((channels [i].PeakVolumeIndex &  						(1UL << j)) != 0)  						bits = (byte)(j + 1);  				  				data.Add (bits);  				  				if (bits > 0)  					data.Add (ByteVector.FromULong (  						channels [i].PeakVolumeIndex)  							.Mid (8 - BitsToBytes (bits)));  			}
Magic Number,TagLib.Id3v2,RelativeVolumeFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\RelativeVolumeFrame.cs,RenderFields,The following statement contains a magic number: for (byte i = 0; i < 9; i ++) {  				if (!channels [i].IsSet)  					continue;  				  				data.Add (i);  				unchecked {  					data.Add (ByteVector.FromUShort (  						(ushort) channels [i]  							.VolumeAdjustmentIndex));  				}  				  				byte bits = 0;  				  				for (byte j = 0; j < 64; j ++)  					if ((channels [i].PeakVolumeIndex &  						(1UL << j)) != 0)  						bits = (byte)(j + 1);  				  				data.Add (bits);  				  				if (bits > 0)  					data.Add (ByteVector.FromULong (  						channels [i].PeakVolumeIndex)  							.Mid (8 - BitsToBytes (bits)));  			}
Magic Number,TagLib.Id3v2,RelativeVolumeFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\RelativeVolumeFrame.cs,RenderFields,The following statement contains a magic number: for (byte i = 0; i < 9; i ++) {  				if (!channels [i].IsSet)  					continue;  				  				data.Add (i);  				unchecked {  					data.Add (ByteVector.FromUShort (  						(ushort) channels [i]  							.VolumeAdjustmentIndex));  				}  				  				byte bits = 0;  				  				for (byte j = 0; j < 64; j ++)  					if ((channels [i].PeakVolumeIndex &  						(1UL << j)) != 0)  						bits = (byte)(j + 1);  				  				data.Add (bits);  				  				if (bits > 0)  					data.Add (ByteVector.FromULong (  						channels [i].PeakVolumeIndex)  							.Mid (8 - BitsToBytes (bits)));  			}
Magic Number,TagLib.Id3v2,RelativeVolumeFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\RelativeVolumeFrame.cs,Clone,The following statement contains a magic number: for (int i = 0; i < 9; i ++)  				frame.channels [i] = channels [i];
Magic Number,TagLib.Id3v2,RelativeVolumeFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\RelativeVolumeFrame.cs,BitsToBytes,The following statement contains a magic number: return i % 8 == 0 ? i / 8 : (i - i % 8) / 8 + 1;
Magic Number,TagLib.Id3v2,RelativeVolumeFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\RelativeVolumeFrame.cs,BitsToBytes,The following statement contains a magic number: return i % 8 == 0 ? i / 8 : (i - i % 8) / 8 + 1;
Magic Number,TagLib.Id3v2,RelativeVolumeFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\RelativeVolumeFrame.cs,BitsToBytes,The following statement contains a magic number: return i % 8 == 0 ? i / 8 : (i - i % 8) / 8 + 1;
Magic Number,TagLib.Id3v2,RelativeVolumeFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\RelativeVolumeFrame.cs,BitsToBytes,The following statement contains a magic number: return i % 8 == 0 ? i / 8 : (i - i % 8) / 8 + 1;
Magic Number,TagLib.Id3v2,SynchronisedLyricsFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\SynchronizedLyricsFrame.cs,GetPreferred,The following statement contains a magic number: foreach (Frame f in tag) {  				SynchronisedLyricsFrame cf =  					f as SynchronisedLyricsFrame;  				  				if (cf == null)  					continue;  				  				int value = 0;  				if (cf.Language == language)  					value += 4;  				if (cf.Description == description)  					value += 2;  				if (cf.Type == type)  					value += 1;  				  				if (value == 7)  					return cf;  				  				if (value <= best_value)  					continue;  				  				best_value = value;  				best_frame = cf;  			}
Magic Number,TagLib.Id3v2,SynchronisedLyricsFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\SynchronizedLyricsFrame.cs,GetPreferred,The following statement contains a magic number: foreach (Frame f in tag) {  				SynchronisedLyricsFrame cf =  					f as SynchronisedLyricsFrame;  				  				if (cf == null)  					continue;  				  				int value = 0;  				if (cf.Language == language)  					value += 4;  				if (cf.Description == description)  					value += 2;  				if (cf.Type == type)  					value += 1;  				  				if (value == 7)  					return cf;  				  				if (value <= best_value)  					continue;  				  				best_value = value;  				best_frame = cf;  			}
Magic Number,TagLib.Id3v2,SynchronisedLyricsFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\SynchronizedLyricsFrame.cs,GetPreferred,The following statement contains a magic number: foreach (Frame f in tag) {  				SynchronisedLyricsFrame cf =  					f as SynchronisedLyricsFrame;  				  				if (cf == null)  					continue;  				  				int value = 0;  				if (cf.Language == language)  					value += 4;  				if (cf.Description == description)  					value += 2;  				if (cf.Type == type)  					value += 1;  				  				if (value == 7)  					return cf;  				  				if (value <= best_value)  					continue;  				  				best_value = value;  				best_frame = cf;  			}
Magic Number,TagLib.Id3v2,SynchronisedLyricsFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\SynchronizedLyricsFrame.cs,ParseFields,The following statement contains a magic number: if (data.Count < 6)  				throw new CorruptFileException (  					"Not enough bytes in field.");
Magic Number,TagLib.Id3v2,SynchronisedLyricsFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\SynchronizedLyricsFrame.cs,ParseFields,The following statement contains a magic number: language = data.ToString (StringType.Latin1' 1' 3);
Magic Number,TagLib.Id3v2,SynchronisedLyricsFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\SynchronizedLyricsFrame.cs,ParseFields,The following statement contains a magic number: timestamp_format = (TimestampFormat) data [4];
Magic Number,TagLib.Id3v2,SynchronisedLyricsFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\SynchronizedLyricsFrame.cs,ParseFields,The following statement contains a magic number: lyrics_type = (SynchedTextType) data [5];
Magic Number,TagLib.Id3v2,SynchronisedLyricsFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\SynchronizedLyricsFrame.cs,ParseFields,The following statement contains a magic number: int delim_index = data.Find (delim' 6' delim.Count);
Magic Number,TagLib.Id3v2,SynchronisedLyricsFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\SynchronizedLyricsFrame.cs,ParseFields,The following statement contains a magic number: description = data.ToString (encoding' 6'  				delim_index - 6);
Magic Number,TagLib.Id3v2,SynchronisedLyricsFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\SynchronizedLyricsFrame.cs,ParseFields,The following statement contains a magic number: description = data.ToString (encoding' 6'  				delim_index - 6);
Magic Number,TagLib.Id3v2,SynchronisedLyricsFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\SynchronizedLyricsFrame.cs,ParseFields,The following statement contains a magic number: while (offset + delim.Count + 4 < data.Count) {  				delim_index = data.Find (delim' offset'  					delim.Count);  				  				if (delim_index < offset)  					throw new CorruptFileException (  						"Text delimiter expected.");  				  				string text = data.ToString (encoding' offset'  					delim_index - offset);  				offset = delim_index + delim.Count;  				  				if (offset + 4 > data.Count)  					break;  				  				l.Add (new SynchedText (data.Mid (offset' 4)  					.ToUInt ()' text));  				offset += 4;  			}
Magic Number,TagLib.Id3v2,SynchronisedLyricsFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\SynchronizedLyricsFrame.cs,ParseFields,The following statement contains a magic number: while (offset + delim.Count + 4 < data.Count) {  				delim_index = data.Find (delim' offset'  					delim.Count);  				  				if (delim_index < offset)  					throw new CorruptFileException (  						"Text delimiter expected.");  				  				string text = data.ToString (encoding' offset'  					delim_index - offset);  				offset = delim_index + delim.Count;  				  				if (offset + 4 > data.Count)  					break;  				  				l.Add (new SynchedText (data.Mid (offset' 4)  					.ToUInt ()' text));  				offset += 4;  			}
Magic Number,TagLib.Id3v2,SynchronisedLyricsFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\SynchronizedLyricsFrame.cs,ParseFields,The following statement contains a magic number: while (offset + delim.Count + 4 < data.Count) {  				delim_index = data.Find (delim' offset'  					delim.Count);  				  				if (delim_index < offset)  					throw new CorruptFileException (  						"Text delimiter expected.");  				  				string text = data.ToString (encoding' offset'  					delim_index - offset);  				offset = delim_index + delim.Count;  				  				if (offset + 4 > data.Count)  					break;  				  				l.Add (new SynchedText (data.Mid (offset' 4)  					.ToUInt ()' text));  				offset += 4;  			}
Magic Number,TagLib.Id3v2,SynchronisedLyricsFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\SynchronizedLyricsFrame.cs,ParseFields,The following statement contains a magic number: while (offset + delim.Count + 4 < data.Count) {  				delim_index = data.Find (delim' offset'  					delim.Count);  				  				if (delim_index < offset)  					throw new CorruptFileException (  						"Text delimiter expected.");  				  				string text = data.ToString (encoding' offset'  					delim_index - offset);  				offset = delim_index + delim.Count;  				  				if (offset + 4 > data.Count)  					break;  				  				l.Add (new SynchedText (data.Mid (offset' 4)  					.ToUInt ()' text));  				offset += 4;  			}
Magic Number,TagLib.Id3v2,TermsOfUseFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\TermsOfUseFrame.cs,ParseFields,The following statement contains a magic number: if (data.Count < 4)  				throw new CorruptFileException (  					"Not enough bytes in field.");
Magic Number,TagLib.Id3v2,TermsOfUseFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\TermsOfUseFrame.cs,ParseFields,The following statement contains a magic number: language = data.ToString (StringType.Latin1' 1' 3);
Magic Number,TagLib.Id3v2,TermsOfUseFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\TermsOfUseFrame.cs,ParseFields,The following statement contains a magic number: text = data.ToString (encoding' 4' data.Count - 4);
Magic Number,TagLib.Id3v2,TermsOfUseFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\TermsOfUseFrame.cs,ParseFields,The following statement contains a magic number: text = data.ToString (encoding' 4' data.Count - 4);
Magic Number,TagLib.Id3v2,TextInformationFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\TextIdentificationFrame.cs,Render,The following statement contains a magic number: if (version != 3 || FrameId != FrameType.TDRC)  				return base.Render (version);
Magic Number,TagLib.Id3v2,TextInformationFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\TextIdentificationFrame.cs,Render,The following statement contains a magic number: if (text.Length < 10 || text [4] != '-' ||  				text [7] != '-')  				return base.Render (version);
Magic Number,TagLib.Id3v2,TextInformationFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\TextIdentificationFrame.cs,Render,The following statement contains a magic number: if (text.Length < 10 || text [4] != '-' ||  				text [7] != '-')  				return base.Render (version);
Magic Number,TagLib.Id3v2,TextInformationFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\TextIdentificationFrame.cs,Render,The following statement contains a magic number: if (text.Length < 10 || text [4] != '-' ||  				text [7] != '-')  				return base.Render (version);
Magic Number,TagLib.Id3v2,TextInformationFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\TextIdentificationFrame.cs,Render,The following statement contains a magic number: f.Text = new string [] {text.Substring (0' 4)};
Magic Number,TagLib.Id3v2,TextInformationFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\TextIdentificationFrame.cs,Render,The following statement contains a magic number: f.Text = new string [] {  				text.Substring (5' 2) + text.Substring (8' 2)  			};
Magic Number,TagLib.Id3v2,TextInformationFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\TextIdentificationFrame.cs,Render,The following statement contains a magic number: f.Text = new string [] {  				text.Substring (5' 2) + text.Substring (8' 2)  			};
Magic Number,TagLib.Id3v2,TextInformationFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\TextIdentificationFrame.cs,Render,The following statement contains a magic number: f.Text = new string [] {  				text.Substring (5' 2) + text.Substring (8' 2)  			};
Magic Number,TagLib.Id3v2,TextInformationFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\TextIdentificationFrame.cs,Render,The following statement contains a magic number: f.Text = new string [] {  				text.Substring (5' 2) + text.Substring (8' 2)  			};
Magic Number,TagLib.Id3v2,TextInformationFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\TextIdentificationFrame.cs,Render,The following statement contains a magic number: if (text.Length < 16 || text [10] != 'T' ||  				text [13] != ':')  				return output;
Magic Number,TagLib.Id3v2,TextInformationFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\TextIdentificationFrame.cs,Render,The following statement contains a magic number: if (text.Length < 16 || text [10] != 'T' ||  				text [13] != ':')  				return output;
Magic Number,TagLib.Id3v2,TextInformationFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\TextIdentificationFrame.cs,Render,The following statement contains a magic number: if (text.Length < 16 || text [10] != 'T' ||  				text [13] != ':')  				return output;
Magic Number,TagLib.Id3v2,TextInformationFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\TextIdentificationFrame.cs,Render,The following statement contains a magic number: f.Text = new string [] {  				text.Substring (11' 2) + text.Substring (14' 2)  			};
Magic Number,TagLib.Id3v2,TextInformationFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\TextIdentificationFrame.cs,Render,The following statement contains a magic number: f.Text = new string [] {  				text.Substring (11' 2) + text.Substring (14' 2)  			};
Magic Number,TagLib.Id3v2,TextInformationFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\TextIdentificationFrame.cs,Render,The following statement contains a magic number: f.Text = new string [] {  				text.Substring (11' 2) + text.Substring (14' 2)  			};
Magic Number,TagLib.Id3v2,TextInformationFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\TextIdentificationFrame.cs,Render,The following statement contains a magic number: f.Text = new string [] {  				text.Substring (11' 2) + text.Substring (14' 2)  			};
Magic Number,TagLib.Id3v2,TextInformationFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\TextIdentificationFrame.cs,Get,The following statement contains a magic number: if (ident.Count != 4)  				throw new ArgumentException (  					"Identifier must be four bytes long."'  					"ident");
Magic Number,TagLib.Id3v2,TextInformationFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\TextIdentificationFrame.cs,ParseRawData,The following statement contains a magic number: if (raw_version > 3 || FrameId == FrameType.TXXX) {  				field_list.AddRange (data.ToStrings (encoding' 1));  			} else if (data.Count > 1 && !data.Mid (1'  				delim.Count).Equals (delim)) {  				string value = data.ToString (encoding' 1'  					data.Count - 1);  				  				// Truncate values containing NULL bytes  				int null_index = value.IndexOf ('\x00');  				if (null_index >= 0) {  					value = value.Substring (0' null_index);  				}  				  				if (FrameId == FrameType.TCOM ||  					FrameId == FrameType.TEXT ||  					FrameId == FrameType.TMCL ||  					FrameId == FrameType.TOLY ||  					FrameId == FrameType.TOPE ||  					FrameId == FrameType.TPE1 ||  					FrameId == FrameType.TPE2 ||  					FrameId == FrameType.TPE3 ||  					FrameId == FrameType.TPE4) {  					field_list.AddRange (value.Split ('/'));  				} else if (FrameId == FrameType.TCON) {  					while (value.Length > 1 && value [0] == '(') {  						int closing = value.IndexOf (')');  						if (closing < 0)  							break;  						  						string number = value.Substring (1'  								closing - 1);  						  						field_list.Add (number);  						  						value = value.Substring (  							closing + 1).TrimStart ('/'' ' ');  						  						string text = Genres.IndexToAudio (number);  						if (text != null && value.StartsWith (text))  							value = value.Substring (text.Length)  								.TrimStart ('/'' ' ');  					}  					  					if (value.Length > 0)  						field_list.AddRange (value.Split (new char [] {'/'}));  				} else {  					field_list.Add (value);  				}  			}
Magic Number,TagLib.Id3v2,TextInformationFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\TextIdentificationFrame.cs,RenderFields,The following statement contains a magic number: if (version > 3 || txxx) {  				  				if (txxx) {  					if (text.Length == 0)  						text = new string [] {null' null};  					else if (text.Length == 1)  						text = new string [] {text [0]'  							null};  				}  				  				for (int i = 0; i < text.Length; i++) {  					// Since the field list is null  					// delimited' if this is not the first  					// element in the list' append the  					// appropriate delimiter for this  					// encoding.  					  					if (i != 0)  						v.Add (ByteVector.TextDelimiter (  							encoding));  						  					if (text [i] != null)  						v.Add (ByteVector.FromString (  							text [i]'  							encoding));  				}  			} else if (FrameId == FrameType.TCON) {  				byte id;  				bool prev_value_indexed = true;  				StringBuilder data = new StringBuilder ();  				foreach (string s in text) {  					if (!prev_value_indexed) {  						data.Append ("/").Append (s);  						continue;  					}  					  					if (prev_value_indexed =  						byte.TryParse (s' out id))  						data.AppendFormat (  							CultureInfo.InvariantCulture'  								"({0})"' id);  					else  						data.Append (s);  				}  				  				v.Add (ByteVector.FromString (data.ToString ()'  					encoding));  			} else {  				v.Add (ByteVector.FromString (  					string.Join ("/"' text)' encoding));  			}
Magic Number,TagLib.Id3v2,UniqueFileIdentifierFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\UniqueFileIdentifierFrame.cs,ParseFields,The following statement contains a magic number: if (fields.Count != 2)  				return;
Magic Number,TagLib.Id3v2,UnsynchronisedLyricsFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\UnsynchronisedLyricsFrame.cs,GetPreferred,The following statement contains a magic number: foreach (Frame frame in tag.GetFrames (FrameType.USLT)) {  				UnsynchronisedLyricsFrame uslt =  					frame as UnsynchronisedLyricsFrame;  				  				if (uslt == null)  					continue;  				  				bool same_name = uslt.Description == description;  				bool same_lang = uslt.Language == language;  				  				if (same_name && same_lang)  					return uslt;  				  				int value = same_lang ? 2 : same_name ? 1 : 0;  				  				if (value <= best_value)  					continue;  				  				best_value = value;  				best_frame = uslt;  			}
Magic Number,TagLib.Id3v2,UnsynchronisedLyricsFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\UnsynchronisedLyricsFrame.cs,ParseFields,The following statement contains a magic number: if (data.Count < 4)  				throw new CorruptFileException (  					"Not enough bytes in field.");
Magic Number,TagLib.Id3v2,UnsynchronisedLyricsFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\UnsynchronisedLyricsFrame.cs,ParseFields,The following statement contains a magic number: language = data.ToString (StringType.Latin1' 1' 3);
Magic Number,TagLib.Id3v2,UnsynchronisedLyricsFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\UnsynchronisedLyricsFrame.cs,ParseFields,The following statement contains a magic number: string [] split = data.ToStrings (encoding' 4' 2);
Magic Number,TagLib.Id3v2,UnsynchronisedLyricsFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\UnsynchronisedLyricsFrame.cs,ParseFields,The following statement contains a magic number: string [] split = data.ToStrings (encoding' 4' 2);
Magic Number,TagLib.Id3v2,UrlLinkFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\UrlLinkFrame.cs,Get,The following statement contains a magic number: if (ident.Count != 4)  								throw new ArgumentException (  								  "Identifier must be four bytes long."'  								  "ident");
Magic Number,TagLib.Id3v2,UrlLinkFrame,C:\repos\mono_taglib-sharp\src\TagLib\Id3v2\Frames\UrlLinkFrame.cs,RenderFields,The following statement contains a magic number: if (version > 3 || wxxx) {  								if (wxxx) {  										if (text.Length == 0)  												text = new string [] { null' null };  										else if (text.Length == 1)  												text = new string [] {text [0]'  							null};  								}    								v.Add (ByteVector.FromString (  								string.Join ("/"' text)' StringType.Latin1));  						} else {  								v.Add (ByteVector.FromString (  								  string.Join ("/"' text)' StringType.Latin1));  						}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ValidateHeader,The following statement contains a magic number: ByteVector segment = ReadBlock (2);
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadSegmentMarker,The following statement contains a magic number: ByteVector segment_header = ReadBlock (2);
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadSegmentMarker,The following statement contains a magic number: if (segment_header.Count != 2)  				throw new CorruptFileException ("Could not read enough bytes for segment maker");
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadSegmentMarker,The following statement contains a magic number: if (segment_header[0] != 0xFF)  				throw new CorruptFileException ("Start of Segment expected at " + (Tell - 2));
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadSegmentSize,The following statement contains a magic number: ByteVector segment_size_bytes = ReadBlock (2);
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadSegmentSize,The following statement contains a magic number: if (segment_size_bytes.Count != 2)  				throw new CorruptFileException ("Could not read enough bytes to determine segment size");
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadSegmentSize,The following statement contains a magic number: if (segment_size < 2)  				throw new CorruptFileException (String.Format ("Invalid segment size ({0} bytes)"' segment_size));
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadMetadata,The following statement contains a magic number: while (true) {  				Marker marker = ReadSegmentMarker ();    				// we stop parsing when the end of file (EOI) or the begin of the  				// data segment is reached (SOS)  				// the second case is a trade-off between tolerant and fast parsing  				if (marker == Marker.EOI || marker == Marker.SOS)  					break;    				long position = Tell;  				ushort segment_size = ReadSegmentSize ();    				// segment size contains 2 bytes of the size itself' so the  				// pure data size is this (and the cast is save)  				ushort data_size = (ushort) (segment_size - 2);    				switch (marker) {  				case Marker.APP0:	// possibly JFIF header  					ReadJFIFHeader (data_size);  					break;    				case Marker.APP1:	// possibly Exif or Xmp data found  					ReadAPP1Segment (data_size);  					break;    				case Marker.APP13: // possibly IPTC-IIM  					ReadAPP13Segment (data_size);  					break;    				case Marker.COM:	// Comment segment found  					ReadCOMSegment (data_size);  					break;    				case Marker.SOF0:  				case Marker.SOF1:  				case Marker.SOF2:  				case Marker.SOF3:  				case Marker.SOF9:  				case Marker.SOF10:  				case Marker.SOF11:  					ReadSOFSegment (data_size' marker);  					break;    				case Marker.DQT:	// Quantization table(s)' use it to guess quality  					ReadDQTSegment (data_size);  					break;  				}    				// set position to next segment and start with next segment marker  				Seek (position + segment_size' SeekOrigin.Begin);  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadJFIFHeader,The following statement contains a magic number: if (Tell != 6)  				return;
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadJFIFHeader,The following statement contains a magic number: if (ReadBlock (5).ToString ().Equals ("JFIF\0")) {    				// store the JFIF header as it is  				Seek (2' SeekOrigin.Begin);  				jfif_header = ReadBlock (length + 2 + 2);    				AddMetadataBlock (2' length + 2 + 2);  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadJFIFHeader,The following statement contains a magic number: if (ReadBlock (5).ToString ().Equals ("JFIF\0")) {    				// store the JFIF header as it is  				Seek (2' SeekOrigin.Begin);  				jfif_header = ReadBlock (length + 2 + 2);    				AddMetadataBlock (2' length + 2 + 2);  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadJFIFHeader,The following statement contains a magic number: if (ReadBlock (5).ToString ().Equals ("JFIF\0")) {    				// store the JFIF header as it is  				Seek (2' SeekOrigin.Begin);  				jfif_header = ReadBlock (length + 2 + 2);    				AddMetadataBlock (2' length + 2 + 2);  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadJFIFHeader,The following statement contains a magic number: if (ReadBlock (5).ToString ().Equals ("JFIF\0")) {    				// store the JFIF header as it is  				Seek (2' SeekOrigin.Begin);  				jfif_header = ReadBlock (length + 2 + 2);    				AddMetadataBlock (2' length + 2 + 2);  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadJFIFHeader,The following statement contains a magic number: if (ReadBlock (5).ToString ().Equals ("JFIF\0")) {    				// store the JFIF header as it is  				Seek (2' SeekOrigin.Begin);  				jfif_header = ReadBlock (length + 2 + 2);    				AddMetadataBlock (2' length + 2 + 2);  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadJFIFHeader,The following statement contains a magic number: if (ReadBlock (5).ToString ().Equals ("JFIF\0")) {    				// store the JFIF header as it is  				Seek (2' SeekOrigin.Begin);  				jfif_header = ReadBlock (length + 2 + 2);    				AddMetadataBlock (2' length + 2 + 2);  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadJFIFHeader,The following statement contains a magic number: if (ReadBlock (5).ToString ().Equals ("JFIF\0")) {    				// store the JFIF header as it is  				Seek (2' SeekOrigin.Begin);  				jfif_header = ReadBlock (length + 2 + 2);    				AddMetadataBlock (2' length + 2 + 2);  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadAPP1Segment,The following statement contains a magic number: int exif_header_length = 14;
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadAPP1Segment,The following statement contains a magic number: if ((ImageTag.TagTypes & TagLib.TagTypes.TiffIFD) == 0x00 && length >= exif_header_length) {    				data = ReadBlock (exif_header_length);    				if (data.Count == exif_header_length  				    && data.Mid (0' 6).ToString ().Equals (EXIF_IDENTIFIER)) {    					bool is_bigendian = data.Mid (6' 2).ToString ().Equals ("MM");    					ushort magic = data.Mid (8' 2).ToUShort (is_bigendian);  					if (magic != 42)  						throw new Exception (String.Format ("Invalid TIFF magic: {0}"' magic));    					uint ifd_offset = data.Mid (10' 4).ToUInt (is_bigendian);    					var exif = new IFDTag ();  					var reader = new IFDReader (this' is_bigendian' exif.Structure' position + 6' ifd_offset' (uint) (length - 6));  					reader.Read ();  					ImageTag.AddTag (exif);    					AddMetadataBlock (position - 4' length + 4);    					return;  				}  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadAPP1Segment,The following statement contains a magic number: if ((ImageTag.TagTypes & TagLib.TagTypes.TiffIFD) == 0x00 && length >= exif_header_length) {    				data = ReadBlock (exif_header_length);    				if (data.Count == exif_header_length  				    && data.Mid (0' 6).ToString ().Equals (EXIF_IDENTIFIER)) {    					bool is_bigendian = data.Mid (6' 2).ToString ().Equals ("MM");    					ushort magic = data.Mid (8' 2).ToUShort (is_bigendian);  					if (magic != 42)  						throw new Exception (String.Format ("Invalid TIFF magic: {0}"' magic));    					uint ifd_offset = data.Mid (10' 4).ToUInt (is_bigendian);    					var exif = new IFDTag ();  					var reader = new IFDReader (this' is_bigendian' exif.Structure' position + 6' ifd_offset' (uint) (length - 6));  					reader.Read ();  					ImageTag.AddTag (exif);    					AddMetadataBlock (position - 4' length + 4);    					return;  				}  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadAPP1Segment,The following statement contains a magic number: if ((ImageTag.TagTypes & TagLib.TagTypes.TiffIFD) == 0x00 && length >= exif_header_length) {    				data = ReadBlock (exif_header_length);    				if (data.Count == exif_header_length  				    && data.Mid (0' 6).ToString ().Equals (EXIF_IDENTIFIER)) {    					bool is_bigendian = data.Mid (6' 2).ToString ().Equals ("MM");    					ushort magic = data.Mid (8' 2).ToUShort (is_bigendian);  					if (magic != 42)  						throw new Exception (String.Format ("Invalid TIFF magic: {0}"' magic));    					uint ifd_offset = data.Mid (10' 4).ToUInt (is_bigendian);    					var exif = new IFDTag ();  					var reader = new IFDReader (this' is_bigendian' exif.Structure' position + 6' ifd_offset' (uint) (length - 6));  					reader.Read ();  					ImageTag.AddTag (exif);    					AddMetadataBlock (position - 4' length + 4);    					return;  				}  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadAPP1Segment,The following statement contains a magic number: if ((ImageTag.TagTypes & TagLib.TagTypes.TiffIFD) == 0x00 && length >= exif_header_length) {    				data = ReadBlock (exif_header_length);    				if (data.Count == exif_header_length  				    && data.Mid (0' 6).ToString ().Equals (EXIF_IDENTIFIER)) {    					bool is_bigendian = data.Mid (6' 2).ToString ().Equals ("MM");    					ushort magic = data.Mid (8' 2).ToUShort (is_bigendian);  					if (magic != 42)  						throw new Exception (String.Format ("Invalid TIFF magic: {0}"' magic));    					uint ifd_offset = data.Mid (10' 4).ToUInt (is_bigendian);    					var exif = new IFDTag ();  					var reader = new IFDReader (this' is_bigendian' exif.Structure' position + 6' ifd_offset' (uint) (length - 6));  					reader.Read ();  					ImageTag.AddTag (exif);    					AddMetadataBlock (position - 4' length + 4);    					return;  				}  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadAPP1Segment,The following statement contains a magic number: if ((ImageTag.TagTypes & TagLib.TagTypes.TiffIFD) == 0x00 && length >= exif_header_length) {    				data = ReadBlock (exif_header_length);    				if (data.Count == exif_header_length  				    && data.Mid (0' 6).ToString ().Equals (EXIF_IDENTIFIER)) {    					bool is_bigendian = data.Mid (6' 2).ToString ().Equals ("MM");    					ushort magic = data.Mid (8' 2).ToUShort (is_bigendian);  					if (magic != 42)  						throw new Exception (String.Format ("Invalid TIFF magic: {0}"' magic));    					uint ifd_offset = data.Mid (10' 4).ToUInt (is_bigendian);    					var exif = new IFDTag ();  					var reader = new IFDReader (this' is_bigendian' exif.Structure' position + 6' ifd_offset' (uint) (length - 6));  					reader.Read ();  					ImageTag.AddTag (exif);    					AddMetadataBlock (position - 4' length + 4);    					return;  				}  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadAPP1Segment,The following statement contains a magic number: if ((ImageTag.TagTypes & TagLib.TagTypes.TiffIFD) == 0x00 && length >= exif_header_length) {    				data = ReadBlock (exif_header_length);    				if (data.Count == exif_header_length  				    && data.Mid (0' 6).ToString ().Equals (EXIF_IDENTIFIER)) {    					bool is_bigendian = data.Mid (6' 2).ToString ().Equals ("MM");    					ushort magic = data.Mid (8' 2).ToUShort (is_bigendian);  					if (magic != 42)  						throw new Exception (String.Format ("Invalid TIFF magic: {0}"' magic));    					uint ifd_offset = data.Mid (10' 4).ToUInt (is_bigendian);    					var exif = new IFDTag ();  					var reader = new IFDReader (this' is_bigendian' exif.Structure' position + 6' ifd_offset' (uint) (length - 6));  					reader.Read ();  					ImageTag.AddTag (exif);    					AddMetadataBlock (position - 4' length + 4);    					return;  				}  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadAPP1Segment,The following statement contains a magic number: if ((ImageTag.TagTypes & TagLib.TagTypes.TiffIFD) == 0x00 && length >= exif_header_length) {    				data = ReadBlock (exif_header_length);    				if (data.Count == exif_header_length  				    && data.Mid (0' 6).ToString ().Equals (EXIF_IDENTIFIER)) {    					bool is_bigendian = data.Mid (6' 2).ToString ().Equals ("MM");    					ushort magic = data.Mid (8' 2).ToUShort (is_bigendian);  					if (magic != 42)  						throw new Exception (String.Format ("Invalid TIFF magic: {0}"' magic));    					uint ifd_offset = data.Mid (10' 4).ToUInt (is_bigendian);    					var exif = new IFDTag ();  					var reader = new IFDReader (this' is_bigendian' exif.Structure' position + 6' ifd_offset' (uint) (length - 6));  					reader.Read ();  					ImageTag.AddTag (exif);    					AddMetadataBlock (position - 4' length + 4);    					return;  				}  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadAPP1Segment,The following statement contains a magic number: if ((ImageTag.TagTypes & TagLib.TagTypes.TiffIFD) == 0x00 && length >= exif_header_length) {    				data = ReadBlock (exif_header_length);    				if (data.Count == exif_header_length  				    && data.Mid (0' 6).ToString ().Equals (EXIF_IDENTIFIER)) {    					bool is_bigendian = data.Mid (6' 2).ToString ().Equals ("MM");    					ushort magic = data.Mid (8' 2).ToUShort (is_bigendian);  					if (magic != 42)  						throw new Exception (String.Format ("Invalid TIFF magic: {0}"' magic));    					uint ifd_offset = data.Mid (10' 4).ToUInt (is_bigendian);    					var exif = new IFDTag ();  					var reader = new IFDReader (this' is_bigendian' exif.Structure' position + 6' ifd_offset' (uint) (length - 6));  					reader.Read ();  					ImageTag.AddTag (exif);    					AddMetadataBlock (position - 4' length + 4);    					return;  				}  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadAPP1Segment,The following statement contains a magic number: if ((ImageTag.TagTypes & TagLib.TagTypes.TiffIFD) == 0x00 && length >= exif_header_length) {    				data = ReadBlock (exif_header_length);    				if (data.Count == exif_header_length  				    && data.Mid (0' 6).ToString ().Equals (EXIF_IDENTIFIER)) {    					bool is_bigendian = data.Mid (6' 2).ToString ().Equals ("MM");    					ushort magic = data.Mid (8' 2).ToUShort (is_bigendian);  					if (magic != 42)  						throw new Exception (String.Format ("Invalid TIFF magic: {0}"' magic));    					uint ifd_offset = data.Mid (10' 4).ToUInt (is_bigendian);    					var exif = new IFDTag ();  					var reader = new IFDReader (this' is_bigendian' exif.Structure' position + 6' ifd_offset' (uint) (length - 6));  					reader.Read ();  					ImageTag.AddTag (exif);    					AddMetadataBlock (position - 4' length + 4);    					return;  				}  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadAPP1Segment,The following statement contains a magic number: if ((ImageTag.TagTypes & TagLib.TagTypes.TiffIFD) == 0x00 && length >= exif_header_length) {    				data = ReadBlock (exif_header_length);    				if (data.Count == exif_header_length  				    && data.Mid (0' 6).ToString ().Equals (EXIF_IDENTIFIER)) {    					bool is_bigendian = data.Mid (6' 2).ToString ().Equals ("MM");    					ushort magic = data.Mid (8' 2).ToUShort (is_bigendian);  					if (magic != 42)  						throw new Exception (String.Format ("Invalid TIFF magic: {0}"' magic));    					uint ifd_offset = data.Mid (10' 4).ToUInt (is_bigendian);    					var exif = new IFDTag ();  					var reader = new IFDReader (this' is_bigendian' exif.Structure' position + 6' ifd_offset' (uint) (length - 6));  					reader.Read ();  					ImageTag.AddTag (exif);    					AddMetadataBlock (position - 4' length + 4);    					return;  				}  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadAPP1Segment,The following statement contains a magic number: if ((ImageTag.TagTypes & TagLib.TagTypes.TiffIFD) == 0x00 && length >= exif_header_length) {    				data = ReadBlock (exif_header_length);    				if (data.Count == exif_header_length  				    && data.Mid (0' 6).ToString ().Equals (EXIF_IDENTIFIER)) {    					bool is_bigendian = data.Mid (6' 2).ToString ().Equals ("MM");    					ushort magic = data.Mid (8' 2).ToUShort (is_bigendian);  					if (magic != 42)  						throw new Exception (String.Format ("Invalid TIFF magic: {0}"' magic));    					uint ifd_offset = data.Mid (10' 4).ToUInt (is_bigendian);    					var exif = new IFDTag ();  					var reader = new IFDReader (this' is_bigendian' exif.Structure' position + 6' ifd_offset' (uint) (length - 6));  					reader.Read ();  					ImageTag.AddTag (exif);    					AddMetadataBlock (position - 4' length + 4);    					return;  				}  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadAPP1Segment,The following statement contains a magic number: if ((ImageTag.TagTypes & TagLib.TagTypes.TiffIFD) == 0x00 && length >= exif_header_length) {    				data = ReadBlock (exif_header_length);    				if (data.Count == exif_header_length  				    && data.Mid (0' 6).ToString ().Equals (EXIF_IDENTIFIER)) {    					bool is_bigendian = data.Mid (6' 2).ToString ().Equals ("MM");    					ushort magic = data.Mid (8' 2).ToUShort (is_bigendian);  					if (magic != 42)  						throw new Exception (String.Format ("Invalid TIFF magic: {0}"' magic));    					uint ifd_offset = data.Mid (10' 4).ToUInt (is_bigendian);    					var exif = new IFDTag ();  					var reader = new IFDReader (this' is_bigendian' exif.Structure' position + 6' ifd_offset' (uint) (length - 6));  					reader.Read ();  					ImageTag.AddTag (exif);    					AddMetadataBlock (position - 4' length + 4);    					return;  				}  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadAPP1Segment,The following statement contains a magic number: if ((ImageTag.TagTypes & TagLib.TagTypes.XMP) == 0x00 && length >= xmp_header_length) {    				// if already data is read for determining the Exif segment'  				// just read the remaining bytes.  				// NOTE: that (exif_header_length < xmp_header_length) holds  				if (data == null)  					data = ReadBlock (xmp_header_length);  				else  					data.Add (ReadBlock (xmp_header_length - exif_header_length));    				if (data.ToString ().Equals (XmpTag.XAP_NS + "\0")) {  					ByteVector xmp_data = ReadBlock (length - xmp_header_length);    					ImageTag.AddTag (new XmpTag (xmp_data.ToString ()' this));    					AddMetadataBlock (position - 4' length + 4);  				}  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadAPP1Segment,The following statement contains a magic number: if ((ImageTag.TagTypes & TagLib.TagTypes.XMP) == 0x00 && length >= xmp_header_length) {    				// if already data is read for determining the Exif segment'  				// just read the remaining bytes.  				// NOTE: that (exif_header_length < xmp_header_length) holds  				if (data == null)  					data = ReadBlock (xmp_header_length);  				else  					data.Add (ReadBlock (xmp_header_length - exif_header_length));    				if (data.ToString ().Equals (XmpTag.XAP_NS + "\0")) {  					ByteVector xmp_data = ReadBlock (length - xmp_header_length);    					ImageTag.AddTag (new XmpTag (xmp_data.ToString ()' this));    					AddMetadataBlock (position - 4' length + 4);  				}  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadAPP13Segment,The following statement contains a magic number: if (headerInfoLen > 0) {  				// PS6 header: 1 byte headerinfolen + headerinfo + 2 bytes 00 padding (?) + 2 bytes length  				lenToSkip = 1 + headerInfoLen + 4;  			} else {  				//old style: 4 bytes 00 padding (?) + 2 bytes length  				lenToSkip = 6;  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadAPP13Segment,The following statement contains a magic number: if (headerInfoLen > 0) {  				// PS6 header: 1 byte headerinfolen + headerinfo + 2 bytes 00 padding (?) + 2 bytes length  				lenToSkip = 1 + headerInfoLen + 4;  			} else {  				//old style: 4 bytes 00 padding (?) + 2 bytes length  				lenToSkip = 6;  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,WriteMetadata,The following statement contains a magic number: SaveMetadata (data' 2);
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,RenderExifSegment,The following statement contains a magic number: uint first_ifd_offset = 8;
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,RenderExifSegment,The following statement contains a magic number: uint segment_size = (uint) (first_ifd_offset + exif_data.Count + 2 + 6);
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,RenderExifSegment,The following statement contains a magic number: uint segment_size = (uint) (first_ifd_offset + exif_data.Count + 2 + 6);
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,RenderExifSegment,The following statement contains a magic number: data.Add (ByteVector.FromUShort (42));
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,RenderXMPSegment,The following statement contains a magic number: uint segment_size = (uint) (2 + xmp_data.Count);
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadCOMSegment,The following statement contains a magic number: AddMetadataBlock (position - 4' length + 4);
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadCOMSegment,The following statement contains a magic number: AddMetadataBlock (position - 4' length + 4);
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,RenderCOMSegment,The following statement contains a magic number: uint segment_size = (uint) (2 + com_data.Count);
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadSOFSegment,The following statement contains a magic number: height = ReadBlock (2).ToUShort ();
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadSOFSegment,The following statement contains a magic number: width = ReadBlock (2).ToUShort ();
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadDQTSegment,The following statement contains a magic number: while (length > 0) {    				byte pqtq = ReadBlock (1)[0]; length --;  				byte pq = (byte)(pqtq >> 4);	//0 indicates 8-bit Qk' 1 indicates 16-bit Qk  				byte tq = (byte)(pqtq & 0x0f);	//table index;  				int [] table = null;  				switch (tq) {  				case 0:  					table = Table.StandardLuminanceQuantization;  					break;  				case 1:  					table = Table.StandardChrominanceQuantization;  					break;  				}    				bool allones = true; //check for all-ones tables (q=100)  				double cumsf = 0.0;  				//double cumsf2 = 0.0;  				for (int row = 0; row < 8; row ++) {  					for (int col = 0; col < 8; col++) {  						ushort val = ReadBlock (pq == 1 ? 2 : 1).ToUShort (); length -= (pq + 1);  						if (table != null) {  							double x = 100.0 * (double)val / (double)table [row*8+col]; //Scaling factor in percent  							cumsf += x;  							//cumsf2 += x*x;  							allones = allones && (val == 1);  						}  					}  				}    				if (table != null) {  					double local_q;  					cumsf /= 64.0;		// mean scale factor  					//cumfs2 /= 64.0;  					//double variance = cumsf2 - (cumsf * cumsf);    					if (allones)  						local_q = 100.0;  					else if (cumsf <= 100.0)  						local_q = (200.0 - cumsf) / 2.0;  					else  						local_q = 5000.0 / cumsf;  					quality = Math.Max (quality' (int)local_q);  				}  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadDQTSegment,The following statement contains a magic number: while (length > 0) {    				byte pqtq = ReadBlock (1)[0]; length --;  				byte pq = (byte)(pqtq >> 4);	//0 indicates 8-bit Qk' 1 indicates 16-bit Qk  				byte tq = (byte)(pqtq & 0x0f);	//table index;  				int [] table = null;  				switch (tq) {  				case 0:  					table = Table.StandardLuminanceQuantization;  					break;  				case 1:  					table = Table.StandardChrominanceQuantization;  					break;  				}    				bool allones = true; //check for all-ones tables (q=100)  				double cumsf = 0.0;  				//double cumsf2 = 0.0;  				for (int row = 0; row < 8; row ++) {  					for (int col = 0; col < 8; col++) {  						ushort val = ReadBlock (pq == 1 ? 2 : 1).ToUShort (); length -= (pq + 1);  						if (table != null) {  							double x = 100.0 * (double)val / (double)table [row*8+col]; //Scaling factor in percent  							cumsf += x;  							//cumsf2 += x*x;  							allones = allones && (val == 1);  						}  					}  				}    				if (table != null) {  					double local_q;  					cumsf /= 64.0;		// mean scale factor  					//cumfs2 /= 64.0;  					//double variance = cumsf2 - (cumsf * cumsf);    					if (allones)  						local_q = 100.0;  					else if (cumsf <= 100.0)  						local_q = (200.0 - cumsf) / 2.0;  					else  						local_q = 5000.0 / cumsf;  					quality = Math.Max (quality' (int)local_q);  				}  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadDQTSegment,The following statement contains a magic number: while (length > 0) {    				byte pqtq = ReadBlock (1)[0]; length --;  				byte pq = (byte)(pqtq >> 4);	//0 indicates 8-bit Qk' 1 indicates 16-bit Qk  				byte tq = (byte)(pqtq & 0x0f);	//table index;  				int [] table = null;  				switch (tq) {  				case 0:  					table = Table.StandardLuminanceQuantization;  					break;  				case 1:  					table = Table.StandardChrominanceQuantization;  					break;  				}    				bool allones = true; //check for all-ones tables (q=100)  				double cumsf = 0.0;  				//double cumsf2 = 0.0;  				for (int row = 0; row < 8; row ++) {  					for (int col = 0; col < 8; col++) {  						ushort val = ReadBlock (pq == 1 ? 2 : 1).ToUShort (); length -= (pq + 1);  						if (table != null) {  							double x = 100.0 * (double)val / (double)table [row*8+col]; //Scaling factor in percent  							cumsf += x;  							//cumsf2 += x*x;  							allones = allones && (val == 1);  						}  					}  				}    				if (table != null) {  					double local_q;  					cumsf /= 64.0;		// mean scale factor  					//cumfs2 /= 64.0;  					//double variance = cumsf2 - (cumsf * cumsf);    					if (allones)  						local_q = 100.0;  					else if (cumsf <= 100.0)  						local_q = (200.0 - cumsf) / 2.0;  					else  						local_q = 5000.0 / cumsf;  					quality = Math.Max (quality' (int)local_q);  				}  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadDQTSegment,The following statement contains a magic number: while (length > 0) {    				byte pqtq = ReadBlock (1)[0]; length --;  				byte pq = (byte)(pqtq >> 4);	//0 indicates 8-bit Qk' 1 indicates 16-bit Qk  				byte tq = (byte)(pqtq & 0x0f);	//table index;  				int [] table = null;  				switch (tq) {  				case 0:  					table = Table.StandardLuminanceQuantization;  					break;  				case 1:  					table = Table.StandardChrominanceQuantization;  					break;  				}    				bool allones = true; //check for all-ones tables (q=100)  				double cumsf = 0.0;  				//double cumsf2 = 0.0;  				for (int row = 0; row < 8; row ++) {  					for (int col = 0; col < 8; col++) {  						ushort val = ReadBlock (pq == 1 ? 2 : 1).ToUShort (); length -= (pq + 1);  						if (table != null) {  							double x = 100.0 * (double)val / (double)table [row*8+col]; //Scaling factor in percent  							cumsf += x;  							//cumsf2 += x*x;  							allones = allones && (val == 1);  						}  					}  				}    				if (table != null) {  					double local_q;  					cumsf /= 64.0;		// mean scale factor  					//cumfs2 /= 64.0;  					//double variance = cumsf2 - (cumsf * cumsf);    					if (allones)  						local_q = 100.0;  					else if (cumsf <= 100.0)  						local_q = (200.0 - cumsf) / 2.0;  					else  						local_q = 5000.0 / cumsf;  					quality = Math.Max (quality' (int)local_q);  				}  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadDQTSegment,The following statement contains a magic number: while (length > 0) {    				byte pqtq = ReadBlock (1)[0]; length --;  				byte pq = (byte)(pqtq >> 4);	//0 indicates 8-bit Qk' 1 indicates 16-bit Qk  				byte tq = (byte)(pqtq & 0x0f);	//table index;  				int [] table = null;  				switch (tq) {  				case 0:  					table = Table.StandardLuminanceQuantization;  					break;  				case 1:  					table = Table.StandardChrominanceQuantization;  					break;  				}    				bool allones = true; //check for all-ones tables (q=100)  				double cumsf = 0.0;  				//double cumsf2 = 0.0;  				for (int row = 0; row < 8; row ++) {  					for (int col = 0; col < 8; col++) {  						ushort val = ReadBlock (pq == 1 ? 2 : 1).ToUShort (); length -= (pq + 1);  						if (table != null) {  							double x = 100.0 * (double)val / (double)table [row*8+col]; //Scaling factor in percent  							cumsf += x;  							//cumsf2 += x*x;  							allones = allones && (val == 1);  						}  					}  				}    				if (table != null) {  					double local_q;  					cumsf /= 64.0;		// mean scale factor  					//cumfs2 /= 64.0;  					//double variance = cumsf2 - (cumsf * cumsf);    					if (allones)  						local_q = 100.0;  					else if (cumsf <= 100.0)  						local_q = (200.0 - cumsf) / 2.0;  					else  						local_q = 5000.0 / cumsf;  					quality = Math.Max (quality' (int)local_q);  				}  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadDQTSegment,The following statement contains a magic number: while (length > 0) {    				byte pqtq = ReadBlock (1)[0]; length --;  				byte pq = (byte)(pqtq >> 4);	//0 indicates 8-bit Qk' 1 indicates 16-bit Qk  				byte tq = (byte)(pqtq & 0x0f);	//table index;  				int [] table = null;  				switch (tq) {  				case 0:  					table = Table.StandardLuminanceQuantization;  					break;  				case 1:  					table = Table.StandardChrominanceQuantization;  					break;  				}    				bool allones = true; //check for all-ones tables (q=100)  				double cumsf = 0.0;  				//double cumsf2 = 0.0;  				for (int row = 0; row < 8; row ++) {  					for (int col = 0; col < 8; col++) {  						ushort val = ReadBlock (pq == 1 ? 2 : 1).ToUShort (); length -= (pq + 1);  						if (table != null) {  							double x = 100.0 * (double)val / (double)table [row*8+col]; //Scaling factor in percent  							cumsf += x;  							//cumsf2 += x*x;  							allones = allones && (val == 1);  						}  					}  				}    				if (table != null) {  					double local_q;  					cumsf /= 64.0;		// mean scale factor  					//cumfs2 /= 64.0;  					//double variance = cumsf2 - (cumsf * cumsf);    					if (allones)  						local_q = 100.0;  					else if (cumsf <= 100.0)  						local_q = (200.0 - cumsf) / 2.0;  					else  						local_q = 5000.0 / cumsf;  					quality = Math.Max (quality' (int)local_q);  				}  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadDQTSegment,The following statement contains a magic number: while (length > 0) {    				byte pqtq = ReadBlock (1)[0]; length --;  				byte pq = (byte)(pqtq >> 4);	//0 indicates 8-bit Qk' 1 indicates 16-bit Qk  				byte tq = (byte)(pqtq & 0x0f);	//table index;  				int [] table = null;  				switch (tq) {  				case 0:  					table = Table.StandardLuminanceQuantization;  					break;  				case 1:  					table = Table.StandardChrominanceQuantization;  					break;  				}    				bool allones = true; //check for all-ones tables (q=100)  				double cumsf = 0.0;  				//double cumsf2 = 0.0;  				for (int row = 0; row < 8; row ++) {  					for (int col = 0; col < 8; col++) {  						ushort val = ReadBlock (pq == 1 ? 2 : 1).ToUShort (); length -= (pq + 1);  						if (table != null) {  							double x = 100.0 * (double)val / (double)table [row*8+col]; //Scaling factor in percent  							cumsf += x;  							//cumsf2 += x*x;  							allones = allones && (val == 1);  						}  					}  				}    				if (table != null) {  					double local_q;  					cumsf /= 64.0;		// mean scale factor  					//cumfs2 /= 64.0;  					//double variance = cumsf2 - (cumsf * cumsf);    					if (allones)  						local_q = 100.0;  					else if (cumsf <= 100.0)  						local_q = (200.0 - cumsf) / 2.0;  					else  						local_q = 5000.0 / cumsf;  					quality = Math.Max (quality' (int)local_q);  				}  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadDQTSegment,The following statement contains a magic number: while (length > 0) {    				byte pqtq = ReadBlock (1)[0]; length --;  				byte pq = (byte)(pqtq >> 4);	//0 indicates 8-bit Qk' 1 indicates 16-bit Qk  				byte tq = (byte)(pqtq & 0x0f);	//table index;  				int [] table = null;  				switch (tq) {  				case 0:  					table = Table.StandardLuminanceQuantization;  					break;  				case 1:  					table = Table.StandardChrominanceQuantization;  					break;  				}    				bool allones = true; //check for all-ones tables (q=100)  				double cumsf = 0.0;  				//double cumsf2 = 0.0;  				for (int row = 0; row < 8; row ++) {  					for (int col = 0; col < 8; col++) {  						ushort val = ReadBlock (pq == 1 ? 2 : 1).ToUShort (); length -= (pq + 1);  						if (table != null) {  							double x = 100.0 * (double)val / (double)table [row*8+col]; //Scaling factor in percent  							cumsf += x;  							//cumsf2 += x*x;  							allones = allones && (val == 1);  						}  					}  				}    				if (table != null) {  					double local_q;  					cumsf /= 64.0;		// mean scale factor  					//cumfs2 /= 64.0;  					//double variance = cumsf2 - (cumsf * cumsf);    					if (allones)  						local_q = 100.0;  					else if (cumsf <= 100.0)  						local_q = (200.0 - cumsf) / 2.0;  					else  						local_q = 5000.0 / cumsf;  					quality = Math.Max (quality' (int)local_q);  				}  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadDQTSegment,The following statement contains a magic number: while (length > 0) {    				byte pqtq = ReadBlock (1)[0]; length --;  				byte pq = (byte)(pqtq >> 4);	//0 indicates 8-bit Qk' 1 indicates 16-bit Qk  				byte tq = (byte)(pqtq & 0x0f);	//table index;  				int [] table = null;  				switch (tq) {  				case 0:  					table = Table.StandardLuminanceQuantization;  					break;  				case 1:  					table = Table.StandardChrominanceQuantization;  					break;  				}    				bool allones = true; //check for all-ones tables (q=100)  				double cumsf = 0.0;  				//double cumsf2 = 0.0;  				for (int row = 0; row < 8; row ++) {  					for (int col = 0; col < 8; col++) {  						ushort val = ReadBlock (pq == 1 ? 2 : 1).ToUShort (); length -= (pq + 1);  						if (table != null) {  							double x = 100.0 * (double)val / (double)table [row*8+col]; //Scaling factor in percent  							cumsf += x;  							//cumsf2 += x*x;  							allones = allones && (val == 1);  						}  					}  				}    				if (table != null) {  					double local_q;  					cumsf /= 64.0;		// mean scale factor  					//cumfs2 /= 64.0;  					//double variance = cumsf2 - (cumsf * cumsf);    					if (allones)  						local_q = 100.0;  					else if (cumsf <= 100.0)  						local_q = (200.0 - cumsf) / 2.0;  					else  						local_q = 5000.0 / cumsf;  					quality = Math.Max (quality' (int)local_q);  				}  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadDQTSegment,The following statement contains a magic number: while (length > 0) {    				byte pqtq = ReadBlock (1)[0]; length --;  				byte pq = (byte)(pqtq >> 4);	//0 indicates 8-bit Qk' 1 indicates 16-bit Qk  				byte tq = (byte)(pqtq & 0x0f);	//table index;  				int [] table = null;  				switch (tq) {  				case 0:  					table = Table.StandardLuminanceQuantization;  					break;  				case 1:  					table = Table.StandardChrominanceQuantization;  					break;  				}    				bool allones = true; //check for all-ones tables (q=100)  				double cumsf = 0.0;  				//double cumsf2 = 0.0;  				for (int row = 0; row < 8; row ++) {  					for (int col = 0; col < 8; col++) {  						ushort val = ReadBlock (pq == 1 ? 2 : 1).ToUShort (); length -= (pq + 1);  						if (table != null) {  							double x = 100.0 * (double)val / (double)table [row*8+col]; //Scaling factor in percent  							cumsf += x;  							//cumsf2 += x*x;  							allones = allones && (val == 1);  						}  					}  				}    				if (table != null) {  					double local_q;  					cumsf /= 64.0;		// mean scale factor  					//cumfs2 /= 64.0;  					//double variance = cumsf2 - (cumsf * cumsf);    					if (allones)  						local_q = 100.0;  					else if (cumsf <= 100.0)  						local_q = (200.0 - cumsf) / 2.0;  					else  						local_q = 5000.0 / cumsf;  					quality = Math.Max (quality' (int)local_q);  				}  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadDQTSegment,The following statement contains a magic number: while (length > 0) {    				byte pqtq = ReadBlock (1)[0]; length --;  				byte pq = (byte)(pqtq >> 4);	//0 indicates 8-bit Qk' 1 indicates 16-bit Qk  				byte tq = (byte)(pqtq & 0x0f);	//table index;  				int [] table = null;  				switch (tq) {  				case 0:  					table = Table.StandardLuminanceQuantization;  					break;  				case 1:  					table = Table.StandardChrominanceQuantization;  					break;  				}    				bool allones = true; //check for all-ones tables (q=100)  				double cumsf = 0.0;  				//double cumsf2 = 0.0;  				for (int row = 0; row < 8; row ++) {  					for (int col = 0; col < 8; col++) {  						ushort val = ReadBlock (pq == 1 ? 2 : 1).ToUShort (); length -= (pq + 1);  						if (table != null) {  							double x = 100.0 * (double)val / (double)table [row*8+col]; //Scaling factor in percent  							cumsf += x;  							//cumsf2 += x*x;  							allones = allones && (val == 1);  						}  					}  				}    				if (table != null) {  					double local_q;  					cumsf /= 64.0;		// mean scale factor  					//cumfs2 /= 64.0;  					//double variance = cumsf2 - (cumsf * cumsf);    					if (allones)  						local_q = 100.0;  					else if (cumsf <= 100.0)  						local_q = (200.0 - cumsf) / 2.0;  					else  						local_q = 5000.0 / cumsf;  					quality = Math.Max (quality' (int)local_q);  				}  			}
Magic Number,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadDQTSegment,The following statement contains a magic number: while (length > 0) {    				byte pqtq = ReadBlock (1)[0]; length --;  				byte pq = (byte)(pqtq >> 4);	//0 indicates 8-bit Qk' 1 indicates 16-bit Qk  				byte tq = (byte)(pqtq & 0x0f);	//table index;  				int [] table = null;  				switch (tq) {  				case 0:  					table = Table.StandardLuminanceQuantization;  					break;  				case 1:  					table = Table.StandardChrominanceQuantization;  					break;  				}    				bool allones = true; //check for all-ones tables (q=100)  				double cumsf = 0.0;  				//double cumsf2 = 0.0;  				for (int row = 0; row < 8; row ++) {  					for (int col = 0; col < 8; col++) {  						ushort val = ReadBlock (pq == 1 ? 2 : 1).ToUShort (); length -= (pq + 1);  						if (table != null) {  							double x = 100.0 * (double)val / (double)table [row*8+col]; //Scaling factor in percent  							cumsf += x;  							//cumsf2 += x*x;  							allones = allones && (val == 1);  						}  					}  				}    				if (table != null) {  					double local_q;  					cumsf /= 64.0;		// mean scale factor  					//cumfs2 /= 64.0;  					//double variance = cumsf2 - (cumsf * cumsf);    					if (allones)  						local_q = 100.0;  					else if (cumsf <= 100.0)  						local_q = (200.0 - cumsf) / 2.0;  					else  						local_q = 5000.0 / cumsf;  					quality = Math.Max (quality' (int)local_q);  				}  			}
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,StreamHeader,The following statement contains a magic number: version = 7;
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,StreamHeader,The following statement contains a magic number: channels = 2;
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,StreamHeader,The following statement contains a magic number: ByteVector magic = file.ReadBlock(4);
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,StreamHeader,The following statement contains a magic number: if (magic.StartsWith(FileIdentifierSv7))  				// SV7 Format has a fixed Header size  				ReadSv7Properties(magic + file.ReadBlock((int)SizeSV7 - 4));   			else if (magic.StartsWith(FileIdentifierSv8))  				// for SV8 the properties need to be read from  				// packet information inside the file   				ReadSv8Properties(file);  			else  				throw new CorruptFileException(  					"Data does not begin with identifier.");
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,ReadSv7Properties,The following statement contains a magic number: version = data[3] & 15;
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,ReadSv7Properties,The following statement contains a magic number: version = data[3] & 15;
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,ReadSv7Properties,The following statement contains a magic number: channels = 2;
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,ReadSv7Properties,The following statement contains a magic number: if (version == 7)  			{  				frames = data.Mid(4' 4).ToUInt(false);  				uint flags = data.Mid(8' 4).ToUInt(false);  				sample_rate = sftable[(int)(((flags >> 17) &  					1) * 2 + ((flags >> 16) & 1))];  				header_data = 0;  			}  			else {  				header_data = data.Mid(0' 4).ToUInt(false);  				version = (int)((header_data >> 11) & 0x03ff);  				sample_rate = 44100;  				frames = data.Mid(4'  					version >= 5 ? 4 : 2).ToUInt(false);  			}
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,ReadSv7Properties,The following statement contains a magic number: if (version == 7)  			{  				frames = data.Mid(4' 4).ToUInt(false);  				uint flags = data.Mid(8' 4).ToUInt(false);  				sample_rate = sftable[(int)(((flags >> 17) &  					1) * 2 + ((flags >> 16) & 1))];  				header_data = 0;  			}  			else {  				header_data = data.Mid(0' 4).ToUInt(false);  				version = (int)((header_data >> 11) & 0x03ff);  				sample_rate = 44100;  				frames = data.Mid(4'  					version >= 5 ? 4 : 2).ToUInt(false);  			}
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,ReadSv7Properties,The following statement contains a magic number: if (version == 7)  			{  				frames = data.Mid(4' 4).ToUInt(false);  				uint flags = data.Mid(8' 4).ToUInt(false);  				sample_rate = sftable[(int)(((flags >> 17) &  					1) * 2 + ((flags >> 16) & 1))];  				header_data = 0;  			}  			else {  				header_data = data.Mid(0' 4).ToUInt(false);  				version = (int)((header_data >> 11) & 0x03ff);  				sample_rate = 44100;  				frames = data.Mid(4'  					version >= 5 ? 4 : 2).ToUInt(false);  			}
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,ReadSv7Properties,The following statement contains a magic number: if (version == 7)  			{  				frames = data.Mid(4' 4).ToUInt(false);  				uint flags = data.Mid(8' 4).ToUInt(false);  				sample_rate = sftable[(int)(((flags >> 17) &  					1) * 2 + ((flags >> 16) & 1))];  				header_data = 0;  			}  			else {  				header_data = data.Mid(0' 4).ToUInt(false);  				version = (int)((header_data >> 11) & 0x03ff);  				sample_rate = 44100;  				frames = data.Mid(4'  					version >= 5 ? 4 : 2).ToUInt(false);  			}
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,ReadSv7Properties,The following statement contains a magic number: if (version == 7)  			{  				frames = data.Mid(4' 4).ToUInt(false);  				uint flags = data.Mid(8' 4).ToUInt(false);  				sample_rate = sftable[(int)(((flags >> 17) &  					1) * 2 + ((flags >> 16) & 1))];  				header_data = 0;  			}  			else {  				header_data = data.Mid(0' 4).ToUInt(false);  				version = (int)((header_data >> 11) & 0x03ff);  				sample_rate = 44100;  				frames = data.Mid(4'  					version >= 5 ? 4 : 2).ToUInt(false);  			}
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,ReadSv7Properties,The following statement contains a magic number: if (version == 7)  			{  				frames = data.Mid(4' 4).ToUInt(false);  				uint flags = data.Mid(8' 4).ToUInt(false);  				sample_rate = sftable[(int)(((flags >> 17) &  					1) * 2 + ((flags >> 16) & 1))];  				header_data = 0;  			}  			else {  				header_data = data.Mid(0' 4).ToUInt(false);  				version = (int)((header_data >> 11) & 0x03ff);  				sample_rate = 44100;  				frames = data.Mid(4'  					version >= 5 ? 4 : 2).ToUInt(false);  			}
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,ReadSv7Properties,The following statement contains a magic number: if (version == 7)  			{  				frames = data.Mid(4' 4).ToUInt(false);  				uint flags = data.Mid(8' 4).ToUInt(false);  				sample_rate = sftable[(int)(((flags >> 17) &  					1) * 2 + ((flags >> 16) & 1))];  				header_data = 0;  			}  			else {  				header_data = data.Mid(0' 4).ToUInt(false);  				version = (int)((header_data >> 11) & 0x03ff);  				sample_rate = 44100;  				frames = data.Mid(4'  					version >= 5 ? 4 : 2).ToUInt(false);  			}
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,ReadSv7Properties,The following statement contains a magic number: if (version == 7)  			{  				frames = data.Mid(4' 4).ToUInt(false);  				uint flags = data.Mid(8' 4).ToUInt(false);  				sample_rate = sftable[(int)(((flags >> 17) &  					1) * 2 + ((flags >> 16) & 1))];  				header_data = 0;  			}  			else {  				header_data = data.Mid(0' 4).ToUInt(false);  				version = (int)((header_data >> 11) & 0x03ff);  				sample_rate = 44100;  				frames = data.Mid(4'  					version >= 5 ? 4 : 2).ToUInt(false);  			}
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,ReadSv7Properties,The following statement contains a magic number: if (version == 7)  			{  				frames = data.Mid(4' 4).ToUInt(false);  				uint flags = data.Mid(8' 4).ToUInt(false);  				sample_rate = sftable[(int)(((flags >> 17) &  					1) * 2 + ((flags >> 16) & 1))];  				header_data = 0;  			}  			else {  				header_data = data.Mid(0' 4).ToUInt(false);  				version = (int)((header_data >> 11) & 0x03ff);  				sample_rate = 44100;  				frames = data.Mid(4'  					version >= 5 ? 4 : 2).ToUInt(false);  			}
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,ReadSv7Properties,The following statement contains a magic number: if (version == 7)  			{  				frames = data.Mid(4' 4).ToUInt(false);  				uint flags = data.Mid(8' 4).ToUInt(false);  				sample_rate = sftable[(int)(((flags >> 17) &  					1) * 2 + ((flags >> 16) & 1))];  				header_data = 0;  			}  			else {  				header_data = data.Mid(0' 4).ToUInt(false);  				version = (int)((header_data >> 11) & 0x03ff);  				sample_rate = 44100;  				frames = data.Mid(4'  					version >= 5 ? 4 : 2).ToUInt(false);  			}
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,ReadSv7Properties,The following statement contains a magic number: if (version == 7)  			{  				frames = data.Mid(4' 4).ToUInt(false);  				uint flags = data.Mid(8' 4).ToUInt(false);  				sample_rate = sftable[(int)(((flags >> 17) &  					1) * 2 + ((flags >> 16) & 1))];  				header_data = 0;  			}  			else {  				header_data = data.Mid(0' 4).ToUInt(false);  				version = (int)((header_data >> 11) & 0x03ff);  				sample_rate = 44100;  				frames = data.Mid(4'  					version >= 5 ? 4 : 2).ToUInt(false);  			}
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,ReadSv7Properties,The following statement contains a magic number: if (version == 7)  			{  				frames = data.Mid(4' 4).ToUInt(false);  				uint flags = data.Mid(8' 4).ToUInt(false);  				sample_rate = sftable[(int)(((flags >> 17) &  					1) * 2 + ((flags >> 16) & 1))];  				header_data = 0;  			}  			else {  				header_data = data.Mid(0' 4).ToUInt(false);  				version = (int)((header_data >> 11) & 0x03ff);  				sample_rate = 44100;  				frames = data.Mid(4'  					version >= 5 ? 4 : 2).ToUInt(false);  			}
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,ReadSv7Properties,The following statement contains a magic number: if (version == 7)  			{  				frames = data.Mid(4' 4).ToUInt(false);  				uint flags = data.Mid(8' 4).ToUInt(false);  				sample_rate = sftable[(int)(((flags >> 17) &  					1) * 2 + ((flags >> 16) & 1))];  				header_data = 0;  			}  			else {  				header_data = data.Mid(0' 4).ToUInt(false);  				version = (int)((header_data >> 11) & 0x03ff);  				sample_rate = 44100;  				frames = data.Mid(4'  					version >= 5 ? 4 : 2).ToUInt(false);  			}
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,ReadSv7Properties,The following statement contains a magic number: if (version == 7)  			{  				frames = data.Mid(4' 4).ToUInt(false);  				uint flags = data.Mid(8' 4).ToUInt(false);  				sample_rate = sftable[(int)(((flags >> 17) &  					1) * 2 + ((flags >> 16) & 1))];  				header_data = 0;  			}  			else {  				header_data = data.Mid(0' 4).ToUInt(false);  				version = (int)((header_data >> 11) & 0x03ff);  				sample_rate = 44100;  				frames = data.Mid(4'  					version >= 5 ? 4 : 2).ToUInt(false);  			}
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,ReadSv7Properties,The following statement contains a magic number: if (version == 7)  			{  				frames = data.Mid(4' 4).ToUInt(false);  				uint flags = data.Mid(8' 4).ToUInt(false);  				sample_rate = sftable[(int)(((flags >> 17) &  					1) * 2 + ((flags >> 16) & 1))];  				header_data = 0;  			}  			else {  				header_data = data.Mid(0' 4).ToUInt(false);  				version = (int)((header_data >> 11) & 0x03ff);  				sample_rate = 44100;  				frames = data.Mid(4'  					version >= 5 ? 4 : 2).ToUInt(false);  			}
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,ReadSv8Properties,The following statement contains a magic number: while (!foundSH)  			{  				ByteVector packetType = file.ReadBlock(2);    				uint packetSizeLength = 0;  				bool eof = false;    				ulong packetSize = ReadSize(file' ref packetSizeLength' ref eof);  				if (eof)  				{  					break;  				}    				ulong payloadSize = packetSize - 2 - packetSizeLength;  				ByteVector data = file.ReadBlock((int)payloadSize);  				  				if (packetType == "SH")  				{  					foundSH = true;    					if (payloadSize <= 5)  					{  						break;  					}    					int pos = 4;  					version = data[pos];  					pos += 1;  					frames = (uint)ReadSize(data' ref pos);  					if (pos > (uint)payloadSize - 3)  					{  						break;  					}    					ulong beginSilence = ReadSize(data' ref pos);  					if (pos > (uint)payloadSize - 2)  					{  						break;  					}    					ushort flags = data.Mid(pos' 1).ToUShort(true);    					sample_rate = sftable[(flags >> 13) & 0x07];  					channels = ((flags >> 4) & 0x0F) + 1;    					framecount = frames - beginSilence;  				}  				else if (packetType == "SE")  				{  					break;  				}  				else  				{  					file.Seek((int)payloadSize' SeekOrigin.Current);  				}  			}
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,ReadSv8Properties,The following statement contains a magic number: while (!foundSH)  			{  				ByteVector packetType = file.ReadBlock(2);    				uint packetSizeLength = 0;  				bool eof = false;    				ulong packetSize = ReadSize(file' ref packetSizeLength' ref eof);  				if (eof)  				{  					break;  				}    				ulong payloadSize = packetSize - 2 - packetSizeLength;  				ByteVector data = file.ReadBlock((int)payloadSize);  				  				if (packetType == "SH")  				{  					foundSH = true;    					if (payloadSize <= 5)  					{  						break;  					}    					int pos = 4;  					version = data[pos];  					pos += 1;  					frames = (uint)ReadSize(data' ref pos);  					if (pos > (uint)payloadSize - 3)  					{  						break;  					}    					ulong beginSilence = ReadSize(data' ref pos);  					if (pos > (uint)payloadSize - 2)  					{  						break;  					}    					ushort flags = data.Mid(pos' 1).ToUShort(true);    					sample_rate = sftable[(flags >> 13) & 0x07];  					channels = ((flags >> 4) & 0x0F) + 1;    					framecount = frames - beginSilence;  				}  				else if (packetType == "SE")  				{  					break;  				}  				else  				{  					file.Seek((int)payloadSize' SeekOrigin.Current);  				}  			}
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,ReadSv8Properties,The following statement contains a magic number: while (!foundSH)  			{  				ByteVector packetType = file.ReadBlock(2);    				uint packetSizeLength = 0;  				bool eof = false;    				ulong packetSize = ReadSize(file' ref packetSizeLength' ref eof);  				if (eof)  				{  					break;  				}    				ulong payloadSize = packetSize - 2 - packetSizeLength;  				ByteVector data = file.ReadBlock((int)payloadSize);  				  				if (packetType == "SH")  				{  					foundSH = true;    					if (payloadSize <= 5)  					{  						break;  					}    					int pos = 4;  					version = data[pos];  					pos += 1;  					frames = (uint)ReadSize(data' ref pos);  					if (pos > (uint)payloadSize - 3)  					{  						break;  					}    					ulong beginSilence = ReadSize(data' ref pos);  					if (pos > (uint)payloadSize - 2)  					{  						break;  					}    					ushort flags = data.Mid(pos' 1).ToUShort(true);    					sample_rate = sftable[(flags >> 13) & 0x07];  					channels = ((flags >> 4) & 0x0F) + 1;    					framecount = frames - beginSilence;  				}  				else if (packetType == "SE")  				{  					break;  				}  				else  				{  					file.Seek((int)payloadSize' SeekOrigin.Current);  				}  			}
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,ReadSv8Properties,The following statement contains a magic number: while (!foundSH)  			{  				ByteVector packetType = file.ReadBlock(2);    				uint packetSizeLength = 0;  				bool eof = false;    				ulong packetSize = ReadSize(file' ref packetSizeLength' ref eof);  				if (eof)  				{  					break;  				}    				ulong payloadSize = packetSize - 2 - packetSizeLength;  				ByteVector data = file.ReadBlock((int)payloadSize);  				  				if (packetType == "SH")  				{  					foundSH = true;    					if (payloadSize <= 5)  					{  						break;  					}    					int pos = 4;  					version = data[pos];  					pos += 1;  					frames = (uint)ReadSize(data' ref pos);  					if (pos > (uint)payloadSize - 3)  					{  						break;  					}    					ulong beginSilence = ReadSize(data' ref pos);  					if (pos > (uint)payloadSize - 2)  					{  						break;  					}    					ushort flags = data.Mid(pos' 1).ToUShort(true);    					sample_rate = sftable[(flags >> 13) & 0x07];  					channels = ((flags >> 4) & 0x0F) + 1;    					framecount = frames - beginSilence;  				}  				else if (packetType == "SE")  				{  					break;  				}  				else  				{  					file.Seek((int)payloadSize' SeekOrigin.Current);  				}  			}
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,ReadSv8Properties,The following statement contains a magic number: while (!foundSH)  			{  				ByteVector packetType = file.ReadBlock(2);    				uint packetSizeLength = 0;  				bool eof = false;    				ulong packetSize = ReadSize(file' ref packetSizeLength' ref eof);  				if (eof)  				{  					break;  				}    				ulong payloadSize = packetSize - 2 - packetSizeLength;  				ByteVector data = file.ReadBlock((int)payloadSize);  				  				if (packetType == "SH")  				{  					foundSH = true;    					if (payloadSize <= 5)  					{  						break;  					}    					int pos = 4;  					version = data[pos];  					pos += 1;  					frames = (uint)ReadSize(data' ref pos);  					if (pos > (uint)payloadSize - 3)  					{  						break;  					}    					ulong beginSilence = ReadSize(data' ref pos);  					if (pos > (uint)payloadSize - 2)  					{  						break;  					}    					ushort flags = data.Mid(pos' 1).ToUShort(true);    					sample_rate = sftable[(flags >> 13) & 0x07];  					channels = ((flags >> 4) & 0x0F) + 1;    					framecount = frames - beginSilence;  				}  				else if (packetType == "SE")  				{  					break;  				}  				else  				{  					file.Seek((int)payloadSize' SeekOrigin.Current);  				}  			}
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,ReadSv8Properties,The following statement contains a magic number: while (!foundSH)  			{  				ByteVector packetType = file.ReadBlock(2);    				uint packetSizeLength = 0;  				bool eof = false;    				ulong packetSize = ReadSize(file' ref packetSizeLength' ref eof);  				if (eof)  				{  					break;  				}    				ulong payloadSize = packetSize - 2 - packetSizeLength;  				ByteVector data = file.ReadBlock((int)payloadSize);  				  				if (packetType == "SH")  				{  					foundSH = true;    					if (payloadSize <= 5)  					{  						break;  					}    					int pos = 4;  					version = data[pos];  					pos += 1;  					frames = (uint)ReadSize(data' ref pos);  					if (pos > (uint)payloadSize - 3)  					{  						break;  					}    					ulong beginSilence = ReadSize(data' ref pos);  					if (pos > (uint)payloadSize - 2)  					{  						break;  					}    					ushort flags = data.Mid(pos' 1).ToUShort(true);    					sample_rate = sftable[(flags >> 13) & 0x07];  					channels = ((flags >> 4) & 0x0F) + 1;    					framecount = frames - beginSilence;  				}  				else if (packetType == "SE")  				{  					break;  				}  				else  				{  					file.Seek((int)payloadSize' SeekOrigin.Current);  				}  			}
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,ReadSv8Properties,The following statement contains a magic number: while (!foundSH)  			{  				ByteVector packetType = file.ReadBlock(2);    				uint packetSizeLength = 0;  				bool eof = false;    				ulong packetSize = ReadSize(file' ref packetSizeLength' ref eof);  				if (eof)  				{  					break;  				}    				ulong payloadSize = packetSize - 2 - packetSizeLength;  				ByteVector data = file.ReadBlock((int)payloadSize);  				  				if (packetType == "SH")  				{  					foundSH = true;    					if (payloadSize <= 5)  					{  						break;  					}    					int pos = 4;  					version = data[pos];  					pos += 1;  					frames = (uint)ReadSize(data' ref pos);  					if (pos > (uint)payloadSize - 3)  					{  						break;  					}    					ulong beginSilence = ReadSize(data' ref pos);  					if (pos > (uint)payloadSize - 2)  					{  						break;  					}    					ushort flags = data.Mid(pos' 1).ToUShort(true);    					sample_rate = sftable[(flags >> 13) & 0x07];  					channels = ((flags >> 4) & 0x0F) + 1;    					framecount = frames - beginSilence;  				}  				else if (packetType == "SE")  				{  					break;  				}  				else  				{  					file.Seek((int)payloadSize' SeekOrigin.Current);  				}  			}
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,ReadSv8Properties,The following statement contains a magic number: while (!foundSH)  			{  				ByteVector packetType = file.ReadBlock(2);    				uint packetSizeLength = 0;  				bool eof = false;    				ulong packetSize = ReadSize(file' ref packetSizeLength' ref eof);  				if (eof)  				{  					break;  				}    				ulong payloadSize = packetSize - 2 - packetSizeLength;  				ByteVector data = file.ReadBlock((int)payloadSize);  				  				if (packetType == "SH")  				{  					foundSH = true;    					if (payloadSize <= 5)  					{  						break;  					}    					int pos = 4;  					version = data[pos];  					pos += 1;  					frames = (uint)ReadSize(data' ref pos);  					if (pos > (uint)payloadSize - 3)  					{  						break;  					}    					ulong beginSilence = ReadSize(data' ref pos);  					if (pos > (uint)payloadSize - 2)  					{  						break;  					}    					ushort flags = data.Mid(pos' 1).ToUShort(true);    					sample_rate = sftable[(flags >> 13) & 0x07];  					channels = ((flags >> 4) & 0x0F) + 1;    					framecount = frames - beginSilence;  				}  				else if (packetType == "SE")  				{  					break;  				}  				else  				{  					file.Seek((int)payloadSize' SeekOrigin.Current);  				}  			}
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,ReadSize,The following statement contains a magic number: do  			{  				ByteVector b = file.ReadBlock(1);  				if (b.IsEmpty)  				{  					eof = true;  					break;  				}    				tmp = b.ToUInt();  				size = (size << 7) | (tmp & 0x7F);  				packetSizeLength++;  			} while ((tmp & 0x80) == 1);
Magic Number,TagLib.MusePack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpc\StreamHeader.cs,ReadSize,The following statement contains a magic number: do  			{  				tmp = data[pos++];  				size = (size << 7) | (tmp & 0x7F);  			} while ((tmp & 0x80) == 0x80 && pos < data.Count);
Magic Number,TagLib.Mpeg,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\AudioHeader.cs,AudioHeader,The following statement contains a magic number: ByteVector xing_data = file.ReadBlock (16);
Magic Number,TagLib.Mpeg,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\AudioHeader.cs,AudioHeader,The following statement contains a magic number: if (xing_data.Count == 16 && xing_data.StartsWith (  				XingHeader.FileIdentifier))  				xing_header = new XingHeader (xing_data);
Magic Number,TagLib.Mpeg,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\AudioHeader.cs,AudioHeader,The following statement contains a magic number: ByteVector vbri_data = file.ReadBlock (24);
Magic Number,TagLib.Mpeg,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\AudioHeader.cs,AudioHeader,The following statement contains a magic number: if (vbri_data.Count == 24 &&  				vbri_data.StartsWith(VBRIHeader.FileIdentifier))  			vbri_header = new VBRIHeader (vbri_data);
Magic Number,TagLib.Mpeg,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\AudioHeader.cs,Find,The following statement contains a magic number: ByteVector buffer = file.ReadBlock (3);
Magic Number,TagLib.Mpeg,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\AudioHeader.cs,Find,The following statement contains a magic number: if (buffer.Count < 3)  				return false;
Magic Number,TagLib.Mpeg,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\AudioHeader.cs,Find,The following statement contains a magic number: do {  				file.Seek (position + 3);  				buffer = buffer.Mid (buffer.Count - 3);  				buffer.Add (file.ReadBlock (  					(int) File.BufferSize));  				  				for (int i = 0; i < buffer.Count - 3 &&  					(length < 0 || position + i < end); i++)  					if (buffer [i] == 0xFF &&  						buffer [i + 1] > 0xE0) {  						ByteVector data = buffer.Mid(i' 4);  						if (GetHeaderError(data) == null) {  							try {  								header = new AudioHeader(  									data'  									file' position + i);  								return true;  							} catch (CorruptFileException) {  							}  						}  					}  				  				position += File.BufferSize;  			} while (buffer.Count > 3 && (length < 0 || position < end));
Magic Number,TagLib.Mpeg,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\AudioHeader.cs,Find,The following statement contains a magic number: do {  				file.Seek (position + 3);  				buffer = buffer.Mid (buffer.Count - 3);  				buffer.Add (file.ReadBlock (  					(int) File.BufferSize));  				  				for (int i = 0; i < buffer.Count - 3 &&  					(length < 0 || position + i < end); i++)  					if (buffer [i] == 0xFF &&  						buffer [i + 1] > 0xE0) {  						ByteVector data = buffer.Mid(i' 4);  						if (GetHeaderError(data) == null) {  							try {  								header = new AudioHeader(  									data'  									file' position + i);  								return true;  							} catch (CorruptFileException) {  							}  						}  					}  				  				position += File.BufferSize;  			} while (buffer.Count > 3 && (length < 0 || position < end));
Magic Number,TagLib.Mpeg,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\AudioHeader.cs,Find,The following statement contains a magic number: do {  				file.Seek (position + 3);  				buffer = buffer.Mid (buffer.Count - 3);  				buffer.Add (file.ReadBlock (  					(int) File.BufferSize));  				  				for (int i = 0; i < buffer.Count - 3 &&  					(length < 0 || position + i < end); i++)  					if (buffer [i] == 0xFF &&  						buffer [i + 1] > 0xE0) {  						ByteVector data = buffer.Mid(i' 4);  						if (GetHeaderError(data) == null) {  							try {  								header = new AudioHeader(  									data'  									file' position + i);  								return true;  							} catch (CorruptFileException) {  							}  						}  					}  				  				position += File.BufferSize;  			} while (buffer.Count > 3 && (length < 0 || position < end));
Magic Number,TagLib.Mpeg,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\AudioHeader.cs,Find,The following statement contains a magic number: do {  				file.Seek (position + 3);  				buffer = buffer.Mid (buffer.Count - 3);  				buffer.Add (file.ReadBlock (  					(int) File.BufferSize));  				  				for (int i = 0; i < buffer.Count - 3 &&  					(length < 0 || position + i < end); i++)  					if (buffer [i] == 0xFF &&  						buffer [i + 1] > 0xE0) {  						ByteVector data = buffer.Mid(i' 4);  						if (GetHeaderError(data) == null) {  							try {  								header = new AudioHeader(  									data'  									file' position + i);  								return true;  							} catch (CorruptFileException) {  							}  						}  					}  				  				position += File.BufferSize;  			} while (buffer.Count > 3 && (length < 0 || position < end));
Magic Number,TagLib.Mpeg,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\AudioHeader.cs,Find,The following statement contains a magic number: do {  				file.Seek (position + 3);  				buffer = buffer.Mid (buffer.Count - 3);  				buffer.Add (file.ReadBlock (  					(int) File.BufferSize));  				  				for (int i = 0; i < buffer.Count - 3 &&  					(length < 0 || position + i < end); i++)  					if (buffer [i] == 0xFF &&  						buffer [i + 1] > 0xE0) {  						ByteVector data = buffer.Mid(i' 4);  						if (GetHeaderError(data) == null) {  							try {  								header = new AudioHeader(  									data'  									file' position + i);  								return true;  							} catch (CorruptFileException) {  							}  						}  					}  				  				position += File.BufferSize;  			} while (buffer.Count > 3 && (length < 0 || position < end));
Magic Number,TagLib.Mpeg,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\AudioHeader.cs,GetHeaderError,The following statement contains a magic number: if (data.Count < 4)  				return "Insufficient header length.";
Magic Number,TagLib.Mpeg,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\AudioHeader.cs,GetHeaderError,The following statement contains a magic number: if (((flags >> 12) & 0x0F) == 0x0F)  				return "Header uses invalid bitrate index.";
Magic Number,TagLib.Mpeg,AudioHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\AudioHeader.cs,GetHeaderError,The following statement contains a magic number: if (((flags >> 10) & 0x03) == 0x03)  				return "Invalid sample rate.";
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadEnd,The following statement contains a magic number: end_time = ReadTimestamp (end + 4);
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,GetMarker,The following statement contains a magic number: ByteVector identifier = ReadBlock (4);
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,GetMarker,The following statement contains a magic number: if (identifier.Count == 4 && identifier.StartsWith (  				MarkerStart))  				return (Marker) identifier [3];
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,GetMarker,The following statement contains a magic number: if (identifier.Count == 4 && identifier.StartsWith (  				MarkerStart))  				return (Marker) identifier [3];
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadSystemFile,The following statement contains a magic number: int sanity_limit = 100;
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadSystemFile,The following statement contains a magic number: for (int i = 0; i < sanity_limit && (start_time == null ||  				!audio_found || !video_found); i ++) {  				  				Marker marker = FindMarker (ref position);  				  				switch (marker)  				{  				case Marker.SystemSyncPacket:  					ReadSystemSyncPacket (ref position);  					break;  				  				case Marker.SystemPacket:  				case Marker.PaddingPacket:  					Seek (position + 4);  					position += ReadBlock (2).ToUShort () +  						6;  					break;  				  				case Marker.VideoPacket:  					ReadVideoPacket (ref position);  					break;  				  				case Marker.AudioPacket:  					ReadAudioPacket (ref position);  					break;  				  				case Marker.EndOfStream:  					return;  				  				default:  					position += 4;  					break;  				}  			}
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadSystemFile,The following statement contains a magic number: for (int i = 0; i < sanity_limit && (start_time == null ||  				!audio_found || !video_found); i ++) {  				  				Marker marker = FindMarker (ref position);  				  				switch (marker)  				{  				case Marker.SystemSyncPacket:  					ReadSystemSyncPacket (ref position);  					break;  				  				case Marker.SystemPacket:  				case Marker.PaddingPacket:  					Seek (position + 4);  					position += ReadBlock (2).ToUShort () +  						6;  					break;  				  				case Marker.VideoPacket:  					ReadVideoPacket (ref position);  					break;  				  				case Marker.AudioPacket:  					ReadAudioPacket (ref position);  					break;  				  				case Marker.EndOfStream:  					return;  				  				default:  					position += 4;  					break;  				}  			}
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadSystemFile,The following statement contains a magic number: for (int i = 0; i < sanity_limit && (start_time == null ||  				!audio_found || !video_found); i ++) {  				  				Marker marker = FindMarker (ref position);  				  				switch (marker)  				{  				case Marker.SystemSyncPacket:  					ReadSystemSyncPacket (ref position);  					break;  				  				case Marker.SystemPacket:  				case Marker.PaddingPacket:  					Seek (position + 4);  					position += ReadBlock (2).ToUShort () +  						6;  					break;  				  				case Marker.VideoPacket:  					ReadVideoPacket (ref position);  					break;  				  				case Marker.AudioPacket:  					ReadAudioPacket (ref position);  					break;  				  				case Marker.EndOfStream:  					return;  				  				default:  					position += 4;  					break;  				}  			}
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadSystemFile,The following statement contains a magic number: for (int i = 0; i < sanity_limit && (start_time == null ||  				!audio_found || !video_found); i ++) {  				  				Marker marker = FindMarker (ref position);  				  				switch (marker)  				{  				case Marker.SystemSyncPacket:  					ReadSystemSyncPacket (ref position);  					break;  				  				case Marker.SystemPacket:  				case Marker.PaddingPacket:  					Seek (position + 4);  					position += ReadBlock (2).ToUShort () +  						6;  					break;  				  				case Marker.VideoPacket:  					ReadVideoPacket (ref position);  					break;  				  				case Marker.AudioPacket:  					ReadAudioPacket (ref position);  					break;  				  				case Marker.EndOfStream:  					return;  				  				default:  					position += 4;  					break;  				}  			}
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadAudioPacket,The following statement contains a magic number: Seek (position + 4);
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadAudioPacket,The following statement contains a magic number: int length = ReadBlock (2).ToUShort ();
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadAudioPacket,The following statement contains a magic number: if (!audio_found)  				audio_found = AudioHeader.Find (  					out audio_header' this' position + 15'  					length - 9);
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadAudioPacket,The following statement contains a magic number: if (!audio_found)  				audio_found = AudioHeader.Find (  					out audio_header' this' position + 15'  					length - 9);
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadVideoPacket,The following statement contains a magic number: Seek (position + 4);
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadVideoPacket,The following statement contains a magic number: int length = ReadBlock (2).ToUShort ();
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadVideoPacket,The following statement contains a magic number: long offset = position + 6;
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadVideoPacket,The following statement contains a magic number: while (!video_found && offset < position + length)  				if (FindMarker (ref offset) ==  					Marker.VideoSyncPacket) {  					video_header = new VideoHeader (this'  						offset + 4);  					video_found = true;  				} else {  					// advance the offset by 6 bytes' so the next iteration of the  					// loop won't find the same marker and get stuck.  6 bytes because findMarker is a  					// generic find that could get both PES packets and Stream packets' the smallest  					// posible pes packet with a size =0 would be 6 bytes.  					offset += 6;  				}
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadVideoPacket,The following statement contains a magic number: while (!video_found && offset < position + length)  				if (FindMarker (ref offset) ==  					Marker.VideoSyncPacket) {  					video_header = new VideoHeader (this'  						offset + 4);  					video_found = true;  				} else {  					// advance the offset by 6 bytes' so the next iteration of the  					// loop won't find the same marker and get stuck.  6 bytes because findMarker is a  					// generic find that could get both PES packets and Stream packets' the smallest  					// posible pes packet with a size =0 would be 6 bytes.  					offset += 6;  				}
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadSystemSyncPacket,The following statement contains a magic number: Seek (position + 4);
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadSystemSyncPacket,The following statement contains a magic number: if ((version_info & 0xF0) == 0x20) {  				version = Version.Version1;  				packet_size = 12;  			} else if ((version_info & 0xC0) == 0x40) {  				version = Version.Version2;  				Seek (position + 13);  				packet_size = 14 + (ReadBlock (1) [0] & 0x07);  			} else  				throw new UnsupportedFormatException (  					"Unknown MPEG version.");
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadSystemSyncPacket,The following statement contains a magic number: if ((version_info & 0xF0) == 0x20) {  				version = Version.Version1;  				packet_size = 12;  			} else if ((version_info & 0xC0) == 0x40) {  				version = Version.Version2;  				Seek (position + 13);  				packet_size = 14 + (ReadBlock (1) [0] & 0x07);  			} else  				throw new UnsupportedFormatException (  					"Unknown MPEG version.");
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadSystemSyncPacket,The following statement contains a magic number: if ((version_info & 0xF0) == 0x20) {  				version = Version.Version1;  				packet_size = 12;  			} else if ((version_info & 0xC0) == 0x40) {  				version = Version.Version2;  				Seek (position + 13);  				packet_size = 14 + (ReadBlock (1) [0] & 0x07);  			} else  				throw new UnsupportedFormatException (  					"Unknown MPEG version.");
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadSystemSyncPacket,The following statement contains a magic number: if (start_time == null)  				start_time = ReadTimestamp (position + 4);
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadTimestamp,The following statement contains a magic number: if (version == Version.Version1) {  				ByteVector data = ReadBlock (5);  				high = (double) ((data [0] >> 3) & 0x01);  				  				low =  ((uint)((data [0] >> 1) & 0x03) << 30) |  					(uint) (data [1] << 22) |  					(uint)((data [2] >> 1) << 15) |  					(uint) (data [3] << 7) |  					(uint) (data [4] << 1);  			} else {  				ByteVector data = ReadBlock (6);  				high = (double) ((data [0] & 0x20) >> 5);  				  				low =  ((uint) ((data [0] & 0x18) >> 3) << 30) |  					(uint) ((data [0] & 0x03) << 28) |  					(uint)  (data [1] << 20) |  					(uint) ((data [2] & 0xF8) << 12) |  					(uint) ((data [2] & 0x03) << 13) |  					(uint)  (data [3] << 5) |  					(uint)  (data [4] >> 3);  			}
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadTimestamp,The following statement contains a magic number: if (version == Version.Version1) {  				ByteVector data = ReadBlock (5);  				high = (double) ((data [0] >> 3) & 0x01);  				  				low =  ((uint)((data [0] >> 1) & 0x03) << 30) |  					(uint) (data [1] << 22) |  					(uint)((data [2] >> 1) << 15) |  					(uint) (data [3] << 7) |  					(uint) (data [4] << 1);  			} else {  				ByteVector data = ReadBlock (6);  				high = (double) ((data [0] & 0x20) >> 5);  				  				low =  ((uint) ((data [0] & 0x18) >> 3) << 30) |  					(uint) ((data [0] & 0x03) << 28) |  					(uint)  (data [1] << 20) |  					(uint) ((data [2] & 0xF8) << 12) |  					(uint) ((data [2] & 0x03) << 13) |  					(uint)  (data [3] << 5) |  					(uint)  (data [4] >> 3);  			}
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadTimestamp,The following statement contains a magic number: if (version == Version.Version1) {  				ByteVector data = ReadBlock (5);  				high = (double) ((data [0] >> 3) & 0x01);  				  				low =  ((uint)((data [0] >> 1) & 0x03) << 30) |  					(uint) (data [1] << 22) |  					(uint)((data [2] >> 1) << 15) |  					(uint) (data [3] << 7) |  					(uint) (data [4] << 1);  			} else {  				ByteVector data = ReadBlock (6);  				high = (double) ((data [0] & 0x20) >> 5);  				  				low =  ((uint) ((data [0] & 0x18) >> 3) << 30) |  					(uint) ((data [0] & 0x03) << 28) |  					(uint)  (data [1] << 20) |  					(uint) ((data [2] & 0xF8) << 12) |  					(uint) ((data [2] & 0x03) << 13) |  					(uint)  (data [3] << 5) |  					(uint)  (data [4] >> 3);  			}
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadTimestamp,The following statement contains a magic number: if (version == Version.Version1) {  				ByteVector data = ReadBlock (5);  				high = (double) ((data [0] >> 3) & 0x01);  				  				low =  ((uint)((data [0] >> 1) & 0x03) << 30) |  					(uint) (data [1] << 22) |  					(uint)((data [2] >> 1) << 15) |  					(uint) (data [3] << 7) |  					(uint) (data [4] << 1);  			} else {  				ByteVector data = ReadBlock (6);  				high = (double) ((data [0] & 0x20) >> 5);  				  				low =  ((uint) ((data [0] & 0x18) >> 3) << 30) |  					(uint) ((data [0] & 0x03) << 28) |  					(uint)  (data [1] << 20) |  					(uint) ((data [2] & 0xF8) << 12) |  					(uint) ((data [2] & 0x03) << 13) |  					(uint)  (data [3] << 5) |  					(uint)  (data [4] >> 3);  			}
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadTimestamp,The following statement contains a magic number: if (version == Version.Version1) {  				ByteVector data = ReadBlock (5);  				high = (double) ((data [0] >> 3) & 0x01);  				  				low =  ((uint)((data [0] >> 1) & 0x03) << 30) |  					(uint) (data [1] << 22) |  					(uint)((data [2] >> 1) << 15) |  					(uint) (data [3] << 7) |  					(uint) (data [4] << 1);  			} else {  				ByteVector data = ReadBlock (6);  				high = (double) ((data [0] & 0x20) >> 5);  				  				low =  ((uint) ((data [0] & 0x18) >> 3) << 30) |  					(uint) ((data [0] & 0x03) << 28) |  					(uint)  (data [1] << 20) |  					(uint) ((data [2] & 0xF8) << 12) |  					(uint) ((data [2] & 0x03) << 13) |  					(uint)  (data [3] << 5) |  					(uint)  (data [4] >> 3);  			}
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadTimestamp,The following statement contains a magic number: if (version == Version.Version1) {  				ByteVector data = ReadBlock (5);  				high = (double) ((data [0] >> 3) & 0x01);  				  				low =  ((uint)((data [0] >> 1) & 0x03) << 30) |  					(uint) (data [1] << 22) |  					(uint)((data [2] >> 1) << 15) |  					(uint) (data [3] << 7) |  					(uint) (data [4] << 1);  			} else {  				ByteVector data = ReadBlock (6);  				high = (double) ((data [0] & 0x20) >> 5);  				  				low =  ((uint) ((data [0] & 0x18) >> 3) << 30) |  					(uint) ((data [0] & 0x03) << 28) |  					(uint)  (data [1] << 20) |  					(uint) ((data [2] & 0xF8) << 12) |  					(uint) ((data [2] & 0x03) << 13) |  					(uint)  (data [3] << 5) |  					(uint)  (data [4] >> 3);  			}
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadTimestamp,The following statement contains a magic number: if (version == Version.Version1) {  				ByteVector data = ReadBlock (5);  				high = (double) ((data [0] >> 3) & 0x01);  				  				low =  ((uint)((data [0] >> 1) & 0x03) << 30) |  					(uint) (data [1] << 22) |  					(uint)((data [2] >> 1) << 15) |  					(uint) (data [3] << 7) |  					(uint) (data [4] << 1);  			} else {  				ByteVector data = ReadBlock (6);  				high = (double) ((data [0] & 0x20) >> 5);  				  				low =  ((uint) ((data [0] & 0x18) >> 3) << 30) |  					(uint) ((data [0] & 0x03) << 28) |  					(uint)  (data [1] << 20) |  					(uint) ((data [2] & 0xF8) << 12) |  					(uint) ((data [2] & 0x03) << 13) |  					(uint)  (data [3] << 5) |  					(uint)  (data [4] >> 3);  			}
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadTimestamp,The following statement contains a magic number: if (version == Version.Version1) {  				ByteVector data = ReadBlock (5);  				high = (double) ((data [0] >> 3) & 0x01);  				  				low =  ((uint)((data [0] >> 1) & 0x03) << 30) |  					(uint) (data [1] << 22) |  					(uint)((data [2] >> 1) << 15) |  					(uint) (data [3] << 7) |  					(uint) (data [4] << 1);  			} else {  				ByteVector data = ReadBlock (6);  				high = (double) ((data [0] & 0x20) >> 5);  				  				low =  ((uint) ((data [0] & 0x18) >> 3) << 30) |  					(uint) ((data [0] & 0x03) << 28) |  					(uint)  (data [1] << 20) |  					(uint) ((data [2] & 0xF8) << 12) |  					(uint) ((data [2] & 0x03) << 13) |  					(uint)  (data [3] << 5) |  					(uint)  (data [4] >> 3);  			}
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadTimestamp,The following statement contains a magic number: if (version == Version.Version1) {  				ByteVector data = ReadBlock (5);  				high = (double) ((data [0] >> 3) & 0x01);  				  				low =  ((uint)((data [0] >> 1) & 0x03) << 30) |  					(uint) (data [1] << 22) |  					(uint)((data [2] >> 1) << 15) |  					(uint) (data [3] << 7) |  					(uint) (data [4] << 1);  			} else {  				ByteVector data = ReadBlock (6);  				high = (double) ((data [0] & 0x20) >> 5);  				  				low =  ((uint) ((data [0] & 0x18) >> 3) << 30) |  					(uint) ((data [0] & 0x03) << 28) |  					(uint)  (data [1] << 20) |  					(uint) ((data [2] & 0xF8) << 12) |  					(uint) ((data [2] & 0x03) << 13) |  					(uint)  (data [3] << 5) |  					(uint)  (data [4] >> 3);  			}
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadTimestamp,The following statement contains a magic number: if (version == Version.Version1) {  				ByteVector data = ReadBlock (5);  				high = (double) ((data [0] >> 3) & 0x01);  				  				low =  ((uint)((data [0] >> 1) & 0x03) << 30) |  					(uint) (data [1] << 22) |  					(uint)((data [2] >> 1) << 15) |  					(uint) (data [3] << 7) |  					(uint) (data [4] << 1);  			} else {  				ByteVector data = ReadBlock (6);  				high = (double) ((data [0] & 0x20) >> 5);  				  				low =  ((uint) ((data [0] & 0x18) >> 3) << 30) |  					(uint) ((data [0] & 0x03) << 28) |  					(uint)  (data [1] << 20) |  					(uint) ((data [2] & 0xF8) << 12) |  					(uint) ((data [2] & 0x03) << 13) |  					(uint)  (data [3] << 5) |  					(uint)  (data [4] >> 3);  			}
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadTimestamp,The following statement contains a magic number: if (version == Version.Version1) {  				ByteVector data = ReadBlock (5);  				high = (double) ((data [0] >> 3) & 0x01);  				  				low =  ((uint)((data [0] >> 1) & 0x03) << 30) |  					(uint) (data [1] << 22) |  					(uint)((data [2] >> 1) << 15) |  					(uint) (data [3] << 7) |  					(uint) (data [4] << 1);  			} else {  				ByteVector data = ReadBlock (6);  				high = (double) ((data [0] & 0x20) >> 5);  				  				low =  ((uint) ((data [0] & 0x18) >> 3) << 30) |  					(uint) ((data [0] & 0x03) << 28) |  					(uint)  (data [1] << 20) |  					(uint) ((data [2] & 0xF8) << 12) |  					(uint) ((data [2] & 0x03) << 13) |  					(uint)  (data [3] << 5) |  					(uint)  (data [4] >> 3);  			}
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadTimestamp,The following statement contains a magic number: if (version == Version.Version1) {  				ByteVector data = ReadBlock (5);  				high = (double) ((data [0] >> 3) & 0x01);  				  				low =  ((uint)((data [0] >> 1) & 0x03) << 30) |  					(uint) (data [1] << 22) |  					(uint)((data [2] >> 1) << 15) |  					(uint) (data [3] << 7) |  					(uint) (data [4] << 1);  			} else {  				ByteVector data = ReadBlock (6);  				high = (double) ((data [0] & 0x20) >> 5);  				  				low =  ((uint) ((data [0] & 0x18) >> 3) << 30) |  					(uint) ((data [0] & 0x03) << 28) |  					(uint)  (data [1] << 20) |  					(uint) ((data [2] & 0xF8) << 12) |  					(uint) ((data [2] & 0x03) << 13) |  					(uint)  (data [3] << 5) |  					(uint)  (data [4] >> 3);  			}
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadTimestamp,The following statement contains a magic number: if (version == Version.Version1) {  				ByteVector data = ReadBlock (5);  				high = (double) ((data [0] >> 3) & 0x01);  				  				low =  ((uint)((data [0] >> 1) & 0x03) << 30) |  					(uint) (data [1] << 22) |  					(uint)((data [2] >> 1) << 15) |  					(uint) (data [3] << 7) |  					(uint) (data [4] << 1);  			} else {  				ByteVector data = ReadBlock (6);  				high = (double) ((data [0] & 0x20) >> 5);  				  				low =  ((uint) ((data [0] & 0x18) >> 3) << 30) |  					(uint) ((data [0] & 0x03) << 28) |  					(uint)  (data [1] << 20) |  					(uint) ((data [2] & 0xF8) << 12) |  					(uint) ((data [2] & 0x03) << 13) |  					(uint)  (data [3] << 5) |  					(uint)  (data [4] >> 3);  			}
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadTimestamp,The following statement contains a magic number: if (version == Version.Version1) {  				ByteVector data = ReadBlock (5);  				high = (double) ((data [0] >> 3) & 0x01);  				  				low =  ((uint)((data [0] >> 1) & 0x03) << 30) |  					(uint) (data [1] << 22) |  					(uint)((data [2] >> 1) << 15) |  					(uint) (data [3] << 7) |  					(uint) (data [4] << 1);  			} else {  				ByteVector data = ReadBlock (6);  				high = (double) ((data [0] & 0x20) >> 5);  				  				low =  ((uint) ((data [0] & 0x18) >> 3) << 30) |  					(uint) ((data [0] & 0x03) << 28) |  					(uint)  (data [1] << 20) |  					(uint) ((data [2] & 0xF8) << 12) |  					(uint) ((data [2] & 0x03) << 13) |  					(uint)  (data [3] << 5) |  					(uint)  (data [4] >> 3);  			}
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadTimestamp,The following statement contains a magic number: if (version == Version.Version1) {  				ByteVector data = ReadBlock (5);  				high = (double) ((data [0] >> 3) & 0x01);  				  				low =  ((uint)((data [0] >> 1) & 0x03) << 30) |  					(uint) (data [1] << 22) |  					(uint)((data [2] >> 1) << 15) |  					(uint) (data [3] << 7) |  					(uint) (data [4] << 1);  			} else {  				ByteVector data = ReadBlock (6);  				high = (double) ((data [0] & 0x20) >> 5);  				  				low =  ((uint) ((data [0] & 0x18) >> 3) << 30) |  					(uint) ((data [0] & 0x03) << 28) |  					(uint)  (data [1] << 20) |  					(uint) ((data [2] & 0xF8) << 12) |  					(uint) ((data [2] & 0x03) << 13) |  					(uint)  (data [3] << 5) |  					(uint)  (data [4] >> 3);  			}
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadTimestamp,The following statement contains a magic number: if (version == Version.Version1) {  				ByteVector data = ReadBlock (5);  				high = (double) ((data [0] >> 3) & 0x01);  				  				low =  ((uint)((data [0] >> 1) & 0x03) << 30) |  					(uint) (data [1] << 22) |  					(uint)((data [2] >> 1) << 15) |  					(uint) (data [3] << 7) |  					(uint) (data [4] << 1);  			} else {  				ByteVector data = ReadBlock (6);  				high = (double) ((data [0] & 0x20) >> 5);  				  				low =  ((uint) ((data [0] & 0x18) >> 3) << 30) |  					(uint) ((data [0] & 0x03) << 28) |  					(uint)  (data [1] << 20) |  					(uint) ((data [2] & 0xF8) << 12) |  					(uint) ((data [2] & 0x03) << 13) |  					(uint)  (data [3] << 5) |  					(uint)  (data [4] >> 3);  			}
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadTimestamp,The following statement contains a magic number: if (version == Version.Version1) {  				ByteVector data = ReadBlock (5);  				high = (double) ((data [0] >> 3) & 0x01);  				  				low =  ((uint)((data [0] >> 1) & 0x03) << 30) |  					(uint) (data [1] << 22) |  					(uint)((data [2] >> 1) << 15) |  					(uint) (data [3] << 7) |  					(uint) (data [4] << 1);  			} else {  				ByteVector data = ReadBlock (6);  				high = (double) ((data [0] & 0x20) >> 5);  				  				low =  ((uint) ((data [0] & 0x18) >> 3) << 30) |  					(uint) ((data [0] & 0x03) << 28) |  					(uint)  (data [1] << 20) |  					(uint) ((data [2] & 0xF8) << 12) |  					(uint) ((data [2] & 0x03) << 13) |  					(uint)  (data [3] << 5) |  					(uint)  (data [4] >> 3);  			}
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadTimestamp,The following statement contains a magic number: if (version == Version.Version1) {  				ByteVector data = ReadBlock (5);  				high = (double) ((data [0] >> 3) & 0x01);  				  				low =  ((uint)((data [0] >> 1) & 0x03) << 30) |  					(uint) (data [1] << 22) |  					(uint)((data [2] >> 1) << 15) |  					(uint) (data [3] << 7) |  					(uint) (data [4] << 1);  			} else {  				ByteVector data = ReadBlock (6);  				high = (double) ((data [0] & 0x20) >> 5);  				  				low =  ((uint) ((data [0] & 0x18) >> 3) << 30) |  					(uint) ((data [0] & 0x03) << 28) |  					(uint)  (data [1] << 20) |  					(uint) ((data [2] & 0xF8) << 12) |  					(uint) ((data [2] & 0x03) << 13) |  					(uint)  (data [3] << 5) |  					(uint)  (data [4] >> 3);  			}
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadTimestamp,The following statement contains a magic number: if (version == Version.Version1) {  				ByteVector data = ReadBlock (5);  				high = (double) ((data [0] >> 3) & 0x01);  				  				low =  ((uint)((data [0] >> 1) & 0x03) << 30) |  					(uint) (data [1] << 22) |  					(uint)((data [2] >> 1) << 15) |  					(uint) (data [3] << 7) |  					(uint) (data [4] << 1);  			} else {  				ByteVector data = ReadBlock (6);  				high = (double) ((data [0] & 0x20) >> 5);  				  				low =  ((uint) ((data [0] & 0x18) >> 3) << 30) |  					(uint) ((data [0] & 0x03) << 28) |  					(uint)  (data [1] << 20) |  					(uint) ((data [2] & 0xF8) << 12) |  					(uint) ((data [2] & 0x03) << 13) |  					(uint)  (data [3] << 5) |  					(uint)  (data [4] >> 3);  			}
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadTimestamp,The following statement contains a magic number: if (version == Version.Version1) {  				ByteVector data = ReadBlock (5);  				high = (double) ((data [0] >> 3) & 0x01);  				  				low =  ((uint)((data [0] >> 1) & 0x03) << 30) |  					(uint) (data [1] << 22) |  					(uint)((data [2] >> 1) << 15) |  					(uint) (data [3] << 7) |  					(uint) (data [4] << 1);  			} else {  				ByteVector data = ReadBlock (6);  				high = (double) ((data [0] & 0x20) >> 5);  				  				low =  ((uint) ((data [0] & 0x18) >> 3) << 30) |  					(uint) ((data [0] & 0x03) << 28) |  					(uint)  (data [1] << 20) |  					(uint) ((data [2] & 0xF8) << 12) |  					(uint) ((data [2] & 0x03) << 13) |  					(uint)  (data [3] << 5) |  					(uint)  (data [4] >> 3);  			}
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadTimestamp,The following statement contains a magic number: if (version == Version.Version1) {  				ByteVector data = ReadBlock (5);  				high = (double) ((data [0] >> 3) & 0x01);  				  				low =  ((uint)((data [0] >> 1) & 0x03) << 30) |  					(uint) (data [1] << 22) |  					(uint)((data [2] >> 1) << 15) |  					(uint) (data [3] << 7) |  					(uint) (data [4] << 1);  			} else {  				ByteVector data = ReadBlock (6);  				high = (double) ((data [0] & 0x20) >> 5);  				  				low =  ((uint) ((data [0] & 0x18) >> 3) << 30) |  					(uint) ((data [0] & 0x03) << 28) |  					(uint)  (data [1] << 20) |  					(uint) ((data [2] & 0xF8) << 12) |  					(uint) ((data [2] & 0x03) << 13) |  					(uint)  (data [3] << 5) |  					(uint)  (data [4] >> 3);  			}
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadTimestamp,The following statement contains a magic number: if (version == Version.Version1) {  				ByteVector data = ReadBlock (5);  				high = (double) ((data [0] >> 3) & 0x01);  				  				low =  ((uint)((data [0] >> 1) & 0x03) << 30) |  					(uint) (data [1] << 22) |  					(uint)((data [2] >> 1) << 15) |  					(uint) (data [3] << 7) |  					(uint) (data [4] << 1);  			} else {  				ByteVector data = ReadBlock (6);  				high = (double) ((data [0] & 0x20) >> 5);  				  				low =  ((uint) ((data [0] & 0x18) >> 3) << 30) |  					(uint) ((data [0] & 0x03) << 28) |  					(uint)  (data [1] << 20) |  					(uint) ((data [2] & 0xF8) << 12) |  					(uint) ((data [2] & 0x03) << 13) |  					(uint)  (data [3] << 5) |  					(uint)  (data [4] >> 3);  			}
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadTimestamp,The following statement contains a magic number: if (version == Version.Version1) {  				ByteVector data = ReadBlock (5);  				high = (double) ((data [0] >> 3) & 0x01);  				  				low =  ((uint)((data [0] >> 1) & 0x03) << 30) |  					(uint) (data [1] << 22) |  					(uint)((data [2] >> 1) << 15) |  					(uint) (data [3] << 7) |  					(uint) (data [4] << 1);  			} else {  				ByteVector data = ReadBlock (6);  				high = (double) ((data [0] & 0x20) >> 5);  				  				low =  ((uint) ((data [0] & 0x18) >> 3) << 30) |  					(uint) ((data [0] & 0x03) << 28) |  					(uint)  (data [1] << 20) |  					(uint) ((data [2] & 0xF8) << 12) |  					(uint) ((data [2] & 0x03) << 13) |  					(uint)  (data [3] << 5) |  					(uint)  (data [4] >> 3);  			}
Magic Number,TagLib.Mpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\File.cs,ReadTimestamp,The following statement contains a magic number: return (((high * 0x10000) * 0x10000) + low) / 90000.0;
Magic Number,TagLib.Mpeg,VBRIHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\VBRIHeader.cs,VBRIHeader,The following statement contains a magic number: int position = 10;
Magic Number,TagLib.Mpeg,VBRIHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\VBRIHeader.cs,VBRIHeader,The following statement contains a magic number: size = data.Mid(position' 4).ToUInt();
Magic Number,TagLib.Mpeg,VBRIHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\VBRIHeader.cs,VBRIHeader,The following statement contains a magic number: position += 4;
Magic Number,TagLib.Mpeg,VBRIHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\VBRIHeader.cs,VBRIHeader,The following statement contains a magic number: frames = data.Mid(position' 4).ToUInt();
Magic Number,TagLib.Mpeg,VBRIHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\VBRIHeader.cs,VBRIHeader,The following statement contains a magic number: position += 4;
Magic Number,TagLib.Mpeg,VideoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\VideoHeader.cs,VideoHeader,The following statement contains a magic number: ByteVector data = file.ReadBlock (7);
Magic Number,TagLib.Mpeg,VideoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\VideoHeader.cs,VideoHeader,The following statement contains a magic number: if (data.Count < 7)  				throw new CorruptFileException (  					"Insufficient data in header.");
Magic Number,TagLib.Mpeg,VideoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\VideoHeader.cs,VideoHeader,The following statement contains a magic number: width = data.Mid (0' 2).ToUShort () >> 4;
Magic Number,TagLib.Mpeg,VideoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\VideoHeader.cs,VideoHeader,The following statement contains a magic number: width = data.Mid (0' 2).ToUShort () >> 4;
Magic Number,TagLib.Mpeg,VideoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\VideoHeader.cs,VideoHeader,The following statement contains a magic number: height = data.Mid (1' 2).ToUShort () & 0x0FFF;
Magic Number,TagLib.Mpeg,VideoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\VideoHeader.cs,VideoHeader,The following statement contains a magic number: frame_rate_index = data [3] & 0x0F;
Magic Number,TagLib.Mpeg,VideoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\VideoHeader.cs,VideoHeader,The following statement contains a magic number: bitrate = (int) ((data.Mid (4' 3).ToUInt () >> 6) &  				0x3FFFF);
Magic Number,TagLib.Mpeg,VideoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\VideoHeader.cs,VideoHeader,The following statement contains a magic number: bitrate = (int) ((data.Mid (4' 3).ToUInt () >> 6) &  				0x3FFFF);
Magic Number,TagLib.Mpeg,VideoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\VideoHeader.cs,VideoHeader,The following statement contains a magic number: bitrate = (int) ((data.Mid (4' 3).ToUInt () >> 6) &  				0x3FFFF);
Magic Number,TagLib.Mpeg,XingHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\XingHeader.cs,XingHeader,The following statement contains a magic number: int position = 8;
Magic Number,TagLib.Mpeg,XingHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\XingHeader.cs,XingHeader,The following statement contains a magic number: if ((data [7] & 0x01) != 0) {  				frames = data.Mid (position' 4).ToUInt ();  				position += 4;  			} else  				frames = 0;
Magic Number,TagLib.Mpeg,XingHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\XingHeader.cs,XingHeader,The following statement contains a magic number: if ((data [7] & 0x01) != 0) {  				frames = data.Mid (position' 4).ToUInt ();  				position += 4;  			} else  				frames = 0;
Magic Number,TagLib.Mpeg,XingHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\XingHeader.cs,XingHeader,The following statement contains a magic number: if ((data [7] & 0x01) != 0) {  				frames = data.Mid (position' 4).ToUInt ();  				position += 4;  			} else  				frames = 0;
Magic Number,TagLib.Mpeg,XingHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\XingHeader.cs,XingHeader,The following statement contains a magic number: if ((data [7] & 0x02) != 0) {  				size = data.Mid (position' 4).ToUInt ();  				position += 4;  			} else  				size = 0;
Magic Number,TagLib.Mpeg,XingHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\XingHeader.cs,XingHeader,The following statement contains a magic number: if ((data [7] & 0x02) != 0) {  				size = data.Mid (position' 4).ToUInt ();  				position += 4;  			} else  				size = 0;
Magic Number,TagLib.Mpeg,XingHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg\XingHeader.cs,XingHeader,The following statement contains a magic number: if ((data [7] & 0x02) != 0) {  				size = data.Mid (position' 4).ToUInt ();  				position += 4;  			} else  				size = 0;
Magic Number,TagLib.Mpeg4,AppleTag,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\AppleTag.cs,FixId,The following statement contains a magic number: if (id.Count == 4) {  				ReadOnlyByteVector roid =  					id as ReadOnlyByteVector;  				if (roid != null)  					return roid;  				  				return new ReadOnlyByteVector (id);  			}
Magic Number,TagLib.Mpeg4,AppleTag,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\AppleTag.cs,FixId,The following statement contains a magic number: if (id.Count == 3)  				return new ReadOnlyByteVector (  					0xa9' id [0]' id [1]' id [2]);
Magic Number,TagLib.Mpeg4,AppleTag,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\AppleTag.cs,FixId,The following statement contains a magic number: if (id.Count == 3)  				return new ReadOnlyByteVector (  					0xa9' id [0]' id [1]' id [2]);
Magic Number,TagLib.Mpeg4,Box,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Box.cs,Render,The following statement contains a magic number: if (free_found || BoxType == Mpeg4.BoxType.Meta) {  				long size_difference = DataSize - output.Count;  				  				// If we have room for free space' add it so we  				// don't have to resize the file.  				if (header.DataSize != 0 && size_difference >= 8)  					output.Add ((new IsoFreeSpaceBox (  						size_difference)).Render ());  				  				// If we're getting bigger' get a lot bigger so  				// we might not have to again.  				else  					output.Add ((new IsoFreeSpaceBox (2048  						)).Render ());  			}
Magic Number,TagLib.Mpeg4,Box,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Box.cs,Render,The following statement contains a magic number: if (free_found || BoxType == Mpeg4.BoxType.Meta) {  				long size_difference = DataSize - output.Count;  				  				// If we have room for free space' add it so we  				// don't have to resize the file.  				if (header.DataSize != 0 && size_difference >= 8)  					output.Add ((new IsoFreeSpaceBox (  						size_difference)).Render ());  				  				// If we're getting bigger' get a lot bigger so  				// we might not have to again.  				else  					output.Add ((new IsoFreeSpaceBox (2048  						)).Render ());  			}
Magic Number,TagLib.Mpeg4,BoxHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\BoxHeader.cs,BoxHeader,The following statement contains a magic number: ByteVector data = file.ReadBlock (32);
Magic Number,TagLib.Mpeg4,BoxHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\BoxHeader.cs,BoxHeader,The following statement contains a magic number: if (data.Count < 8 + offset)  				throw new CorruptFileException (  					"Not enough data in box header.");
Magic Number,TagLib.Mpeg4,BoxHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\BoxHeader.cs,BoxHeader,The following statement contains a magic number: header_size = 8;
Magic Number,TagLib.Mpeg4,BoxHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\BoxHeader.cs,BoxHeader,The following statement contains a magic number: box_size = data.Mid (offset' 4).ToUInt ();
Magic Number,TagLib.Mpeg4,BoxHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\BoxHeader.cs,BoxHeader,The following statement contains a magic number: box_type = data.Mid (offset + 4' 4);
Magic Number,TagLib.Mpeg4,BoxHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\BoxHeader.cs,BoxHeader,The following statement contains a magic number: box_type = data.Mid (offset + 4' 4);
Magic Number,TagLib.Mpeg4,BoxHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\BoxHeader.cs,BoxHeader,The following statement contains a magic number: if (box_size == 1) {  				if (data.Count < 8 + offset)  					throw new CorruptFileException (  						"Not enough data in box header.");  				  				header_size += 8;  				offset += 8;  				box_size = data.Mid (offset' 8).ToULong ();  			}
Magic Number,TagLib.Mpeg4,BoxHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\BoxHeader.cs,BoxHeader,The following statement contains a magic number: if (box_size == 1) {  				if (data.Count < 8 + offset)  					throw new CorruptFileException (  						"Not enough data in box header.");  				  				header_size += 8;  				offset += 8;  				box_size = data.Mid (offset' 8).ToULong ();  			}
Magic Number,TagLib.Mpeg4,BoxHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\BoxHeader.cs,BoxHeader,The following statement contains a magic number: if (box_size == 1) {  				if (data.Count < 8 + offset)  					throw new CorruptFileException (  						"Not enough data in box header.");  				  				header_size += 8;  				offset += 8;  				box_size = data.Mid (offset' 8).ToULong ();  			}
Magic Number,TagLib.Mpeg4,BoxHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\BoxHeader.cs,BoxHeader,The following statement contains a magic number: if (box_size == 1) {  				if (data.Count < 8 + offset)  					throw new CorruptFileException (  						"Not enough data in box header.");  				  				header_size += 8;  				offset += 8;  				box_size = data.Mid (offset' 8).ToULong ();  			}
Magic Number,TagLib.Mpeg4,BoxHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\BoxHeader.cs,BoxHeader,The following statement contains a magic number: if (box_type == Mpeg4.BoxType.Uuid) {  				if (data.Count < 16 + offset)  					throw new CorruptFileException (  						"Not enough data in box header.");  				  				header_size += 16;  				extended_type = data.Mid (offset' 16);  			} else  				extended_type = null;
Magic Number,TagLib.Mpeg4,BoxHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\BoxHeader.cs,BoxHeader,The following statement contains a magic number: if (box_type == Mpeg4.BoxType.Uuid) {  				if (data.Count < 16 + offset)  					throw new CorruptFileException (  						"Not enough data in box header.");  				  				header_size += 16;  				extended_type = data.Mid (offset' 16);  			} else  				extended_type = null;
Magic Number,TagLib.Mpeg4,BoxHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\BoxHeader.cs,BoxHeader,The following statement contains a magic number: if (box_type == Mpeg4.BoxType.Uuid) {  				if (data.Count < 16 + offset)  					throw new CorruptFileException (  						"Not enough data in box header.");  				  				header_size += 16;  				extended_type = data.Mid (offset' 16);  			} else  				extended_type = null;
Magic Number,TagLib.Mpeg4,BoxHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\BoxHeader.cs,BoxHeader,The following statement contains a magic number: if (type.Count != 4)  				throw new ArgumentException (  					"Box type must be 4 bytes in length."'  					"type");
Magic Number,TagLib.Mpeg4,BoxHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\BoxHeader.cs,BoxHeader,The following statement contains a magic number: box_size = header_size = 8;
Magic Number,TagLib.Mpeg4,BoxHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\BoxHeader.cs,BoxHeader,The following statement contains a magic number: if (extendedType.Count != 16)  				throw new ArgumentException (  					"Extended type must be 16 bytes in length."'  					"extendedType");
Magic Number,TagLib.Mpeg4,BoxHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\BoxHeader.cs,BoxHeader,The following statement contains a magic number: box_size = header_size = 24;
Magic Number,TagLib.Mpeg4,BoxHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\BoxHeader.cs,Render,The following statement contains a magic number: if ((header_size == 8 || header_size == 24) &&  				box_size > uint.MaxValue) {  				header_size += 8;  				box_size += 8;  			}
Magic Number,TagLib.Mpeg4,BoxHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\BoxHeader.cs,Render,The following statement contains a magic number: if ((header_size == 8 || header_size == 24) &&  				box_size > uint.MaxValue) {  				header_size += 8;  				box_size += 8;  			}
Magic Number,TagLib.Mpeg4,BoxHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\BoxHeader.cs,Render,The following statement contains a magic number: if ((header_size == 8 || header_size == 24) &&  				box_size > uint.MaxValue) {  				header_size += 8;  				box_size += 8;  			}
Magic Number,TagLib.Mpeg4,BoxHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\BoxHeader.cs,Render,The following statement contains a magic number: if ((header_size == 8 || header_size == 24) &&  				box_size > uint.MaxValue) {  				header_size += 8;  				box_size += 8;  			}
Magic Number,TagLib.Mpeg4,BoxHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\BoxHeader.cs,Render,The following statement contains a magic number: ByteVector output = ByteVector.FromUInt (  				(header_size == 8 || header_size == 24) ?  				(uint) box_size : 1);
Magic Number,TagLib.Mpeg4,BoxHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\BoxHeader.cs,Render,The following statement contains a magic number: ByteVector output = ByteVector.FromUInt (  				(header_size == 8 || header_size == 24) ?  				(uint) box_size : 1);
Magic Number,TagLib.Mpeg4,BoxHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\BoxHeader.cs,Render,The following statement contains a magic number: if (header_size == 16 || header_size == 32)  				output.Add (ByteVector.FromULong (box_size));
Magic Number,TagLib.Mpeg4,BoxHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\BoxHeader.cs,Render,The following statement contains a magic number: if (header_size == 16 || header_size == 32)  				output.Add (ByteVector.FromULong (box_size));
Magic Number,TagLib.Mpeg4,BoxHeader,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\BoxHeader.cs,Render,The following statement contains a magic number: if (header_size >= 24)  				output.Add (extended_type);
Magic Number,TagLib.Mpeg4,File,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\File.cs,Save,The following statement contains a magic number: try {  				FileParser parser = new FileParser (this);  				parser.ParseBoxHeaders ();  				  				InvariantStartPosition = parser.MdatStartPosition;  				InvariantEndPosition = parser.MdatEndPosition;  				  				long size_change = 0;  				long write_position = 0;  				  				// To avoid rewriting udta blocks which might not have been modified'  				// the code here will work correctly if:  				// 1. There is a single udta for the entire file  				//   - OR -  				// 2. There are multiple utdtas' but only 1 of them contains the Apple ILST box.  				// We should be OK in the vast majority of cases  				IsoUserDataBox udtaBox = FindAppleTagUdta();  				if (null == udtaBox)  					udtaBox = new IsoUserDataBox ();  				ByteVector tag_data = udtaBox.Render ();  				  				// If we don't have a "udta" box to overwrite...  				if (udtaBox.ParentTree == null ||  					udtaBox.ParentTree.Length == 0) {  					  					// Stick the box at the end of the moov box.  					BoxHeader moov_header = parser.MoovTree [  						parser.MoovTree.Length - 1];  					size_change = tag_data.Count;  					write_position = moov_header.Position +  						moov_header.TotalBoxSize;  					Insert (tag_data' write_position' 0);  					  					// Overwrite the parent box sizes.  					for (int i = parser.MoovTree.Length - 1; i >= 0;  						i --)  						size_change = parser.MoovTree [i  							].Overwrite (this' size_change);  				} else {  					// Overwrite the old box.  					BoxHeader udta_header = udtaBox.ParentTree[udtaBox.ParentTree.Length - 1];  					size_change = tag_data.Count -  						udta_header.TotalBoxSize;  					write_position = udta_header.Position;  					Insert (tag_data' write_position'  						udta_header.TotalBoxSize);  					  					// Overwrite the parent box sizes.  					for (int i = udtaBox.ParentTree.Length - 2; i >= 0;  						i --)  						size_change = udtaBox.ParentTree [i  							].Overwrite (this' size_change);  				}  				  				// If we've had a size change' we may need to adjust  				// chunk offsets.  				if (size_change != 0) {  					// We may have moved the offset boxes' so we  					// need to reread.  					parser.ParseChunkOffsets ();  					InvariantStartPosition = parser.MdatStartPosition;  					InvariantEndPosition = parser.MdatEndPosition;  					  					foreach (Box box in parser.ChunkOffsetBoxes) {  						IsoChunkLargeOffsetBox co64 =   							box as IsoChunkLargeOffsetBox;  						  						if (co64 != null) {  							co64.Overwrite (this'  								size_change'  								write_position);  							continue;  						}  						  						IsoChunkOffsetBox stco =   							box as IsoChunkOffsetBox;  						  						if (stco != null) {  							stco.Overwrite (this'  								size_change'  								write_position);  							continue;  						}  					}  				}  				  				TagTypesOnDisk = TagTypes;  			} finally {  				Mode = File.AccessMode.Closed;  			}
Magic Number,TagLib.Mpeg4,AppleDataBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\AppleDataBox.cs,Render,The following statement contains a magic number: ByteVector output = new ByteVector (4);
Magic Number,TagLib.Mpeg4,AppleElementaryStreamDescriptor,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\AppleElementaryStreamDescriptor.cs,AppleElementaryStreamDescriptor,The following statement contains a magic number: if (box_data [offset ++] == 3) {  				// We have a descriptor tag. Check that it's at  				// least 20 long.  				if (ReadLength (box_data' ref offset) < 20)  					throw new CorruptFileException (  						"Insufficient data present.");  				  				es_id = box_data.Mid (offset' 2).ToUShort ();  				offset += 2;  				stream_priority = box_data [offset ++];  			} else {  				// The tag wasn't found' so the next two byte  				// are the ID' and after that' business as  				// usual.  				es_id = box_data.Mid (offset' 2).ToUShort ();  				offset += 2;  			}
Magic Number,TagLib.Mpeg4,AppleElementaryStreamDescriptor,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\AppleElementaryStreamDescriptor.cs,AppleElementaryStreamDescriptor,The following statement contains a magic number: if (box_data [offset ++] == 3) {  				// We have a descriptor tag. Check that it's at  				// least 20 long.  				if (ReadLength (box_data' ref offset) < 20)  					throw new CorruptFileException (  						"Insufficient data present.");  				  				es_id = box_data.Mid (offset' 2).ToUShort ();  				offset += 2;  				stream_priority = box_data [offset ++];  			} else {  				// The tag wasn't found' so the next two byte  				// are the ID' and after that' business as  				// usual.  				es_id = box_data.Mid (offset' 2).ToUShort ();  				offset += 2;  			}
Magic Number,TagLib.Mpeg4,AppleElementaryStreamDescriptor,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\AppleElementaryStreamDescriptor.cs,AppleElementaryStreamDescriptor,The following statement contains a magic number: if (box_data [offset ++] == 3) {  				// We have a descriptor tag. Check that it's at  				// least 20 long.  				if (ReadLength (box_data' ref offset) < 20)  					throw new CorruptFileException (  						"Insufficient data present.");  				  				es_id = box_data.Mid (offset' 2).ToUShort ();  				offset += 2;  				stream_priority = box_data [offset ++];  			} else {  				// The tag wasn't found' so the next two byte  				// are the ID' and after that' business as  				// usual.  				es_id = box_data.Mid (offset' 2).ToUShort ();  				offset += 2;  			}
Magic Number,TagLib.Mpeg4,AppleElementaryStreamDescriptor,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\AppleElementaryStreamDescriptor.cs,AppleElementaryStreamDescriptor,The following statement contains a magic number: if (box_data [offset ++] == 3) {  				// We have a descriptor tag. Check that it's at  				// least 20 long.  				if (ReadLength (box_data' ref offset) < 20)  					throw new CorruptFileException (  						"Insufficient data present.");  				  				es_id = box_data.Mid (offset' 2).ToUShort ();  				offset += 2;  				stream_priority = box_data [offset ++];  			} else {  				// The tag wasn't found' so the next two byte  				// are the ID' and after that' business as  				// usual.  				es_id = box_data.Mid (offset' 2).ToUShort ();  				offset += 2;  			}
Magic Number,TagLib.Mpeg4,AppleElementaryStreamDescriptor,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\AppleElementaryStreamDescriptor.cs,AppleElementaryStreamDescriptor,The following statement contains a magic number: if (box_data [offset ++] == 3) {  				// We have a descriptor tag. Check that it's at  				// least 20 long.  				if (ReadLength (box_data' ref offset) < 20)  					throw new CorruptFileException (  						"Insufficient data present.");  				  				es_id = box_data.Mid (offset' 2).ToUShort ();  				offset += 2;  				stream_priority = box_data [offset ++];  			} else {  				// The tag wasn't found' so the next two byte  				// are the ID' and after that' business as  				// usual.  				es_id = box_data.Mid (offset' 2).ToUShort ();  				offset += 2;  			}
Magic Number,TagLib.Mpeg4,AppleElementaryStreamDescriptor,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\AppleElementaryStreamDescriptor.cs,AppleElementaryStreamDescriptor,The following statement contains a magic number: if (box_data [offset ++] == 3) {  				// We have a descriptor tag. Check that it's at  				// least 20 long.  				if (ReadLength (box_data' ref offset) < 20)  					throw new CorruptFileException (  						"Insufficient data present.");  				  				es_id = box_data.Mid (offset' 2).ToUShort ();  				offset += 2;  				stream_priority = box_data [offset ++];  			} else {  				// The tag wasn't found' so the next two byte  				// are the ID' and after that' business as  				// usual.  				es_id = box_data.Mid (offset' 2).ToUShort ();  				offset += 2;  			}
Magic Number,TagLib.Mpeg4,AppleElementaryStreamDescriptor,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\AppleElementaryStreamDescriptor.cs,AppleElementaryStreamDescriptor,The following statement contains a magic number: if (box_data [offset ++] != 4)  				throw new CorruptFileException (  					"Could not identify decoder configuration descriptor.");
Magic Number,TagLib.Mpeg4,AppleElementaryStreamDescriptor,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\AppleElementaryStreamDescriptor.cs,AppleElementaryStreamDescriptor,The following statement contains a magic number: if (ReadLength (box_data' ref offset) < 15)  				throw new CorruptFileException (  					"Could not read data. Too small.");
Magic Number,TagLib.Mpeg4,AppleElementaryStreamDescriptor,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\AppleElementaryStreamDescriptor.cs,AppleElementaryStreamDescriptor,The following statement contains a magic number: buffer_size_db = box_data.Mid (offset' 3).ToUInt ();
Magic Number,TagLib.Mpeg4,AppleElementaryStreamDescriptor,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\AppleElementaryStreamDescriptor.cs,AppleElementaryStreamDescriptor,The following statement contains a magic number: offset += 3;
Magic Number,TagLib.Mpeg4,AppleElementaryStreamDescriptor,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\AppleElementaryStreamDescriptor.cs,AppleElementaryStreamDescriptor,The following statement contains a magic number: max_bitrate = box_data.Mid (offset' 4).ToUInt ();
Magic Number,TagLib.Mpeg4,AppleElementaryStreamDescriptor,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\AppleElementaryStreamDescriptor.cs,AppleElementaryStreamDescriptor,The following statement contains a magic number: offset += 4;
Magic Number,TagLib.Mpeg4,AppleElementaryStreamDescriptor,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\AppleElementaryStreamDescriptor.cs,AppleElementaryStreamDescriptor,The following statement contains a magic number: average_bitrate = box_data.Mid (offset' 4).ToUInt ();
Magic Number,TagLib.Mpeg4,AppleElementaryStreamDescriptor,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\AppleElementaryStreamDescriptor.cs,AppleElementaryStreamDescriptor,The following statement contains a magic number: offset += 4;
Magic Number,TagLib.Mpeg4,AppleElementaryStreamDescriptor,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\AppleElementaryStreamDescriptor.cs,AppleElementaryStreamDescriptor,The following statement contains a magic number: if (box_data [offset ++] != 5)  				throw new CorruptFileException (  					"Could not identify decoder specific descriptor.");
Magic Number,TagLib.Mpeg4,AppleElementaryStreamDescriptor,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\AppleElementaryStreamDescriptor.cs,ReadLength,The following statement contains a magic number: int end = offset + 4;
Magic Number,TagLib.Mpeg4,AppleElementaryStreamDescriptor,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\AppleElementaryStreamDescriptor.cs,ReadLength,The following statement contains a magic number: do {  				b = data [offset ++];  				length = (uint) (length << 7) |  					(uint) (b & 0x7f);  			} while ((b & 0x80) != 0 && offset <= end);
Magic Number,TagLib.Mpeg4,FullBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\FullBox.cs,FullBox,The following statement contains a magic number: ByteVector header_data = file.ReadBlock (4);
Magic Number,TagLib.Mpeg4,FullBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\FullBox.cs,FullBox,The following statement contains a magic number: flags = header_data.Mid (1' 3).ToUInt ();
Magic Number,TagLib.Mpeg4,FullBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\FullBox.cs,Render,The following statement contains a magic number: output.Add (ByteVector.FromUInt (flags).Mid (1'3));
Magic Number,TagLib.Mpeg4,IsoAudioSampleEntry,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoAudioSampleEntry.cs,IsoAudioSampleEntry,The following statement contains a magic number: file.Seek (base.DataPosition + 8);
Magic Number,TagLib.Mpeg4,IsoAudioSampleEntry,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoAudioSampleEntry.cs,IsoAudioSampleEntry,The following statement contains a magic number: channel_count = file.ReadBlock (2).ToUShort ();
Magic Number,TagLib.Mpeg4,IsoAudioSampleEntry,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoAudioSampleEntry.cs,IsoAudioSampleEntry,The following statement contains a magic number: sample_size = file.ReadBlock (2).ToUShort ();
Magic Number,TagLib.Mpeg4,IsoAudioSampleEntry,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoAudioSampleEntry.cs,IsoAudioSampleEntry,The following statement contains a magic number: file.Seek (base.DataPosition + 16);
Magic Number,TagLib.Mpeg4,IsoAudioSampleEntry,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoAudioSampleEntry.cs,IsoAudioSampleEntry,The following statement contains a magic number: sample_rate = file.ReadBlock (4).ToUInt ();
Magic Number,TagLib.Mpeg4,IsoChunkLargeOffsetBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoChunkLargeOffsetBox.cs,IsoChunkLargeOffsetBox,The following statement contains a magic number: offsets = new ulong [(int)  				box_data.Mid (0' 4).ToUInt ()];
Magic Number,TagLib.Mpeg4,IsoChunkLargeOffsetBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoChunkLargeOffsetBox.cs,IsoChunkLargeOffsetBox,The following statement contains a magic number: for (int i = 0; i < offsets.Length; i ++)  				offsets [i] = box_data.Mid (4 + i * 8'  					8).ToULong ();
Magic Number,TagLib.Mpeg4,IsoChunkLargeOffsetBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoChunkLargeOffsetBox.cs,IsoChunkLargeOffsetBox,The following statement contains a magic number: for (int i = 0; i < offsets.Length; i ++)  				offsets [i] = box_data.Mid (4 + i * 8'  					8).ToULong ();
Magic Number,TagLib.Mpeg4,IsoChunkLargeOffsetBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoChunkLargeOffsetBox.cs,IsoChunkLargeOffsetBox,The following statement contains a magic number: for (int i = 0; i < offsets.Length; i ++)  				offsets [i] = box_data.Mid (4 + i * 8'  					8).ToULong ();
Magic Number,TagLib.Mpeg4,IsoChunkOffsetBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoChunkOffsetBox.cs,IsoChunkOffsetBox,The following statement contains a magic number: offsets = new uint [(int)  				box_data.Mid (0' 4).ToUInt ()];
Magic Number,TagLib.Mpeg4,IsoChunkOffsetBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoChunkOffsetBox.cs,IsoChunkOffsetBox,The following statement contains a magic number: for (int i = 0; i < offsets.Length; i ++)  				offsets [i] = box_data.Mid (4 + i * 4'  					4).ToUInt ();
Magic Number,TagLib.Mpeg4,IsoChunkOffsetBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoChunkOffsetBox.cs,IsoChunkOffsetBox,The following statement contains a magic number: for (int i = 0; i < offsets.Length; i ++)  				offsets [i] = box_data.Mid (4 + i * 4'  					4).ToUInt ();
Magic Number,TagLib.Mpeg4,IsoChunkOffsetBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoChunkOffsetBox.cs,IsoChunkOffsetBox,The following statement contains a magic number: for (int i = 0; i < offsets.Length; i ++)  				offsets [i] = box_data.Mid (4 + i * 4'  					4).ToUInt ();
Magic Number,TagLib.Mpeg4,IsoHandlerBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoHandlerBox.cs,IsoHandlerBox,The following statement contains a magic number: file.Seek (DataPosition + 4);
Magic Number,TagLib.Mpeg4,IsoHandlerBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoHandlerBox.cs,IsoHandlerBox,The following statement contains a magic number: ByteVector box_data = file.ReadBlock (DataSize - 4);
Magic Number,TagLib.Mpeg4,IsoHandlerBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoHandlerBox.cs,IsoHandlerBox,The following statement contains a magic number: handler_type = box_data.Mid (0' 4);
Magic Number,TagLib.Mpeg4,IsoHandlerBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoHandlerBox.cs,IsoHandlerBox,The following statement contains a magic number: int end = box_data.Find ((byte) 0' 16);
Magic Number,TagLib.Mpeg4,IsoHandlerBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoHandlerBox.cs,IsoHandlerBox,The following statement contains a magic number: if (end < 16)  				end = box_data.Count;
Magic Number,TagLib.Mpeg4,IsoHandlerBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoHandlerBox.cs,IsoHandlerBox,The following statement contains a magic number: name = box_data.ToString (StringType.UTF8' 16' end - 16);
Magic Number,TagLib.Mpeg4,IsoHandlerBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoHandlerBox.cs,IsoHandlerBox,The following statement contains a magic number: name = box_data.ToString (StringType.UTF8' 16' end - 16);
Magic Number,TagLib.Mpeg4,IsoHandlerBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoHandlerBox.cs,IsoHandlerBox,The following statement contains a magic number: if (handlerType.Count < 4)  				throw new ArgumentException (  					"The handler type must be four bytes long."'  					"handlerType");
Magic Number,TagLib.Mpeg4,IsoHandlerBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoHandlerBox.cs,IsoHandlerBox,The following statement contains a magic number: this.handler_type = handlerType.Mid (0'4);
Magic Number,TagLib.Mpeg4,IsoMetaBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMetaBox.cs,IsoMetaBox,The following statement contains a magic number: if (handlerType.Count < 4)  				throw new ArgumentException (  					"The handler type must be four bytes long."'  					"handlerType");
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (Version == 1) {  				// Read version one (large integers).  				data = file.ReadBlock (Math.Min (28'  					bytes_remaining));  				if (data.Count >= 8)  					creation_time = data.Mid (0'  						8).ToULong ();  				if (data.Count >= 16)  					modification_time = data.Mid (8'  						8).ToULong ();  				if (data.Count >= 20)  					timescale = data.Mid (16' 4).ToUInt ();  				if (data.Count >= 28)  					duration = data.Mid (20' 8).ToULong ();  				bytes_remaining -= 28;  			} else {  				// Read version zero (normal integers).  				data = file.ReadBlock (Math.Min (16'  					bytes_remaining));  				if (data.Count >= 4)  					creation_time = data.Mid (0'  						4).ToUInt ();  				if (data.Count >= 8)  					modification_time = data.Mid (4'  						4).ToUInt ();  				if (data.Count >= 12)  					timescale = data.Mid (8' 4).ToUInt ();  				if (data.Count >= 16)  					duration = data.Mid (12' 4).ToUInt ();  				bytes_remaining -= 16;  			}
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (Version == 1) {  				// Read version one (large integers).  				data = file.ReadBlock (Math.Min (28'  					bytes_remaining));  				if (data.Count >= 8)  					creation_time = data.Mid (0'  						8).ToULong ();  				if (data.Count >= 16)  					modification_time = data.Mid (8'  						8).ToULong ();  				if (data.Count >= 20)  					timescale = data.Mid (16' 4).ToUInt ();  				if (data.Count >= 28)  					duration = data.Mid (20' 8).ToULong ();  				bytes_remaining -= 28;  			} else {  				// Read version zero (normal integers).  				data = file.ReadBlock (Math.Min (16'  					bytes_remaining));  				if (data.Count >= 4)  					creation_time = data.Mid (0'  						4).ToUInt ();  				if (data.Count >= 8)  					modification_time = data.Mid (4'  						4).ToUInt ();  				if (data.Count >= 12)  					timescale = data.Mid (8' 4).ToUInt ();  				if (data.Count >= 16)  					duration = data.Mid (12' 4).ToUInt ();  				bytes_remaining -= 16;  			}
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (Version == 1) {  				// Read version one (large integers).  				data = file.ReadBlock (Math.Min (28'  					bytes_remaining));  				if (data.Count >= 8)  					creation_time = data.Mid (0'  						8).ToULong ();  				if (data.Count >= 16)  					modification_time = data.Mid (8'  						8).ToULong ();  				if (data.Count >= 20)  					timescale = data.Mid (16' 4).ToUInt ();  				if (data.Count >= 28)  					duration = data.Mid (20' 8).ToULong ();  				bytes_remaining -= 28;  			} else {  				// Read version zero (normal integers).  				data = file.ReadBlock (Math.Min (16'  					bytes_remaining));  				if (data.Count >= 4)  					creation_time = data.Mid (0'  						4).ToUInt ();  				if (data.Count >= 8)  					modification_time = data.Mid (4'  						4).ToUInt ();  				if (data.Count >= 12)  					timescale = data.Mid (8' 4).ToUInt ();  				if (data.Count >= 16)  					duration = data.Mid (12' 4).ToUInt ();  				bytes_remaining -= 16;  			}
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (Version == 1) {  				// Read version one (large integers).  				data = file.ReadBlock (Math.Min (28'  					bytes_remaining));  				if (data.Count >= 8)  					creation_time = data.Mid (0'  						8).ToULong ();  				if (data.Count >= 16)  					modification_time = data.Mid (8'  						8).ToULong ();  				if (data.Count >= 20)  					timescale = data.Mid (16' 4).ToUInt ();  				if (data.Count >= 28)  					duration = data.Mid (20' 8).ToULong ();  				bytes_remaining -= 28;  			} else {  				// Read version zero (normal integers).  				data = file.ReadBlock (Math.Min (16'  					bytes_remaining));  				if (data.Count >= 4)  					creation_time = data.Mid (0'  						4).ToUInt ();  				if (data.Count >= 8)  					modification_time = data.Mid (4'  						4).ToUInt ();  				if (data.Count >= 12)  					timescale = data.Mid (8' 4).ToUInt ();  				if (data.Count >= 16)  					duration = data.Mid (12' 4).ToUInt ();  				bytes_remaining -= 16;  			}
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (Version == 1) {  				// Read version one (large integers).  				data = file.ReadBlock (Math.Min (28'  					bytes_remaining));  				if (data.Count >= 8)  					creation_time = data.Mid (0'  						8).ToULong ();  				if (data.Count >= 16)  					modification_time = data.Mid (8'  						8).ToULong ();  				if (data.Count >= 20)  					timescale = data.Mid (16' 4).ToUInt ();  				if (data.Count >= 28)  					duration = data.Mid (20' 8).ToULong ();  				bytes_remaining -= 28;  			} else {  				// Read version zero (normal integers).  				data = file.ReadBlock (Math.Min (16'  					bytes_remaining));  				if (data.Count >= 4)  					creation_time = data.Mid (0'  						4).ToUInt ();  				if (data.Count >= 8)  					modification_time = data.Mid (4'  						4).ToUInt ();  				if (data.Count >= 12)  					timescale = data.Mid (8' 4).ToUInt ();  				if (data.Count >= 16)  					duration = data.Mid (12' 4).ToUInt ();  				bytes_remaining -= 16;  			}
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (Version == 1) {  				// Read version one (large integers).  				data = file.ReadBlock (Math.Min (28'  					bytes_remaining));  				if (data.Count >= 8)  					creation_time = data.Mid (0'  						8).ToULong ();  				if (data.Count >= 16)  					modification_time = data.Mid (8'  						8).ToULong ();  				if (data.Count >= 20)  					timescale = data.Mid (16' 4).ToUInt ();  				if (data.Count >= 28)  					duration = data.Mid (20' 8).ToULong ();  				bytes_remaining -= 28;  			} else {  				// Read version zero (normal integers).  				data = file.ReadBlock (Math.Min (16'  					bytes_remaining));  				if (data.Count >= 4)  					creation_time = data.Mid (0'  						4).ToUInt ();  				if (data.Count >= 8)  					modification_time = data.Mid (4'  						4).ToUInt ();  				if (data.Count >= 12)  					timescale = data.Mid (8' 4).ToUInt ();  				if (data.Count >= 16)  					duration = data.Mid (12' 4).ToUInt ();  				bytes_remaining -= 16;  			}
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (Version == 1) {  				// Read version one (large integers).  				data = file.ReadBlock (Math.Min (28'  					bytes_remaining));  				if (data.Count >= 8)  					creation_time = data.Mid (0'  						8).ToULong ();  				if (data.Count >= 16)  					modification_time = data.Mid (8'  						8).ToULong ();  				if (data.Count >= 20)  					timescale = data.Mid (16' 4).ToUInt ();  				if (data.Count >= 28)  					duration = data.Mid (20' 8).ToULong ();  				bytes_remaining -= 28;  			} else {  				// Read version zero (normal integers).  				data = file.ReadBlock (Math.Min (16'  					bytes_remaining));  				if (data.Count >= 4)  					creation_time = data.Mid (0'  						4).ToUInt ();  				if (data.Count >= 8)  					modification_time = data.Mid (4'  						4).ToUInt ();  				if (data.Count >= 12)  					timescale = data.Mid (8' 4).ToUInt ();  				if (data.Count >= 16)  					duration = data.Mid (12' 4).ToUInt ();  				bytes_remaining -= 16;  			}
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (Version == 1) {  				// Read version one (large integers).  				data = file.ReadBlock (Math.Min (28'  					bytes_remaining));  				if (data.Count >= 8)  					creation_time = data.Mid (0'  						8).ToULong ();  				if (data.Count >= 16)  					modification_time = data.Mid (8'  						8).ToULong ();  				if (data.Count >= 20)  					timescale = data.Mid (16' 4).ToUInt ();  				if (data.Count >= 28)  					duration = data.Mid (20' 8).ToULong ();  				bytes_remaining -= 28;  			} else {  				// Read version zero (normal integers).  				data = file.ReadBlock (Math.Min (16'  					bytes_remaining));  				if (data.Count >= 4)  					creation_time = data.Mid (0'  						4).ToUInt ();  				if (data.Count >= 8)  					modification_time = data.Mid (4'  						4).ToUInt ();  				if (data.Count >= 12)  					timescale = data.Mid (8' 4).ToUInt ();  				if (data.Count >= 16)  					duration = data.Mid (12' 4).ToUInt ();  				bytes_remaining -= 16;  			}
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (Version == 1) {  				// Read version one (large integers).  				data = file.ReadBlock (Math.Min (28'  					bytes_remaining));  				if (data.Count >= 8)  					creation_time = data.Mid (0'  						8).ToULong ();  				if (data.Count >= 16)  					modification_time = data.Mid (8'  						8).ToULong ();  				if (data.Count >= 20)  					timescale = data.Mid (16' 4).ToUInt ();  				if (data.Count >= 28)  					duration = data.Mid (20' 8).ToULong ();  				bytes_remaining -= 28;  			} else {  				// Read version zero (normal integers).  				data = file.ReadBlock (Math.Min (16'  					bytes_remaining));  				if (data.Count >= 4)  					creation_time = data.Mid (0'  						4).ToUInt ();  				if (data.Count >= 8)  					modification_time = data.Mid (4'  						4).ToUInt ();  				if (data.Count >= 12)  					timescale = data.Mid (8' 4).ToUInt ();  				if (data.Count >= 16)  					duration = data.Mid (12' 4).ToUInt ();  				bytes_remaining -= 16;  			}
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (Version == 1) {  				// Read version one (large integers).  				data = file.ReadBlock (Math.Min (28'  					bytes_remaining));  				if (data.Count >= 8)  					creation_time = data.Mid (0'  						8).ToULong ();  				if (data.Count >= 16)  					modification_time = data.Mid (8'  						8).ToULong ();  				if (data.Count >= 20)  					timescale = data.Mid (16' 4).ToUInt ();  				if (data.Count >= 28)  					duration = data.Mid (20' 8).ToULong ();  				bytes_remaining -= 28;  			} else {  				// Read version zero (normal integers).  				data = file.ReadBlock (Math.Min (16'  					bytes_remaining));  				if (data.Count >= 4)  					creation_time = data.Mid (0'  						4).ToUInt ();  				if (data.Count >= 8)  					modification_time = data.Mid (4'  						4).ToUInt ();  				if (data.Count >= 12)  					timescale = data.Mid (8' 4).ToUInt ();  				if (data.Count >= 16)  					duration = data.Mid (12' 4).ToUInt ();  				bytes_remaining -= 16;  			}
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (Version == 1) {  				// Read version one (large integers).  				data = file.ReadBlock (Math.Min (28'  					bytes_remaining));  				if (data.Count >= 8)  					creation_time = data.Mid (0'  						8).ToULong ();  				if (data.Count >= 16)  					modification_time = data.Mid (8'  						8).ToULong ();  				if (data.Count >= 20)  					timescale = data.Mid (16' 4).ToUInt ();  				if (data.Count >= 28)  					duration = data.Mid (20' 8).ToULong ();  				bytes_remaining -= 28;  			} else {  				// Read version zero (normal integers).  				data = file.ReadBlock (Math.Min (16'  					bytes_remaining));  				if (data.Count >= 4)  					creation_time = data.Mid (0'  						4).ToUInt ();  				if (data.Count >= 8)  					modification_time = data.Mid (4'  						4).ToUInt ();  				if (data.Count >= 12)  					timescale = data.Mid (8' 4).ToUInt ();  				if (data.Count >= 16)  					duration = data.Mid (12' 4).ToUInt ();  				bytes_remaining -= 16;  			}
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (Version == 1) {  				// Read version one (large integers).  				data = file.ReadBlock (Math.Min (28'  					bytes_remaining));  				if (data.Count >= 8)  					creation_time = data.Mid (0'  						8).ToULong ();  				if (data.Count >= 16)  					modification_time = data.Mid (8'  						8).ToULong ();  				if (data.Count >= 20)  					timescale = data.Mid (16' 4).ToUInt ();  				if (data.Count >= 28)  					duration = data.Mid (20' 8).ToULong ();  				bytes_remaining -= 28;  			} else {  				// Read version zero (normal integers).  				data = file.ReadBlock (Math.Min (16'  					bytes_remaining));  				if (data.Count >= 4)  					creation_time = data.Mid (0'  						4).ToUInt ();  				if (data.Count >= 8)  					modification_time = data.Mid (4'  						4).ToUInt ();  				if (data.Count >= 12)  					timescale = data.Mid (8' 4).ToUInt ();  				if (data.Count >= 16)  					duration = data.Mid (12' 4).ToUInt ();  				bytes_remaining -= 16;  			}
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (Version == 1) {  				// Read version one (large integers).  				data = file.ReadBlock (Math.Min (28'  					bytes_remaining));  				if (data.Count >= 8)  					creation_time = data.Mid (0'  						8).ToULong ();  				if (data.Count >= 16)  					modification_time = data.Mid (8'  						8).ToULong ();  				if (data.Count >= 20)  					timescale = data.Mid (16' 4).ToUInt ();  				if (data.Count >= 28)  					duration = data.Mid (20' 8).ToULong ();  				bytes_remaining -= 28;  			} else {  				// Read version zero (normal integers).  				data = file.ReadBlock (Math.Min (16'  					bytes_remaining));  				if (data.Count >= 4)  					creation_time = data.Mid (0'  						4).ToUInt ();  				if (data.Count >= 8)  					modification_time = data.Mid (4'  						4).ToUInt ();  				if (data.Count >= 12)  					timescale = data.Mid (8' 4).ToUInt ();  				if (data.Count >= 16)  					duration = data.Mid (12' 4).ToUInt ();  				bytes_remaining -= 16;  			}
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (Version == 1) {  				// Read version one (large integers).  				data = file.ReadBlock (Math.Min (28'  					bytes_remaining));  				if (data.Count >= 8)  					creation_time = data.Mid (0'  						8).ToULong ();  				if (data.Count >= 16)  					modification_time = data.Mid (8'  						8).ToULong ();  				if (data.Count >= 20)  					timescale = data.Mid (16' 4).ToUInt ();  				if (data.Count >= 28)  					duration = data.Mid (20' 8).ToULong ();  				bytes_remaining -= 28;  			} else {  				// Read version zero (normal integers).  				data = file.ReadBlock (Math.Min (16'  					bytes_remaining));  				if (data.Count >= 4)  					creation_time = data.Mid (0'  						4).ToUInt ();  				if (data.Count >= 8)  					modification_time = data.Mid (4'  						4).ToUInt ();  				if (data.Count >= 12)  					timescale = data.Mid (8' 4).ToUInt ();  				if (data.Count >= 16)  					duration = data.Mid (12' 4).ToUInt ();  				bytes_remaining -= 16;  			}
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (Version == 1) {  				// Read version one (large integers).  				data = file.ReadBlock (Math.Min (28'  					bytes_remaining));  				if (data.Count >= 8)  					creation_time = data.Mid (0'  						8).ToULong ();  				if (data.Count >= 16)  					modification_time = data.Mid (8'  						8).ToULong ();  				if (data.Count >= 20)  					timescale = data.Mid (16' 4).ToUInt ();  				if (data.Count >= 28)  					duration = data.Mid (20' 8).ToULong ();  				bytes_remaining -= 28;  			} else {  				// Read version zero (normal integers).  				data = file.ReadBlock (Math.Min (16'  					bytes_remaining));  				if (data.Count >= 4)  					creation_time = data.Mid (0'  						4).ToUInt ();  				if (data.Count >= 8)  					modification_time = data.Mid (4'  						4).ToUInt ();  				if (data.Count >= 12)  					timescale = data.Mid (8' 4).ToUInt ();  				if (data.Count >= 16)  					duration = data.Mid (12' 4).ToUInt ();  				bytes_remaining -= 16;  			}
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (Version == 1) {  				// Read version one (large integers).  				data = file.ReadBlock (Math.Min (28'  					bytes_remaining));  				if (data.Count >= 8)  					creation_time = data.Mid (0'  						8).ToULong ();  				if (data.Count >= 16)  					modification_time = data.Mid (8'  						8).ToULong ();  				if (data.Count >= 20)  					timescale = data.Mid (16' 4).ToUInt ();  				if (data.Count >= 28)  					duration = data.Mid (20' 8).ToULong ();  				bytes_remaining -= 28;  			} else {  				// Read version zero (normal integers).  				data = file.ReadBlock (Math.Min (16'  					bytes_remaining));  				if (data.Count >= 4)  					creation_time = data.Mid (0'  						4).ToUInt ();  				if (data.Count >= 8)  					modification_time = data.Mid (4'  						4).ToUInt ();  				if (data.Count >= 12)  					timescale = data.Mid (8' 4).ToUInt ();  				if (data.Count >= 16)  					duration = data.Mid (12' 4).ToUInt ();  				bytes_remaining -= 16;  			}
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (Version == 1) {  				// Read version one (large integers).  				data = file.ReadBlock (Math.Min (28'  					bytes_remaining));  				if (data.Count >= 8)  					creation_time = data.Mid (0'  						8).ToULong ();  				if (data.Count >= 16)  					modification_time = data.Mid (8'  						8).ToULong ();  				if (data.Count >= 20)  					timescale = data.Mid (16' 4).ToUInt ();  				if (data.Count >= 28)  					duration = data.Mid (20' 8).ToULong ();  				bytes_remaining -= 28;  			} else {  				// Read version zero (normal integers).  				data = file.ReadBlock (Math.Min (16'  					bytes_remaining));  				if (data.Count >= 4)  					creation_time = data.Mid (0'  						4).ToUInt ();  				if (data.Count >= 8)  					modification_time = data.Mid (4'  						4).ToUInt ();  				if (data.Count >= 12)  					timescale = data.Mid (8' 4).ToUInt ();  				if (data.Count >= 16)  					duration = data.Mid (12' 4).ToUInt ();  				bytes_remaining -= 16;  			}
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (Version == 1) {  				// Read version one (large integers).  				data = file.ReadBlock (Math.Min (28'  					bytes_remaining));  				if (data.Count >= 8)  					creation_time = data.Mid (0'  						8).ToULong ();  				if (data.Count >= 16)  					modification_time = data.Mid (8'  						8).ToULong ();  				if (data.Count >= 20)  					timescale = data.Mid (16' 4).ToUInt ();  				if (data.Count >= 28)  					duration = data.Mid (20' 8).ToULong ();  				bytes_remaining -= 28;  			} else {  				// Read version zero (normal integers).  				data = file.ReadBlock (Math.Min (16'  					bytes_remaining));  				if (data.Count >= 4)  					creation_time = data.Mid (0'  						4).ToUInt ();  				if (data.Count >= 8)  					modification_time = data.Mid (4'  						4).ToUInt ();  				if (data.Count >= 12)  					timescale = data.Mid (8' 4).ToUInt ();  				if (data.Count >= 16)  					duration = data.Mid (12' 4).ToUInt ();  				bytes_remaining -= 16;  			}
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (Version == 1) {  				// Read version one (large integers).  				data = file.ReadBlock (Math.Min (28'  					bytes_remaining));  				if (data.Count >= 8)  					creation_time = data.Mid (0'  						8).ToULong ();  				if (data.Count >= 16)  					modification_time = data.Mid (8'  						8).ToULong ();  				if (data.Count >= 20)  					timescale = data.Mid (16' 4).ToUInt ();  				if (data.Count >= 28)  					duration = data.Mid (20' 8).ToULong ();  				bytes_remaining -= 28;  			} else {  				// Read version zero (normal integers).  				data = file.ReadBlock (Math.Min (16'  					bytes_remaining));  				if (data.Count >= 4)  					creation_time = data.Mid (0'  						4).ToUInt ();  				if (data.Count >= 8)  					modification_time = data.Mid (4'  						4).ToUInt ();  				if (data.Count >= 12)  					timescale = data.Mid (8' 4).ToUInt ();  				if (data.Count >= 16)  					duration = data.Mid (12' 4).ToUInt ();  				bytes_remaining -= 16;  			}
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (Version == 1) {  				// Read version one (large integers).  				data = file.ReadBlock (Math.Min (28'  					bytes_remaining));  				if (data.Count >= 8)  					creation_time = data.Mid (0'  						8).ToULong ();  				if (data.Count >= 16)  					modification_time = data.Mid (8'  						8).ToULong ();  				if (data.Count >= 20)  					timescale = data.Mid (16' 4).ToUInt ();  				if (data.Count >= 28)  					duration = data.Mid (20' 8).ToULong ();  				bytes_remaining -= 28;  			} else {  				// Read version zero (normal integers).  				data = file.ReadBlock (Math.Min (16'  					bytes_remaining));  				if (data.Count >= 4)  					creation_time = data.Mid (0'  						4).ToUInt ();  				if (data.Count >= 8)  					modification_time = data.Mid (4'  						4).ToUInt ();  				if (data.Count >= 12)  					timescale = data.Mid (8' 4).ToUInt ();  				if (data.Count >= 16)  					duration = data.Mid (12' 4).ToUInt ();  				bytes_remaining -= 16;  			}
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (Version == 1) {  				// Read version one (large integers).  				data = file.ReadBlock (Math.Min (28'  					bytes_remaining));  				if (data.Count >= 8)  					creation_time = data.Mid (0'  						8).ToULong ();  				if (data.Count >= 16)  					modification_time = data.Mid (8'  						8).ToULong ();  				if (data.Count >= 20)  					timescale = data.Mid (16' 4).ToUInt ();  				if (data.Count >= 28)  					duration = data.Mid (20' 8).ToULong ();  				bytes_remaining -= 28;  			} else {  				// Read version zero (normal integers).  				data = file.ReadBlock (Math.Min (16'  					bytes_remaining));  				if (data.Count >= 4)  					creation_time = data.Mid (0'  						4).ToUInt ();  				if (data.Count >= 8)  					modification_time = data.Mid (4'  						4).ToUInt ();  				if (data.Count >= 12)  					timescale = data.Mid (8' 4).ToUInt ();  				if (data.Count >= 16)  					duration = data.Mid (12' 4).ToUInt ();  				bytes_remaining -= 16;  			}
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (Version == 1) {  				// Read version one (large integers).  				data = file.ReadBlock (Math.Min (28'  					bytes_remaining));  				if (data.Count >= 8)  					creation_time = data.Mid (0'  						8).ToULong ();  				if (data.Count >= 16)  					modification_time = data.Mid (8'  						8).ToULong ();  				if (data.Count >= 20)  					timescale = data.Mid (16' 4).ToUInt ();  				if (data.Count >= 28)  					duration = data.Mid (20' 8).ToULong ();  				bytes_remaining -= 28;  			} else {  				// Read version zero (normal integers).  				data = file.ReadBlock (Math.Min (16'  					bytes_remaining));  				if (data.Count >= 4)  					creation_time = data.Mid (0'  						4).ToUInt ();  				if (data.Count >= 8)  					modification_time = data.Mid (4'  						4).ToUInt ();  				if (data.Count >= 12)  					timescale = data.Mid (8' 4).ToUInt ();  				if (data.Count >= 16)  					duration = data.Mid (12' 4).ToUInt ();  				bytes_remaining -= 16;  			}
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (Version == 1) {  				// Read version one (large integers).  				data = file.ReadBlock (Math.Min (28'  					bytes_remaining));  				if (data.Count >= 8)  					creation_time = data.Mid (0'  						8).ToULong ();  				if (data.Count >= 16)  					modification_time = data.Mid (8'  						8).ToULong ();  				if (data.Count >= 20)  					timescale = data.Mid (16' 4).ToUInt ();  				if (data.Count >= 28)  					duration = data.Mid (20' 8).ToULong ();  				bytes_remaining -= 28;  			} else {  				// Read version zero (normal integers).  				data = file.ReadBlock (Math.Min (16'  					bytes_remaining));  				if (data.Count >= 4)  					creation_time = data.Mid (0'  						4).ToUInt ();  				if (data.Count >= 8)  					modification_time = data.Mid (4'  						4).ToUInt ();  				if (data.Count >= 12)  					timescale = data.Mid (8' 4).ToUInt ();  				if (data.Count >= 16)  					duration = data.Mid (12' 4).ToUInt ();  				bytes_remaining -= 16;  			}
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (Version == 1) {  				// Read version one (large integers).  				data = file.ReadBlock (Math.Min (28'  					bytes_remaining));  				if (data.Count >= 8)  					creation_time = data.Mid (0'  						8).ToULong ();  				if (data.Count >= 16)  					modification_time = data.Mid (8'  						8).ToULong ();  				if (data.Count >= 20)  					timescale = data.Mid (16' 4).ToUInt ();  				if (data.Count >= 28)  					duration = data.Mid (20' 8).ToULong ();  				bytes_remaining -= 28;  			} else {  				// Read version zero (normal integers).  				data = file.ReadBlock (Math.Min (16'  					bytes_remaining));  				if (data.Count >= 4)  					creation_time = data.Mid (0'  						4).ToUInt ();  				if (data.Count >= 8)  					modification_time = data.Mid (4'  						4).ToUInt ();  				if (data.Count >= 12)  					timescale = data.Mid (8' 4).ToUInt ();  				if (data.Count >= 16)  					duration = data.Mid (12' 4).ToUInt ();  				bytes_remaining -= 16;  			}
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (Version == 1) {  				// Read version one (large integers).  				data = file.ReadBlock (Math.Min (28'  					bytes_remaining));  				if (data.Count >= 8)  					creation_time = data.Mid (0'  						8).ToULong ();  				if (data.Count >= 16)  					modification_time = data.Mid (8'  						8).ToULong ();  				if (data.Count >= 20)  					timescale = data.Mid (16' 4).ToUInt ();  				if (data.Count >= 28)  					duration = data.Mid (20' 8).ToULong ();  				bytes_remaining -= 28;  			} else {  				// Read version zero (normal integers).  				data = file.ReadBlock (Math.Min (16'  					bytes_remaining));  				if (data.Count >= 4)  					creation_time = data.Mid (0'  						4).ToUInt ();  				if (data.Count >= 8)  					modification_time = data.Mid (4'  						4).ToUInt ();  				if (data.Count >= 12)  					timescale = data.Mid (8' 4).ToUInt ();  				if (data.Count >= 16)  					duration = data.Mid (12' 4).ToUInt ();  				bytes_remaining -= 16;  			}
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (Version == 1) {  				// Read version one (large integers).  				data = file.ReadBlock (Math.Min (28'  					bytes_remaining));  				if (data.Count >= 8)  					creation_time = data.Mid (0'  						8).ToULong ();  				if (data.Count >= 16)  					modification_time = data.Mid (8'  						8).ToULong ();  				if (data.Count >= 20)  					timescale = data.Mid (16' 4).ToUInt ();  				if (data.Count >= 28)  					duration = data.Mid (20' 8).ToULong ();  				bytes_remaining -= 28;  			} else {  				// Read version zero (normal integers).  				data = file.ReadBlock (Math.Min (16'  					bytes_remaining));  				if (data.Count >= 4)  					creation_time = data.Mid (0'  						4).ToUInt ();  				if (data.Count >= 8)  					modification_time = data.Mid (4'  						4).ToUInt ();  				if (data.Count >= 12)  					timescale = data.Mid (8' 4).ToUInt ();  				if (data.Count >= 16)  					duration = data.Mid (12' 4).ToUInt ();  				bytes_remaining -= 16;  			}
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: data = file.ReadBlock (Math.Min (6' bytes_remaining));
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (data.Count >= 4)  				rate = data.Mid (0' 4).ToUInt ();
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (data.Count >= 4)  				rate = data.Mid (0' 4).ToUInt ();
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (data.Count >= 6)  				volume = data.Mid (4' 2).ToUShort ();
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (data.Count >= 6)  				volume = data.Mid (4' 2).ToUShort ();
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (data.Count >= 6)  				volume = data.Mid (4' 2).ToUShort ();
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: file.Seek (file.Tell + 70);
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: bytes_remaining -= 76;
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: data = file.ReadBlock (Math.Min (4'  				bytes_remaining));
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (data.Count >= 4)  				next_track_id = data.Mid (0' 4).ToUInt ();
Magic Number,TagLib.Mpeg4,IsoMovieHeaderBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoMovieHeaderBox.cs,IsoMovieHeaderBox,The following statement contains a magic number: if (data.Count >= 4)  				next_track_id = data.Mid (0' 4).ToUInt ();
Magic Number,TagLib.Mpeg4,IsoSampleDescriptionBox,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoSampleDescriptionBox.cs,IsoSampleDescriptionBox,The following statement contains a magic number: entry_count = file.ReadBlock (4).ToUInt ();
Magic Number,TagLib.Mpeg4,IsoSampleEntry,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoSampleEntry.cs,IsoSampleEntry,The following statement contains a magic number: file.Seek (base.DataPosition + 6);
Magic Number,TagLib.Mpeg4,IsoSampleEntry,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoSampleEntry.cs,IsoSampleEntry,The following statement contains a magic number: data_reference_index = file.ReadBlock (2).ToUShort ();
Magic Number,TagLib.Mpeg4,IsoVisualSampleEntry,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoVisualSampleEntry.cs,IsoVisualSampleEntry,The following statement contains a magic number: file.Seek (base.DataPosition + 16);
Magic Number,TagLib.Mpeg4,IsoVisualSampleEntry,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoVisualSampleEntry.cs,IsoVisualSampleEntry,The following statement contains a magic number: width = file.ReadBlock (2).ToUShort ();
Magic Number,TagLib.Mpeg4,IsoVisualSampleEntry,C:\repos\mono_taglib-sharp\src\TagLib\Mpeg4\Boxes\IsoVisualSampleEntry.cs,IsoVisualSampleEntry,The following statement contains a magic number: height = file.ReadBlock (2).ToUShort ();
Magic Number,TagLib.NonContainer,EndTag,C:\repos\mono_taglib-sharp\src\TagLib\NonContainer\EndTag.cs,AddTag,The following statement contains a magic number: if (type == TagTypes.Id3v1) {  				tag = new TagLib.Id3v1.Tag ();  			} else if (type == TagTypes.Id3v2) {  				Id3v2.Tag tag32 = new Id3v2.Tag ();  				tag32.Version = 4;  				tag32.Flags |= Id3v2.HeaderFlags.FooterPresent;  				tag = tag32;  			} else if (type == TagTypes.Ape) {  				tag = new TagLib.Ape.Tag ();  			}
Magic Number,TagLib.Ogg,Page,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Page.cs,Render,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				data [i + 22] = checksum [i];
Magic Number,TagLib.Ogg,Page,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Page.cs,Render,The following statement contains a magic number: for (int i = 0; i < 4; i++)  				data [i + 22] = checksum [i];
Magic Number,TagLib.Ogg,Page,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Page.cs,OverwriteSequenceNumbers,The following statement contains a magic number: while (position < file.Length - 27) {  				PageHeader header = new PageHeader (file' position);  				int size = (int) (header.Size + header.DataSize);  				  				if (shiftTable.ContainsKey (header.StreamSerialNumber)  					&& shiftTable [header.StreamSerialNumber] != 0) {  					file.Seek (position);  					ByteVector page_data = file.ReadBlock (size);  					  					ByteVector new_data = ByteVector.FromUInt (  						(uint)(header.PageSequenceNumber +  						shiftTable [header.StreamSerialNumber])'  						false);  					  					for (int i = 18; i < 22; i ++)  						page_data [i] = new_data [i - 18];  					for (int i = 22; i < 26; i++)  						page_data [i] = 0;  					  					new_data.Add (ByteVector.FromUInt (  						page_data.Checksum' false));  					file.Seek (position + 18);  					file.WriteBlock (new_data);  				}  				position += size;  			}
Magic Number,TagLib.Ogg,Page,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Page.cs,OverwriteSequenceNumbers,The following statement contains a magic number: while (position < file.Length - 27) {  				PageHeader header = new PageHeader (file' position);  				int size = (int) (header.Size + header.DataSize);  				  				if (shiftTable.ContainsKey (header.StreamSerialNumber)  					&& shiftTable [header.StreamSerialNumber] != 0) {  					file.Seek (position);  					ByteVector page_data = file.ReadBlock (size);  					  					ByteVector new_data = ByteVector.FromUInt (  						(uint)(header.PageSequenceNumber +  						shiftTable [header.StreamSerialNumber])'  						false);  					  					for (int i = 18; i < 22; i ++)  						page_data [i] = new_data [i - 18];  					for (int i = 22; i < 26; i++)  						page_data [i] = 0;  					  					new_data.Add (ByteVector.FromUInt (  						page_data.Checksum' false));  					file.Seek (position + 18);  					file.WriteBlock (new_data);  				}  				position += size;  			}
Magic Number,TagLib.Ogg,Page,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Page.cs,OverwriteSequenceNumbers,The following statement contains a magic number: while (position < file.Length - 27) {  				PageHeader header = new PageHeader (file' position);  				int size = (int) (header.Size + header.DataSize);  				  				if (shiftTable.ContainsKey (header.StreamSerialNumber)  					&& shiftTable [header.StreamSerialNumber] != 0) {  					file.Seek (position);  					ByteVector page_data = file.ReadBlock (size);  					  					ByteVector new_data = ByteVector.FromUInt (  						(uint)(header.PageSequenceNumber +  						shiftTable [header.StreamSerialNumber])'  						false);  					  					for (int i = 18; i < 22; i ++)  						page_data [i] = new_data [i - 18];  					for (int i = 22; i < 26; i++)  						page_data [i] = 0;  					  					new_data.Add (ByteVector.FromUInt (  						page_data.Checksum' false));  					file.Seek (position + 18);  					file.WriteBlock (new_data);  				}  				position += size;  			}
Magic Number,TagLib.Ogg,Page,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Page.cs,OverwriteSequenceNumbers,The following statement contains a magic number: while (position < file.Length - 27) {  				PageHeader header = new PageHeader (file' position);  				int size = (int) (header.Size + header.DataSize);  				  				if (shiftTable.ContainsKey (header.StreamSerialNumber)  					&& shiftTable [header.StreamSerialNumber] != 0) {  					file.Seek (position);  					ByteVector page_data = file.ReadBlock (size);  					  					ByteVector new_data = ByteVector.FromUInt (  						(uint)(header.PageSequenceNumber +  						shiftTable [header.StreamSerialNumber])'  						false);  					  					for (int i = 18; i < 22; i ++)  						page_data [i] = new_data [i - 18];  					for (int i = 22; i < 26; i++)  						page_data [i] = 0;  					  					new_data.Add (ByteVector.FromUInt (  						page_data.Checksum' false));  					file.Seek (position + 18);  					file.WriteBlock (new_data);  				}  				position += size;  			}
Magic Number,TagLib.Ogg,Page,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Page.cs,OverwriteSequenceNumbers,The following statement contains a magic number: while (position < file.Length - 27) {  				PageHeader header = new PageHeader (file' position);  				int size = (int) (header.Size + header.DataSize);  				  				if (shiftTable.ContainsKey (header.StreamSerialNumber)  					&& shiftTable [header.StreamSerialNumber] != 0) {  					file.Seek (position);  					ByteVector page_data = file.ReadBlock (size);  					  					ByteVector new_data = ByteVector.FromUInt (  						(uint)(header.PageSequenceNumber +  						shiftTable [header.StreamSerialNumber])'  						false);  					  					for (int i = 18; i < 22; i ++)  						page_data [i] = new_data [i - 18];  					for (int i = 22; i < 26; i++)  						page_data [i] = 0;  					  					new_data.Add (ByteVector.FromUInt (  						page_data.Checksum' false));  					file.Seek (position + 18);  					file.WriteBlock (new_data);  				}  				position += size;  			}
Magic Number,TagLib.Ogg,Page,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Page.cs,OverwriteSequenceNumbers,The following statement contains a magic number: while (position < file.Length - 27) {  				PageHeader header = new PageHeader (file' position);  				int size = (int) (header.Size + header.DataSize);  				  				if (shiftTable.ContainsKey (header.StreamSerialNumber)  					&& shiftTable [header.StreamSerialNumber] != 0) {  					file.Seek (position);  					ByteVector page_data = file.ReadBlock (size);  					  					ByteVector new_data = ByteVector.FromUInt (  						(uint)(header.PageSequenceNumber +  						shiftTable [header.StreamSerialNumber])'  						false);  					  					for (int i = 18; i < 22; i ++)  						page_data [i] = new_data [i - 18];  					for (int i = 22; i < 26; i++)  						page_data [i] = 0;  					  					new_data.Add (ByteVector.FromUInt (  						page_data.Checksum' false));  					file.Seek (position + 18);  					file.WriteBlock (new_data);  				}  				position += size;  			}
Magic Number,TagLib.Ogg,Page,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Page.cs,OverwriteSequenceNumbers,The following statement contains a magic number: while (position < file.Length - 27) {  				PageHeader header = new PageHeader (file' position);  				int size = (int) (header.Size + header.DataSize);  				  				if (shiftTable.ContainsKey (header.StreamSerialNumber)  					&& shiftTable [header.StreamSerialNumber] != 0) {  					file.Seek (position);  					ByteVector page_data = file.ReadBlock (size);  					  					ByteVector new_data = ByteVector.FromUInt (  						(uint)(header.PageSequenceNumber +  						shiftTable [header.StreamSerialNumber])'  						false);  					  					for (int i = 18; i < 22; i ++)  						page_data [i] = new_data [i - 18];  					for (int i = 22; i < 26; i++)  						page_data [i] = 0;  					  					new_data.Add (ByteVector.FromUInt (  						page_data.Checksum' false));  					file.Seek (position + 18);  					file.WriteBlock (new_data);  				}  				position += size;  			}
Magic Number,TagLib.Ogg,PageHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\PageHeader.cs,PageHeader,The following statement contains a magic number: if (position < 0 || position > file.Length - 27) 				throw new ArgumentOutOfRangeException ( 					"position");
Magic Number,TagLib.Ogg,PageHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\PageHeader.cs,PageHeader,The following statement contains a magic number: ByteVector data = file.ReadBlock (27);
Magic Number,TagLib.Ogg,PageHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\PageHeader.cs,PageHeader,The following statement contains a magic number: if (data.Count < 27 || !data.StartsWith ("OggS")) 				throw new CorruptFileException ( 					"Error reading page header");
Magic Number,TagLib.Ogg,PageHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\PageHeader.cs,PageHeader,The following statement contains a magic number: version = data [4];
Magic Number,TagLib.Ogg,PageHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\PageHeader.cs,PageHeader,The following statement contains a magic number: this.flags = (PageFlags) data [5];
Magic Number,TagLib.Ogg,PageHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\PageHeader.cs,PageHeader,The following statement contains a magic number: absolute_granular_position = data.Mid(6' 8).ToULong ( 				false);
Magic Number,TagLib.Ogg,PageHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\PageHeader.cs,PageHeader,The following statement contains a magic number: absolute_granular_position = data.Mid(6' 8).ToULong ( 				false);
Magic Number,TagLib.Ogg,PageHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\PageHeader.cs,PageHeader,The following statement contains a magic number: stream_serial_number = data.Mid(14' 4).ToUInt (false);
Magic Number,TagLib.Ogg,PageHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\PageHeader.cs,PageHeader,The following statement contains a magic number: stream_serial_number = data.Mid(14' 4).ToUInt (false);
Magic Number,TagLib.Ogg,PageHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\PageHeader.cs,PageHeader,The following statement contains a magic number: page_sequence_number = data.Mid(18' 4).ToUInt (false);
Magic Number,TagLib.Ogg,PageHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\PageHeader.cs,PageHeader,The following statement contains a magic number: page_sequence_number = data.Mid(18' 4).ToUInt (false);
Magic Number,TagLib.Ogg,PageHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\PageHeader.cs,PageHeader,The following statement contains a magic number: int page_segment_count = data [26];
Magic Number,TagLib.Ogg,PageHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\PageHeader.cs,PageHeader,The following statement contains a magic number: size = (uint)(27 + page_segment_count);
Magic Number,TagLib.Ogg,PageHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\PageHeader.cs,PageHeader,The following statement contains a magic number: for (int i = 0; i < page_segment_count; i++) { 				data_size += page_segments [i]; 				packet_size += page_segments [i]; 					 				if (page_segments [i] < 255) { 					packet_sizes.Add (packet_size); 					packet_size = 0; 				} 			}
Magic Number,TagLib.Ogg,PageHeader,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\PageHeader.cs,Render,The following statement contains a magic number: data.Add (new ByteVector (4' 0));
Magic Number,TagLib.Ogg,XiphComment,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\XiphComment.cs,Parse,The following statement contains a magic number: int vendor_length = (int) data.Mid (pos' 4)  				.ToUInt (false);
Magic Number,TagLib.Ogg,XiphComment,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\XiphComment.cs,Parse,The following statement contains a magic number: pos += 4;
Magic Number,TagLib.Ogg,XiphComment,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\XiphComment.cs,Parse,The following statement contains a magic number: int comment_fields = (int) data.Mid (pos' 4)  				.ToUInt (false);
Magic Number,TagLib.Ogg,XiphComment,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\XiphComment.cs,Parse,The following statement contains a magic number: pos += 4;
Magic Number,TagLib.Ogg,XiphComment,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\XiphComment.cs,Parse,The following statement contains a magic number: for(int i = 0; i < comment_fields; i++) {  				// Each comment field is in the format  				// "KEY=value" in a UTF8 string and has 4 bytes  				// before the text starts that gives the length.    				int comment_length = (int) data.Mid (pos' 4)  					.ToUInt (false);  				pos += 4;    				string comment = data.ToString (StringType.UTF8'  					pos' comment_length);  				pos += comment_length;    				int comment_separator_position = comment  					.IndexOf ('=');    				if (comment_separator_position < 0)  					continue;    				string key = comment.Substring (0'  					comment_separator_position)  					.ToUpper (  						CultureInfo.InvariantCulture);  				string value = comment.Substring (  					comment_separator_position + 1);  				string [] values;  				  				if (field_list.TryGetValue (key' out values)) {  					Array.Resize <string> (ref values'  						values.Length + 1);  					values [values.Length - 1] = value;  					field_list [key] = values;  				} else {  					SetField (key' value);  				}  			}
Magic Number,TagLib.Ogg,XiphComment,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\XiphComment.cs,Parse,The following statement contains a magic number: for(int i = 0; i < comment_fields; i++) {  				// Each comment field is in the format  				// "KEY=value" in a UTF8 string and has 4 bytes  				// before the text starts that gives the length.    				int comment_length = (int) data.Mid (pos' 4)  					.ToUInt (false);  				pos += 4;    				string comment = data.ToString (StringType.UTF8'  					pos' comment_length);  				pos += comment_length;    				int comment_separator_position = comment  					.IndexOf ('=');    				if (comment_separator_position < 0)  					continue;    				string key = comment.Substring (0'  					comment_separator_position)  					.ToUpper (  						CultureInfo.InvariantCulture);  				string value = comment.Substring (  					comment_separator_position + 1);  				string [] values;  				  				if (field_list.TryGetValue (key' out values)) {  					Array.Resize <string> (ref values'  						values.Length + 1);  					values [values.Length - 1] = value;  					field_list [key] = values;  				} else {  					SetField (key' value);  				}  			}
Magic Number,TagLib.Ogg.Codecs,Theora,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,ReadPacket,The following statement contains a magic number: if (comment_data == null) {  				if (type == 0x80)  					header = new HeaderPacket (packet);  				else if (type == 0x81)  					comment_data = packet.Mid (7);  				else  					return true;  			}
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: major_version = data [7];
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: minor_version = data [8];
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: revision_version = data [9];
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: width = (int) data.Mid (14' 3).ToUInt ();
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: width = (int) data.Mid (14' 3).ToUInt ();
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: height = (int) data.Mid (17' 3).ToUInt ();
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: height = (int) data.Mid (17' 3).ToUInt ();
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: fps_numerator = (int) data.Mid (22' 4).ToUInt ();
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: fps_numerator = (int) data.Mid (22' 4).ToUInt ();
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: fps_denominator = (int) data.Mid (26' 4).ToUInt ();
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: fps_denominator = (int) data.Mid (26' 4).ToUInt ();
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: ushort last_bits = data.Mid (40' 2).ToUShort ();
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: ushort last_bits = data.Mid (40' 2).ToUShort ();
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: keyframe_granule_shift = (last_bits >> 5) & 0x1F;
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: vorbis_version  = data.Mid(7' 4).ToUInt (false);
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: vorbis_version  = data.Mid(7' 4).ToUInt (false);
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: channels        = data [11];
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: sample_rate     = data.Mid(12' 4).ToUInt (false);
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: sample_rate     = data.Mid(12' 4).ToUInt (false);
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: bitrate_maximum = data.Mid(16' 4).ToUInt (false);
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: bitrate_maximum = data.Mid(16' 4).ToUInt (false);
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: bitrate_nominal = data.Mid(20' 4).ToUInt (false);
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: bitrate_nominal = data.Mid(20' 4).ToUInt (false);
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: bitrate_minimum = data.Mid(24' 4).ToUInt (false);
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: bitrate_minimum = data.Mid(24' 4).ToUInt (false);
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: opus_version  	  = data [8];
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: channel_count     = data [9];
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: pre_skip	  = data.Mid(10' 2).ToUInt (false);
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: pre_skip	  = data.Mid(10' 2).ToUInt (false);
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: input_sample_rate = data.Mid(12' 4).ToUInt (false);
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: input_sample_rate = data.Mid(12' 4).ToUInt (false);
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: output_gain	  = data.Mid(16' 2).ToUInt (false);
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: output_gain	  = data.Mid(16' 2).ToUInt (false);
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: channel_map       = data[18];
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: if(channel_map == 0) {  					stream_count = 1;  					two_channel_stream_count = channel_count - 1;    					channel_mappings = new uint[channel_count];  					channel_mappings[0] = 0;  					if(channel_count == 2) {  						channel_mappings[1] = 1;  					}  				} else {  					stream_count = data[19];  					two_channel_stream_count = data[20];    					channel_mappings = new uint[channel_count];  					for (int i = 0; i < channel_count; i++) {  						channel_mappings[i] = data[21 + i];  					}  				}
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: if(channel_map == 0) {  					stream_count = 1;  					two_channel_stream_count = channel_count - 1;    					channel_mappings = new uint[channel_count];  					channel_mappings[0] = 0;  					if(channel_count == 2) {  						channel_mappings[1] = 1;  					}  				} else {  					stream_count = data[19];  					two_channel_stream_count = data[20];    					channel_mappings = new uint[channel_count];  					for (int i = 0; i < channel_count; i++) {  						channel_mappings[i] = data[21 + i];  					}  				}
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: if(channel_map == 0) {  					stream_count = 1;  					two_channel_stream_count = channel_count - 1;    					channel_mappings = new uint[channel_count];  					channel_mappings[0] = 0;  					if(channel_count == 2) {  						channel_mappings[1] = 1;  					}  				} else {  					stream_count = data[19];  					two_channel_stream_count = data[20];    					channel_mappings = new uint[channel_count];  					for (int i = 0; i < channel_count; i++) {  						channel_mappings[i] = data[21 + i];  					}  				}
Magic Number,TagLib.Ogg.Codecs,HeaderPacket,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Theora.cs,HeaderPacket,The following statement contains a magic number: if(channel_map == 0) {  					stream_count = 1;  					two_channel_stream_count = channel_count - 1;    					channel_mappings = new uint[channel_count];  					channel_mappings[0] = 0;  					if(channel_count == 2) {  						channel_mappings[1] = 1;  					}  				} else {  					stream_count = data[19];  					two_channel_stream_count = data[20];    					channel_mappings = new uint[channel_count];  					for (int i = 0; i < channel_count; i++) {  						channel_mappings[i] = data[21 + i];  					}  				}
Magic Number,TagLib.Ogg.Codecs,Vorbis,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Vorbis.cs,ReadPacket,The following statement contains a magic number: if (comment_data == null) {  				if (type == 1)  					header = new HeaderPacket (packet);  				else if (type == 3)  					comment_data = packet.Mid (7);  				else  					return true;  			}
Magic Number,TagLib.Ogg.Codecs,Vorbis,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Vorbis.cs,ReadPacket,The following statement contains a magic number: if (comment_data == null) {  				if (type == 1)  					header = new HeaderPacket (packet);  				else if (type == 3)  					comment_data = packet.Mid (7);  				else  					return true;  			}
Magic Number,TagLib.Ogg.Codecs,Opus,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Opus.cs,GetDuration,The following statement contains a magic number: return TimeSpan.FromSeconds ((double)  					(lastGranularPosition -  						firstGranularPosition  						- 2 * header.pre_skip) /  					(double) 48000);
Magic Number,TagLib.Ogg.Codecs,Opus,C:\repos\mono_taglib-sharp\src\TagLib\Ogg\Codecs\Opus.cs,GetDuration,The following statement contains a magic number: return TimeSpan.FromSeconds ((double)  					(lastGranularPosition -  						firstGranularPosition  						- 2 * header.pre_skip) /  					(double) 48000);
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,ValidateHeader,The following statement contains a magic number: ByteVector data = ReadBlock (8);
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,ValidateHeader,The following statement contains a magic number: if (data.Count != 8)  				throw new CorruptFileException ("Unexpected end of header");
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,ReadChunkLength,The following statement contains a magic number: ByteVector data = ReadBlock (4);
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,ReadChunkLength,The following statement contains a magic number: if (data.Count != 4)  				throw new CorruptFileException ("Unexpected end of Chunk Length");
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,ReadChunkType,The following statement contains a magic number: ByteVector data = ReadBlock (4);
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,ReadChunkType,The following statement contains a magic number: if (data.Count != 4)  				throw new CorruptFileException ("Unexpected end of Chunk Type");
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,ReadCRC,The following statement contains a magic number: ByteVector data = ReadBlock (4);
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,ReadCRC,The following statement contains a magic number: if (data.Count != 4)  				throw new CorruptFileException ("Unexpected end of CRC");
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,ReadIHDRChunk,The following statement contains a magic number: if (data_length != 13)  				throw new CorruptFileException ("IHDR chunk data length must be 13");
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,ReadIHDRChunk,The following statement contains a magic number: uint width = data.Mid (0' 4).ToUInt (true);
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,ReadIHDRChunk,The following statement contains a magic number: uint height = data.Mid (4' 4).ToUInt (true);
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,ReadIHDRChunk,The following statement contains a magic number: uint height = data.Mid (4' 4).ToUInt (true);
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,ReadiTXtChunk,The following statement contains a magic number: if (data.StartsWith (XMP_CHUNK_HEADER)) {  				ImageTag.AddTag (new XmpTag (data.Mid (XMP_CHUNK_HEADER.Length).ToString (StringType.UTF8)' this));    				AddMetadataBlock (position - 8' data_length + 8 + 4);    				return;  			}
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,ReadiTXtChunk,The following statement contains a magic number: if (data.StartsWith (XMP_CHUNK_HEADER)) {  				ImageTag.AddTag (new XmpTag (data.Mid (XMP_CHUNK_HEADER.Length).ToString (StringType.UTF8)' this));    				AddMetadataBlock (position - 8' data_length + 8 + 4);    				return;  			}
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,ReadiTXtChunk,The following statement contains a magic number: if (data.StartsWith (XMP_CHUNK_HEADER)) {  				ImageTag.AddTag (new XmpTag (data.Mid (XMP_CHUNK_HEADER.Length).ToString (StringType.UTF8)' this));    				AddMetadataBlock (position - 8' data_length + 8 + 4);    				return;  			}
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,ReadiTXtChunk,The following statement contains a magic number: if (terminator_index + 2 >= data_length)  				throw new CorruptFileException ("Compression Flag and Compression Method byte expected");
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,ReadiTXtChunk,The following statement contains a magic number: byte compression_method = data[terminator_index + 2];
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,ReadiTXtChunk,The following statement contains a magic number: AddMetadataBlock (position - 8' data_length + 8 + 4);
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,ReadiTXtChunk,The following statement contains a magic number: AddMetadataBlock (position - 8' data_length + 8 + 4);
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,ReadiTXtChunk,The following statement contains a magic number: AddMetadataBlock (position - 8' data_length + 8 + 4);
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,ReadtEXtChunk,The following statement contains a magic number: AddMetadataBlock (position - 8' data_length + 8 + 4);
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,ReadtEXtChunk,The following statement contains a magic number: AddMetadataBlock (position - 8' data_length + 8 + 4);
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,ReadtEXtChunk,The following statement contains a magic number: AddMetadataBlock (position - 8' data_length + 8 + 4);
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,ReadzTXtChunk,The following statement contains a magic number: ByteVector plain_data = Decompress (compression_method' data.Mid (terminator_index + 2));
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,ReadzTXtChunk,The following statement contains a magic number: AddMetadataBlock (position - 8' data_length + 8 + 4);
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,ReadzTXtChunk,The following statement contains a magic number: AddMetadataBlock (position - 8' data_length + 8 + 4);
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,ReadzTXtChunk,The following statement contains a magic number: AddMetadataBlock (position - 8' data_length + 8 + 4);
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,SaveMetadata,The following statement contains a magic number: SaveMetadata (metadata_chunks' HEADER.Length + 13 + 4 + 4 + 4);
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,SaveMetadata,The following statement contains a magic number: SaveMetadata (metadata_chunks' HEADER.Length + 13 + 4 + 4 + 4);
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,SaveMetadata,The following statement contains a magic number: SaveMetadata (metadata_chunks' HEADER.Length + 13 + 4 + 4 + 4);
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,SaveMetadata,The following statement contains a magic number: SaveMetadata (metadata_chunks' HEADER.Length + 13 + 4 + 4 + 4);
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,ComputeCRC,The following statement contains a magic number: foreach (var data in datas) {    				foreach (byte b in data) {  					crc = crc_table[(crc ^ b) & 0xFF] ^ (crc >> 8);  				}  			}
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,BuildCRCTable,The following statement contains a magic number: crc_table = new uint [256];
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,BuildCRCTable,The following statement contains a magic number: for (int i = 0; i < 256; i++) {    				uint c = (uint) i;  				for (int k = 0; k < 8; k++) {  					if ((c & 0x00000001) != 0x00)  						c = polynom ^ (c >> 1);  					else  						c = c >> 1;  				}  				crc_table[i] = c;  			}
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,BuildCRCTable,The following statement contains a magic number: for (int i = 0; i < 256; i++) {    				uint c = (uint) i;  				for (int k = 0; k < 8; k++) {  					if ((c & 0x00000001) != 0x00)  						c = polynom ^ (c >> 1);  					else  						c = c >> 1;  				}  				crc_table[i] = c;  			}
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,Inflate,The following statement contains a magic number: using (MemoryStream out_stream = new System.IO.MemoryStream ())  			using (var input = new MemoryStream (data.Data)) {  				input.Seek (2' SeekOrigin.Begin); // First 2 bytes are properties deflate does not need (or handle)  				using (var zipstream = new DeflateStream (input' CompressionMode.Decompress)) {  					//zipstream.CopyTo (out_stream); Cleaner with .NET 4  					byte[] buffer = new byte[1024];  					int written_bytes;    					while ((written_bytes = zipstream.Read (buffer' 0' 1024)) > 0)  						out_stream.Write (buffer' 0' written_bytes);    					return new ByteVector (out_stream.ToArray());  				}  			}
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,Inflate,The following statement contains a magic number: using (MemoryStream out_stream = new System.IO.MemoryStream ())  			using (var input = new MemoryStream (data.Data)) {  				input.Seek (2' SeekOrigin.Begin); // First 2 bytes are properties deflate does not need (or handle)  				using (var zipstream = new DeflateStream (input' CompressionMode.Decompress)) {  					//zipstream.CopyTo (out_stream); Cleaner with .NET 4  					byte[] buffer = new byte[1024];  					int written_bytes;    					while ((written_bytes = zipstream.Read (buffer' 0' 1024)) > 0)  						out_stream.Write (buffer' 0' written_bytes);    					return new ByteVector (out_stream.ToArray());  				}  			}
Magic Number,TagLib.Png,File,C:\repos\mono_taglib-sharp\src\TagLib\Png\File.cs,Inflate,The following statement contains a magic number: using (MemoryStream out_stream = new System.IO.MemoryStream ())  			using (var input = new MemoryStream (data.Data)) {  				input.Seek (2' SeekOrigin.Begin); // First 2 bytes are properties deflate does not need (or handle)  				using (var zipstream = new DeflateStream (input' CompressionMode.Decompress)) {  					//zipstream.CopyTo (out_stream); Cleaner with .NET 4  					byte[] buffer = new byte[1024];  					int written_bytes;    					while ((written_bytes = zipstream.Read (buffer' 0' 1024)) > 0)  						out_stream.Write (buffer' 0' written_bytes);    					return new ByteVector (out_stream.ToArray());  				}  			}
Magic Number,TagLib.Riff,AviHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviHeaderList.cs,AviHeader,The following statement contains a magic number: if (offset + 40 > data.Count)  				throw new CorruptFileException (  					"Expected 40 bytes.");
Magic Number,TagLib.Riff,AviHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviHeaderList.cs,AviHeader,The following statement contains a magic number: microseconds_per_frame = data.Mid (offset'      4).ToUInt (false);
Magic Number,TagLib.Riff,AviHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviHeaderList.cs,AviHeader,The following statement contains a magic number: max_bytes_per_second   = data.Mid (offset +  4' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviHeaderList.cs,AviHeader,The following statement contains a magic number: max_bytes_per_second   = data.Mid (offset +  4' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviHeaderList.cs,AviHeader,The following statement contains a magic number: flags                  = data.Mid (offset + 12' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviHeaderList.cs,AviHeader,The following statement contains a magic number: flags                  = data.Mid (offset + 12' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviHeaderList.cs,AviHeader,The following statement contains a magic number: total_frames           = data.Mid (offset + 16' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviHeaderList.cs,AviHeader,The following statement contains a magic number: total_frames           = data.Mid (offset + 16' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviHeaderList.cs,AviHeader,The following statement contains a magic number: initial_frames         = data.Mid (offset + 20' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviHeaderList.cs,AviHeader,The following statement contains a magic number: initial_frames         = data.Mid (offset + 20' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviHeaderList.cs,AviHeader,The following statement contains a magic number: streams                = data.Mid (offset + 24' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviHeaderList.cs,AviHeader,The following statement contains a magic number: streams                = data.Mid (offset + 24' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviHeaderList.cs,AviHeader,The following statement contains a magic number: suggested_buffer_size  = data.Mid (offset + 28' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviHeaderList.cs,AviHeader,The following statement contains a magic number: suggested_buffer_size  = data.Mid (offset + 28' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviHeaderList.cs,AviHeader,The following statement contains a magic number: width                  = data.Mid (offset + 32' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviHeaderList.cs,AviHeader,The following statement contains a magic number: width                  = data.Mid (offset + 32' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviHeaderList.cs,AviHeader,The following statement contains a magic number: height                 = data.Mid (offset + 36' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviHeaderList.cs,AviHeader,The following statement contains a magic number: height                 = data.Mid (offset + 36' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviStream,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,ParseStreamList,The following statement contains a magic number: int pos = 4;
Magic Number,TagLib.Riff,AviStream,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,ParseStreamList,The following statement contains a magic number: while (pos + 8 < data.Count) {  				ByteVector id = data.Mid (pos' 4);  				int block_length = (int) data.Mid (pos + 4' 4)  					.ToUInt (false);  				  				if (id == "strh" && stream == null) {  					AviStreamHeader stream_header =  						new AviStreamHeader (data' pos + 8);  					if (stream_header.Type == "vids")  						stream = new AviVideoStream (  							stream_header);  					else if (stream_header.Type == "auds")  						stream = new AviAudioStream (  							stream_header);  				} else if (stream != null) {  					stream.ParseItem (id' data' pos + 8' block_length);  				}  				  				pos += block_length + 8;  			}
Magic Number,TagLib.Riff,AviStream,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,ParseStreamList,The following statement contains a magic number: while (pos + 8 < data.Count) {  				ByteVector id = data.Mid (pos' 4);  				int block_length = (int) data.Mid (pos + 4' 4)  					.ToUInt (false);  				  				if (id == "strh" && stream == null) {  					AviStreamHeader stream_header =  						new AviStreamHeader (data' pos + 8);  					if (stream_header.Type == "vids")  						stream = new AviVideoStream (  							stream_header);  					else if (stream_header.Type == "auds")  						stream = new AviAudioStream (  							stream_header);  				} else if (stream != null) {  					stream.ParseItem (id' data' pos + 8' block_length);  				}  				  				pos += block_length + 8;  			}
Magic Number,TagLib.Riff,AviStream,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,ParseStreamList,The following statement contains a magic number: while (pos + 8 < data.Count) {  				ByteVector id = data.Mid (pos' 4);  				int block_length = (int) data.Mid (pos + 4' 4)  					.ToUInt (false);  				  				if (id == "strh" && stream == null) {  					AviStreamHeader stream_header =  						new AviStreamHeader (data' pos + 8);  					if (stream_header.Type == "vids")  						stream = new AviVideoStream (  							stream_header);  					else if (stream_header.Type == "auds")  						stream = new AviAudioStream (  							stream_header);  				} else if (stream != null) {  					stream.ParseItem (id' data' pos + 8' block_length);  				}  				  				pos += block_length + 8;  			}
Magic Number,TagLib.Riff,AviStream,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,ParseStreamList,The following statement contains a magic number: while (pos + 8 < data.Count) {  				ByteVector id = data.Mid (pos' 4);  				int block_length = (int) data.Mid (pos + 4' 4)  					.ToUInt (false);  				  				if (id == "strh" && stream == null) {  					AviStreamHeader stream_header =  						new AviStreamHeader (data' pos + 8);  					if (stream_header.Type == "vids")  						stream = new AviVideoStream (  							stream_header);  					else if (stream_header.Type == "auds")  						stream = new AviAudioStream (  							stream_header);  				} else if (stream != null) {  					stream.ParseItem (id' data' pos + 8' block_length);  				}  				  				pos += block_length + 8;  			}
Magic Number,TagLib.Riff,AviStream,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,ParseStreamList,The following statement contains a magic number: while (pos + 8 < data.Count) {  				ByteVector id = data.Mid (pos' 4);  				int block_length = (int) data.Mid (pos + 4' 4)  					.ToUInt (false);  				  				if (id == "strh" && stream == null) {  					AviStreamHeader stream_header =  						new AviStreamHeader (data' pos + 8);  					if (stream_header.Type == "vids")  						stream = new AviVideoStream (  							stream_header);  					else if (stream_header.Type == "auds")  						stream = new AviAudioStream (  							stream_header);  				} else if (stream != null) {  					stream.ParseItem (id' data' pos + 8' block_length);  				}  				  				pos += block_length + 8;  			}
Magic Number,TagLib.Riff,AviStream,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,ParseStreamList,The following statement contains a magic number: while (pos + 8 < data.Count) {  				ByteVector id = data.Mid (pos' 4);  				int block_length = (int) data.Mid (pos + 4' 4)  					.ToUInt (false);  				  				if (id == "strh" && stream == null) {  					AviStreamHeader stream_header =  						new AviStreamHeader (data' pos + 8);  					if (stream_header.Type == "vids")  						stream = new AviVideoStream (  							stream_header);  					else if (stream_header.Type == "auds")  						stream = new AviAudioStream (  							stream_header);  				} else if (stream != null) {  					stream.ParseItem (id' data' pos + 8' block_length);  				}  				  				pos += block_length + 8;  			}
Magic Number,TagLib.Riff,AviStream,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,ParseStreamList,The following statement contains a magic number: while (pos + 8 < data.Count) {  				ByteVector id = data.Mid (pos' 4);  				int block_length = (int) data.Mid (pos + 4' 4)  					.ToUInt (false);  				  				if (id == "strh" && stream == null) {  					AviStreamHeader stream_header =  						new AviStreamHeader (data' pos + 8);  					if (stream_header.Type == "vids")  						stream = new AviVideoStream (  							stream_header);  					else if (stream_header.Type == "auds")  						stream = new AviAudioStream (  							stream_header);  				} else if (stream != null) {  					stream.ParseItem (id' data' pos + 8' block_length);  				}  				  				pos += block_length + 8;  			}
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: if (offset + 56 > data.Count)  				throw new CorruptFileException (  					"Expected 56 bytes.");
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: type                  = data.Mid (offset'      4);
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: handler               = data.Mid (offset +  4' 4);
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: handler               = data.Mid (offset +  4' 4);
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: flags                 = data.Mid (offset +  8' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: flags                 = data.Mid (offset +  8' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: priority              = data.Mid (offset + 12' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: priority              = data.Mid (offset + 12' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: initial_frames        = data.Mid (offset + 16' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: initial_frames        = data.Mid (offset + 16' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: scale                 = data.Mid (offset + 20' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: scale                 = data.Mid (offset + 20' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: rate                  = data.Mid (offset + 24' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: rate                  = data.Mid (offset + 24' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: start                 = data.Mid (offset + 28' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: start                 = data.Mid (offset + 28' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: length                = data.Mid (offset + 32' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: length                = data.Mid (offset + 32' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: suggested_buffer_size = data.Mid (offset + 36' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: suggested_buffer_size = data.Mid (offset + 36' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: quality               = data.Mid (offset + 40' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: quality               = data.Mid (offset + 40' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: sample_size           = data.Mid (offset + 44' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: sample_size           = data.Mid (offset + 44' 4).ToUInt (false);
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: left                  = data.Mid (offset + 48' 2).ToUShort (false);
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: left                  = data.Mid (offset + 48' 2).ToUShort (false);
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: top                   = data.Mid (offset + 50' 2).ToUShort (false);
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: top                   = data.Mid (offset + 50' 2).ToUShort (false);
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: right                 = data.Mid (offset + 52' 2).ToUShort (false);
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: right                 = data.Mid (offset + 52' 2).ToUShort (false);
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: bottom                = data.Mid (offset + 54' 2).ToUShort (false);
Magic Number,TagLib.Riff,AviStreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\AviStream.cs,AviStreamHeader,The following statement contains a magic number: bottom                = data.Mid (offset + 54' 2).ToUShort (false);
Magic Number,TagLib.Riff,BitmapInfoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\BitmapInfoHeader.cs,BitmapInfoHeader,The following statement contains a magic number: if (offset + 40 > data.Count)  				throw new CorruptFileException (  					"Expected 40 bytes.");
Magic Number,TagLib.Riff,BitmapInfoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\BitmapInfoHeader.cs,BitmapInfoHeader,The following statement contains a magic number: size               = data.Mid (offset +  0' 4).ToUInt (false);
Magic Number,TagLib.Riff,BitmapInfoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\BitmapInfoHeader.cs,BitmapInfoHeader,The following statement contains a magic number: width              = data.Mid (offset +  4' 4).ToUInt (false);
Magic Number,TagLib.Riff,BitmapInfoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\BitmapInfoHeader.cs,BitmapInfoHeader,The following statement contains a magic number: width              = data.Mid (offset +  4' 4).ToUInt (false);
Magic Number,TagLib.Riff,BitmapInfoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\BitmapInfoHeader.cs,BitmapInfoHeader,The following statement contains a magic number: height             = data.Mid (offset +  8' 4).ToUInt (false);
Magic Number,TagLib.Riff,BitmapInfoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\BitmapInfoHeader.cs,BitmapInfoHeader,The following statement contains a magic number: height             = data.Mid (offset +  8' 4).ToUInt (false);
Magic Number,TagLib.Riff,BitmapInfoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\BitmapInfoHeader.cs,BitmapInfoHeader,The following statement contains a magic number: planes             = data.Mid (offset + 12' 2).ToUShort (false);
Magic Number,TagLib.Riff,BitmapInfoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\BitmapInfoHeader.cs,BitmapInfoHeader,The following statement contains a magic number: planes             = data.Mid (offset + 12' 2).ToUShort (false);
Magic Number,TagLib.Riff,BitmapInfoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\BitmapInfoHeader.cs,BitmapInfoHeader,The following statement contains a magic number: bit_count          = data.Mid (offset + 14' 2).ToUShort (false);
Magic Number,TagLib.Riff,BitmapInfoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\BitmapInfoHeader.cs,BitmapInfoHeader,The following statement contains a magic number: bit_count          = data.Mid (offset + 14' 2).ToUShort (false);
Magic Number,TagLib.Riff,BitmapInfoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\BitmapInfoHeader.cs,BitmapInfoHeader,The following statement contains a magic number: compression_id     = data.Mid (offset + 16' 4);
Magic Number,TagLib.Riff,BitmapInfoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\BitmapInfoHeader.cs,BitmapInfoHeader,The following statement contains a magic number: compression_id     = data.Mid (offset + 16' 4);
Magic Number,TagLib.Riff,BitmapInfoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\BitmapInfoHeader.cs,BitmapInfoHeader,The following statement contains a magic number: size_of_image      = data.Mid (offset + 20' 4).ToUInt (false);
Magic Number,TagLib.Riff,BitmapInfoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\BitmapInfoHeader.cs,BitmapInfoHeader,The following statement contains a magic number: size_of_image      = data.Mid (offset + 20' 4).ToUInt (false);
Magic Number,TagLib.Riff,BitmapInfoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\BitmapInfoHeader.cs,BitmapInfoHeader,The following statement contains a magic number: x_pixels_per_meter = data.Mid (offset + 24' 4).ToUInt (false);
Magic Number,TagLib.Riff,BitmapInfoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\BitmapInfoHeader.cs,BitmapInfoHeader,The following statement contains a magic number: x_pixels_per_meter = data.Mid (offset + 24' 4).ToUInt (false);
Magic Number,TagLib.Riff,BitmapInfoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\BitmapInfoHeader.cs,BitmapInfoHeader,The following statement contains a magic number: y_pixels_per_meter = data.Mid (offset + 28' 4).ToUInt (false);
Magic Number,TagLib.Riff,BitmapInfoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\BitmapInfoHeader.cs,BitmapInfoHeader,The following statement contains a magic number: y_pixels_per_meter = data.Mid (offset + 28' 4).ToUInt (false);
Magic Number,TagLib.Riff,BitmapInfoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\BitmapInfoHeader.cs,BitmapInfoHeader,The following statement contains a magic number: colors_used        = data.Mid (offset + 32' 4).ToUInt (false);
Magic Number,TagLib.Riff,BitmapInfoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\BitmapInfoHeader.cs,BitmapInfoHeader,The following statement contains a magic number: colors_used        = data.Mid (offset + 32' 4).ToUInt (false);
Magic Number,TagLib.Riff,BitmapInfoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\BitmapInfoHeader.cs,BitmapInfoHeader,The following statement contains a magic number: colors_important   = data.Mid (offset + 36' 4).ToUInt (false);
Magic Number,TagLib.Riff,BitmapInfoHeader,C:\repos\mono_taglib-sharp\src\TagLib\Riff\BitmapInfoHeader.cs,BitmapInfoHeader,The following statement contains a magic number: colors_important   = data.Mid (offset + 36' 4).ToUInt (false);
Magic Number,TagLib.Riff,DivXTag,C:\repos\mono_taglib-sharp\src\TagLib\Riff\DivXTag.cs,Render,The following statement contains a magic number: data.Add (ByteVector.FromString (title'   StringType.Latin1).Resize (32' 0x20));
Magic Number,TagLib.Riff,DivXTag,C:\repos\mono_taglib-sharp\src\TagLib\Riff\DivXTag.cs,Render,The following statement contains a magic number: data.Add (ByteVector.FromString (artist'  StringType.Latin1).Resize (28' 0x20));
Magic Number,TagLib.Riff,DivXTag,C:\repos\mono_taglib-sharp\src\TagLib\Riff\DivXTag.cs,Render,The following statement contains a magic number: data.Add (ByteVector.FromString (year'    StringType.Latin1).Resize ( 4' 0x20));
Magic Number,TagLib.Riff,DivXTag,C:\repos\mono_taglib-sharp\src\TagLib\Riff\DivXTag.cs,Render,The following statement contains a magic number: data.Add (ByteVector.FromString (comment' StringType.Latin1).Resize (48' 0x20));
Magic Number,TagLib.Riff,DivXTag,C:\repos\mono_taglib-sharp\src\TagLib\Riff\DivXTag.cs,Render,The following statement contains a magic number: data.Add (ByteVector.FromString (genre'   StringType.Latin1).Resize ( 3' 0x20));
Magic Number,TagLib.Riff,DivXTag,C:\repos\mono_taglib-sharp\src\TagLib\Riff\DivXTag.cs,Parse,The following statement contains a magic number: title      = data.ToString (StringType.Latin1'  0' 32).Trim ();
Magic Number,TagLib.Riff,DivXTag,C:\repos\mono_taglib-sharp\src\TagLib\Riff\DivXTag.cs,Parse,The following statement contains a magic number: artist     = data.ToString (StringType.Latin1' 32' 28).Trim ();
Magic Number,TagLib.Riff,DivXTag,C:\repos\mono_taglib-sharp\src\TagLib\Riff\DivXTag.cs,Parse,The following statement contains a magic number: artist     = data.ToString (StringType.Latin1' 32' 28).Trim ();
Magic Number,TagLib.Riff,DivXTag,C:\repos\mono_taglib-sharp\src\TagLib\Riff\DivXTag.cs,Parse,The following statement contains a magic number: year       = data.ToString (StringType.Latin1' 60'  4).Trim ();
Magic Number,TagLib.Riff,DivXTag,C:\repos\mono_taglib-sharp\src\TagLib\Riff\DivXTag.cs,Parse,The following statement contains a magic number: year       = data.ToString (StringType.Latin1' 60'  4).Trim ();
Magic Number,TagLib.Riff,DivXTag,C:\repos\mono_taglib-sharp\src\TagLib\Riff\DivXTag.cs,Parse,The following statement contains a magic number: comment    = data.ToString (StringType.Latin1' 64' 48).Trim ();
Magic Number,TagLib.Riff,DivXTag,C:\repos\mono_taglib-sharp\src\TagLib\Riff\DivXTag.cs,Parse,The following statement contains a magic number: comment    = data.ToString (StringType.Latin1' 64' 48).Trim ();
Magic Number,TagLib.Riff,DivXTag,C:\repos\mono_taglib-sharp\src\TagLib\Riff\DivXTag.cs,Parse,The following statement contains a magic number: genre      = data.ToString (StringType.Latin1'112'  3).Trim ();
Magic Number,TagLib.Riff,DivXTag,C:\repos\mono_taglib-sharp\src\TagLib\Riff\DivXTag.cs,Parse,The following statement contains a magic number: genre      = data.ToString (StringType.Latin1'112'  3).Trim ();
Magic Number,TagLib.Riff,DivXTag,C:\repos\mono_taglib-sharp\src\TagLib\Riff\DivXTag.cs,Parse,The following statement contains a magic number: extra_data = data.Mid (115'  6);
Magic Number,TagLib.Riff,DivXTag,C:\repos\mono_taglib-sharp\src\TagLib\Riff\DivXTag.cs,Parse,The following statement contains a magic number: extra_data = data.Mid (115'  6);
Magic Number,TagLib.Riff,DivXTag,C:\repos\mono_taglib-sharp\src\TagLib\Riff\DivXTag.cs,Clear,The following statement contains a magic number: extra_data = new ByteVector (6);
Magic Number,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Save,The following statement contains a magic number: try {  				ByteVector data = new ByteVector ();  				  				// Enclose the Id3v2 tag in an "ID32" item and  				// embed it as the first tag.  				if (id32_tag != null) {  					ByteVector tag_data = id32_tag.Render ();  					if (tag_data.Count > 10) {  						if (tag_data.Count % 2 == 1)  							tag_data.Add (0);  						data.Add ("ID32");  						data.Add (ByteVector.FromUInt (  							(uint) tag_data.Count'  							false));  						data.Add (tag_data);  					}  				}  				  				// Embed "INFO" as the second tag.  				if (info_tag != null)  					data.Add (info_tag.RenderEnclosed ());    				// Embed "MID " as the third tag.  				if (mid_tag != null)  					data.Add (mid_tag.RenderEnclosed ());    				// Embed the DivX tag in "IDVX and embed it as  				// the fourth tag.  				if (divx_tag != null && !divx_tag.IsEmpty) {  					ByteVector tag_data = divx_tag.Render ();  					data.Add ("IDVX");  					data.Add (ByteVector.FromUInt (  						(uint) tag_data.Count' false));  					data.Add (tag_data);  				}  				  				// Read the file to determine the current RIFF  				// size and the area tagging does in.  				uint riff_size;  				long tag_start' tag_end;  				Read (false' ReadStyle.None' out riff_size'  					out tag_start' out tag_end);  				  				// If tagging info cannot be found' place it at  				// the end of the file.  				if (tag_start < 12 || tag_end < tag_start)  					tag_start = tag_end = Length;  				  				int length = (int)(tag_end - tag_start);  				  				// If the tag isn't at the end of the file'  				// try appending using padding to improve  				// write time now or for subsequent writes.  				if (tag_end != Length) {  					int padding_size = length - data.Count - 8;  					if (padding_size < 0)  						padding_size = 1024;  					  					  					data.Add ("JUNK");  					data.Add (ByteVector.FromUInt (  						(uint)padding_size' false));  					data.Add (new ByteVector (padding_size));  				}  				  				// Insert the tagging data.  				Insert (data' tag_start' length);  				  				// If the data size changed' and the tagging  				// data is within the RIFF portion of the file'  				// update the riff size.  				if (data.Count - length != 0 &&  					tag_start <= riff_size)  					Insert (ByteVector.FromUInt ((uint)  						(riff_size + data.Count - length)'  						false)' 4' 4);  				  				// Update the tag types.  				TagTypesOnDisk = TagTypes;  			} finally {  				Mode = AccessMode.Closed;  			}
Magic Number,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Save,The following statement contains a magic number: try {  				ByteVector data = new ByteVector ();  				  				// Enclose the Id3v2 tag in an "ID32" item and  				// embed it as the first tag.  				if (id32_tag != null) {  					ByteVector tag_data = id32_tag.Render ();  					if (tag_data.Count > 10) {  						if (tag_data.Count % 2 == 1)  							tag_data.Add (0);  						data.Add ("ID32");  						data.Add (ByteVector.FromUInt (  							(uint) tag_data.Count'  							false));  						data.Add (tag_data);  					}  				}  				  				// Embed "INFO" as the second tag.  				if (info_tag != null)  					data.Add (info_tag.RenderEnclosed ());    				// Embed "MID " as the third tag.  				if (mid_tag != null)  					data.Add (mid_tag.RenderEnclosed ());    				// Embed the DivX tag in "IDVX and embed it as  				// the fourth tag.  				if (divx_tag != null && !divx_tag.IsEmpty) {  					ByteVector tag_data = divx_tag.Render ();  					data.Add ("IDVX");  					data.Add (ByteVector.FromUInt (  						(uint) tag_data.Count' false));  					data.Add (tag_data);  				}  				  				// Read the file to determine the current RIFF  				// size and the area tagging does in.  				uint riff_size;  				long tag_start' tag_end;  				Read (false' ReadStyle.None' out riff_size'  					out tag_start' out tag_end);  				  				// If tagging info cannot be found' place it at  				// the end of the file.  				if (tag_start < 12 || tag_end < tag_start)  					tag_start = tag_end = Length;  				  				int length = (int)(tag_end - tag_start);  				  				// If the tag isn't at the end of the file'  				// try appending using padding to improve  				// write time now or for subsequent writes.  				if (tag_end != Length) {  					int padding_size = length - data.Count - 8;  					if (padding_size < 0)  						padding_size = 1024;  					  					  					data.Add ("JUNK");  					data.Add (ByteVector.FromUInt (  						(uint)padding_size' false));  					data.Add (new ByteVector (padding_size));  				}  				  				// Insert the tagging data.  				Insert (data' tag_start' length);  				  				// If the data size changed' and the tagging  				// data is within the RIFF portion of the file'  				// update the riff size.  				if (data.Count - length != 0 &&  					tag_start <= riff_size)  					Insert (ByteVector.FromUInt ((uint)  						(riff_size + data.Count - length)'  						false)' 4' 4);  				  				// Update the tag types.  				TagTypesOnDisk = TagTypes;  			} finally {  				Mode = AccessMode.Closed;  			}
Magic Number,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Save,The following statement contains a magic number: try {  				ByteVector data = new ByteVector ();  				  				// Enclose the Id3v2 tag in an "ID32" item and  				// embed it as the first tag.  				if (id32_tag != null) {  					ByteVector tag_data = id32_tag.Render ();  					if (tag_data.Count > 10) {  						if (tag_data.Count % 2 == 1)  							tag_data.Add (0);  						data.Add ("ID32");  						data.Add (ByteVector.FromUInt (  							(uint) tag_data.Count'  							false));  						data.Add (tag_data);  					}  				}  				  				// Embed "INFO" as the second tag.  				if (info_tag != null)  					data.Add (info_tag.RenderEnclosed ());    				// Embed "MID " as the third tag.  				if (mid_tag != null)  					data.Add (mid_tag.RenderEnclosed ());    				// Embed the DivX tag in "IDVX and embed it as  				// the fourth tag.  				if (divx_tag != null && !divx_tag.IsEmpty) {  					ByteVector tag_data = divx_tag.Render ();  					data.Add ("IDVX");  					data.Add (ByteVector.FromUInt (  						(uint) tag_data.Count' false));  					data.Add (tag_data);  				}  				  				// Read the file to determine the current RIFF  				// size and the area tagging does in.  				uint riff_size;  				long tag_start' tag_end;  				Read (false' ReadStyle.None' out riff_size'  					out tag_start' out tag_end);  				  				// If tagging info cannot be found' place it at  				// the end of the file.  				if (tag_start < 12 || tag_end < tag_start)  					tag_start = tag_end = Length;  				  				int length = (int)(tag_end - tag_start);  				  				// If the tag isn't at the end of the file'  				// try appending using padding to improve  				// write time now or for subsequent writes.  				if (tag_end != Length) {  					int padding_size = length - data.Count - 8;  					if (padding_size < 0)  						padding_size = 1024;  					  					  					data.Add ("JUNK");  					data.Add (ByteVector.FromUInt (  						(uint)padding_size' false));  					data.Add (new ByteVector (padding_size));  				}  				  				// Insert the tagging data.  				Insert (data' tag_start' length);  				  				// If the data size changed' and the tagging  				// data is within the RIFF portion of the file'  				// update the riff size.  				if (data.Count - length != 0 &&  					tag_start <= riff_size)  					Insert (ByteVector.FromUInt ((uint)  						(riff_size + data.Count - length)'  						false)' 4' 4);  				  				// Update the tag types.  				TagTypesOnDisk = TagTypes;  			} finally {  				Mode = AccessMode.Closed;  			}
Magic Number,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Save,The following statement contains a magic number: try {  				ByteVector data = new ByteVector ();  				  				// Enclose the Id3v2 tag in an "ID32" item and  				// embed it as the first tag.  				if (id32_tag != null) {  					ByteVector tag_data = id32_tag.Render ();  					if (tag_data.Count > 10) {  						if (tag_data.Count % 2 == 1)  							tag_data.Add (0);  						data.Add ("ID32");  						data.Add (ByteVector.FromUInt (  							(uint) tag_data.Count'  							false));  						data.Add (tag_data);  					}  				}  				  				// Embed "INFO" as the second tag.  				if (info_tag != null)  					data.Add (info_tag.RenderEnclosed ());    				// Embed "MID " as the third tag.  				if (mid_tag != null)  					data.Add (mid_tag.RenderEnclosed ());    				// Embed the DivX tag in "IDVX and embed it as  				// the fourth tag.  				if (divx_tag != null && !divx_tag.IsEmpty) {  					ByteVector tag_data = divx_tag.Render ();  					data.Add ("IDVX");  					data.Add (ByteVector.FromUInt (  						(uint) tag_data.Count' false));  					data.Add (tag_data);  				}  				  				// Read the file to determine the current RIFF  				// size and the area tagging does in.  				uint riff_size;  				long tag_start' tag_end;  				Read (false' ReadStyle.None' out riff_size'  					out tag_start' out tag_end);  				  				// If tagging info cannot be found' place it at  				// the end of the file.  				if (tag_start < 12 || tag_end < tag_start)  					tag_start = tag_end = Length;  				  				int length = (int)(tag_end - tag_start);  				  				// If the tag isn't at the end of the file'  				// try appending using padding to improve  				// write time now or for subsequent writes.  				if (tag_end != Length) {  					int padding_size = length - data.Count - 8;  					if (padding_size < 0)  						padding_size = 1024;  					  					  					data.Add ("JUNK");  					data.Add (ByteVector.FromUInt (  						(uint)padding_size' false));  					data.Add (new ByteVector (padding_size));  				}  				  				// Insert the tagging data.  				Insert (data' tag_start' length);  				  				// If the data size changed' and the tagging  				// data is within the RIFF portion of the file'  				// update the riff size.  				if (data.Count - length != 0 &&  					tag_start <= riff_size)  					Insert (ByteVector.FromUInt ((uint)  						(riff_size + data.Count - length)'  						false)' 4' 4);  				  				// Update the tag types.  				TagTypesOnDisk = TagTypes;  			} finally {  				Mode = AccessMode.Closed;  			}
Magic Number,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Save,The following statement contains a magic number: try {  				ByteVector data = new ByteVector ();  				  				// Enclose the Id3v2 tag in an "ID32" item and  				// embed it as the first tag.  				if (id32_tag != null) {  					ByteVector tag_data = id32_tag.Render ();  					if (tag_data.Count > 10) {  						if (tag_data.Count % 2 == 1)  							tag_data.Add (0);  						data.Add ("ID32");  						data.Add (ByteVector.FromUInt (  							(uint) tag_data.Count'  							false));  						data.Add (tag_data);  					}  				}  				  				// Embed "INFO" as the second tag.  				if (info_tag != null)  					data.Add (info_tag.RenderEnclosed ());    				// Embed "MID " as the third tag.  				if (mid_tag != null)  					data.Add (mid_tag.RenderEnclosed ());    				// Embed the DivX tag in "IDVX and embed it as  				// the fourth tag.  				if (divx_tag != null && !divx_tag.IsEmpty) {  					ByteVector tag_data = divx_tag.Render ();  					data.Add ("IDVX");  					data.Add (ByteVector.FromUInt (  						(uint) tag_data.Count' false));  					data.Add (tag_data);  				}  				  				// Read the file to determine the current RIFF  				// size and the area tagging does in.  				uint riff_size;  				long tag_start' tag_end;  				Read (false' ReadStyle.None' out riff_size'  					out tag_start' out tag_end);  				  				// If tagging info cannot be found' place it at  				// the end of the file.  				if (tag_start < 12 || tag_end < tag_start)  					tag_start = tag_end = Length;  				  				int length = (int)(tag_end - tag_start);  				  				// If the tag isn't at the end of the file'  				// try appending using padding to improve  				// write time now or for subsequent writes.  				if (tag_end != Length) {  					int padding_size = length - data.Count - 8;  					if (padding_size < 0)  						padding_size = 1024;  					  					  					data.Add ("JUNK");  					data.Add (ByteVector.FromUInt (  						(uint)padding_size' false));  					data.Add (new ByteVector (padding_size));  				}  				  				// Insert the tagging data.  				Insert (data' tag_start' length);  				  				// If the data size changed' and the tagging  				// data is within the RIFF portion of the file'  				// update the riff size.  				if (data.Count - length != 0 &&  					tag_start <= riff_size)  					Insert (ByteVector.FromUInt ((uint)  						(riff_size + data.Count - length)'  						false)' 4' 4);  				  				// Update the tag types.  				TagTypesOnDisk = TagTypes;  			} finally {  				Mode = AccessMode.Closed;  			}
Magic Number,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Save,The following statement contains a magic number: try {  				ByteVector data = new ByteVector ();  				  				// Enclose the Id3v2 tag in an "ID32" item and  				// embed it as the first tag.  				if (id32_tag != null) {  					ByteVector tag_data = id32_tag.Render ();  					if (tag_data.Count > 10) {  						if (tag_data.Count % 2 == 1)  							tag_data.Add (0);  						data.Add ("ID32");  						data.Add (ByteVector.FromUInt (  							(uint) tag_data.Count'  							false));  						data.Add (tag_data);  					}  				}  				  				// Embed "INFO" as the second tag.  				if (info_tag != null)  					data.Add (info_tag.RenderEnclosed ());    				// Embed "MID " as the third tag.  				if (mid_tag != null)  					data.Add (mid_tag.RenderEnclosed ());    				// Embed the DivX tag in "IDVX and embed it as  				// the fourth tag.  				if (divx_tag != null && !divx_tag.IsEmpty) {  					ByteVector tag_data = divx_tag.Render ();  					data.Add ("IDVX");  					data.Add (ByteVector.FromUInt (  						(uint) tag_data.Count' false));  					data.Add (tag_data);  				}  				  				// Read the file to determine the current RIFF  				// size and the area tagging does in.  				uint riff_size;  				long tag_start' tag_end;  				Read (false' ReadStyle.None' out riff_size'  					out tag_start' out tag_end);  				  				// If tagging info cannot be found' place it at  				// the end of the file.  				if (tag_start < 12 || tag_end < tag_start)  					tag_start = tag_end = Length;  				  				int length = (int)(tag_end - tag_start);  				  				// If the tag isn't at the end of the file'  				// try appending using padding to improve  				// write time now or for subsequent writes.  				if (tag_end != Length) {  					int padding_size = length - data.Count - 8;  					if (padding_size < 0)  						padding_size = 1024;  					  					  					data.Add ("JUNK");  					data.Add (ByteVector.FromUInt (  						(uint)padding_size' false));  					data.Add (new ByteVector (padding_size));  				}  				  				// Insert the tagging data.  				Insert (data' tag_start' length);  				  				// If the data size changed' and the tagging  				// data is within the RIFF portion of the file'  				// update the riff size.  				if (data.Count - length != 0 &&  					tag_start <= riff_size)  					Insert (ByteVector.FromUInt ((uint)  						(riff_size + data.Count - length)'  						false)' 4' 4);  				  				// Update the tag types.  				TagTypesOnDisk = TagTypes;  			} finally {  				Mode = AccessMode.Closed;  			}
Magic Number,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Save,The following statement contains a magic number: try {  				ByteVector data = new ByteVector ();  				  				// Enclose the Id3v2 tag in an "ID32" item and  				// embed it as the first tag.  				if (id32_tag != null) {  					ByteVector tag_data = id32_tag.Render ();  					if (tag_data.Count > 10) {  						if (tag_data.Count % 2 == 1)  							tag_data.Add (0);  						data.Add ("ID32");  						data.Add (ByteVector.FromUInt (  							(uint) tag_data.Count'  							false));  						data.Add (tag_data);  					}  				}  				  				// Embed "INFO" as the second tag.  				if (info_tag != null)  					data.Add (info_tag.RenderEnclosed ());    				// Embed "MID " as the third tag.  				if (mid_tag != null)  					data.Add (mid_tag.RenderEnclosed ());    				// Embed the DivX tag in "IDVX and embed it as  				// the fourth tag.  				if (divx_tag != null && !divx_tag.IsEmpty) {  					ByteVector tag_data = divx_tag.Render ();  					data.Add ("IDVX");  					data.Add (ByteVector.FromUInt (  						(uint) tag_data.Count' false));  					data.Add (tag_data);  				}  				  				// Read the file to determine the current RIFF  				// size and the area tagging does in.  				uint riff_size;  				long tag_start' tag_end;  				Read (false' ReadStyle.None' out riff_size'  					out tag_start' out tag_end);  				  				// If tagging info cannot be found' place it at  				// the end of the file.  				if (tag_start < 12 || tag_end < tag_start)  					tag_start = tag_end = Length;  				  				int length = (int)(tag_end - tag_start);  				  				// If the tag isn't at the end of the file'  				// try appending using padding to improve  				// write time now or for subsequent writes.  				if (tag_end != Length) {  					int padding_size = length - data.Count - 8;  					if (padding_size < 0)  						padding_size = 1024;  					  					  					data.Add ("JUNK");  					data.Add (ByteVector.FromUInt (  						(uint)padding_size' false));  					data.Add (new ByteVector (padding_size));  				}  				  				// Insert the tagging data.  				Insert (data' tag_start' length);  				  				// If the data size changed' and the tagging  				// data is within the RIFF portion of the file'  				// update the riff size.  				if (data.Count - length != 0 &&  					tag_start <= riff_size)  					Insert (ByteVector.FromUInt ((uint)  						(riff_size + data.Count - length)'  						false)' 4' 4);  				  				// Update the tag types.  				TagTypesOnDisk = TagTypes;  			} finally {  				Mode = AccessMode.Closed;  			}
Magic Number,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,GetTag,The following statement contains a magic number: switch (type)  			{  			case TagTypes.Id3v2:  				if (id32_tag == null && create) {  					id32_tag = new Id3v2.Tag ();  					id32_tag.Version = 4;  					id32_tag.Flags |= Id3v2.HeaderFlags  						.FooterPresent;  					this.tag.CopyTo (id32_tag' true);  				}  				  				tag = id32_tag;  				break;  				  			case TagTypes.RiffInfo:  				if (info_tag == null && create) {  					info_tag = new InfoTag ();  					this.tag.CopyTo (info_tag' true);  				}  				  				tag = info_tag;  				break;  				  			case TagTypes.MovieId:  				if (mid_tag == null && create) {  					mid_tag = new MovieIdTag ();  					this.tag.CopyTo (mid_tag' true);  				}  				  				tag = mid_tag;  				break;  				  			case TagTypes.DivX:  				if (divx_tag == null && create) {  					divx_tag = new DivXTag ();  					this.tag.CopyTo (divx_tag' true);  				}  				  				tag = divx_tag;  				break;  			}
Magic Number,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Read,The following statement contains a magic number: if (ReadBlock (4) != FileIdentifier)  				throw new CorruptFileException (  					"File does not begin with RIFF identifier");
Magic Number,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Read,The following statement contains a magic number: riff_size = ReadBlock (4).ToUInt (false);
Magic Number,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Read,The following statement contains a magic number: ByteVector stream_format = ReadBlock (4);
Magic Number,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Read,The following statement contains a magic number: long position = 12;
Magic Number,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Read,The following statement contains a magic number: do {  				bool tag_found = false;  				  				Seek (position);  				string fourcc = ReadBlock (4).ToString (StringType.UTF8);  				size = ReadBlock (4).ToUInt (false);  				  				switch (fourcc)  				{  				  				// "fmt " is used by Wave files to hold the  				// WaveFormatEx structure.  				case "fmt ":  					if (style == ReadStyle.None ||  						stream_format != "WAVE")  						break;  					  					Seek (position + 8);  					codecs = new ICodec [] {  						new WaveFormatEx (ReadBlock (18)' 0)  					};  					break;  				  				// "data" contains the audio data for wave  				// files. It's contents represent the invariant  				// portion of the file and is used to determine  				// the duration of a file. It should always  				// appear after "fmt ".  				case "data":  					if (stream_format != "WAVE")  						break;  					  					InvariantStartPosition = position;  					InvariantEndPosition = position + size;  					  					if (style == ReadStyle.None ||  						codecs.Length != 1 ||  						!(codecs [0] is WaveFormatEx))  						break;  					  					duration += TimeSpan.FromSeconds (  						(double) size / (double)  						((WaveFormatEx) codecs [0])  							.AverageBytesPerSecond);  					  					break;  				  				// Lists are used to store a variety of data  				// collections. Read the type and act on it.  				case "LIST":  				{  					switch (ReadBlock (4).ToString (StringType.UTF8))  					{  					  					// "hdlr" is used by AVI files to hold  					// a media header and BitmapInfoHeader  					// and WaveFormatEx structures.  					case "hdrl":  						if (style == ReadStyle.None ||  							stream_format != "AVI ")  							continue;  						  						AviHeaderList header_list =  							new AviHeaderList (this'  								position + 12'  								(int) (size - 4));  						duration = header_list.Header.Duration;  						codecs = header_list.Codecs;  						break;  					  					// "INFO" is a tagging format handled by  					// the InfoTag class.  					case "INFO":  						if (read_tags && info_tag == null)  							info_tag = new InfoTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "MID " is a tagging format handled by  					// the MovieIdTag class.  					case "MID ":  						if (read_tags && mid_tag == null)  							mid_tag = new MovieIdTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "movi" contains the media data for  					// and AVI and its contents represent  					// the invariant portion of the file.  					case "movi":  						if (stream_format != "AVI ")  							break;  						  						InvariantStartPosition = position;  						InvariantEndPosition = position + size;  						break;  					}  					break;  				}  				  				// "ID32" is a custom box for this format that  				// contains an ID3v2 tag.  				case "ID32":  					if (read_tags && id32_tag == null)  						id32_tag = new Id3v2.Tag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "IDVX" is used by DivX and holds an ID3v1-  				// style tag.  				case "IDVX":  					if (read_tags && divx_tag == null)  						divx_tag = new DivXTag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "JUNK" is a padding element that could be  				// associated with tag data.  				case "JUNK":  					if (tag_end == position)  						tag_end = position + 8 + size;  					break;  				}  				  				// Determine the region of the file that  				// contains tags.  				if (tag_found) {  					if (tag_start == -1) {  						tag_start = position;  						tag_end = position + 8 + size;  					} else if (tag_end == position) {  						tag_end = position + 8 + size;  					}  				}  				  				// Move to the next item.  			} while ((position += 8 + size) + 8 < length);
Magic Number,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Read,The following statement contains a magic number: do {  				bool tag_found = false;  				  				Seek (position);  				string fourcc = ReadBlock (4).ToString (StringType.UTF8);  				size = ReadBlock (4).ToUInt (false);  				  				switch (fourcc)  				{  				  				// "fmt " is used by Wave files to hold the  				// WaveFormatEx structure.  				case "fmt ":  					if (style == ReadStyle.None ||  						stream_format != "WAVE")  						break;  					  					Seek (position + 8);  					codecs = new ICodec [] {  						new WaveFormatEx (ReadBlock (18)' 0)  					};  					break;  				  				// "data" contains the audio data for wave  				// files. It's contents represent the invariant  				// portion of the file and is used to determine  				// the duration of a file. It should always  				// appear after "fmt ".  				case "data":  					if (stream_format != "WAVE")  						break;  					  					InvariantStartPosition = position;  					InvariantEndPosition = position + size;  					  					if (style == ReadStyle.None ||  						codecs.Length != 1 ||  						!(codecs [0] is WaveFormatEx))  						break;  					  					duration += TimeSpan.FromSeconds (  						(double) size / (double)  						((WaveFormatEx) codecs [0])  							.AverageBytesPerSecond);  					  					break;  				  				// Lists are used to store a variety of data  				// collections. Read the type and act on it.  				case "LIST":  				{  					switch (ReadBlock (4).ToString (StringType.UTF8))  					{  					  					// "hdlr" is used by AVI files to hold  					// a media header and BitmapInfoHeader  					// and WaveFormatEx structures.  					case "hdrl":  						if (style == ReadStyle.None ||  							stream_format != "AVI ")  							continue;  						  						AviHeaderList header_list =  							new AviHeaderList (this'  								position + 12'  								(int) (size - 4));  						duration = header_list.Header.Duration;  						codecs = header_list.Codecs;  						break;  					  					// "INFO" is a tagging format handled by  					// the InfoTag class.  					case "INFO":  						if (read_tags && info_tag == null)  							info_tag = new InfoTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "MID " is a tagging format handled by  					// the MovieIdTag class.  					case "MID ":  						if (read_tags && mid_tag == null)  							mid_tag = new MovieIdTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "movi" contains the media data for  					// and AVI and its contents represent  					// the invariant portion of the file.  					case "movi":  						if (stream_format != "AVI ")  							break;  						  						InvariantStartPosition = position;  						InvariantEndPosition = position + size;  						break;  					}  					break;  				}  				  				// "ID32" is a custom box for this format that  				// contains an ID3v2 tag.  				case "ID32":  					if (read_tags && id32_tag == null)  						id32_tag = new Id3v2.Tag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "IDVX" is used by DivX and holds an ID3v1-  				// style tag.  				case "IDVX":  					if (read_tags && divx_tag == null)  						divx_tag = new DivXTag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "JUNK" is a padding element that could be  				// associated with tag data.  				case "JUNK":  					if (tag_end == position)  						tag_end = position + 8 + size;  					break;  				}  				  				// Determine the region of the file that  				// contains tags.  				if (tag_found) {  					if (tag_start == -1) {  						tag_start = position;  						tag_end = position + 8 + size;  					} else if (tag_end == position) {  						tag_end = position + 8 + size;  					}  				}  				  				// Move to the next item.  			} while ((position += 8 + size) + 8 < length);
Magic Number,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Read,The following statement contains a magic number: do {  				bool tag_found = false;  				  				Seek (position);  				string fourcc = ReadBlock (4).ToString (StringType.UTF8);  				size = ReadBlock (4).ToUInt (false);  				  				switch (fourcc)  				{  				  				// "fmt " is used by Wave files to hold the  				// WaveFormatEx structure.  				case "fmt ":  					if (style == ReadStyle.None ||  						stream_format != "WAVE")  						break;  					  					Seek (position + 8);  					codecs = new ICodec [] {  						new WaveFormatEx (ReadBlock (18)' 0)  					};  					break;  				  				// "data" contains the audio data for wave  				// files. It's contents represent the invariant  				// portion of the file and is used to determine  				// the duration of a file. It should always  				// appear after "fmt ".  				case "data":  					if (stream_format != "WAVE")  						break;  					  					InvariantStartPosition = position;  					InvariantEndPosition = position + size;  					  					if (style == ReadStyle.None ||  						codecs.Length != 1 ||  						!(codecs [0] is WaveFormatEx))  						break;  					  					duration += TimeSpan.FromSeconds (  						(double) size / (double)  						((WaveFormatEx) codecs [0])  							.AverageBytesPerSecond);  					  					break;  				  				// Lists are used to store a variety of data  				// collections. Read the type and act on it.  				case "LIST":  				{  					switch (ReadBlock (4).ToString (StringType.UTF8))  					{  					  					// "hdlr" is used by AVI files to hold  					// a media header and BitmapInfoHeader  					// and WaveFormatEx structures.  					case "hdrl":  						if (style == ReadStyle.None ||  							stream_format != "AVI ")  							continue;  						  						AviHeaderList header_list =  							new AviHeaderList (this'  								position + 12'  								(int) (size - 4));  						duration = header_list.Header.Duration;  						codecs = header_list.Codecs;  						break;  					  					// "INFO" is a tagging format handled by  					// the InfoTag class.  					case "INFO":  						if (read_tags && info_tag == null)  							info_tag = new InfoTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "MID " is a tagging format handled by  					// the MovieIdTag class.  					case "MID ":  						if (read_tags && mid_tag == null)  							mid_tag = new MovieIdTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "movi" contains the media data for  					// and AVI and its contents represent  					// the invariant portion of the file.  					case "movi":  						if (stream_format != "AVI ")  							break;  						  						InvariantStartPosition = position;  						InvariantEndPosition = position + size;  						break;  					}  					break;  				}  				  				// "ID32" is a custom box for this format that  				// contains an ID3v2 tag.  				case "ID32":  					if (read_tags && id32_tag == null)  						id32_tag = new Id3v2.Tag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "IDVX" is used by DivX and holds an ID3v1-  				// style tag.  				case "IDVX":  					if (read_tags && divx_tag == null)  						divx_tag = new DivXTag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "JUNK" is a padding element that could be  				// associated with tag data.  				case "JUNK":  					if (tag_end == position)  						tag_end = position + 8 + size;  					break;  				}  				  				// Determine the region of the file that  				// contains tags.  				if (tag_found) {  					if (tag_start == -1) {  						tag_start = position;  						tag_end = position + 8 + size;  					} else if (tag_end == position) {  						tag_end = position + 8 + size;  					}  				}  				  				// Move to the next item.  			} while ((position += 8 + size) + 8 < length);
Magic Number,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Read,The following statement contains a magic number: do {  				bool tag_found = false;  				  				Seek (position);  				string fourcc = ReadBlock (4).ToString (StringType.UTF8);  				size = ReadBlock (4).ToUInt (false);  				  				switch (fourcc)  				{  				  				// "fmt " is used by Wave files to hold the  				// WaveFormatEx structure.  				case "fmt ":  					if (style == ReadStyle.None ||  						stream_format != "WAVE")  						break;  					  					Seek (position + 8);  					codecs = new ICodec [] {  						new WaveFormatEx (ReadBlock (18)' 0)  					};  					break;  				  				// "data" contains the audio data for wave  				// files. It's contents represent the invariant  				// portion of the file and is used to determine  				// the duration of a file. It should always  				// appear after "fmt ".  				case "data":  					if (stream_format != "WAVE")  						break;  					  					InvariantStartPosition = position;  					InvariantEndPosition = position + size;  					  					if (style == ReadStyle.None ||  						codecs.Length != 1 ||  						!(codecs [0] is WaveFormatEx))  						break;  					  					duration += TimeSpan.FromSeconds (  						(double) size / (double)  						((WaveFormatEx) codecs [0])  							.AverageBytesPerSecond);  					  					break;  				  				// Lists are used to store a variety of data  				// collections. Read the type and act on it.  				case "LIST":  				{  					switch (ReadBlock (4).ToString (StringType.UTF8))  					{  					  					// "hdlr" is used by AVI files to hold  					// a media header and BitmapInfoHeader  					// and WaveFormatEx structures.  					case "hdrl":  						if (style == ReadStyle.None ||  							stream_format != "AVI ")  							continue;  						  						AviHeaderList header_list =  							new AviHeaderList (this'  								position + 12'  								(int) (size - 4));  						duration = header_list.Header.Duration;  						codecs = header_list.Codecs;  						break;  					  					// "INFO" is a tagging format handled by  					// the InfoTag class.  					case "INFO":  						if (read_tags && info_tag == null)  							info_tag = new InfoTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "MID " is a tagging format handled by  					// the MovieIdTag class.  					case "MID ":  						if (read_tags && mid_tag == null)  							mid_tag = new MovieIdTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "movi" contains the media data for  					// and AVI and its contents represent  					// the invariant portion of the file.  					case "movi":  						if (stream_format != "AVI ")  							break;  						  						InvariantStartPosition = position;  						InvariantEndPosition = position + size;  						break;  					}  					break;  				}  				  				// "ID32" is a custom box for this format that  				// contains an ID3v2 tag.  				case "ID32":  					if (read_tags && id32_tag == null)  						id32_tag = new Id3v2.Tag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "IDVX" is used by DivX and holds an ID3v1-  				// style tag.  				case "IDVX":  					if (read_tags && divx_tag == null)  						divx_tag = new DivXTag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "JUNK" is a padding element that could be  				// associated with tag data.  				case "JUNK":  					if (tag_end == position)  						tag_end = position + 8 + size;  					break;  				}  				  				// Determine the region of the file that  				// contains tags.  				if (tag_found) {  					if (tag_start == -1) {  						tag_start = position;  						tag_end = position + 8 + size;  					} else if (tag_end == position) {  						tag_end = position + 8 + size;  					}  				}  				  				// Move to the next item.  			} while ((position += 8 + size) + 8 < length);
Magic Number,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Read,The following statement contains a magic number: do {  				bool tag_found = false;  				  				Seek (position);  				string fourcc = ReadBlock (4).ToString (StringType.UTF8);  				size = ReadBlock (4).ToUInt (false);  				  				switch (fourcc)  				{  				  				// "fmt " is used by Wave files to hold the  				// WaveFormatEx structure.  				case "fmt ":  					if (style == ReadStyle.None ||  						stream_format != "WAVE")  						break;  					  					Seek (position + 8);  					codecs = new ICodec [] {  						new WaveFormatEx (ReadBlock (18)' 0)  					};  					break;  				  				// "data" contains the audio data for wave  				// files. It's contents represent the invariant  				// portion of the file and is used to determine  				// the duration of a file. It should always  				// appear after "fmt ".  				case "data":  					if (stream_format != "WAVE")  						break;  					  					InvariantStartPosition = position;  					InvariantEndPosition = position + size;  					  					if (style == ReadStyle.None ||  						codecs.Length != 1 ||  						!(codecs [0] is WaveFormatEx))  						break;  					  					duration += TimeSpan.FromSeconds (  						(double) size / (double)  						((WaveFormatEx) codecs [0])  							.AverageBytesPerSecond);  					  					break;  				  				// Lists are used to store a variety of data  				// collections. Read the type and act on it.  				case "LIST":  				{  					switch (ReadBlock (4).ToString (StringType.UTF8))  					{  					  					// "hdlr" is used by AVI files to hold  					// a media header and BitmapInfoHeader  					// and WaveFormatEx structures.  					case "hdrl":  						if (style == ReadStyle.None ||  							stream_format != "AVI ")  							continue;  						  						AviHeaderList header_list =  							new AviHeaderList (this'  								position + 12'  								(int) (size - 4));  						duration = header_list.Header.Duration;  						codecs = header_list.Codecs;  						break;  					  					// "INFO" is a tagging format handled by  					// the InfoTag class.  					case "INFO":  						if (read_tags && info_tag == null)  							info_tag = new InfoTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "MID " is a tagging format handled by  					// the MovieIdTag class.  					case "MID ":  						if (read_tags && mid_tag == null)  							mid_tag = new MovieIdTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "movi" contains the media data for  					// and AVI and its contents represent  					// the invariant portion of the file.  					case "movi":  						if (stream_format != "AVI ")  							break;  						  						InvariantStartPosition = position;  						InvariantEndPosition = position + size;  						break;  					}  					break;  				}  				  				// "ID32" is a custom box for this format that  				// contains an ID3v2 tag.  				case "ID32":  					if (read_tags && id32_tag == null)  						id32_tag = new Id3v2.Tag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "IDVX" is used by DivX and holds an ID3v1-  				// style tag.  				case "IDVX":  					if (read_tags && divx_tag == null)  						divx_tag = new DivXTag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "JUNK" is a padding element that could be  				// associated with tag data.  				case "JUNK":  					if (tag_end == position)  						tag_end = position + 8 + size;  					break;  				}  				  				// Determine the region of the file that  				// contains tags.  				if (tag_found) {  					if (tag_start == -1) {  						tag_start = position;  						tag_end = position + 8 + size;  					} else if (tag_end == position) {  						tag_end = position + 8 + size;  					}  				}  				  				// Move to the next item.  			} while ((position += 8 + size) + 8 < length);
Magic Number,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Read,The following statement contains a magic number: do {  				bool tag_found = false;  				  				Seek (position);  				string fourcc = ReadBlock (4).ToString (StringType.UTF8);  				size = ReadBlock (4).ToUInt (false);  				  				switch (fourcc)  				{  				  				// "fmt " is used by Wave files to hold the  				// WaveFormatEx structure.  				case "fmt ":  					if (style == ReadStyle.None ||  						stream_format != "WAVE")  						break;  					  					Seek (position + 8);  					codecs = new ICodec [] {  						new WaveFormatEx (ReadBlock (18)' 0)  					};  					break;  				  				// "data" contains the audio data for wave  				// files. It's contents represent the invariant  				// portion of the file and is used to determine  				// the duration of a file. It should always  				// appear after "fmt ".  				case "data":  					if (stream_format != "WAVE")  						break;  					  					InvariantStartPosition = position;  					InvariantEndPosition = position + size;  					  					if (style == ReadStyle.None ||  						codecs.Length != 1 ||  						!(codecs [0] is WaveFormatEx))  						break;  					  					duration += TimeSpan.FromSeconds (  						(double) size / (double)  						((WaveFormatEx) codecs [0])  							.AverageBytesPerSecond);  					  					break;  				  				// Lists are used to store a variety of data  				// collections. Read the type and act on it.  				case "LIST":  				{  					switch (ReadBlock (4).ToString (StringType.UTF8))  					{  					  					// "hdlr" is used by AVI files to hold  					// a media header and BitmapInfoHeader  					// and WaveFormatEx structures.  					case "hdrl":  						if (style == ReadStyle.None ||  							stream_format != "AVI ")  							continue;  						  						AviHeaderList header_list =  							new AviHeaderList (this'  								position + 12'  								(int) (size - 4));  						duration = header_list.Header.Duration;  						codecs = header_list.Codecs;  						break;  					  					// "INFO" is a tagging format handled by  					// the InfoTag class.  					case "INFO":  						if (read_tags && info_tag == null)  							info_tag = new InfoTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "MID " is a tagging format handled by  					// the MovieIdTag class.  					case "MID ":  						if (read_tags && mid_tag == null)  							mid_tag = new MovieIdTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "movi" contains the media data for  					// and AVI and its contents represent  					// the invariant portion of the file.  					case "movi":  						if (stream_format != "AVI ")  							break;  						  						InvariantStartPosition = position;  						InvariantEndPosition = position + size;  						break;  					}  					break;  				}  				  				// "ID32" is a custom box for this format that  				// contains an ID3v2 tag.  				case "ID32":  					if (read_tags && id32_tag == null)  						id32_tag = new Id3v2.Tag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "IDVX" is used by DivX and holds an ID3v1-  				// style tag.  				case "IDVX":  					if (read_tags && divx_tag == null)  						divx_tag = new DivXTag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "JUNK" is a padding element that could be  				// associated with tag data.  				case "JUNK":  					if (tag_end == position)  						tag_end = position + 8 + size;  					break;  				}  				  				// Determine the region of the file that  				// contains tags.  				if (tag_found) {  					if (tag_start == -1) {  						tag_start = position;  						tag_end = position + 8 + size;  					} else if (tag_end == position) {  						tag_end = position + 8 + size;  					}  				}  				  				// Move to the next item.  			} while ((position += 8 + size) + 8 < length);
Magic Number,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Read,The following statement contains a magic number: do {  				bool tag_found = false;  				  				Seek (position);  				string fourcc = ReadBlock (4).ToString (StringType.UTF8);  				size = ReadBlock (4).ToUInt (false);  				  				switch (fourcc)  				{  				  				// "fmt " is used by Wave files to hold the  				// WaveFormatEx structure.  				case "fmt ":  					if (style == ReadStyle.None ||  						stream_format != "WAVE")  						break;  					  					Seek (position + 8);  					codecs = new ICodec [] {  						new WaveFormatEx (ReadBlock (18)' 0)  					};  					break;  				  				// "data" contains the audio data for wave  				// files. It's contents represent the invariant  				// portion of the file and is used to determine  				// the duration of a file. It should always  				// appear after "fmt ".  				case "data":  					if (stream_format != "WAVE")  						break;  					  					InvariantStartPosition = position;  					InvariantEndPosition = position + size;  					  					if (style == ReadStyle.None ||  						codecs.Length != 1 ||  						!(codecs [0] is WaveFormatEx))  						break;  					  					duration += TimeSpan.FromSeconds (  						(double) size / (double)  						((WaveFormatEx) codecs [0])  							.AverageBytesPerSecond);  					  					break;  				  				// Lists are used to store a variety of data  				// collections. Read the type and act on it.  				case "LIST":  				{  					switch (ReadBlock (4).ToString (StringType.UTF8))  					{  					  					// "hdlr" is used by AVI files to hold  					// a media header and BitmapInfoHeader  					// and WaveFormatEx structures.  					case "hdrl":  						if (style == ReadStyle.None ||  							stream_format != "AVI ")  							continue;  						  						AviHeaderList header_list =  							new AviHeaderList (this'  								position + 12'  								(int) (size - 4));  						duration = header_list.Header.Duration;  						codecs = header_list.Codecs;  						break;  					  					// "INFO" is a tagging format handled by  					// the InfoTag class.  					case "INFO":  						if (read_tags && info_tag == null)  							info_tag = new InfoTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "MID " is a tagging format handled by  					// the MovieIdTag class.  					case "MID ":  						if (read_tags && mid_tag == null)  							mid_tag = new MovieIdTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "movi" contains the media data for  					// and AVI and its contents represent  					// the invariant portion of the file.  					case "movi":  						if (stream_format != "AVI ")  							break;  						  						InvariantStartPosition = position;  						InvariantEndPosition = position + size;  						break;  					}  					break;  				}  				  				// "ID32" is a custom box for this format that  				// contains an ID3v2 tag.  				case "ID32":  					if (read_tags && id32_tag == null)  						id32_tag = new Id3v2.Tag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "IDVX" is used by DivX and holds an ID3v1-  				// style tag.  				case "IDVX":  					if (read_tags && divx_tag == null)  						divx_tag = new DivXTag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "JUNK" is a padding element that could be  				// associated with tag data.  				case "JUNK":  					if (tag_end == position)  						tag_end = position + 8 + size;  					break;  				}  				  				// Determine the region of the file that  				// contains tags.  				if (tag_found) {  					if (tag_start == -1) {  						tag_start = position;  						tag_end = position + 8 + size;  					} else if (tag_end == position) {  						tag_end = position + 8 + size;  					}  				}  				  				// Move to the next item.  			} while ((position += 8 + size) + 8 < length);
Magic Number,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Read,The following statement contains a magic number: do {  				bool tag_found = false;  				  				Seek (position);  				string fourcc = ReadBlock (4).ToString (StringType.UTF8);  				size = ReadBlock (4).ToUInt (false);  				  				switch (fourcc)  				{  				  				// "fmt " is used by Wave files to hold the  				// WaveFormatEx structure.  				case "fmt ":  					if (style == ReadStyle.None ||  						stream_format != "WAVE")  						break;  					  					Seek (position + 8);  					codecs = new ICodec [] {  						new WaveFormatEx (ReadBlock (18)' 0)  					};  					break;  				  				// "data" contains the audio data for wave  				// files. It's contents represent the invariant  				// portion of the file and is used to determine  				// the duration of a file. It should always  				// appear after "fmt ".  				case "data":  					if (stream_format != "WAVE")  						break;  					  					InvariantStartPosition = position;  					InvariantEndPosition = position + size;  					  					if (style == ReadStyle.None ||  						codecs.Length != 1 ||  						!(codecs [0] is WaveFormatEx))  						break;  					  					duration += TimeSpan.FromSeconds (  						(double) size / (double)  						((WaveFormatEx) codecs [0])  							.AverageBytesPerSecond);  					  					break;  				  				// Lists are used to store a variety of data  				// collections. Read the type and act on it.  				case "LIST":  				{  					switch (ReadBlock (4).ToString (StringType.UTF8))  					{  					  					// "hdlr" is used by AVI files to hold  					// a media header and BitmapInfoHeader  					// and WaveFormatEx structures.  					case "hdrl":  						if (style == ReadStyle.None ||  							stream_format != "AVI ")  							continue;  						  						AviHeaderList header_list =  							new AviHeaderList (this'  								position + 12'  								(int) (size - 4));  						duration = header_list.Header.Duration;  						codecs = header_list.Codecs;  						break;  					  					// "INFO" is a tagging format handled by  					// the InfoTag class.  					case "INFO":  						if (read_tags && info_tag == null)  							info_tag = new InfoTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "MID " is a tagging format handled by  					// the MovieIdTag class.  					case "MID ":  						if (read_tags && mid_tag == null)  							mid_tag = new MovieIdTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "movi" contains the media data for  					// and AVI and its contents represent  					// the invariant portion of the file.  					case "movi":  						if (stream_format != "AVI ")  							break;  						  						InvariantStartPosition = position;  						InvariantEndPosition = position + size;  						break;  					}  					break;  				}  				  				// "ID32" is a custom box for this format that  				// contains an ID3v2 tag.  				case "ID32":  					if (read_tags && id32_tag == null)  						id32_tag = new Id3v2.Tag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "IDVX" is used by DivX and holds an ID3v1-  				// style tag.  				case "IDVX":  					if (read_tags && divx_tag == null)  						divx_tag = new DivXTag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "JUNK" is a padding element that could be  				// associated with tag data.  				case "JUNK":  					if (tag_end == position)  						tag_end = position + 8 + size;  					break;  				}  				  				// Determine the region of the file that  				// contains tags.  				if (tag_found) {  					if (tag_start == -1) {  						tag_start = position;  						tag_end = position + 8 + size;  					} else if (tag_end == position) {  						tag_end = position + 8 + size;  					}  				}  				  				// Move to the next item.  			} while ((position += 8 + size) + 8 < length);
Magic Number,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Read,The following statement contains a magic number: do {  				bool tag_found = false;  				  				Seek (position);  				string fourcc = ReadBlock (4).ToString (StringType.UTF8);  				size = ReadBlock (4).ToUInt (false);  				  				switch (fourcc)  				{  				  				// "fmt " is used by Wave files to hold the  				// WaveFormatEx structure.  				case "fmt ":  					if (style == ReadStyle.None ||  						stream_format != "WAVE")  						break;  					  					Seek (position + 8);  					codecs = new ICodec [] {  						new WaveFormatEx (ReadBlock (18)' 0)  					};  					break;  				  				// "data" contains the audio data for wave  				// files. It's contents represent the invariant  				// portion of the file and is used to determine  				// the duration of a file. It should always  				// appear after "fmt ".  				case "data":  					if (stream_format != "WAVE")  						break;  					  					InvariantStartPosition = position;  					InvariantEndPosition = position + size;  					  					if (style == ReadStyle.None ||  						codecs.Length != 1 ||  						!(codecs [0] is WaveFormatEx))  						break;  					  					duration += TimeSpan.FromSeconds (  						(double) size / (double)  						((WaveFormatEx) codecs [0])  							.AverageBytesPerSecond);  					  					break;  				  				// Lists are used to store a variety of data  				// collections. Read the type and act on it.  				case "LIST":  				{  					switch (ReadBlock (4).ToString (StringType.UTF8))  					{  					  					// "hdlr" is used by AVI files to hold  					// a media header and BitmapInfoHeader  					// and WaveFormatEx structures.  					case "hdrl":  						if (style == ReadStyle.None ||  							stream_format != "AVI ")  							continue;  						  						AviHeaderList header_list =  							new AviHeaderList (this'  								position + 12'  								(int) (size - 4));  						duration = header_list.Header.Duration;  						codecs = header_list.Codecs;  						break;  					  					// "INFO" is a tagging format handled by  					// the InfoTag class.  					case "INFO":  						if (read_tags && info_tag == null)  							info_tag = new InfoTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "MID " is a tagging format handled by  					// the MovieIdTag class.  					case "MID ":  						if (read_tags && mid_tag == null)  							mid_tag = new MovieIdTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "movi" contains the media data for  					// and AVI and its contents represent  					// the invariant portion of the file.  					case "movi":  						if (stream_format != "AVI ")  							break;  						  						InvariantStartPosition = position;  						InvariantEndPosition = position + size;  						break;  					}  					break;  				}  				  				// "ID32" is a custom box for this format that  				// contains an ID3v2 tag.  				case "ID32":  					if (read_tags && id32_tag == null)  						id32_tag = new Id3v2.Tag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "IDVX" is used by DivX and holds an ID3v1-  				// style tag.  				case "IDVX":  					if (read_tags && divx_tag == null)  						divx_tag = new DivXTag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "JUNK" is a padding element that could be  				// associated with tag data.  				case "JUNK":  					if (tag_end == position)  						tag_end = position + 8 + size;  					break;  				}  				  				// Determine the region of the file that  				// contains tags.  				if (tag_found) {  					if (tag_start == -1) {  						tag_start = position;  						tag_end = position + 8 + size;  					} else if (tag_end == position) {  						tag_end = position + 8 + size;  					}  				}  				  				// Move to the next item.  			} while ((position += 8 + size) + 8 < length);
Magic Number,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Read,The following statement contains a magic number: do {  				bool tag_found = false;  				  				Seek (position);  				string fourcc = ReadBlock (4).ToString (StringType.UTF8);  				size = ReadBlock (4).ToUInt (false);  				  				switch (fourcc)  				{  				  				// "fmt " is used by Wave files to hold the  				// WaveFormatEx structure.  				case "fmt ":  					if (style == ReadStyle.None ||  						stream_format != "WAVE")  						break;  					  					Seek (position + 8);  					codecs = new ICodec [] {  						new WaveFormatEx (ReadBlock (18)' 0)  					};  					break;  				  				// "data" contains the audio data for wave  				// files. It's contents represent the invariant  				// portion of the file and is used to determine  				// the duration of a file. It should always  				// appear after "fmt ".  				case "data":  					if (stream_format != "WAVE")  						break;  					  					InvariantStartPosition = position;  					InvariantEndPosition = position + size;  					  					if (style == ReadStyle.None ||  						codecs.Length != 1 ||  						!(codecs [0] is WaveFormatEx))  						break;  					  					duration += TimeSpan.FromSeconds (  						(double) size / (double)  						((WaveFormatEx) codecs [0])  							.AverageBytesPerSecond);  					  					break;  				  				// Lists are used to store a variety of data  				// collections. Read the type and act on it.  				case "LIST":  				{  					switch (ReadBlock (4).ToString (StringType.UTF8))  					{  					  					// "hdlr" is used by AVI files to hold  					// a media header and BitmapInfoHeader  					// and WaveFormatEx structures.  					case "hdrl":  						if (style == ReadStyle.None ||  							stream_format != "AVI ")  							continue;  						  						AviHeaderList header_list =  							new AviHeaderList (this'  								position + 12'  								(int) (size - 4));  						duration = header_list.Header.Duration;  						codecs = header_list.Codecs;  						break;  					  					// "INFO" is a tagging format handled by  					// the InfoTag class.  					case "INFO":  						if (read_tags && info_tag == null)  							info_tag = new InfoTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "MID " is a tagging format handled by  					// the MovieIdTag class.  					case "MID ":  						if (read_tags && mid_tag == null)  							mid_tag = new MovieIdTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "movi" contains the media data for  					// and AVI and its contents represent  					// the invariant portion of the file.  					case "movi":  						if (stream_format != "AVI ")  							break;  						  						InvariantStartPosition = position;  						InvariantEndPosition = position + size;  						break;  					}  					break;  				}  				  				// "ID32" is a custom box for this format that  				// contains an ID3v2 tag.  				case "ID32":  					if (read_tags && id32_tag == null)  						id32_tag = new Id3v2.Tag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "IDVX" is used by DivX and holds an ID3v1-  				// style tag.  				case "IDVX":  					if (read_tags && divx_tag == null)  						divx_tag = new DivXTag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "JUNK" is a padding element that could be  				// associated with tag data.  				case "JUNK":  					if (tag_end == position)  						tag_end = position + 8 + size;  					break;  				}  				  				// Determine the region of the file that  				// contains tags.  				if (tag_found) {  					if (tag_start == -1) {  						tag_start = position;  						tag_end = position + 8 + size;  					} else if (tag_end == position) {  						tag_end = position + 8 + size;  					}  				}  				  				// Move to the next item.  			} while ((position += 8 + size) + 8 < length);
Magic Number,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Read,The following statement contains a magic number: do {  				bool tag_found = false;  				  				Seek (position);  				string fourcc = ReadBlock (4).ToString (StringType.UTF8);  				size = ReadBlock (4).ToUInt (false);  				  				switch (fourcc)  				{  				  				// "fmt " is used by Wave files to hold the  				// WaveFormatEx structure.  				case "fmt ":  					if (style == ReadStyle.None ||  						stream_format != "WAVE")  						break;  					  					Seek (position + 8);  					codecs = new ICodec [] {  						new WaveFormatEx (ReadBlock (18)' 0)  					};  					break;  				  				// "data" contains the audio data for wave  				// files. It's contents represent the invariant  				// portion of the file and is used to determine  				// the duration of a file. It should always  				// appear after "fmt ".  				case "data":  					if (stream_format != "WAVE")  						break;  					  					InvariantStartPosition = position;  					InvariantEndPosition = position + size;  					  					if (style == ReadStyle.None ||  						codecs.Length != 1 ||  						!(codecs [0] is WaveFormatEx))  						break;  					  					duration += TimeSpan.FromSeconds (  						(double) size / (double)  						((WaveFormatEx) codecs [0])  							.AverageBytesPerSecond);  					  					break;  				  				// Lists are used to store a variety of data  				// collections. Read the type and act on it.  				case "LIST":  				{  					switch (ReadBlock (4).ToString (StringType.UTF8))  					{  					  					// "hdlr" is used by AVI files to hold  					// a media header and BitmapInfoHeader  					// and WaveFormatEx structures.  					case "hdrl":  						if (style == ReadStyle.None ||  							stream_format != "AVI ")  							continue;  						  						AviHeaderList header_list =  							new AviHeaderList (this'  								position + 12'  								(int) (size - 4));  						duration = header_list.Header.Duration;  						codecs = header_list.Codecs;  						break;  					  					// "INFO" is a tagging format handled by  					// the InfoTag class.  					case "INFO":  						if (read_tags && info_tag == null)  							info_tag = new InfoTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "MID " is a tagging format handled by  					// the MovieIdTag class.  					case "MID ":  						if (read_tags && mid_tag == null)  							mid_tag = new MovieIdTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "movi" contains the media data for  					// and AVI and its contents represent  					// the invariant portion of the file.  					case "movi":  						if (stream_format != "AVI ")  							break;  						  						InvariantStartPosition = position;  						InvariantEndPosition = position + size;  						break;  					}  					break;  				}  				  				// "ID32" is a custom box for this format that  				// contains an ID3v2 tag.  				case "ID32":  					if (read_tags && id32_tag == null)  						id32_tag = new Id3v2.Tag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "IDVX" is used by DivX and holds an ID3v1-  				// style tag.  				case "IDVX":  					if (read_tags && divx_tag == null)  						divx_tag = new DivXTag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "JUNK" is a padding element that could be  				// associated with tag data.  				case "JUNK":  					if (tag_end == position)  						tag_end = position + 8 + size;  					break;  				}  				  				// Determine the region of the file that  				// contains tags.  				if (tag_found) {  					if (tag_start == -1) {  						tag_start = position;  						tag_end = position + 8 + size;  					} else if (tag_end == position) {  						tag_end = position + 8 + size;  					}  				}  				  				// Move to the next item.  			} while ((position += 8 + size) + 8 < length);
Magic Number,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Read,The following statement contains a magic number: do {  				bool tag_found = false;  				  				Seek (position);  				string fourcc = ReadBlock (4).ToString (StringType.UTF8);  				size = ReadBlock (4).ToUInt (false);  				  				switch (fourcc)  				{  				  				// "fmt " is used by Wave files to hold the  				// WaveFormatEx structure.  				case "fmt ":  					if (style == ReadStyle.None ||  						stream_format != "WAVE")  						break;  					  					Seek (position + 8);  					codecs = new ICodec [] {  						new WaveFormatEx (ReadBlock (18)' 0)  					};  					break;  				  				// "data" contains the audio data for wave  				// files. It's contents represent the invariant  				// portion of the file and is used to determine  				// the duration of a file. It should always  				// appear after "fmt ".  				case "data":  					if (stream_format != "WAVE")  						break;  					  					InvariantStartPosition = position;  					InvariantEndPosition = position + size;  					  					if (style == ReadStyle.None ||  						codecs.Length != 1 ||  						!(codecs [0] is WaveFormatEx))  						break;  					  					duration += TimeSpan.FromSeconds (  						(double) size / (double)  						((WaveFormatEx) codecs [0])  							.AverageBytesPerSecond);  					  					break;  				  				// Lists are used to store a variety of data  				// collections. Read the type and act on it.  				case "LIST":  				{  					switch (ReadBlock (4).ToString (StringType.UTF8))  					{  					  					// "hdlr" is used by AVI files to hold  					// a media header and BitmapInfoHeader  					// and WaveFormatEx structures.  					case "hdrl":  						if (style == ReadStyle.None ||  							stream_format != "AVI ")  							continue;  						  						AviHeaderList header_list =  							new AviHeaderList (this'  								position + 12'  								(int) (size - 4));  						duration = header_list.Header.Duration;  						codecs = header_list.Codecs;  						break;  					  					// "INFO" is a tagging format handled by  					// the InfoTag class.  					case "INFO":  						if (read_tags && info_tag == null)  							info_tag = new InfoTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "MID " is a tagging format handled by  					// the MovieIdTag class.  					case "MID ":  						if (read_tags && mid_tag == null)  							mid_tag = new MovieIdTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "movi" contains the media data for  					// and AVI and its contents represent  					// the invariant portion of the file.  					case "movi":  						if (stream_format != "AVI ")  							break;  						  						InvariantStartPosition = position;  						InvariantEndPosition = position + size;  						break;  					}  					break;  				}  				  				// "ID32" is a custom box for this format that  				// contains an ID3v2 tag.  				case "ID32":  					if (read_tags && id32_tag == null)  						id32_tag = new Id3v2.Tag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "IDVX" is used by DivX and holds an ID3v1-  				// style tag.  				case "IDVX":  					if (read_tags && divx_tag == null)  						divx_tag = new DivXTag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "JUNK" is a padding element that could be  				// associated with tag data.  				case "JUNK":  					if (tag_end == position)  						tag_end = position + 8 + size;  					break;  				}  				  				// Determine the region of the file that  				// contains tags.  				if (tag_found) {  					if (tag_start == -1) {  						tag_start = position;  						tag_end = position + 8 + size;  					} else if (tag_end == position) {  						tag_end = position + 8 + size;  					}  				}  				  				// Move to the next item.  			} while ((position += 8 + size) + 8 < length);
Magic Number,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Read,The following statement contains a magic number: do {  				bool tag_found = false;  				  				Seek (position);  				string fourcc = ReadBlock (4).ToString (StringType.UTF8);  				size = ReadBlock (4).ToUInt (false);  				  				switch (fourcc)  				{  				  				// "fmt " is used by Wave files to hold the  				// WaveFormatEx structure.  				case "fmt ":  					if (style == ReadStyle.None ||  						stream_format != "WAVE")  						break;  					  					Seek (position + 8);  					codecs = new ICodec [] {  						new WaveFormatEx (ReadBlock (18)' 0)  					};  					break;  				  				// "data" contains the audio data for wave  				// files. It's contents represent the invariant  				// portion of the file and is used to determine  				// the duration of a file. It should always  				// appear after "fmt ".  				case "data":  					if (stream_format != "WAVE")  						break;  					  					InvariantStartPosition = position;  					InvariantEndPosition = position + size;  					  					if (style == ReadStyle.None ||  						codecs.Length != 1 ||  						!(codecs [0] is WaveFormatEx))  						break;  					  					duration += TimeSpan.FromSeconds (  						(double) size / (double)  						((WaveFormatEx) codecs [0])  							.AverageBytesPerSecond);  					  					break;  				  				// Lists are used to store a variety of data  				// collections. Read the type and act on it.  				case "LIST":  				{  					switch (ReadBlock (4).ToString (StringType.UTF8))  					{  					  					// "hdlr" is used by AVI files to hold  					// a media header and BitmapInfoHeader  					// and WaveFormatEx structures.  					case "hdrl":  						if (style == ReadStyle.None ||  							stream_format != "AVI ")  							continue;  						  						AviHeaderList header_list =  							new AviHeaderList (this'  								position + 12'  								(int) (size - 4));  						duration = header_list.Header.Duration;  						codecs = header_list.Codecs;  						break;  					  					// "INFO" is a tagging format handled by  					// the InfoTag class.  					case "INFO":  						if (read_tags && info_tag == null)  							info_tag = new InfoTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "MID " is a tagging format handled by  					// the MovieIdTag class.  					case "MID ":  						if (read_tags && mid_tag == null)  							mid_tag = new MovieIdTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "movi" contains the media data for  					// and AVI and its contents represent  					// the invariant portion of the file.  					case "movi":  						if (stream_format != "AVI ")  							break;  						  						InvariantStartPosition = position;  						InvariantEndPosition = position + size;  						break;  					}  					break;  				}  				  				// "ID32" is a custom box for this format that  				// contains an ID3v2 tag.  				case "ID32":  					if (read_tags && id32_tag == null)  						id32_tag = new Id3v2.Tag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "IDVX" is used by DivX and holds an ID3v1-  				// style tag.  				case "IDVX":  					if (read_tags && divx_tag == null)  						divx_tag = new DivXTag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "JUNK" is a padding element that could be  				// associated with tag data.  				case "JUNK":  					if (tag_end == position)  						tag_end = position + 8 + size;  					break;  				}  				  				// Determine the region of the file that  				// contains tags.  				if (tag_found) {  					if (tag_start == -1) {  						tag_start = position;  						tag_end = position + 8 + size;  					} else if (tag_end == position) {  						tag_end = position + 8 + size;  					}  				}  				  				// Move to the next item.  			} while ((position += 8 + size) + 8 < length);
Magic Number,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Read,The following statement contains a magic number: do {  				bool tag_found = false;  				  				Seek (position);  				string fourcc = ReadBlock (4).ToString (StringType.UTF8);  				size = ReadBlock (4).ToUInt (false);  				  				switch (fourcc)  				{  				  				// "fmt " is used by Wave files to hold the  				// WaveFormatEx structure.  				case "fmt ":  					if (style == ReadStyle.None ||  						stream_format != "WAVE")  						break;  					  					Seek (position + 8);  					codecs = new ICodec [] {  						new WaveFormatEx (ReadBlock (18)' 0)  					};  					break;  				  				// "data" contains the audio data for wave  				// files. It's contents represent the invariant  				// portion of the file and is used to determine  				// the duration of a file. It should always  				// appear after "fmt ".  				case "data":  					if (stream_format != "WAVE")  						break;  					  					InvariantStartPosition = position;  					InvariantEndPosition = position + size;  					  					if (style == ReadStyle.None ||  						codecs.Length != 1 ||  						!(codecs [0] is WaveFormatEx))  						break;  					  					duration += TimeSpan.FromSeconds (  						(double) size / (double)  						((WaveFormatEx) codecs [0])  							.AverageBytesPerSecond);  					  					break;  				  				// Lists are used to store a variety of data  				// collections. Read the type and act on it.  				case "LIST":  				{  					switch (ReadBlock (4).ToString (StringType.UTF8))  					{  					  					// "hdlr" is used by AVI files to hold  					// a media header and BitmapInfoHeader  					// and WaveFormatEx structures.  					case "hdrl":  						if (style == ReadStyle.None ||  							stream_format != "AVI ")  							continue;  						  						AviHeaderList header_list =  							new AviHeaderList (this'  								position + 12'  								(int) (size - 4));  						duration = header_list.Header.Duration;  						codecs = header_list.Codecs;  						break;  					  					// "INFO" is a tagging format handled by  					// the InfoTag class.  					case "INFO":  						if (read_tags && info_tag == null)  							info_tag = new InfoTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "MID " is a tagging format handled by  					// the MovieIdTag class.  					case "MID ":  						if (read_tags && mid_tag == null)  							mid_tag = new MovieIdTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "movi" contains the media data for  					// and AVI and its contents represent  					// the invariant portion of the file.  					case "movi":  						if (stream_format != "AVI ")  							break;  						  						InvariantStartPosition = position;  						InvariantEndPosition = position + size;  						break;  					}  					break;  				}  				  				// "ID32" is a custom box for this format that  				// contains an ID3v2 tag.  				case "ID32":  					if (read_tags && id32_tag == null)  						id32_tag = new Id3v2.Tag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "IDVX" is used by DivX and holds an ID3v1-  				// style tag.  				case "IDVX":  					if (read_tags && divx_tag == null)  						divx_tag = new DivXTag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "JUNK" is a padding element that could be  				// associated with tag data.  				case "JUNK":  					if (tag_end == position)  						tag_end = position + 8 + size;  					break;  				}  				  				// Determine the region of the file that  				// contains tags.  				if (tag_found) {  					if (tag_start == -1) {  						tag_start = position;  						tag_end = position + 8 + size;  					} else if (tag_end == position) {  						tag_end = position + 8 + size;  					}  				}  				  				// Move to the next item.  			} while ((position += 8 + size) + 8 < length);
Magic Number,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Read,The following statement contains a magic number: do {  				bool tag_found = false;  				  				Seek (position);  				string fourcc = ReadBlock (4).ToString (StringType.UTF8);  				size = ReadBlock (4).ToUInt (false);  				  				switch (fourcc)  				{  				  				// "fmt " is used by Wave files to hold the  				// WaveFormatEx structure.  				case "fmt ":  					if (style == ReadStyle.None ||  						stream_format != "WAVE")  						break;  					  					Seek (position + 8);  					codecs = new ICodec [] {  						new WaveFormatEx (ReadBlock (18)' 0)  					};  					break;  				  				// "data" contains the audio data for wave  				// files. It's contents represent the invariant  				// portion of the file and is used to determine  				// the duration of a file. It should always  				// appear after "fmt ".  				case "data":  					if (stream_format != "WAVE")  						break;  					  					InvariantStartPosition = position;  					InvariantEndPosition = position + size;  					  					if (style == ReadStyle.None ||  						codecs.Length != 1 ||  						!(codecs [0] is WaveFormatEx))  						break;  					  					duration += TimeSpan.FromSeconds (  						(double) size / (double)  						((WaveFormatEx) codecs [0])  							.AverageBytesPerSecond);  					  					break;  				  				// Lists are used to store a variety of data  				// collections. Read the type and act on it.  				case "LIST":  				{  					switch (ReadBlock (4).ToString (StringType.UTF8))  					{  					  					// "hdlr" is used by AVI files to hold  					// a media header and BitmapInfoHeader  					// and WaveFormatEx structures.  					case "hdrl":  						if (style == ReadStyle.None ||  							stream_format != "AVI ")  							continue;  						  						AviHeaderList header_list =  							new AviHeaderList (this'  								position + 12'  								(int) (size - 4));  						duration = header_list.Header.Duration;  						codecs = header_list.Codecs;  						break;  					  					// "INFO" is a tagging format handled by  					// the InfoTag class.  					case "INFO":  						if (read_tags && info_tag == null)  							info_tag = new InfoTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "MID " is a tagging format handled by  					// the MovieIdTag class.  					case "MID ":  						if (read_tags && mid_tag == null)  							mid_tag = new MovieIdTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "movi" contains the media data for  					// and AVI and its contents represent  					// the invariant portion of the file.  					case "movi":  						if (stream_format != "AVI ")  							break;  						  						InvariantStartPosition = position;  						InvariantEndPosition = position + size;  						break;  					}  					break;  				}  				  				// "ID32" is a custom box for this format that  				// contains an ID3v2 tag.  				case "ID32":  					if (read_tags && id32_tag == null)  						id32_tag = new Id3v2.Tag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "IDVX" is used by DivX and holds an ID3v1-  				// style tag.  				case "IDVX":  					if (read_tags && divx_tag == null)  						divx_tag = new DivXTag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "JUNK" is a padding element that could be  				// associated with tag data.  				case "JUNK":  					if (tag_end == position)  						tag_end = position + 8 + size;  					break;  				}  				  				// Determine the region of the file that  				// contains tags.  				if (tag_found) {  					if (tag_start == -1) {  						tag_start = position;  						tag_end = position + 8 + size;  					} else if (tag_end == position) {  						tag_end = position + 8 + size;  					}  				}  				  				// Move to the next item.  			} while ((position += 8 + size) + 8 < length);
Magic Number,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Read,The following statement contains a magic number: do {  				bool tag_found = false;  				  				Seek (position);  				string fourcc = ReadBlock (4).ToString (StringType.UTF8);  				size = ReadBlock (4).ToUInt (false);  				  				switch (fourcc)  				{  				  				// "fmt " is used by Wave files to hold the  				// WaveFormatEx structure.  				case "fmt ":  					if (style == ReadStyle.None ||  						stream_format != "WAVE")  						break;  					  					Seek (position + 8);  					codecs = new ICodec [] {  						new WaveFormatEx (ReadBlock (18)' 0)  					};  					break;  				  				// "data" contains the audio data for wave  				// files. It's contents represent the invariant  				// portion of the file and is used to determine  				// the duration of a file. It should always  				// appear after "fmt ".  				case "data":  					if (stream_format != "WAVE")  						break;  					  					InvariantStartPosition = position;  					InvariantEndPosition = position + size;  					  					if (style == ReadStyle.None ||  						codecs.Length != 1 ||  						!(codecs [0] is WaveFormatEx))  						break;  					  					duration += TimeSpan.FromSeconds (  						(double) size / (double)  						((WaveFormatEx) codecs [0])  							.AverageBytesPerSecond);  					  					break;  				  				// Lists are used to store a variety of data  				// collections. Read the type and act on it.  				case "LIST":  				{  					switch (ReadBlock (4).ToString (StringType.UTF8))  					{  					  					// "hdlr" is used by AVI files to hold  					// a media header and BitmapInfoHeader  					// and WaveFormatEx structures.  					case "hdrl":  						if (style == ReadStyle.None ||  							stream_format != "AVI ")  							continue;  						  						AviHeaderList header_list =  							new AviHeaderList (this'  								position + 12'  								(int) (size - 4));  						duration = header_list.Header.Duration;  						codecs = header_list.Codecs;  						break;  					  					// "INFO" is a tagging format handled by  					// the InfoTag class.  					case "INFO":  						if (read_tags && info_tag == null)  							info_tag = new InfoTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "MID " is a tagging format handled by  					// the MovieIdTag class.  					case "MID ":  						if (read_tags && mid_tag == null)  							mid_tag = new MovieIdTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "movi" contains the media data for  					// and AVI and its contents represent  					// the invariant portion of the file.  					case "movi":  						if (stream_format != "AVI ")  							break;  						  						InvariantStartPosition = position;  						InvariantEndPosition = position + size;  						break;  					}  					break;  				}  				  				// "ID32" is a custom box for this format that  				// contains an ID3v2 tag.  				case "ID32":  					if (read_tags && id32_tag == null)  						id32_tag = new Id3v2.Tag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "IDVX" is used by DivX and holds an ID3v1-  				// style tag.  				case "IDVX":  					if (read_tags && divx_tag == null)  						divx_tag = new DivXTag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "JUNK" is a padding element that could be  				// associated with tag data.  				case "JUNK":  					if (tag_end == position)  						tag_end = position + 8 + size;  					break;  				}  				  				// Determine the region of the file that  				// contains tags.  				if (tag_found) {  					if (tag_start == -1) {  						tag_start = position;  						tag_end = position + 8 + size;  					} else if (tag_end == position) {  						tag_end = position + 8 + size;  					}  				}  				  				// Move to the next item.  			} while ((position += 8 + size) + 8 < length);
Magic Number,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Read,The following statement contains a magic number: do {  				bool tag_found = false;  				  				Seek (position);  				string fourcc = ReadBlock (4).ToString (StringType.UTF8);  				size = ReadBlock (4).ToUInt (false);  				  				switch (fourcc)  				{  				  				// "fmt " is used by Wave files to hold the  				// WaveFormatEx structure.  				case "fmt ":  					if (style == ReadStyle.None ||  						stream_format != "WAVE")  						break;  					  					Seek (position + 8);  					codecs = new ICodec [] {  						new WaveFormatEx (ReadBlock (18)' 0)  					};  					break;  				  				// "data" contains the audio data for wave  				// files. It's contents represent the invariant  				// portion of the file and is used to determine  				// the duration of a file. It should always  				// appear after "fmt ".  				case "data":  					if (stream_format != "WAVE")  						break;  					  					InvariantStartPosition = position;  					InvariantEndPosition = position + size;  					  					if (style == ReadStyle.None ||  						codecs.Length != 1 ||  						!(codecs [0] is WaveFormatEx))  						break;  					  					duration += TimeSpan.FromSeconds (  						(double) size / (double)  						((WaveFormatEx) codecs [0])  							.AverageBytesPerSecond);  					  					break;  				  				// Lists are used to store a variety of data  				// collections. Read the type and act on it.  				case "LIST":  				{  					switch (ReadBlock (4).ToString (StringType.UTF8))  					{  					  					// "hdlr" is used by AVI files to hold  					// a media header and BitmapInfoHeader  					// and WaveFormatEx structures.  					case "hdrl":  						if (style == ReadStyle.None ||  							stream_format != "AVI ")  							continue;  						  						AviHeaderList header_list =  							new AviHeaderList (this'  								position + 12'  								(int) (size - 4));  						duration = header_list.Header.Duration;  						codecs = header_list.Codecs;  						break;  					  					// "INFO" is a tagging format handled by  					// the InfoTag class.  					case "INFO":  						if (read_tags && info_tag == null)  							info_tag = new InfoTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "MID " is a tagging format handled by  					// the MovieIdTag class.  					case "MID ":  						if (read_tags && mid_tag == null)  							mid_tag = new MovieIdTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "movi" contains the media data for  					// and AVI and its contents represent  					// the invariant portion of the file.  					case "movi":  						if (stream_format != "AVI ")  							break;  						  						InvariantStartPosition = position;  						InvariantEndPosition = position + size;  						break;  					}  					break;  				}  				  				// "ID32" is a custom box for this format that  				// contains an ID3v2 tag.  				case "ID32":  					if (read_tags && id32_tag == null)  						id32_tag = new Id3v2.Tag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "IDVX" is used by DivX and holds an ID3v1-  				// style tag.  				case "IDVX":  					if (read_tags && divx_tag == null)  						divx_tag = new DivXTag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "JUNK" is a padding element that could be  				// associated with tag data.  				case "JUNK":  					if (tag_end == position)  						tag_end = position + 8 + size;  					break;  				}  				  				// Determine the region of the file that  				// contains tags.  				if (tag_found) {  					if (tag_start == -1) {  						tag_start = position;  						tag_end = position + 8 + size;  					} else if (tag_end == position) {  						tag_end = position + 8 + size;  					}  				}  				  				// Move to the next item.  			} while ((position += 8 + size) + 8 < length);
Magic Number,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Read,The following statement contains a magic number: do {  				bool tag_found = false;  				  				Seek (position);  				string fourcc = ReadBlock (4).ToString (StringType.UTF8);  				size = ReadBlock (4).ToUInt (false);  				  				switch (fourcc)  				{  				  				// "fmt " is used by Wave files to hold the  				// WaveFormatEx structure.  				case "fmt ":  					if (style == ReadStyle.None ||  						stream_format != "WAVE")  						break;  					  					Seek (position + 8);  					codecs = new ICodec [] {  						new WaveFormatEx (ReadBlock (18)' 0)  					};  					break;  				  				// "data" contains the audio data for wave  				// files. It's contents represent the invariant  				// portion of the file and is used to determine  				// the duration of a file. It should always  				// appear after "fmt ".  				case "data":  					if (stream_format != "WAVE")  						break;  					  					InvariantStartPosition = position;  					InvariantEndPosition = position + size;  					  					if (style == ReadStyle.None ||  						codecs.Length != 1 ||  						!(codecs [0] is WaveFormatEx))  						break;  					  					duration += TimeSpan.FromSeconds (  						(double) size / (double)  						((WaveFormatEx) codecs [0])  							.AverageBytesPerSecond);  					  					break;  				  				// Lists are used to store a variety of data  				// collections. Read the type and act on it.  				case "LIST":  				{  					switch (ReadBlock (4).ToString (StringType.UTF8))  					{  					  					// "hdlr" is used by AVI files to hold  					// a media header and BitmapInfoHeader  					// and WaveFormatEx structures.  					case "hdrl":  						if (style == ReadStyle.None ||  							stream_format != "AVI ")  							continue;  						  						AviHeaderList header_list =  							new AviHeaderList (this'  								position + 12'  								(int) (size - 4));  						duration = header_list.Header.Duration;  						codecs = header_list.Codecs;  						break;  					  					// "INFO" is a tagging format handled by  					// the InfoTag class.  					case "INFO":  						if (read_tags && info_tag == null)  							info_tag = new InfoTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "MID " is a tagging format handled by  					// the MovieIdTag class.  					case "MID ":  						if (read_tags && mid_tag == null)  							mid_tag = new MovieIdTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "movi" contains the media data for  					// and AVI and its contents represent  					// the invariant portion of the file.  					case "movi":  						if (stream_format != "AVI ")  							break;  						  						InvariantStartPosition = position;  						InvariantEndPosition = position + size;  						break;  					}  					break;  				}  				  				// "ID32" is a custom box for this format that  				// contains an ID3v2 tag.  				case "ID32":  					if (read_tags && id32_tag == null)  						id32_tag = new Id3v2.Tag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "IDVX" is used by DivX and holds an ID3v1-  				// style tag.  				case "IDVX":  					if (read_tags && divx_tag == null)  						divx_tag = new DivXTag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "JUNK" is a padding element that could be  				// associated with tag data.  				case "JUNK":  					if (tag_end == position)  						tag_end = position + 8 + size;  					break;  				}  				  				// Determine the region of the file that  				// contains tags.  				if (tag_found) {  					if (tag_start == -1) {  						tag_start = position;  						tag_end = position + 8 + size;  					} else if (tag_end == position) {  						tag_end = position + 8 + size;  					}  				}  				  				// Move to the next item.  			} while ((position += 8 + size) + 8 < length);
Magic Number,TagLib.Riff,List,C:\repos\mono_taglib-sharp\src\TagLib\Riff\List.cs,Render,The following statement contains a magic number: foreach (ByteVector id in Keys)  				foreach (ByteVector value in this [id]) {  					if (value.Count == 0)  						continue;  					  					data.Add (id);  					data.Add (ByteVector.FromUInt (  						(uint) value.Count' false));  					data.Add (value);  					  					if (value.Count % 2 == 1)  						data.Add (0);  				}
Magic Number,TagLib.Riff,List,C:\repos\mono_taglib-sharp\src\TagLib\Riff\List.cs,RenderEnclosed,The following statement contains a magic number: if (id.Count != 4)  				throw new ArgumentException (  					"ID must be 4 bytes long."' "id");
Magic Number,TagLib.Riff,List,C:\repos\mono_taglib-sharp\src\TagLib\Riff\List.cs,RenderEnclosed,The following statement contains a magic number: if (data.Count <= 8)  				return new ByteVector ();
Magic Number,TagLib.Riff,List,C:\repos\mono_taglib-sharp\src\TagLib\Riff\List.cs,RenderEnclosed,The following statement contains a magic number: header.Add (ByteVector.FromUInt (  				(uint) (data.Count + 4)' false));
Magic Number,TagLib.Riff,List,C:\repos\mono_taglib-sharp\src\TagLib\Riff\List.cs,GetValues,The following statement contains a magic number: if (id.Count != 4)  				throw new ArgumentException (  					"ID must be 4 bytes long."' "id");
Magic Number,TagLib.Riff,List,C:\repos\mono_taglib-sharp\src\TagLib\Riff\List.cs,GetValuesAsStrings,The following statement contains a magic number: if (id.Count != 4)  				throw new ArgumentException (  					"ID must be 4 bytes long."' "id");
Magic Number,TagLib.Riff,List,C:\repos\mono_taglib-sharp\src\TagLib\Riff\List.cs,GetValuesAsStringCollection,The following statement contains a magic number: if (id.Count != 4)  				throw new ArgumentException (  					"ID must be 4 bytes long."' "id");
Magic Number,TagLib.Riff,List,C:\repos\mono_taglib-sharp\src\TagLib\Riff\List.cs,GetValueAsUInt,The following statement contains a magic number: if (id.Count != 4)  				throw new ArgumentException (  					"ID must be 4 bytes long."' "id");
Magic Number,TagLib.Riff,List,C:\repos\mono_taglib-sharp\src\TagLib\Riff\List.cs,SetValue,The following statement contains a magic number: if (id.Count != 4)  				throw new ArgumentException (  					"ID must be 4 bytes long."' "id");
Magic Number,TagLib.Riff,List,C:\repos\mono_taglib-sharp\src\TagLib\Riff\List.cs,SetValue,The following statement contains a magic number: if (id.Count != 4)  				throw new ArgumentException (  					"ID must be 4 bytes long."' "id");
Magic Number,TagLib.Riff,List,C:\repos\mono_taglib-sharp\src\TagLib\Riff\List.cs,SetValue,The following statement contains a magic number: if (id.Count != 4)  				throw new ArgumentException (  					"ID must be 4 bytes long."' "id");
Magic Number,TagLib.Riff,List,C:\repos\mono_taglib-sharp\src\TagLib\Riff\List.cs,SetValue,The following statement contains a magic number: if (id.Count != 4)  				throw new ArgumentException (  					"ID must be 4 bytes long."' "id");
Magic Number,TagLib.Riff,List,C:\repos\mono_taglib-sharp\src\TagLib\Riff\List.cs,SetValue,The following statement contains a magic number: if (id.Count != 4)  				throw new ArgumentException (  					"ID must be 4 bytes long."' "id");
Magic Number,TagLib.Riff,List,C:\repos\mono_taglib-sharp\src\TagLib\Riff\List.cs,RemoveValue,The following statement contains a magic number: if (id.Count != 4)  				throw new ArgumentException (  					"ID must be 4 bytes long."' "id");
Magic Number,TagLib.Riff,List,C:\repos\mono_taglib-sharp\src\TagLib\Riff\List.cs,Parse,The following statement contains a magic number: while (offset + 8 < data.Count) {  				ByteVector id = data.Mid (offset' 4);  				int length = (int) data.Mid (offset + 4' 4)  					.ToUInt (false);  				  				if (!ContainsKey (id))  					Add (id' new ByteVectorCollection ());  				  				this [id].Add (data.Mid (offset + 8' length));  				  				if (length % 2 == 1)  					length ++;  				  				offset += 8 + length;  			}
Magic Number,TagLib.Riff,List,C:\repos\mono_taglib-sharp\src\TagLib\Riff\List.cs,Parse,The following statement contains a magic number: while (offset + 8 < data.Count) {  				ByteVector id = data.Mid (offset' 4);  				int length = (int) data.Mid (offset + 4' 4)  					.ToUInt (false);  				  				if (!ContainsKey (id))  					Add (id' new ByteVectorCollection ());  				  				this [id].Add (data.Mid (offset + 8' length));  				  				if (length % 2 == 1)  					length ++;  				  				offset += 8 + length;  			}
Magic Number,TagLib.Riff,List,C:\repos\mono_taglib-sharp\src\TagLib\Riff\List.cs,Parse,The following statement contains a magic number: while (offset + 8 < data.Count) {  				ByteVector id = data.Mid (offset' 4);  				int length = (int) data.Mid (offset + 4' 4)  					.ToUInt (false);  				  				if (!ContainsKey (id))  					Add (id' new ByteVectorCollection ());  				  				this [id].Add (data.Mid (offset + 8' length));  				  				if (length % 2 == 1)  					length ++;  				  				offset += 8 + length;  			}
Magic Number,TagLib.Riff,List,C:\repos\mono_taglib-sharp\src\TagLib\Riff\List.cs,Parse,The following statement contains a magic number: while (offset + 8 < data.Count) {  				ByteVector id = data.Mid (offset' 4);  				int length = (int) data.Mid (offset + 4' 4)  					.ToUInt (false);  				  				if (!ContainsKey (id))  					Add (id' new ByteVectorCollection ());  				  				this [id].Add (data.Mid (offset + 8' length));  				  				if (length % 2 == 1)  					length ++;  				  				offset += 8 + length;  			}
Magic Number,TagLib.Riff,List,C:\repos\mono_taglib-sharp\src\TagLib\Riff\List.cs,Parse,The following statement contains a magic number: while (offset + 8 < data.Count) {  				ByteVector id = data.Mid (offset' 4);  				int length = (int) data.Mid (offset + 4' 4)  					.ToUInt (false);  				  				if (!ContainsKey (id))  					Add (id' new ByteVectorCollection ());  				  				this [id].Add (data.Mid (offset + 8' length));  				  				if (length % 2 == 1)  					length ++;  				  				offset += 8 + length;  			}
Magic Number,TagLib.Riff,List,C:\repos\mono_taglib-sharp\src\TagLib\Riff\List.cs,Parse,The following statement contains a magic number: while (offset + 8 < data.Count) {  				ByteVector id = data.Mid (offset' 4);  				int length = (int) data.Mid (offset + 4' 4)  					.ToUInt (false);  				  				if (!ContainsKey (id))  					Add (id' new ByteVectorCollection ());  				  				this [id].Add (data.Mid (offset + 8' length));  				  				if (length % 2 == 1)  					length ++;  				  				offset += 8 + length;  			}
Magic Number,TagLib.Riff,List,C:\repos\mono_taglib-sharp\src\TagLib\Riff\List.cs,Parse,The following statement contains a magic number: while (offset + 8 < data.Count) {  				ByteVector id = data.Mid (offset' 4);  				int length = (int) data.Mid (offset + 4' 4)  					.ToUInt (false);  				  				if (!ContainsKey (id))  					Add (id' new ByteVectorCollection ());  				  				this [id].Add (data.Mid (offset + 8' length));  				  				if (length % 2 == 1)  					length ++;  				  				offset += 8 + length;  			}
Magic Number,TagLib.Riff,ListTag,C:\repos\mono_taglib-sharp\src\TagLib\Riff\ListTag.cs,RenderEnclosed,The following statement contains a magic number: if (id.Count != 4)  				throw new ArgumentException (  					"ID must be 4 bytes long."' "id");
Magic Number,TagLib.Riff,ListTag,C:\repos\mono_taglib-sharp\src\TagLib\Riff\ListTag.cs,GetValues,The following statement contains a magic number: if (id.Count != 4)  				throw new ArgumentException (  					"ID must be 4 bytes long."' "id");
Magic Number,TagLib.Riff,ListTag,C:\repos\mono_taglib-sharp\src\TagLib\Riff\ListTag.cs,GetValuesAsStrings,The following statement contains a magic number: if (id.Count != 4)  				throw new ArgumentException (  					"ID must be 4 bytes long."' "id");
Magic Number,TagLib.Riff,ListTag,C:\repos\mono_taglib-sharp\src\TagLib\Riff\ListTag.cs,GetValueAsUInt,The following statement contains a magic number: if (id.Count != 4)  				throw new ArgumentException (  					"ID must be 4 bytes long."' "id");
Magic Number,TagLib.Riff,ListTag,C:\repos\mono_taglib-sharp\src\TagLib\Riff\ListTag.cs,SetValue,The following statement contains a magic number: if (id.Count != 4)  				throw new ArgumentException (  					"ID must be 4 bytes long."' "id");
Magic Number,TagLib.Riff,ListTag,C:\repos\mono_taglib-sharp\src\TagLib\Riff\ListTag.cs,SetValue,The following statement contains a magic number: if (id.Count != 4)  				throw new ArgumentException (  					"ID must be 4 bytes long."' "id");
Magic Number,TagLib.Riff,ListTag,C:\repos\mono_taglib-sharp\src\TagLib\Riff\ListTag.cs,SetValue,The following statement contains a magic number: if (id.Count != 4)  				throw new ArgumentException (  					"ID must be 4 bytes long."' "id");
Magic Number,TagLib.Riff,ListTag,C:\repos\mono_taglib-sharp\src\TagLib\Riff\ListTag.cs,RemoveValue,The following statement contains a magic number: if (id.Count != 4)  				throw new ArgumentException (  					"ID must be 4 bytes long."' "id");
Magic Number,TagLib.Riff,WaveFormatEx,C:\repos\mono_taglib-sharp\src\TagLib\Riff\WaveFormatEx.cs,WaveFormatEx,The following statement contains a magic number: if (offset + 16 > data.Count)  				throw new CorruptFileException (  					"Expected 16 bytes.");
Magic Number,TagLib.Riff,WaveFormatEx,C:\repos\mono_taglib-sharp\src\TagLib\Riff\WaveFormatEx.cs,WaveFormatEx,The following statement contains a magic number: format_tag = data.Mid (offset' 2).ToUShort (false);
Magic Number,TagLib.Riff,WaveFormatEx,C:\repos\mono_taglib-sharp\src\TagLib\Riff\WaveFormatEx.cs,WaveFormatEx,The following statement contains a magic number: channels = data.Mid (offset + 2' 2).ToUShort (false);
Magic Number,TagLib.Riff,WaveFormatEx,C:\repos\mono_taglib-sharp\src\TagLib\Riff\WaveFormatEx.cs,WaveFormatEx,The following statement contains a magic number: channels = data.Mid (offset + 2' 2).ToUShort (false);
Magic Number,TagLib.Riff,WaveFormatEx,C:\repos\mono_taglib-sharp\src\TagLib\Riff\WaveFormatEx.cs,WaveFormatEx,The following statement contains a magic number: samples_per_second = data.Mid (offset + 4' 4)  				.ToUInt (false);
Magic Number,TagLib.Riff,WaveFormatEx,C:\repos\mono_taglib-sharp\src\TagLib\Riff\WaveFormatEx.cs,WaveFormatEx,The following statement contains a magic number: samples_per_second = data.Mid (offset + 4' 4)  				.ToUInt (false);
Magic Number,TagLib.Riff,WaveFormatEx,C:\repos\mono_taglib-sharp\src\TagLib\Riff\WaveFormatEx.cs,WaveFormatEx,The following statement contains a magic number: average_bytes_per_second = data.Mid (offset + 8' 4)  				.ToUInt (false);
Magic Number,TagLib.Riff,WaveFormatEx,C:\repos\mono_taglib-sharp\src\TagLib\Riff\WaveFormatEx.cs,WaveFormatEx,The following statement contains a magic number: average_bytes_per_second = data.Mid (offset + 8' 4)  				.ToUInt (false);
Magic Number,TagLib.Riff,WaveFormatEx,C:\repos\mono_taglib-sharp\src\TagLib\Riff\WaveFormatEx.cs,WaveFormatEx,The following statement contains a magic number: bits_per_sample = data.Mid (offset + 14' 2)  				.ToUShort (false);
Magic Number,TagLib.Riff,WaveFormatEx,C:\repos\mono_taglib-sharp\src\TagLib\Riff\WaveFormatEx.cs,WaveFormatEx,The following statement contains a magic number: bits_per_sample = data.Mid (offset + 14' 2)  				.ToUShort (false);
Magic Number,TagLib.Tiff,BaseTiffFile,C:\repos\mono_taglib-sharp\src\TagLib\Tiff\BaseTiffFile.cs,BaseTiffFile,The following statement contains a magic number: Magic = 42;
Magic Number,TagLib.Tiff,BaseTiffFile,C:\repos\mono_taglib-sharp\src\TagLib\Tiff\BaseTiffFile.cs,BaseTiffFile,The following statement contains a magic number: Magic = 42;
Magic Number,TagLib.Tiff,BaseTiffFile,C:\repos\mono_taglib-sharp\src\TagLib\Tiff\BaseTiffFile.cs,ReadHeader,The following statement contains a magic number: ByteVector header = ReadBlock (8);
Magic Number,TagLib.Tiff,BaseTiffFile,C:\repos\mono_taglib-sharp\src\TagLib\Tiff\BaseTiffFile.cs,ReadHeader,The following statement contains a magic number: if (header.Count != 8)  				throw new CorruptFileException ("Unexpected end of header");
Magic Number,TagLib.Tiff,BaseTiffFile,C:\repos\mono_taglib-sharp\src\TagLib\Tiff\BaseTiffFile.cs,ReadHeader,The following statement contains a magic number: string order = header.Mid (0' 2).ToString ();
Magic Number,TagLib.Tiff,BaseTiffFile,C:\repos\mono_taglib-sharp\src\TagLib\Tiff\BaseTiffFile.cs,ReadHeader,The following statement contains a magic number: if (header.Mid (2' 2).ToUShort (IsBigEndian) != Magic)  				throw new CorruptFileException (String.Format ("TIFF Magic ({0}) expected"' Magic));
Magic Number,TagLib.Tiff,BaseTiffFile,C:\repos\mono_taglib-sharp\src\TagLib\Tiff\BaseTiffFile.cs,ReadHeader,The following statement contains a magic number: if (header.Mid (2' 2).ToUShort (IsBigEndian) != Magic)  				throw new CorruptFileException (String.Format ("TIFF Magic ({0}) expected"' Magic));
Magic Number,TagLib.Tiff,BaseTiffFile,C:\repos\mono_taglib-sharp\src\TagLib\Tiff\BaseTiffFile.cs,ReadHeader,The following statement contains a magic number: uint first_ifd_offset = header.Mid (4' 4).ToUInt (IsBigEndian);
Magic Number,TagLib.Tiff,BaseTiffFile,C:\repos\mono_taglib-sharp\src\TagLib\Tiff\BaseTiffFile.cs,ReadHeader,The following statement contains a magic number: uint first_ifd_offset = header.Mid (4' 4).ToUInt (IsBigEndian);
Magic Number,TagLib.Tiff,BaseTiffFile,C:\repos\mono_taglib-sharp\src\TagLib\Tiff\BaseTiffFile.cs,ReadIFD,The following statement contains a magic number: try {  				length = Length;  			} catch (Exception) {  				// Use a safety-value of 4 gigabyte.  				length = 1073741824L * 4;  			}
Magic Number,TagLib.Tiff,File,C:\repos\mono_taglib-sharp\src\TagLib\Tiff\File.cs,WriteFile,The following statement contains a magic number: uint first_ifd_offset = 8;
Magic Number,TagLib.Tiff.Cr2,File,C:\repos\mono_taglib-sharp\src\TagLib\Tiff\Cr2\File.cs,ReadFile,The following statement contains a magic number: ReadIFD (first_ifd_offset' 3);
Magic Number,TagLib.Tiff.Cr2,File,C:\repos\mono_taglib-sharp\src\TagLib\Tiff\Cr2\File.cs,ReadAdditionalCR2Header,The following statement contains a magic number: ByteVector header = ReadBlock (8);
Magic Number,TagLib.Tiff.Cr2,File,C:\repos\mono_taglib-sharp\src\TagLib\Tiff\Cr2\File.cs,ReadAdditionalCR2Header,The following statement contains a magic number: if (header.Count != 8)  				throw new CorruptFileException ("Unexpected end of CR2 header");
Magic Number,TagLib.Tiff.Cr2,File,C:\repos\mono_taglib-sharp\src\TagLib\Tiff\Cr2\File.cs,ReadAdditionalCR2Header,The following statement contains a magic number: if (header.Mid (0' 2).ToString () != "CR")  				throw new CorruptFileException("CR2 Magic (CR) expected");
Magic Number,TagLib.Tiff.Cr2,File,C:\repos\mono_taglib-sharp\src\TagLib\Tiff\Cr2\File.cs,ReadAdditionalCR2Header,The following statement contains a magic number: byte major_version = header [2];
Magic Number,TagLib.Tiff.Cr2,File,C:\repos\mono_taglib-sharp\src\TagLib\Tiff\Cr2\File.cs,ReadAdditionalCR2Header,The following statement contains a magic number: byte minor_version = header [3];
Magic Number,TagLib.Tiff.Cr2,File,C:\repos\mono_taglib-sharp\src\TagLib\Tiff\Cr2\File.cs,ReadAdditionalCR2Header,The following statement contains a magic number: if (major_version != 2 || minor_version != 0)  				throw new UnsupportedFormatException ("Only major version 2 and minor version 0 are supported");
Magic Number,TagLib.Tiff.Cr2,File,C:\repos\mono_taglib-sharp\src\TagLib\Tiff\Cr2\File.cs,ReadAdditionalCR2Header,The following statement contains a magic number: uint raw_ifd_offset = header.Mid (4' 4).ToUInt (IsBigEndian);
Magic Number,TagLib.Tiff.Cr2,File,C:\repos\mono_taglib-sharp\src\TagLib\Tiff\Cr2\File.cs,ReadAdditionalCR2Header,The following statement contains a magic number: uint raw_ifd_offset = header.Mid (4' 4).ToUInt (IsBigEndian);
Magic Number,TagLib.Tiff.Rw2,File,C:\repos\mono_taglib-sharp\src\TagLib\Tiff\Rw2\File.cs,File,The following statement contains a magic number: Magic = 85;
Magic Number,TagLib.Tiff.Rw2,File,C:\repos\mono_taglib-sharp\src\TagLib\Tiff\Rw2\File.cs,ReadFile,The following statement contains a magic number: ReadIFD (first_ifd_offset' 3);
Magic Number,TagLib.Tiff.Rw2,File,C:\repos\mono_taglib-sharp\src\TagLib\Tiff\Rw2\File.cs,ReadAdditionalRW2Header,The following statement contains a magic number: ByteVector header = ReadBlock (16);
Magic Number,TagLib.Tiff.Rw2,File,C:\repos\mono_taglib-sharp\src\TagLib\Tiff\Rw2\File.cs,ReadAdditionalRW2Header,The following statement contains a magic number: if (header.Count != 16)  				throw new CorruptFileException ("Unexpected end of RW2 header");
Magic Number,TagLib.WavPack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\WavPack\StreamHeader.cs,StreamHeader,The following statement contains a magic number: version = data.Mid (8' 2).ToUShort (false);
Magic Number,TagLib.WavPack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\WavPack\StreamHeader.cs,StreamHeader,The following statement contains a magic number: version = data.Mid (8' 2).ToUShort (false);
Magic Number,TagLib.WavPack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\WavPack\StreamHeader.cs,StreamHeader,The following statement contains a magic number: flags = data.Mid (24' 4).ToUInt (false);
Magic Number,TagLib.WavPack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\WavPack\StreamHeader.cs,StreamHeader,The following statement contains a magic number: flags = data.Mid (24' 4).ToUInt (false);
Magic Number,TagLib.WavPack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\WavPack\StreamHeader.cs,StreamHeader,The following statement contains a magic number: samples = data.Mid (12' 4).ToUInt (false);
Magic Number,TagLib.WavPack,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\WavPack\StreamHeader.cs,StreamHeader,The following statement contains a magic number: samples = data.Mid (12' 4).ToUInt (false);
Magic Number,TagLib.Xmp,XmpTag,C:\repos\mono_taglib-sharp\src\TagLib\Xmp\XmpTag.cs,ParsePropertyElement,The following statement contains a magic number: if (count > 3) {  				ParseEmptyPropertyElement (parent' node);  			} else {  				if (!has_other) {  					if (!node.HasChildNodes) {  						ParseEmptyPropertyElement (parent' node);  					} else {  						bool only_text = true;  						foreach (XmlNode child in node.ChildNodes) {  							if (!(child is XmlText))  								only_text = false;  						}    						if (only_text) {  							ParseLiteralPropertyElement (parent' node);  						} else {  							ParseResourcePropertyElement (parent' node);  						}  					}  				} else {  					foreach (XmlAttribute attr in node.Attributes) {  						if (attr.Is (XML_NS' LANG_URI) || attr.Is (RDF_NS' ID_URI) || attr.In (XMLNS_NS))  							continue;    						if (attr.Is (RDF_NS' DATA_TYPE_URI)) {  							ParseLiteralPropertyElement (parent' node);  						} else if (!attr.Is (RDF_NS' PARSE_TYPE_URI)) {  							ParseEmptyPropertyElement (parent' node);  						} else if (attr.InnerText.Equals ("Resource")) {  							ParseTypeResourcePropertyElement (parent' node);  						} else {  							// Neither Literal' Collection or anything else is allowed  							throw new CorruptFileException (String.Format ("This is not allowed in XMP! Bad XMP: {0}"' node.OuterXml));  						}  					}  				}  			}
Magic Number,TagLib.Xmp,XmpTag,C:\repos\mono_taglib-sharp\src\TagLib\Xmp\XmpTag.cs,GetRationalNode,The following statement contains a magic number: if (values.Length != 2) {    				// but we also try to parse a double value directly.  				double result;  				if (Double.TryParse (text' out result))  					return result;    				return null;  			}
Magic Number,TagLib.Xmp,XmpTag,C:\repos\mono_taglib-sharp\src\TagLib\Xmp\XmpTag.cs,SetRationalNode,The following statement contains a magic number: string fraction = DecimalToFraction (value' (long) Math.Pow (10' 10));
Magic Number,TagLib.Xmp,XmpTag,C:\repos\mono_taglib-sharp\src\TagLib\Xmp\XmpTag.cs,SetRationalNode,The following statement contains a magic number: string fraction = DecimalToFraction (value' (long) Math.Pow (10' 10));
Magic Number,TagLib.Xmp,XmpTag,C:\repos\mono_taglib-sharp\src\TagLib\Xmp\XmpTag.cs,DecimalToFraction,The following statement contains a magic number: var m = new long [2' 2];
Magic Number,TagLib.Xmp,XmpTag,C:\repos\mono_taglib-sharp\src\TagLib\Xmp\XmpTag.cs,DecimalToFraction,The following statement contains a magic number: var m = new long [2' 2];
Missing Default,TagLib,ByteVector,C:\repos\mono_taglib-sharp\src\TagLib\ByteVector.cs,StringTypeToEncoding,The following switch statement is missing a default case: switch(type) {  			case StringType.UTF16:  				// If we have a BOM' return the appropriate  				// encoding. Otherwise' assume we're reading  				// from a string that was already identified. In  				// that case' the encoding will be stored as  				// last_utf16_encoding.  				  				if (bom == null)  					return last_utf16_encoding;  				  				if (bom [0] == 0xFF && bom [1] == 0xFE)  					return last_utf16_encoding =  						Encoding.Unicode;  				  				if (bom [1] == 0xFF && bom [0] == 0xFE)  					return last_utf16_encoding =  						Encoding.BigEndianUnicode;  				  				return last_utf16_encoding;  				  			case StringType.UTF16BE:  				return Encoding.BigEndianUnicode;  				  			case StringType.UTF8:  				return Encoding.UTF8;  				  			case StringType.UTF16LE:  				return Encoding.Unicode;  			}
Missing Default,TagLib,Picture,C:\repos\mono_taglib-sharp\src\TagLib\Picture.cs,FillInMimeFromExt,The following switch statement is missing a default case: switch (ext)  			{  				case ".aac": mime_type = "audio/aac"; break; // AAC audio file  				case ".abw": mime_type = "application/x-abiword"; break; // AbiWord document  				case ".arc": mime_type = "application/octet-stream"; break; // Archive document (multiple files embedded)  				case ".avi": mime_type = "video/x-msvideo"; break; // AVI: Audio Video Interleave  				case ".azw": mime_type = "application/vnd.amazon.ebook"; break; // Amazon Kindle eBook format  				case ".bin": mime_type = "application/octet-stream"; break; // Any kind of binary data  				case ".bz": mime_type = "application/x-bzip"; break; // BZip archive  				case ".bz2": mime_type = "application/x-bzip2"; break; // BZip2 archive  				case ".csh": mime_type = "application/x-csh"; break; // C-Shell script  				case ".css": mime_type = "text/css"; break; // Cascading Style Sheets (CSS)  				case ".csv": mime_type = "text/csv"; break; // Comma-separated values (CSV)  				case ".doc": mime_type = "application/msword"; break; // Microsoft Word  				case ".eot": mime_type = "application/vnd.ms-fontobject"; break; // MS Embedded OpenType fonts  				case ".epub": mime_type = "application/epub+zip"; break; // Electronic publication (EPUB)  				case ".gif":  mime_type = "image/gif"; break; // Graphics Interchange Format (GIF)  				case ".htm":  				case ".html": mime_type = "text/html"; break; // HyperText Markup Language (HTML)text / html  				case ".ico": mime_type = "image/x-icon"; break; // Icon format  				case ".ics": mime_type = "text/calendar"; break; // iCalendar format  				case ".jar": mime_type = "application/java-archive"; break; // Java Archive (JAR)  				case ".jpeg":  				case ".jpg": mime_type = "image/jpeg"; break; // JPEG images  				case ".js": mime_type = "application/javascript"; break; // JavaScript (ECMAScript)  				case ".json": mime_type = "application/json"; break; // JSON format  				case ".mid":  				case ".midi": mime_type = "audio/midi"; break; // Musical Instrument Digital Interface (MIDI)  				case ".mp1":  				case ".mp2":  				case ".mp3":  				case ".mpg": mime_type = "audio/mpeg"; break;  				case ".mpeg": mime_type = "video/mpeg"; break; // MPEG Video  				case ".m4a": mime_type = "audio/mp4"; break;  				case ".mp4":  				case ".m4v": mime_type = "video/mp4"; break;  				case ".mpkg": mime_type = "application/vnd.apple.installer+xml"; break; // Apple Installer Package  				case ".odp": mime_type = "application/vnd.oasis.opendocument.presentation"; break; // OpenDocuemnt presentation document  				case ".ods": mime_type = "application/vnd.oasis.opendocument.spreadsheet"; break; // OpenDocuemnt spreadsheet document  				case ".odt": mime_type = "application/vnd.oasis.opendocument.text"; break; // OpenDocument text document  				case ".oga": mime_type = "audio/ogg"; break; // OGG audio  				case ".ogg": mime_type = "audio/ogg"; break;  				case ".ogx": mime_type = "application/ogg"; break; // OGG  				case ".ogv": mime_type = "video/ogg"; break;  				case ".otf": mime_type = "font/otf"; break; // OpenType font  				case ".png": mime_type = "image/png"; break; // Portable Network Graphics  				case ".pdf": mime_type = "application/pdf"; break; // Adobe Portable Document Format (PDF)  				case ".ppt": mime_type = "application/vnd.ms-powerpoint"; break; // Microsoft PowerPoint  				case ".rar": mime_type = "application/x-rar-compressed"; break; // RAR archive  				case ".rtf": mime_type = "application/rtf"; break; // Rich Text Format (RTF)  				case ".sh": mime_type = "application/x-sh"; break; // Bourne shell script  				case ".svg": mime_type = "image/svg+xml"; break; // Scalable Vector Graphics (SVG)  				case ".swf": mime_type = "application/x-shockwave-flash"; break; // Small web format (SWF) or Adobe Flash document  				case ".tar": mime_type = "application/x-tar"; break; // Tape Archive (TAR)  				case ".tif":  				case ".tiff": mime_type = "image/tiff"; break; //  Tagged Image File Format(TIFF)  				case ".ts": mime_type = "video/vnd.dlna.mpeg-tts"; break; // Typescript file  				case ".ttf": mime_type = "font/ttf"; break; // TrueType Font  				case ".vsd": mime_type = "application/vnd.visio"; break; // Microsoft Visio  				case ".wav": mime_type = "audio/x-wav"; break; // Waveform Audio Format  				case ".weba": mime_type = "audio/webm"; break; // WEBM audio  				case ".webm": mime_type = "video/webm"; break; // WEBM video  				case ".webp": mime_type = "image/webp"; break; // WEBP image  				case ".woff": mime_type = "font/woff"; break; // Web Open Font Format (WOFF)  				case ".woff2": mime_type = "font/woff2"; break; // Web Open Font Format (WOFF)  				case ".xhtml": mime_type = "application/xhtml+xml"; break; // XHTML  				case ".xls": mime_type = "application/vnd.ms"; break; // excel application  				case ".xlsx": mime_type = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"; break; // excel 2007 application  				case ".xml": mime_type = "application/xml"; break; // XML  				case ".xul": mime_type = "application/vnd.mozilla.xul+xml"; break; // XUL  				case ".zip": mime_type = "application/zip"; break; // ZIP archive  				case ".3gp": mime_type = "video/3gpp"; break; // 3GPP audio/video container  				case "audio/3gpp": mime_type = "video"; break; // if it doesn't contain  				case ".3g2": mime_type = "video/3gpp2"; break; // 3GPP2 audio/video container  				case "audio/3gpp2": mime_type = "video"; break; // if it doesn't contain  				case ".7z": mime_type = "application/x-7z-compressed"; break; // 7-zip archive  			}
Missing Default,TagLib.Matroska,Tag,C:\repos\mono_taglib-sharp\src\TagLib\Matroska\Tag.cs,MakeTargetType,The following switch statement is missing a default case: switch (targetTypeValue)  			{  				case 70: ret = TargetType.COLLECTION; break;  				case 60: ret = IsVideo ? TargetType.SEASON : TargetType.VOLUME; break;  				case 50: ret = IsVideo ? TargetType.MOVIE : TargetType.ALBUM; break;  				case 40: ret = TargetType.PART; break;  				case 30: ret = IsVideo ? TargetType.CHAPTER : TargetType.TRACK; break;  				case 20: ret = IsVideo ? TargetType.SCENE : TargetType.MOVEMENT; break;  				case 10: ret = TargetType.SHOT; break;  			}
Missing Default,TagLib.Aiff,File,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\File.cs,GetTag,The following switch statement is missing a default case: switch (type)  			{  				case TagTypes.Id3v2:  					if (tag == null && create)  					{  						tag = new Id3v2.Tag();  						tag.Version = 2;  					}    					id32_tag = tag;  					break;  			}
Missing Default,TagLib.Aiff,StreamHeader,C:\repos\mono_taglib-sharp\src\TagLib\Aiff\StreamHeader.cs,StreamHeader,The following switch statement is missing a default case: switch (sample_rate_tmp)  			{  				case 44100:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 44100;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22050;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11025;  					}  					break;    				case 48000:  					if (sample_rate_indicator == 0x0E)  					{  						sample_rate = 48000;  					}  					else if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 24000;  					}  					break;    				case 64000:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 32000;  					}  					else if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 16000;  					}  					else if (sample_rate_indicator == 0x0B)  					{  						sample_rate = 8000;  					}  					break;    				case 44510:  					if (sample_rate_indicator == 0x0D)  					{  						sample_rate = 22255;  					}  					break;    				case 44508:  					if (sample_rate_indicator == 0x0C)  					{  						sample_rate = 11127;  					}  					break;  			}
Missing Default,TagLib.Dsf,File,C:\repos\mono_taglib-sharp\src\TagLib\Dsf\File.cs,GetTag,The following switch statement is missing a default case: switch (type)  			{  				case TagTypes.Id3v2:  					if (tag == null && create)  					{  						tag = new Id3v2.Tag();  						tag.Version = 2;  					}    					id32_tag = tag;  					break;  			}
Missing Default,TagLib.Flac,File,C:\repos\mono_taglib-sharp\src\TagLib\Flac\File.cs,GetTag,The following switch statement is missing a default case: switch (type)  			{  			case TagTypes.Xiph:  				return metadata.GetComment (create' tag);  				  			case TagTypes.FlacMetadata:  				return metadata;  			}
Missing Default,TagLib.IIM,IIMReader,C:\repos\mono_taglib-sharp\src\TagLib\IIM\IIMReader.cs,Process,The following switch statement is missing a default case: switch (Data [i]) {  					case 5: // Object Name  						Tag.Title = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 25: // Keywords  						Tag.AddKeyword (Data.ToString (StringType.Latin1' i + 3' len));  						break;  					case 80: // By-line  						Tag.Creator = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 116: // Copyright notice  						Tag.Copyright = Data.ToString (StringType.Latin1' i + 3' len);  						break;  					case 120: // Caption/Abstract  						Tag.Comment = Data.ToString (StringType.Latin1' i + 3' len);  						break;  				}
Missing Default,TagLib.Image,File,C:\repos\mono_taglib-sharp\src\TagLib\Image\File.cs,GetTag,The following switch statement is missing a default case: switch (type) {  			case TagTypes.JpegComment:  				new_tag = new JpegCommentTag ();  				break;    			case TagTypes.GifComment:  				new_tag = new GifCommentTag ();  				break;    			case TagTypes.Png:  				new_tag = new PngTag ();  				break;    			case TagTypes.TiffIFD:  				new_tag = new IFDTag ();  				break;    			case TagTypes.XMP:  				new_tag = new XmpTag ();  				break;  			}
Missing Default,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadMetadata,The following switch statement is missing a default case: switch (marker) {  				case Marker.APP0:	// possibly JFIF header  					ReadJFIFHeader (data_size);  					break;    				case Marker.APP1:	// possibly Exif or Xmp data found  					ReadAPP1Segment (data_size);  					break;    				case Marker.APP13: // possibly IPTC-IIM  					ReadAPP13Segment (data_size);  					break;    				case Marker.COM:	// Comment segment found  					ReadCOMSegment (data_size);  					break;    				case Marker.SOF0:  				case Marker.SOF1:  				case Marker.SOF2:  				case Marker.SOF3:  				case Marker.SOF9:  				case Marker.SOF10:  				case Marker.SOF11:  					ReadSOFSegment (data_size' marker);  					break;    				case Marker.DQT:	// Quantization table(s)' use it to guess quality  					ReadDQTSegment (data_size);  					break;  				}
Missing Default,TagLib.Jpeg,File,C:\repos\mono_taglib-sharp\src\TagLib\Jpeg\File.cs,ReadDQTSegment,The following switch statement is missing a default case: switch (tq) {  				case 0:  					table = Table.StandardLuminanceQuantization;  					break;  				case 1:  					table = Table.StandardChrominanceQuantization;  					break;  				}
Missing Default,TagLib.NonContainer,EndTag,C:\repos\mono_taglib-sharp\src\TagLib\NonContainer\EndTag.cs,ReadTag,The following switch statement is missing a default case: switch (type)  				{  				case TagTypes.Ape:  					tag = new TagLib.Ape.Tag (file' end - TagLib.Ape.Footer.Size);  					break;  				case TagTypes.Id3v2:  					tag = new TagLib.Id3v2.Tag (file' start);  					break;  				case TagTypes.Id3v1:  					tag = new TagLib.Id3v1.Tag (file' start);  					break;  				}
Missing Default,TagLib.NonContainer,StartTag,C:\repos\mono_taglib-sharp\src\TagLib\NonContainer\StartTag.cs,ReadTag,The following switch statement is missing a default case: switch (type) {  				case TagTypes.Ape:  					tag = new TagLib.Ape.Tag (file' start);  					break;  				case TagTypes.Id3v2:  					tag = new TagLib.Id3v2.Tag (file' start);  					break;  			}
Missing Default,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,GetTag,The following switch statement is missing a default case: switch (type)  			{  			case TagTypes.Id3v2:  				if (id32_tag == null && create) {  					id32_tag = new Id3v2.Tag ();  					id32_tag.Version = 4;  					id32_tag.Flags |= Id3v2.HeaderFlags  						.FooterPresent;  					this.tag.CopyTo (id32_tag' true);  				}  				  				tag = id32_tag;  				break;  				  			case TagTypes.RiffInfo:  				if (info_tag == null && create) {  					info_tag = new InfoTag ();  					this.tag.CopyTo (info_tag' true);  				}  				  				tag = info_tag;  				break;  				  			case TagTypes.MovieId:  				if (mid_tag == null && create) {  					mid_tag = new MovieIdTag ();  					this.tag.CopyTo (mid_tag' true);  				}  				  				tag = mid_tag;  				break;  				  			case TagTypes.DivX:  				if (divx_tag == null && create) {  					divx_tag = new DivXTag ();  					this.tag.CopyTo (divx_tag' true);  				}  				  				tag = divx_tag;  				break;  			}
Missing Default,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Read,The following switch statement is missing a default case: switch (fourcc)  				{  				  				// "fmt " is used by Wave files to hold the  				// WaveFormatEx structure.  				case "fmt ":  					if (style == ReadStyle.None ||  						stream_format != "WAVE")  						break;  					  					Seek (position + 8);  					codecs = new ICodec [] {  						new WaveFormatEx (ReadBlock (18)' 0)  					};  					break;  				  				// "data" contains the audio data for wave  				// files. It's contents represent the invariant  				// portion of the file and is used to determine  				// the duration of a file. It should always  				// appear after "fmt ".  				case "data":  					if (stream_format != "WAVE")  						break;  					  					InvariantStartPosition = position;  					InvariantEndPosition = position + size;  					  					if (style == ReadStyle.None ||  						codecs.Length != 1 ||  						!(codecs [0] is WaveFormatEx))  						break;  					  					duration += TimeSpan.FromSeconds (  						(double) size / (double)  						((WaveFormatEx) codecs [0])  							.AverageBytesPerSecond);  					  					break;  				  				// Lists are used to store a variety of data  				// collections. Read the type and act on it.  				case "LIST":  				{  					switch (ReadBlock (4).ToString (StringType.UTF8))  					{  					  					// "hdlr" is used by AVI files to hold  					// a media header and BitmapInfoHeader  					// and WaveFormatEx structures.  					case "hdrl":  						if (style == ReadStyle.None ||  							stream_format != "AVI ")  							continue;  						  						AviHeaderList header_list =  							new AviHeaderList (this'  								position + 12'  								(int) (size - 4));  						duration = header_list.Header.Duration;  						codecs = header_list.Codecs;  						break;  					  					// "INFO" is a tagging format handled by  					// the InfoTag class.  					case "INFO":  						if (read_tags && info_tag == null)  							info_tag = new InfoTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "MID " is a tagging format handled by  					// the MovieIdTag class.  					case "MID ":  						if (read_tags && mid_tag == null)  							mid_tag = new MovieIdTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "movi" contains the media data for  					// and AVI and its contents represent  					// the invariant portion of the file.  					case "movi":  						if (stream_format != "AVI ")  							break;  						  						InvariantStartPosition = position;  						InvariantEndPosition = position + size;  						break;  					}  					break;  				}  				  				// "ID32" is a custom box for this format that  				// contains an ID3v2 tag.  				case "ID32":  					if (read_tags && id32_tag == null)  						id32_tag = new Id3v2.Tag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "IDVX" is used by DivX and holds an ID3v1-  				// style tag.  				case "IDVX":  					if (read_tags && divx_tag == null)  						divx_tag = new DivXTag (this'  							position + 8);  					  					tag_found = true;  					break;  				  				// "JUNK" is a padding element that could be  				// associated with tag data.  				case "JUNK":  					if (tag_end == position)  						tag_end = position + 8 + size;  					break;  				}
Missing Default,TagLib.Riff,File,C:\repos\mono_taglib-sharp\src\TagLib\Riff\File.cs,Read,The following switch statement is missing a default case: switch (ReadBlock (4).ToString (StringType.UTF8))  					{  					  					// "hdlr" is used by AVI files to hold  					// a media header and BitmapInfoHeader  					// and WaveFormatEx structures.  					case "hdrl":  						if (style == ReadStyle.None ||  							stream_format != "AVI ")  							continue;  						  						AviHeaderList header_list =  							new AviHeaderList (this'  								position + 12'  								(int) (size - 4));  						duration = header_list.Header.Duration;  						codecs = header_list.Codecs;  						break;  					  					// "INFO" is a tagging format handled by  					// the InfoTag class.  					case "INFO":  						if (read_tags && info_tag == null)  							info_tag = new InfoTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "MID " is a tagging format handled by  					// the MovieIdTag class.  					case "MID ":  						if (read_tags && mid_tag == null)  							mid_tag = new MovieIdTag (  								this'  								position + 12'  								(int) (size - 4));  						  						tag_found = true;  						break;  					  					// "movi" contains the media data for  					// and AVI and its contents represent  					// the invariant portion of the file.  					case "movi":  						if (stream_format != "AVI ")  							break;  						  						InvariantStartPosition = position;  						InvariantEndPosition = position + size;  						break;  					}
