Implementation smell,Namespace,Class,File,Method,Description
Long Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseMediaQuery,The method has 105 lines of code.
Long Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseMediaQueryExpression,The method has 135 lines of code.
Long Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseTypeOrUniversalSelector,The method has 110 lines of code.
Long Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseAttributeSelector,The method has 212 lines of code.
Long Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParsePseudoSelector,The method has 224 lines of code.
Long Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParsePseudoClassWithNthPairArg,The method has 112 lines of code.
Long Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseColor,The method has 101 lines of code.
Long Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseDeclaration,The method has 119 lines of code.
Long Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseVariant,The method has 248 lines of code.
Long Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseFlex,The method has 113 lines of code.
Long Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseRadialGradient,The method has 137 lines of code.
Long Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParsePropertyByFunction,The method has 198 lines of code.
Long Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBackgroundItem,The method has 184 lines of code.
Long Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBackgroundPositionValues,The method has 179 lines of code.
Long Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseFont,The method has 106 lines of code.
Long Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The method has 183 lines of code.
Long Method,Alba.CsCss.Style,nsCSSProps,C:\repos\Athari_CsCss\Alba.CsCss\Style\nsCSSProps.cs,nsCSSProps,The method has 303 lines of code.
Long Method,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,ScanNumber,The method has 136 lines of code.
Long Method,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,Next,The method has 122 lines of code.
Long Method,Alba.CsCss.Style,CssToken,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssToken.conv.cs,AppendToString,The method has 101 lines of code.
Complex Method,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,LooseHexToRGB,Cyclomatic complexity of the method is 9
Complex Method,Alba.CsCss.Gfx,nsFont,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\nsFont.cs,EnumerateFamilies,Cyclomatic complexity of the method is 10
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseSheet,Cyclomatic complexity of the method is 14
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseProperty,Cyclomatic complexity of the method is 12
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,SkipAtRule,Cyclomatic complexity of the method is 8
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseMediaQuery,Cyclomatic complexity of the method is 16
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GatherMedia,Cyclomatic complexity of the method is 8
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseMediaQueryExpression,Cyclomatic complexity of the method is 19
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseGroupRule,Cyclomatic complexity of the method is 8
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseFontFaceRule,Cyclomatic complexity of the method is 13
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseFontDescriptor,Cyclomatic complexity of the method is 10
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseKeyframesRule,Cyclomatic complexity of the method is 9
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseSupportsConditionNegation,Cyclomatic complexity of the method is 8
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseSupportsConditionInParens,Cyclomatic complexity of the method is 14
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,SkipDeclaration,Cyclomatic complexity of the method is 10
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseSelectorList,Cyclomatic complexity of the method is 10
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseSelectorGroup,Cyclomatic complexity of the method is 9
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseTypeOrUniversalSelector,Cyclomatic complexity of the method is 8
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseAttributeSelector,Cyclomatic complexity of the method is 22
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParsePseudoSelector,Cyclomatic complexity of the method is 20
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseNegatedSimpleSelector,Cyclomatic complexity of the method is 11
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParsePseudoClassWithIdentArg,Cyclomatic complexity of the method is 10
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParsePseudoClassWithNthPairArg,Cyclomatic complexity of the method is 21
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseSelector,Cyclomatic complexity of the method is 15
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseDeclarationBlock,Cyclomatic complexity of the method is 10
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseColorComponent,Cyclomatic complexity of the method is 8
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseHSLColor,Cyclomatic complexity of the method is 23
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseColorOpacity,Cyclomatic complexity of the method is 8
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseDeclaration,Cyclomatic complexity of the method is 14
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseVariant,Cyclomatic complexity of the method is 50
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseCounter,Cyclomatic complexity of the method is 11
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseAttr,Cyclomatic complexity of the method is 9
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseFlex,Cyclomatic complexity of the method is 10
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseLinearGradient,Cyclomatic complexity of the method is 12
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseRadialGradient,Cyclomatic complexity of the method is 17
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBoxProperties,Cyclomatic complexity of the method is 9
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBoxCornerRadii,Cyclomatic complexity of the method is 16
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseSingleValueProperty,Cyclomatic complexity of the method is 9
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBoxPositionValues,Cyclomatic complexity of the method is 10
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBorderSide,Cyclomatic complexity of the method is 9
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseCalcMultiplicativeExpression,Cyclomatic complexity of the method is 10
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseCalcTerm,Cyclomatic complexity of the method is 8
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseCounterData,Cyclomatic complexity of the method is 8
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseFont,Cyclomatic complexity of the method is 11
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseFamily,Cyclomatic complexity of the method is 13
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseFontSrc,Cyclomatic complexity of the method is 8
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseFontRanges,Cyclomatic complexity of the method is 10
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseFontFeatureSettings,Cyclomatic complexity of the method is 8
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseListStyle,Cyclomatic complexity of the method is 9
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseTransitionStepTimingFunctionValues,Cyclomatic complexity of the method is 8
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseAnimationOrTransitionShorthand,Cyclomatic complexity of the method is 16
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseShadowItem,Cyclomatic complexity of the method is 9
Complex Method,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParsePaintOrder,Cyclomatic complexity of the method is 12
Complex Method,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,ScanNumber,Cyclomatic complexity of the method is 12
Complex Method,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,Next,Cyclomatic complexity of the method is 22
Long Parameter List,Alba.CsCss.Gfx,nsFont,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\nsFont.cs,nsFont,The method has 10 parameters. Parameters: name' style' systemFont' variant' decorations' weight' stretch' size' sizeAdjust' languageOverride
Long Parameter List,Alba.CsCss.Gfx,nsFont,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\nsFont.cs,nsFont,The method has 10 parameters. Parameters: name' style' systemFont' variant' decorations' weight' stretch' size' sizeAdjust' languageOverride
Long Parameter List,Alba.CsCss.Internal.Extensions,StringBuilderExts,C:\repos\Athari_CsCss\Alba.CsCss\Internal\Extensions\StringBuilderExts.cs,Trim,The method has 5 parameters. Parameters: this' aSet' aLeading' aTrailing' unused
Long Parameter List,Alba.CsCss.Style,CssMediaFeature,C:\repos\Athari_CsCss\Alba.CsCss\Style\Media\CssMediaFeature.cs,CssMediaFeature,The method has 5 parameters. Parameters: aName' aRangeType' aValueType' aKeywordTable' aMetric
Long Parameter List,Alba.CsCss.Style,CssAttrSelector,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssAttrSelector.cs,CssAttrSelector,The method has 5 parameters. Parameters: aNameSpace' aAttr' aFunction' aValue' aCaseSensitive
Long Parameter List,Alba.CsCss.Style,nsCSSExpandedDataBlock,C:\repos\Athari_CsCss\Alba.CsCss\Style\nsCSSExpandedDataBlock.cs,TransferFromBlock,The method has 6 parameters. Parameters: aFromBlock' aPropID' aIsImportant' aOverrideImportant' aMustCallValueAppended' aDeclaration
Long Parameter List,Alba.CsCss.Style,nsCSSExpandedDataBlock,C:\repos\Athari_CsCss\Alba.CsCss\Style\nsCSSExpandedDataBlock.cs,DoTransferFromBlock,The method has 6 parameters. Parameters: aFromBlock' aPropID' aIsImportant' aOverrideImportant' aMustCallValueAppended' aDeclaration
Long Parameter List,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,InitScanner,The method has 5 parameters. Parameters: aScanner' aReporter' aSheetURI' aBaseURI' aSheetPrincipal
Long Parameter List,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseSheet,The method has 6 parameters. Parameters: aInput' aSheetURI' aBaseURI' aSheetPrincipal' aLineNumber' aAllowUnsafeRules
Long Parameter List,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseStyleAttribute,The method has 5 parameters. Parameters: aAttributeValue' aDocURI' aBaseURI' aNodePrincipal' aResult
Long Parameter List,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseDeclarations,The method has 6 parameters. Parameters: aBuffer' aSheetURI' aBaseURI' aSheetPrincipal' aDeclaration' aChanged
Long Parameter List,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseRule,The method has 5 parameters. Parameters: aRule' aSheetURI' aBaseURI' aSheetPrincipal' aResult
Long Parameter List,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseProperty,The method has 9 parameters. Parameters: aPropID' aPropValue' aSheetURI' aBaseURI' aSheetPrincipal' aDeclaration' aChanged' aIsImportant' aIsSVGMode
Long Parameter List,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseMediaList,The method has 5 parameters. Parameters: aBuffer' aURI' aLineNumber' aMediaList' aHTMLMode
Long Parameter List,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,EvaluateSupportsDeclaration,The method has 5 parameters. Parameters: aProperty' aValue' aDocURL' aBaseURL' aDocPrincipal
Long Parameter List,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParsePseudoSelector,The method has 6 parameters. Parameters: aDataMask' aSelector' aIsNegated' aPseudoElement' aPseudoElementArgs' aPseudoElementType
Long Parameter List,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseDeclaration,The method has 5 parameters. Parameters: aDeclaration' aFlags' aMustCallValueAppended' aChanged' aContext
Long Parameter List,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseFunction,The method has 5 parameters. Parameters: aFunction' aAllowedTypes' aMinElems' aMaxElems' aValue
Long Parameter List,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The method has 6 parameters. Parameters: aToken' aIsPrefixed' aMinElems' aMaxElems' aVariantMask' aIs3D
Long Parameter List,Alba.CsCss.Style,BackgroundParseState,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,BackgroundParseState,The method has 8 parameters. Parameters: mColor' mImage' mRepeat' mAttachment' mClip' mOrigin' mPosition' mSize
Long Parameter List,Alba.CsCss.Style,CssSelector,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssSelector.cs,AddAttribute,The method has 5 parameters. Parameters: aNameSpace' aAttr' aFunc' aValue' aCaseSensitive
Long Identifier,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The length of the parameter eTwoLengthPercentCalcsOneLengthCalc is 35.
Long Identifier,Alba.CsCss.Style,nsCSSProps,C:\repos\Athari_CsCss\Alba.CsCss\Style\nsCSSProps.cs,,The length of the parameter kAnimationIterationCountKTable is 30.
Long Identifier,Alba.CsCss.Style,nsCSSProps,C:\repos\Athari_CsCss\Alba.CsCss\Style\nsCSSProps.cs,,The length of the parameter kRadialGradientLegacySizeKTable is 31.
Long Identifier,Alba.CsCss.Style,nsCSSProps,C:\repos\Athari_CsCss\Alba.CsCss\Style\nsCSSProps.cs,,The length of the parameter kTransitionTimingFunctionKTable is 31.
Long Identifier,Alba.CsCss.Style,nsCSSProps,C:\repos\Athari_CsCss\Alba.CsCss\Style\nsCSSProps.cs,,The length of the parameter APPLIES_TO_FIRST_LETTER_AND_FIRST_LINE is 38.
Long Identifier,Alba.CsCss.Style,CssStyle,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\nsStyle.nsIWidget.conv.cs,,The length of the parameter ColorMozDefaultBackgroundColor is 30.
Long Identifier,Alba.CsCss.Style,CssStyle,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\nsStyle.nsIWidget.conv.cs,,The length of the parameter AnimationDirectionAlternateReverse is 34.
Long Identifier,Alba.CsCss.Style,CssStyle,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\nsStyle.nsIWidget.conv.cs,,The length of the parameter AnimationIterationCountInfinite is 31.
Long Identifier,Alba.CsCss.Style,CssStyle,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\nsStyle.nsIWidget.conv.cs,,The length of the parameter MathmlDefaultScriptSizeMultiplier is 33.
Long Identifier,Alba.CsCss.Style,CssStyle,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\nsStyle.nsIWidget.conv.cs,,The length of the parameter ListStyleMozTradChineseInformal is 31.
Long Identifier,Alba.CsCss.Style,CssStyle,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\nsStyle.nsIWidget.conv.cs,,The length of the parameter ListStyleMozSimpChineseInformal is 31.
Long Identifier,Alba.CsCss.Style,CssStyle,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\nsStyle.nsIWidget.conv.cs,,The length of the parameter ListStyleMozEthiopicHalehameAm is 30.
Long Identifier,Alba.CsCss.Style,CssStyle,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\nsStyle.nsIWidget.conv.cs,,The length of the parameter ListStyleMozEthiopicHalehameTiEr is 32.
Long Identifier,Alba.CsCss.Style,CssStyle,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\nsStyle.nsIWidget.conv.cs,,The length of the parameter ListStyleMozEthiopicHalehameTiEt is 32.
Long Identifier,Alba.CsCss.Style,CssStyle,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\nsStyle.nsIWidget.conv.cs,,The length of the parameter TransitionTimingFunctionLinear is 30.
Long Identifier,Alba.CsCss.Style,CssStyle,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\nsStyle.nsIWidget.conv.cs,,The length of the parameter TransitionTimingFunctionEaseIn is 30.
Long Identifier,Alba.CsCss.Style,CssStyle,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\nsStyle.nsIWidget.conv.cs,,The length of the parameter TransitionTimingFunctionEaseOut is 31.
Long Identifier,Alba.CsCss.Style,CssStyle,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\nsStyle.nsIWidget.conv.cs,,The length of the parameter TransitionTimingFunctionEaseInOut is 33.
Long Identifier,Alba.CsCss.Style,CssStyle,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\nsStyle.nsIWidget.conv.cs,,The length of the parameter TransitionTimingFunctionStepStart is 33.
Long Identifier,Alba.CsCss.Style,CssStyle,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\nsStyle.nsIWidget.conv.cs,,The length of the parameter TransitionTimingFunctionStepEnd is 31.
Long Identifier,Alba.CsCss.Style,CssStyle,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\nsStyle.nsIWidget.conv.cs,,The length of the parameter VerticalAlignMiddleWithBaseline is 31.
Long Identifier,Alba.CsCss.Style,CssStyle,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\nsStyle.nsIWidget.conv.cs,,The length of the parameter DominantBaselineTextBeforeEdge is 30.
Long Identifier,Alba.CsCss.Style,CssStyle,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\nsStyle.nsIWidget.conv.cs,,The length of the parameter ShapeRenderingGeometricprecision is 32.
Long Identifier,Alba.CsCss.Style,CssStyle,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\nsStyle.nsIWidget.conv.cs,,The length of the parameter TextRenderingOptimizelegibility is 31.
Long Identifier,Alba.CsCss.Style,CssStyle,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\nsStyle.nsIWidget.conv.cs,,The length of the parameter TextRenderingGeometricprecision is 31.
Long Statement,Alba.CsCss.Style,nsCSSExpandedDataBlock,C:\repos\Athari_CsCss\Alba.CsCss\Style\nsCSSExpandedDataBlock.cs,TransferFromBlock,The length of the statement  "                return DoTransferFromBlock(aFromBlock' aPropID' aIsImportant' aOverrideImportant' aMustCallValueAppended' aDeclaration); " is 120.
Long Statement,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseNegatedSimpleSelector,The length of the statement  "            { string _1 = null; nsCSSPseudoElement _2 = 0; parsingStatus = ParsePseudoSelector(ref aDataMask' newSel' true' ref _1' null' ref _2); } " is 136.
Long Statement,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBackground,The length of the statement  "            nsCSSValue image = new nsCSSValue()' repeat = new nsCSSValue()' attachment = new nsCSSValue()' clip = new nsCSSValue()' origin = new nsCSSValue()' position = new nsCSSValue()' size = new nsCSSValue(); " is 200.
Complex Conditional,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,HexToRGB,The conditional expression  "((ch >= '0') && (ch <= '9')) ||                          ((ch >= 'a') && (ch <= 'f')) ||                          ((ch >= 'A') && (ch <= 'F'))"  is complex.
Complex Conditional,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,LooseHexToRGB,The conditional expression  "('1' <= ch && ch <= '9') ||                          ('A' <= ch && ch <= 'F') ||                          ('a' <= ch && ch <= 'f')"  is complex.
Complex Conditional,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,ComponentValue,The conditional expression  "(('a' <= ch) && (ch <= 'f')) ||                      (('A' <= ch) && (ch <= 'F'))"  is complex.
Complex Conditional,Alba.CsCss.Internal,nsStyleUtil,C:\repos\Athari_CsCss\Alba.CsCss\Internal\nsStyleUtil.cs,AppendEscapedCSSIdent,The conditional expression  "i != end && (ident[i] == '-' || ('0' <= ident[i] && ident[i] <= '9'))"  is complex.
Complex Conditional,Alba.CsCss.Internal,nsStyleUtil,C:\repos\Athari_CsCss\Alba.CsCss\Internal\nsStyleUtil.cs,AppendEscapedCSSIdent,The conditional expression  "ch < 0x7F &&                          ch != '_' && ch != '-' &&                          (ch < '0' || '9' < ch) &&                          (ch < 'A' || 'Z' < ch) &&                          (ch < 'a' || 'z' < ch)"  is complex.
Complex Conditional,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ExpectSymbol,The conditional expression  "aSymbol == ')' || aSymbol == ']' ||                  aSymbol == '}' || aSymbol == ';'"  is complex.
Complex Conditional,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,CheckEndProperty,The conditional expression  "(nsCSSTokenType.Symbol == mToken.mType) &&                ((';' == mToken.mSymbol) ||                 ('!' == mToken.mSymbol) ||                 ('}' == mToken.mSymbol) ||                 (')' == mToken.mSymbol))"  is complex.
Complex Conditional,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseMediaQuery,The conditional expression  "nsCSSTokenType.Symbol == mToken.mType && aInAtRule &&                (mToken.mSymbol == ';' || mToken.mSymbol == '{' || mToken.mSymbol == '}' )"  is complex.
Complex Conditional,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseMediaQuery,The conditional expression  "nsCSSTokenType.Symbol == mToken.mType && aInAtRule &&                  (mToken.mSymbol == ';' || mToken.mSymbol == '{' || mToken.mSymbol == '}')"  is complex.
Complex Conditional,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GatherMedia,The conditional expression  "mToken.mType == nsCSSTokenType.Symbol && aInAtRule &&                    (mToken.mSymbol == '{' || mToken.mSymbol == ';'  || mToken.mSymbol == '}')"  is complex.
Complex Conditional,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseSupportsCondition,The conditional expression  "mToken.IsSymbol('(') ||                mToken.mType == nsCSSTokenType.Function ||                mToken.mType == nsCSSTokenType.URL ||                mToken.mType == nsCSSTokenType.Bad_URL"  is complex.
Complex Conditional,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseAttributeSelector,The conditional expression  "(nsCSSTokenType.Symbol == mToken.mType) ||                (nsCSSTokenType.Includes == mToken.mType) ||                (nsCSSTokenType.Dashmatch == mToken.mType) ||                (nsCSSTokenType.Beginsmatch == mToken.mType) ||                (nsCSSTokenType.Endsmatch == mToken.mType) ||                (nsCSSTokenType.Containsmatch == mToken.mType)"  is complex.
Complex Conditional,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParsePseudoSelector,The conditional expression  "(nsCSSTokenType.Function == mToken.mType) !=                (          #if MOZ_XUL                 isTree ||          #endif                 nsCSSPseudoClass.NotPseudo == pseudoClassType ||                 nsCSSPseudoClasses.HasStringArg(pseudoClassType) ||                 nsCSSPseudoClasses.HasNthPairArg(pseudoClassType) ||                 nsCSSPseudoClasses.HasSelectorListArg(pseudoClassType))"  is complex.
Complex Conditional,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseColor,The conditional expression  "ParseColorComponent(ref r' ref type' ''') &&                      ParseColorComponent(ref g' ref type' ''') &&                      ParseColorComponent(ref b' ref type' ''') &&                      ParseColorOpacity(ref a)"  is complex.
Complex Conditional,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,TranslateDimension,The conditional expression  "!mViewportUnitsEnabled &&                  (nsCSSUnit.ViewportWidth == units  ||                   nsCSSUnit.ViewportHeight == units ||                   nsCSSUnit.ViewportMin == units    ||                   nsCSSUnit.ViewportMax == units)"  is complex.
Complex Conditional,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseVariant,The conditional expression  "((aVariantMask & (VARIANT_LENGTH | VARIANT_ANGLE |                                  VARIANT_FREQUENCY | VARIANT_TIME)) != 0 &&                 nsCSSTokenType.Dimension == tk.mType) ||                ((aVariantMask & (VARIANT_LENGTH | VARIANT_ZERO_ANGLE)) != 0 &&                 nsCSSTokenType.Number == tk.mType &&                 tk.mNumber == 0.0f)"  is complex.
Complex Conditional,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseVariant,The conditional expression  "((aVariantMask & VARIANT_POSITIVE_DIMENSION) != 0 &&                    tk.mNumber <= 0.0) ||                  ((aVariantMask & VARIANT_NONNEGATIVE_DIMENSION) != 0 &&                    tk.mNumber < 0.0)"  is complex.
Complex Conditional,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseVariant,The conditional expression  "mHashlessColorQuirk || // NONSTANDARD: Nav interprets 'xxyyzz' values even without '#' prefix                  (nsCSSTokenType.ID == tk.mType) ||                  (nsCSSTokenType.Hash == tk.mType) ||                  (nsCSSTokenType.Ident == tk.mType) ||                  ((nsCSSTokenType.Function == tk.mType) &&                   (tk.mIdentStr.LowerCaseEqualsLiteral("rgb") ||                    tk.mIdentStr.LowerCaseEqualsLiteral("hsl") ||                    tk.mIdentStr.LowerCaseEqualsLiteral("-moz-rgba") ||                    tk.mIdentStr.LowerCaseEqualsLiteral("-moz-hsla") ||                    tk.mIdentStr.LowerCaseEqualsLiteral("rgba") ||                    tk.mIdentStr.LowerCaseEqualsLiteral("hsla")))"  is complex.
Complex Conditional,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseVariant,The conditional expression  "((aVariantMask &                  (VARIANT_IDENTIFIER | VARIANT_IDENTIFIER_NO_INHERIT)) != 0) &&                (nsCSSTokenType.Ident == tk.mType) &&                ((aVariantMask & VARIANT_IDENTIFIER) != 0 ||                 !(tk.mIdentStr.LowerCaseEqualsLiteral("inherit") ||                   tk.mIdentStr.LowerCaseEqualsLiteral("initial")))"  is complex.
Complex Conditional,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseVariant,The conditional expression  "((aVariantMask & VARIANT_COUNTER) != 0) &&                (nsCSSTokenType.Function == tk.mType) &&                (tk.mIdentStr.LowerCaseEqualsLiteral("counter") ||                 tk.mIdentStr.LowerCaseEqualsLiteral("counters"))"  is complex.
Complex Conditional,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseVariant,The conditional expression  "((aVariantMask & VARIANT_CALC) != 0) &&                (nsCSSTokenType.Function == tk.mType) &&                (tk.mIdentStr.LowerCaseEqualsLiteral("calc") ||                 tk.mIdentStr.LowerCaseEqualsLiteral("-moz-calc"))"  is complex.
Complex Conditional,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseImageRect,The conditional expression  "!ParseNonNegativeVariant(ref top' VARIANT_SIDE' null) ||                  !ExpectSymbol('''' true) ||                  !ParseNonNegativeVariant(ref right' VARIANT_SIDE' null) ||                  !ExpectSymbol('''' true) ||                  !ParseNonNegativeVariant(ref bottom' VARIANT_SIDE' null) ||                  !ExpectSymbol('''' true) ||                  !ParseNonNegativeVariant(ref left' VARIANT_SIDE' null) ||                  !ExpectSymbol(')'' true)"  is complex.
Complex Conditional,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseLinearGradient,The conditional expression  "xValue.GetUnit() != nsCSSUnit.Enumerated ||                  0 == (xValue.GetIntValue() & (nsStyle.BgPositionLeft |                                            nsStyle.BgPositionCenter |                                            nsStyle.BgPositionRight)) ||                  yValue.GetUnit() != nsCSSUnit.Enumerated ||                  0 == (yValue.GetIntValue() & (nsStyle.BgPositionTop |                                            nsStyle.BgPositionCenter |                                            nsStyle.BgPositionBottom))"  is complex.
Complex Conditional,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseLinearGradient,The conditional expression  "!ExpectSymbol('''' true) &&                    // if we didn't already get an angle' we might have one now'                    // otherwise it's an error                    (haveAngle ||                     !ParseVariant(ref cssGradient.mAngle' VARIANT_ANGLE' null) ||                     // now we better have a comma                     !ExpectSymbol('''' true))"  is complex.
Complex Conditional,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseRadialGradient,The conditional expression  "!ExpectSymbol('''' true) &&                    // if we didn't already get an angle' we might have one now'                    // otherwise it's an error                    (haveAngle ||                     !ParseVariant(ref cssGradient.mAngle' VARIANT_ANGLE' null) ||                     // now we better have a comma                     !ExpectSymbol('''' true))"  is complex.
Complex Conditional,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBackgroundItem,The conditional expression  "tt == nsCSSTokenType.URL ||                         (tt == nsCSSTokenType.Function &&                          (mToken.mIdentStr.LowerCaseEqualsLiteral("linear-gradient") ||                           mToken.mIdentStr.LowerCaseEqualsLiteral("radial-gradient") ||                           mToken.mIdentStr.LowerCaseEqualsLiteral("repeating-linear-gradient") ||                           mToken.mIdentStr.LowerCaseEqualsLiteral("repeating-radial-gradient") ||                           mToken.mIdentStr.LowerCaseEqualsLiteral("-moz-linear-gradient") ||                           mToken.mIdentStr.LowerCaseEqualsLiteral("-moz-radial-gradient") ||                           mToken.mIdentStr.LowerCaseEqualsLiteral("-moz-repeating-linear-gradient") ||                           mToken.mIdentStr.LowerCaseEqualsLiteral("-moz-repeating-radial-gradient") ||                           mToken.mIdentStr.LowerCaseEqualsLiteral("-moz-image-rect") ||                           mToken.mIdentStr.LowerCaseEqualsLiteral("-moz-element")))"  is complex.
Complex Conditional,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBackgroundItem,The conditional expression  "tt == nsCSSTokenType.Dimension ||                         tt == nsCSSTokenType.Number ||                         tt == nsCSSTokenType.Percentage ||                         (tt == nsCSSTokenType.Function &&                          (mToken.mIdentStr.LowerCaseEqualsLiteral("calc") ||                           mToken.mIdentStr.LowerCaseEqualsLiteral("-moz-calc")))"  is complex.
Complex Conditional,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBoxPositionValues,The conditional expression  "(mask == 0) || (mask == (BG_TOP | BG_BOTTOM)) ||                (mask == (BG_LEFT | BG_RIGHT)) ||                (!aAllowExplicitCenter && ((mask & BG_CENTER) != 0))"  is complex.
Complex Conditional,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBackgroundPositionValues,The conditional expression  "nsCSSUnit.Enumerated != xEdge.GetUnit() ||                    BG_CENTER == xEdge.GetIntValue() ||                    nsCSSUnit.Enumerated == xOffset.GetUnit() ||                    nsCSSUnit.Enumerated != yEdge.GetUnit() ||                    BG_CENTER == yEdge.GetIntValue() ||                    nsCSSUnit.Enumerated == yOffset.GetUnit()"  is complex.
Complex Conditional,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseTransitionTimingFunctionValues,The conditional expression  "!ParseTransitionTimingFunctionValueComponent(ref x1' '''' true) ||                !ParseTransitionTimingFunctionValueComponent(ref y1' '''' false) ||                !ParseTransitionTimingFunctionValueComponent(ref x2' '''' true) ||                !ParseTransitionTimingFunctionValueComponent(ref y2' ')'' false)"  is complex.
Complex Conditional,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,ScanNumber,The conditional expression  "IsDigit(expSignChar) ||                  ((expSignChar == '-' || expSignChar == '+') && IsDigit(nextChar))"  is complex.
Complex Conditional,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,Next,The conditional expression  "ch == '<' && Peek(1) == '!' && Peek(2) == '-' && Peek(3) == '-'"  is complex.
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,RGB,The following statement contains a magic number: return new CssColor(((uint)255 << 24) | ((uint)(b) << 16) | ((uint)(g) << 8) | (r));
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,RGB,The following statement contains a magic number: return new CssColor(((uint)255 << 24) | ((uint)(b) << 16) | ((uint)(g) << 8) | (r));
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,RGB,The following statement contains a magic number: return new CssColor(((uint)255 << 24) | ((uint)(b) << 16) | ((uint)(g) << 8) | (r));
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,RGB,The following statement contains a magic number: return new CssColor(((uint)255 << 24) | ((uint)(b) << 16) | ((uint)(g) << 8) | (r));
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,RGBA,The following statement contains a magic number: return new CssColor(((uint)a << 24) | ((uint)(b) << 16) | ((uint)(g) << 8) | (r));
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,RGBA,The following statement contains a magic number: return new CssColor(((uint)a << 24) | ((uint)(b) << 16) | ((uint)(g) << 8) | (r));
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,RGBA,The following statement contains a magic number: return new CssColor(((uint)a << 24) | ((uint)(b) << 16) | ((uint)(g) << 8) | (r));
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,HexToRGB,The following statement contains a magic number: if ((nameLen == 3) || (nameLen == 6)) {                  // Make sure the digits are legal                  for (int i = 0; i < nameLen; i++) {                      PRUnichar ch = buffer[i];                      if (((ch >= '0') && (ch <= '9')) ||                          ((ch >= 'a') && (ch <= 'f')) ||                          ((ch >= 'A') && (ch <= 'F'))) {                          // Legal character                          continue;                      }                      // Whoops. Illegal character.                      return false;                  }                    // Convert the ascii to binary                  int dpc = ((3 == nameLen) ? 1 : 2);                  // Translate components from hex to binary                  byte r = ComponentValue(buffer' nameLen' 0' dpc);                  byte g = ComponentValue(buffer' nameLen' 1' dpc);                  byte b = ComponentValue(buffer' nameLen' 2' dpc);                  if (dpc == 1) {                      // Scale single digit component to an 8 bit value. Replicate the                      // single digit to compute the new value.                      r = (byte)((r << 4) | r);                      g = (byte)((g << 4) | g);                      b = (byte)((b << 4) | b);                  }                  aResult = RGB(r' g' b);                  return true;              }
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,HexToRGB,The following statement contains a magic number: if ((nameLen == 3) || (nameLen == 6)) {                  // Make sure the digits are legal                  for (int i = 0; i < nameLen; i++) {                      PRUnichar ch = buffer[i];                      if (((ch >= '0') && (ch <= '9')) ||                          ((ch >= 'a') && (ch <= 'f')) ||                          ((ch >= 'A') && (ch <= 'F'))) {                          // Legal character                          continue;                      }                      // Whoops. Illegal character.                      return false;                  }                    // Convert the ascii to binary                  int dpc = ((3 == nameLen) ? 1 : 2);                  // Translate components from hex to binary                  byte r = ComponentValue(buffer' nameLen' 0' dpc);                  byte g = ComponentValue(buffer' nameLen' 1' dpc);                  byte b = ComponentValue(buffer' nameLen' 2' dpc);                  if (dpc == 1) {                      // Scale single digit component to an 8 bit value. Replicate the                      // single digit to compute the new value.                      r = (byte)((r << 4) | r);                      g = (byte)((g << 4) | g);                      b = (byte)((b << 4) | b);                  }                  aResult = RGB(r' g' b);                  return true;              }
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,HexToRGB,The following statement contains a magic number: if ((nameLen == 3) || (nameLen == 6)) {                  // Make sure the digits are legal                  for (int i = 0; i < nameLen; i++) {                      PRUnichar ch = buffer[i];                      if (((ch >= '0') && (ch <= '9')) ||                          ((ch >= 'a') && (ch <= 'f')) ||                          ((ch >= 'A') && (ch <= 'F'))) {                          // Legal character                          continue;                      }                      // Whoops. Illegal character.                      return false;                  }                    // Convert the ascii to binary                  int dpc = ((3 == nameLen) ? 1 : 2);                  // Translate components from hex to binary                  byte r = ComponentValue(buffer' nameLen' 0' dpc);                  byte g = ComponentValue(buffer' nameLen' 1' dpc);                  byte b = ComponentValue(buffer' nameLen' 2' dpc);                  if (dpc == 1) {                      // Scale single digit component to an 8 bit value. Replicate the                      // single digit to compute the new value.                      r = (byte)((r << 4) | r);                      g = (byte)((g << 4) | g);                      b = (byte)((b << 4) | b);                  }                  aResult = RGB(r' g' b);                  return true;              }
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,HexToRGB,The following statement contains a magic number: if ((nameLen == 3) || (nameLen == 6)) {                  // Make sure the digits are legal                  for (int i = 0; i < nameLen; i++) {                      PRUnichar ch = buffer[i];                      if (((ch >= '0') && (ch <= '9')) ||                          ((ch >= 'a') && (ch <= 'f')) ||                          ((ch >= 'A') && (ch <= 'F'))) {                          // Legal character                          continue;                      }                      // Whoops. Illegal character.                      return false;                  }                    // Convert the ascii to binary                  int dpc = ((3 == nameLen) ? 1 : 2);                  // Translate components from hex to binary                  byte r = ComponentValue(buffer' nameLen' 0' dpc);                  byte g = ComponentValue(buffer' nameLen' 1' dpc);                  byte b = ComponentValue(buffer' nameLen' 2' dpc);                  if (dpc == 1) {                      // Scale single digit component to an 8 bit value. Replicate the                      // single digit to compute the new value.                      r = (byte)((r << 4) | r);                      g = (byte)((g << 4) | g);                      b = (byte)((b << 4) | b);                  }                  aResult = RGB(r' g' b);                  return true;              }
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,HexToRGB,The following statement contains a magic number: if ((nameLen == 3) || (nameLen == 6)) {                  // Make sure the digits are legal                  for (int i = 0; i < nameLen; i++) {                      PRUnichar ch = buffer[i];                      if (((ch >= '0') && (ch <= '9')) ||                          ((ch >= 'a') && (ch <= 'f')) ||                          ((ch >= 'A') && (ch <= 'F'))) {                          // Legal character                          continue;                      }                      // Whoops. Illegal character.                      return false;                  }                    // Convert the ascii to binary                  int dpc = ((3 == nameLen) ? 1 : 2);                  // Translate components from hex to binary                  byte r = ComponentValue(buffer' nameLen' 0' dpc);                  byte g = ComponentValue(buffer' nameLen' 1' dpc);                  byte b = ComponentValue(buffer' nameLen' 2' dpc);                  if (dpc == 1) {                      // Scale single digit component to an 8 bit value. Replicate the                      // single digit to compute the new value.                      r = (byte)((r << 4) | r);                      g = (byte)((g << 4) | g);                      b = (byte)((b << 4) | b);                  }                  aResult = RGB(r' g' b);                  return true;              }
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,HexToRGB,The following statement contains a magic number: if ((nameLen == 3) || (nameLen == 6)) {                  // Make sure the digits are legal                  for (int i = 0; i < nameLen; i++) {                      PRUnichar ch = buffer[i];                      if (((ch >= '0') && (ch <= '9')) ||                          ((ch >= 'a') && (ch <= 'f')) ||                          ((ch >= 'A') && (ch <= 'F'))) {                          // Legal character                          continue;                      }                      // Whoops. Illegal character.                      return false;                  }                    // Convert the ascii to binary                  int dpc = ((3 == nameLen) ? 1 : 2);                  // Translate components from hex to binary                  byte r = ComponentValue(buffer' nameLen' 0' dpc);                  byte g = ComponentValue(buffer' nameLen' 1' dpc);                  byte b = ComponentValue(buffer' nameLen' 2' dpc);                  if (dpc == 1) {                      // Scale single digit component to an 8 bit value. Replicate the                      // single digit to compute the new value.                      r = (byte)((r << 4) | r);                      g = (byte)((g << 4) | g);                      b = (byte)((b << 4) | b);                  }                  aResult = RGB(r' g' b);                  return true;              }
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,HexToRGB,The following statement contains a magic number: if ((nameLen == 3) || (nameLen == 6)) {                  // Make sure the digits are legal                  for (int i = 0; i < nameLen; i++) {                      PRUnichar ch = buffer[i];                      if (((ch >= '0') && (ch <= '9')) ||                          ((ch >= 'a') && (ch <= 'f')) ||                          ((ch >= 'A') && (ch <= 'F'))) {                          // Legal character                          continue;                      }                      // Whoops. Illegal character.                      return false;                  }                    // Convert the ascii to binary                  int dpc = ((3 == nameLen) ? 1 : 2);                  // Translate components from hex to binary                  byte r = ComponentValue(buffer' nameLen' 0' dpc);                  byte g = ComponentValue(buffer' nameLen' 1' dpc);                  byte b = ComponentValue(buffer' nameLen' 2' dpc);                  if (dpc == 1) {                      // Scale single digit component to an 8 bit value. Replicate the                      // single digit to compute the new value.                      r = (byte)((r << 4) | r);                      g = (byte)((g << 4) | g);                      b = (byte)((b << 4) | b);                  }                  aResult = RGB(r' g' b);                  return true;              }
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,HexToRGB,The following statement contains a magic number: if ((nameLen == 3) || (nameLen == 6)) {                  // Make sure the digits are legal                  for (int i = 0; i < nameLen; i++) {                      PRUnichar ch = buffer[i];                      if (((ch >= '0') && (ch <= '9')) ||                          ((ch >= 'a') && (ch <= 'f')) ||                          ((ch >= 'A') && (ch <= 'F'))) {                          // Legal character                          continue;                      }                      // Whoops. Illegal character.                      return false;                  }                    // Convert the ascii to binary                  int dpc = ((3 == nameLen) ? 1 : 2);                  // Translate components from hex to binary                  byte r = ComponentValue(buffer' nameLen' 0' dpc);                  byte g = ComponentValue(buffer' nameLen' 1' dpc);                  byte b = ComponentValue(buffer' nameLen' 2' dpc);                  if (dpc == 1) {                      // Scale single digit component to an 8 bit value. Replicate the                      // single digit to compute the new value.                      r = (byte)((r << 4) | r);                      g = (byte)((g << 4) | g);                      b = (byte)((b << 4) | b);                  }                  aResult = RGB(r' g' b);                  return true;              }
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,LooseHexToRGB,The following statement contains a magic number: if (nameLen > 128) {                  nameLen = 128;              }
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,LooseHexToRGB,The following statement contains a magic number: if (nameLen > 128) {                  nameLen = 128;              }
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,LooseHexToRGB,The following statement contains a magic number: int dpc = (nameLen + 2) / 3;
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,LooseHexToRGB,The following statement contains a magic number: int dpc = (nameLen + 2) / 3;
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,LooseHexToRGB,The following statement contains a magic number: if (newdpc > 8) {                  nameLen -= newdpc - 8;                  idx += newdpc - 8;                  newdpc = 8;              }
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,LooseHexToRGB,The following statement contains a magic number: if (newdpc > 8) {                  nameLen -= newdpc - 8;                  idx += newdpc - 8;                  newdpc = 8;              }
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,LooseHexToRGB,The following statement contains a magic number: if (newdpc > 8) {                  nameLen -= newdpc - 8;                  idx += newdpc - 8;                  newdpc = 8;              }
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,LooseHexToRGB,The following statement contains a magic number: if (newdpc > 8) {                  nameLen -= newdpc - 8;                  idx += newdpc - 8;                  newdpc = 8;              }
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,LooseHexToRGB,The following statement contains a magic number: while (newdpc > 2) {                  bool haveNonzero = false;                  for (int c = 0; c < 3; ++c) {                      PRUnichar ch = colorSpec[idx + c * dpc];                      if (('1' <= ch && ch <= '9') ||                          ('A' <= ch && ch <= 'F') ||                          ('a' <= ch && ch <= 'f')) {                          haveNonzero = true;                          break;                      }                  }                  if (haveNonzero) {                      break;                  }                  --newdpc;                  --nameLen;                  ++idx;              }
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,LooseHexToRGB,The following statement contains a magic number: while (newdpc > 2) {                  bool haveNonzero = false;                  for (int c = 0; c < 3; ++c) {                      PRUnichar ch = colorSpec[idx + c * dpc];                      if (('1' <= ch && ch <= '9') ||                          ('A' <= ch && ch <= 'F') ||                          ('a' <= ch && ch <= 'f')) {                          haveNonzero = true;                          break;                      }                  }                  if (haveNonzero) {                      break;                  }                  --newdpc;                  --nameLen;                  ++idx;              }
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,LooseHexToRGB,The following statement contains a magic number: byte b = ComponentValue(colorSpec' nameLen' 2' dpc);
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,HSL2RGB,The following statement contains a magic number: float m1 = l * 2 - m2;
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,HSL2RGB,The following statement contains a magic number: byte r = (byte)(255 * HSL_HueToRGB(m1' m2' h + 1.0f / 3.0f));
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,HSL2RGB,The following statement contains a magic number: byte g = (byte)(255 * HSL_HueToRGB(m1' m2' h));
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,HSL2RGB,The following statement contains a magic number: byte b = (byte)(255 * HSL_HueToRGB(m1' m2' h - 1.0f / 3.0f));
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,HSL_HueToRGB,The following statement contains a magic number: if (h < (float)(1.0 / 6.0))                  return m1 + (m2 - m1) * h * 6.0f;
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,HSL_HueToRGB,The following statement contains a magic number: if (h < (float)(1.0 / 2.0))                  return m2;
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,HSL_HueToRGB,The following statement contains a magic number: if (h < (float)(2.0 / 3.0))                  return m1 + (m2 - m1) * ((float)(2.0 / 3.0) - h) * 6.0f;
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,HSL_HueToRGB,The following statement contains a magic number: if (h < (float)(2.0 / 3.0))                  return m1 + (m2 - m1) * ((float)(2.0 / 3.0) - h) * 6.0f;
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,HSL_HueToRGB,The following statement contains a magic number: if (h < (float)(2.0 / 3.0))                  return m1 + (m2 - m1) * ((float)(2.0 / 3.0) - h) * 6.0f;
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,HSL_HueToRGB,The following statement contains a magic number: if (h < (float)(2.0 / 3.0))                  return m1 + (m2 - m1) * ((float)(2.0 / 3.0) - h) * 6.0f;
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,ComponentValue,The following statement contains a magic number: if (2 < dpc) {                  dpc = 2;              }
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,ComponentValue,The following statement contains a magic number: if (2 < dpc) {                  dpc = 2;              }
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,ComponentValue,The following statement contains a magic number: while (--dpc >= 0) {                  PRUnichar ch = ((index < aLen) ? aColorSpec[index++] : '0');                  if (('0' <= ch) && (ch <= '9')) {                      component = (component * 16) + (ch - '0');                  }                  else if ((('a' <= ch) && (ch <= 'f')) ||                      (('A' <= ch) && (ch <= 'F'))) {                      // "ch&7" handles lower and uppercase hex alphabetics                      component = (component * 16) + (ch & 7) + 9;                  }                  else { // not a hex digit' treat it like 0                      component = (component * 16);                  }              }
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,ComponentValue,The following statement contains a magic number: while (--dpc >= 0) {                  PRUnichar ch = ((index < aLen) ? aColorSpec[index++] : '0');                  if (('0' <= ch) && (ch <= '9')) {                      component = (component * 16) + (ch - '0');                  }                  else if ((('a' <= ch) && (ch <= 'f')) ||                      (('A' <= ch) && (ch <= 'F'))) {                      // "ch&7" handles lower and uppercase hex alphabetics                      component = (component * 16) + (ch & 7) + 9;                  }                  else { // not a hex digit' treat it like 0                      component = (component * 16);                  }              }
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,ComponentValue,The following statement contains a magic number: while (--dpc >= 0) {                  PRUnichar ch = ((index < aLen) ? aColorSpec[index++] : '0');                  if (('0' <= ch) && (ch <= '9')) {                      component = (component * 16) + (ch - '0');                  }                  else if ((('a' <= ch) && (ch <= 'f')) ||                      (('A' <= ch) && (ch <= 'F'))) {                      // "ch&7" handles lower and uppercase hex alphabetics                      component = (component * 16) + (ch & 7) + 9;                  }                  else { // not a hex digit' treat it like 0                      component = (component * 16);                  }              }
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,ComponentValue,The following statement contains a magic number: while (--dpc >= 0) {                  PRUnichar ch = ((index < aLen) ? aColorSpec[index++] : '0');                  if (('0' <= ch) && (ch <= '9')) {                      component = (component * 16) + (ch - '0');                  }                  else if ((('a' <= ch) && (ch <= 'f')) ||                      (('A' <= ch) && (ch <= 'F'))) {                      // "ch&7" handles lower and uppercase hex alphabetics                      component = (component * 16) + (ch & 7) + 9;                  }                  else { // not a hex digit' treat it like 0                      component = (component * 16);                  }              }
Magic Number,Alba.CsCss.Gfx,CssColor,C:\repos\Athari_CsCss\Alba.CsCss\Gfx\Original\CssColor.g.cs,ComponentValue,The following statement contains a magic number: while (--dpc >= 0) {                  PRUnichar ch = ((index < aLen) ? aColorSpec[index++] : '0');                  if (('0' <= ch) && (ch <= '9')) {                      component = (component * 16) + (ch - '0');                  }                  else if ((('a' <= ch) && (ch <= 'f')) ||                      (('A' <= ch) && (ch <= 'F'))) {                      // "ch&7" handles lower and uppercase hex alphabetics                      component = (component * 16) + (ch & 7) + 9;                  }                  else { // not a hex digit' treat it like 0                      component = (component * 16);                  }              }
Magic Number,Alba.CsCss.Internal,CommonUtil,C:\repos\Athari_CsCss\Alba.CsCss\Internal\CommonUtil.cs,ComputeCalc,The following statement contains a magic number: switch (aOps.GetUnit(aValue)) {                  case CssUnit.Calc: {                      TInput[] arr = aValue.GetArrayValue();                      Debug.Assert(arr.Count() == 1' "unexpected length");                      return ComputeCalc(arr.Item(0)' aOps);                  }                  case CssUnit.CalcPlus:                  case CssUnit.CalcMinus: {                      TInput[] arr = aValue.GetArrayValue();                      Debug.Assert(arr.Count() == 2' "unexpected length");                      TResult lhs = ComputeCalc(arr.Item(0)' aOps)' rhs = ComputeCalc(arr.Item(1)' aOps);                      return aOps.MergeAdditive(aOps.GetUnit(aValue)' lhs' rhs);                  }                  case CssUnit.CalcTimesL: {                      TInput[] arr = aValue.GetArrayValue();                      Debug.Assert(arr.Count() == 2' "unexpected length");                      TResult lhs = aOps.ComputeNumber(arr.Item(0))' rhs = ComputeCalc(arr.Item(1)' aOps);                      return aOps.MergeMultiplicativeL(aOps.GetUnit(aValue)' lhs' rhs);                  }                  case CssUnit.CalcTimesR:                  case CssUnit.CalcDivided: {                      TInput[] arr = aValue.GetArrayValue();                      Debug.Assert(arr.Count() == 2' "unexpected length");                      TResult lhs = ComputeCalc(arr.Item(0)' aOps)' rhs = aOps.ComputeNumber(arr.Item(1));                      return aOps.MergeMultiplicativeR(aOps.GetUnit(aValue)' lhs' rhs);                  }                  default: {                      return aOps.ComputeLeafValue(aValue);                  }              }
Magic Number,Alba.CsCss.Internal,CommonUtil,C:\repos\Athari_CsCss\Alba.CsCss\Internal\CommonUtil.cs,ComputeCalc,The following statement contains a magic number: switch (aOps.GetUnit(aValue)) {                  case CssUnit.Calc: {                      TInput[] arr = aValue.GetArrayValue();                      Debug.Assert(arr.Count() == 1' "unexpected length");                      return ComputeCalc(arr.Item(0)' aOps);                  }                  case CssUnit.CalcPlus:                  case CssUnit.CalcMinus: {                      TInput[] arr = aValue.GetArrayValue();                      Debug.Assert(arr.Count() == 2' "unexpected length");                      TResult lhs = ComputeCalc(arr.Item(0)' aOps)' rhs = ComputeCalc(arr.Item(1)' aOps);                      return aOps.MergeAdditive(aOps.GetUnit(aValue)' lhs' rhs);                  }                  case CssUnit.CalcTimesL: {                      TInput[] arr = aValue.GetArrayValue();                      Debug.Assert(arr.Count() == 2' "unexpected length");                      TResult lhs = aOps.ComputeNumber(arr.Item(0))' rhs = ComputeCalc(arr.Item(1)' aOps);                      return aOps.MergeMultiplicativeL(aOps.GetUnit(aValue)' lhs' rhs);                  }                  case CssUnit.CalcTimesR:                  case CssUnit.CalcDivided: {                      TInput[] arr = aValue.GetArrayValue();                      Debug.Assert(arr.Count() == 2' "unexpected length");                      TResult lhs = ComputeCalc(arr.Item(0)' aOps)' rhs = aOps.ComputeNumber(arr.Item(1));                      return aOps.MergeMultiplicativeR(aOps.GetUnit(aValue)' lhs' rhs);                  }                  default: {                      return aOps.ComputeLeafValue(aValue);                  }              }
Magic Number,Alba.CsCss.Internal,CommonUtil,C:\repos\Athari_CsCss\Alba.CsCss\Internal\CommonUtil.cs,ComputeCalc,The following statement contains a magic number: switch (aOps.GetUnit(aValue)) {                  case CssUnit.Calc: {                      TInput[] arr = aValue.GetArrayValue();                      Debug.Assert(arr.Count() == 1' "unexpected length");                      return ComputeCalc(arr.Item(0)' aOps);                  }                  case CssUnit.CalcPlus:                  case CssUnit.CalcMinus: {                      TInput[] arr = aValue.GetArrayValue();                      Debug.Assert(arr.Count() == 2' "unexpected length");                      TResult lhs = ComputeCalc(arr.Item(0)' aOps)' rhs = ComputeCalc(arr.Item(1)' aOps);                      return aOps.MergeAdditive(aOps.GetUnit(aValue)' lhs' rhs);                  }                  case CssUnit.CalcTimesL: {                      TInput[] arr = aValue.GetArrayValue();                      Debug.Assert(arr.Count() == 2' "unexpected length");                      TResult lhs = aOps.ComputeNumber(arr.Item(0))' rhs = ComputeCalc(arr.Item(1)' aOps);                      return aOps.MergeMultiplicativeL(aOps.GetUnit(aValue)' lhs' rhs);                  }                  case CssUnit.CalcTimesR:                  case CssUnit.CalcDivided: {                      TInput[] arr = aValue.GetArrayValue();                      Debug.Assert(arr.Count() == 2' "unexpected length");                      TResult lhs = ComputeCalc(arr.Item(0)' aOps)' rhs = aOps.ComputeNumber(arr.Item(1));                      return aOps.MergeMultiplicativeR(aOps.GetUnit(aValue)' lhs' rhs);                  }                  default: {                      return aOps.ComputeLeafValue(aValue);                  }              }
Magic Number,Alba.CsCss.Internal,nsStyleUtil,C:\repos\Athari_CsCss\Alba.CsCss\Internal\nsStyleUtil.cs,FloatToColorComponent,The following statement contains a magic number: return (byte)CommonUtil.NSToIntRound(aAlpha * 255);
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseMediaQueryExpression,The following statement contains a magic number: if (StringBeginsWith(mToken.mIdentStr' "min-")) {              expr.mRange = nsMediaExpression.RangeType.Min;              featureString = mToken.mIdentStr.Substring(4);            } else if (StringBeginsWith(mToken.mIdentStr' "max-")) {              expr.mRange = nsMediaExpression.RangeType.Max;              featureString = mToken.mIdentStr.Substring(4);            } else {              expr.mRange = nsMediaExpression.RangeType.Equal;              featureString = mToken.mIdentStr;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseMediaQueryExpression,The following statement contains a magic number: if (StringBeginsWith(mToken.mIdentStr' "min-")) {              expr.mRange = nsMediaExpression.RangeType.Min;              featureString = mToken.mIdentStr.Substring(4);            } else if (StringBeginsWith(mToken.mIdentStr' "max-")) {              expr.mRange = nsMediaExpression.RangeType.Max;              featureString = mToken.mIdentStr.Substring(4);            } else {              expr.mRange = nsMediaExpression.RangeType.Equal;              featureString = mToken.mIdentStr;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseMediaQueryExpression,The following statement contains a magic number: switch (feature.mValueType) {              case nsMediaFeature.ValueType.Length:                rv = ParseNonNegativeVariant(ref expr.mValue' VARIANT_LENGTH' null);                break;              case nsMediaFeature.ValueType.Integer:              case nsMediaFeature.ValueType.BoolInteger:                rv = ParseNonNegativeVariant(ref expr.mValue' VARIANT_INTEGER' null);                // Enforce extra restrictions for eBoolInteger                if (rv &&                    feature.mValueType == nsMediaFeature.ValueType.BoolInteger &&                    expr.mValue.GetIntValue() > 1)                  rv = false;                break;              case nsMediaFeature.ValueType.Float:                rv = ParseNonNegativeVariant(ref expr.mValue' VARIANT_NUMBER' null);                break;              case nsMediaFeature.ValueType.IntRatio:                {                  // Two integers separated by '/'' with optional whitespace on                  // either side of the '/'.                  nsCSSValue[] a = new nsCSSValue[2];                  expr.mValue.SetArrayValue(a' nsCSSUnit.Array);                  // We don't bother with ParseNonNegativeVariant since we have to                  // check for != 0 as well; no need to worry about the UngetToken                  // since we're throwing out up to the next ')' anyway.                  rv = ParseVariant(ref a[0]' VARIANT_INTEGER' null) &&                       a[0].GetIntValue() > 0 &&                       ExpectSymbol('/'' true) &&                       ParseVariant(ref a[1]' VARIANT_INTEGER' null) &&                       a[1].GetIntValue() > 0;                }                break;              case nsMediaFeature.ValueType.Resolution:                rv = GetToken(true);                if (!rv)                  break;                rv = mToken.mType == nsCSSTokenType.Dimension && mToken.mNumber > 0.0f;                if (!rv) {                  UngetToken();                  break;                }                // No worries about whether unitless zero is allowed' since the                // value must be positive (and we checked that above).                Debug.Assert(!mToken.mIdentStr.IsEmpty()' "unit lied");                if (mToken.mIdentStr.LowerCaseEqualsLiteral("dpi")) {                  expr.mValue.SetFloatValue(mToken.mNumber' nsCSSUnit.Inch);                } else if (mToken.mIdentStr.LowerCaseEqualsLiteral("dppx")) {                  expr.mValue.SetFloatValue(mToken.mNumber' nsCSSUnit.Pixel);                } else if (mToken.mIdentStr.LowerCaseEqualsLiteral("dpcm")) {                  expr.mValue.SetFloatValue(mToken.mNumber' nsCSSUnit.Centimeter);                } else {                  rv = false;                }                break;              case nsMediaFeature.ValueType.Enumerated:                rv = ParseVariant(ref expr.mValue' VARIANT_KEYWORD'                                  feature.mData.mKeywordTable);                break;              case nsMediaFeature.ValueType.Ident:                rv = ParseVariant(ref expr.mValue' VARIANT_IDENTIFIER' null);                break;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,SkipUntil,The following statement contains a magic number: var stack = new List<char>(16);
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParsePseudoClassWithNthPairArg,The following statement contains a magic number: if (nsCSSTokenType.Ident == mToken.mType || nsCSSTokenType.Dimension == mToken.mType) {              // The CSS tokenization doesn't handle :nth-child() containing - well:              //   2n-1 is a dimension              //   n-1 is an identifier              // The easiest way to deal with that is to push everything from the              // minus on back onto the scanner's pushback buffer.              uint32_t truncAt = 0;              if (StringBeginsWith(mToken.mIdentStr' "n-")) {                truncAt = 1;              } else if (StringBeginsWith(mToken.mIdentStr' "-n-")) {                truncAt = 2;              }              if (truncAt != 0) {                mScanner.Backup(mToken.mIdentStr.Length() - truncAt);                mToken.mIdentStr = mToken.mIdentStr.Substring(0' truncAt);              }            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParsePseudoClassWithNthPairArg,The following statement contains a magic number: if (nsCSSTokenType.Ident == mToken.mType) {              if (mToken.mIdentStr.LowerCaseEqualsLiteral("odd")) {                numbers[0] = 2;                numbers[1] = 1;                lookForB = false;              }              else if (mToken.mIdentStr.LowerCaseEqualsLiteral("even")) {                numbers[0] = 2;                numbers[1] = 0;                lookForB = false;              }              else if (mToken.mIdentStr.LowerCaseEqualsLiteral("n")) {                numbers[0] = 1;              }              else if (mToken.mIdentStr.LowerCaseEqualsLiteral("-n")) {                numbers[0] = -1;              }              else {                { if (!mSuppressErrors) mReporter.ReportUnexpected("PEPseudoClassArgNotNth"' mToken); };                return nsSelectorParsingStatus.Error; // our caller calls SkipUntil(')')              }            }            else if (nsCSSTokenType.Number == mToken.mType) {              if (!mToken.mIntegerValid) {                { if (!mSuppressErrors) mReporter.ReportUnexpected("PEPseudoClassArgNotNth"' mToken); };                return nsSelectorParsingStatus.Error; // our caller calls SkipUntil(')')              }              numbers[1] = mToken.mInteger;              lookForB = false;            }            else if (nsCSSTokenType.Dimension == mToken.mType) {              if (!mToken.mIntegerValid || !mToken.mIdentStr.LowerCaseEqualsLiteral("n")) {                { if (!mSuppressErrors) mReporter.ReportUnexpected("PEPseudoClassArgNotNth"' mToken); };                return nsSelectorParsingStatus.Error; // our caller calls SkipUntil(')')              }              numbers[0] = mToken.mInteger;            }            // XXX If it's a ')'' is that valid?  (as 0n+0)            else {              { if (!mSuppressErrors) mReporter.ReportUnexpected("PEPseudoClassArgNotNth"' mToken); };              UngetToken();              return nsSelectorParsingStatus.Error; // our caller calls SkipUntil(')')            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParsePseudoClassWithNthPairArg,The following statement contains a magic number: if (nsCSSTokenType.Ident == mToken.mType) {              if (mToken.mIdentStr.LowerCaseEqualsLiteral("odd")) {                numbers[0] = 2;                numbers[1] = 1;                lookForB = false;              }              else if (mToken.mIdentStr.LowerCaseEqualsLiteral("even")) {                numbers[0] = 2;                numbers[1] = 0;                lookForB = false;              }              else if (mToken.mIdentStr.LowerCaseEqualsLiteral("n")) {                numbers[0] = 1;              }              else if (mToken.mIdentStr.LowerCaseEqualsLiteral("-n")) {                numbers[0] = -1;              }              else {                { if (!mSuppressErrors) mReporter.ReportUnexpected("PEPseudoClassArgNotNth"' mToken); };                return nsSelectorParsingStatus.Error; // our caller calls SkipUntil(')')              }            }            else if (nsCSSTokenType.Number == mToken.mType) {              if (!mToken.mIntegerValid) {                { if (!mSuppressErrors) mReporter.ReportUnexpected("PEPseudoClassArgNotNth"' mToken); };                return nsSelectorParsingStatus.Error; // our caller calls SkipUntil(')')              }              numbers[1] = mToken.mInteger;              lookForB = false;            }            else if (nsCSSTokenType.Dimension == mToken.mType) {              if (!mToken.mIntegerValid || !mToken.mIdentStr.LowerCaseEqualsLiteral("n")) {                { if (!mSuppressErrors) mReporter.ReportUnexpected("PEPseudoClassArgNotNth"' mToken); };                return nsSelectorParsingStatus.Error; // our caller calls SkipUntil(')')              }              numbers[0] = mToken.mInteger;            }            // XXX If it's a ')'' is that valid?  (as 0n+0)            else {              { if (!mSuppressErrors) mReporter.ReportUnexpected("PEPseudoClassArgNotNth"' mToken); };              UngetToken();              return nsSelectorParsingStatus.Error; // our caller calls SkipUntil(')')            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseVariant,The following statement contains a magic number: if ((aVariantMask & VARIANT_GRADIENT) != 0 &&                nsCSSTokenType.Function == tk.mType) {              // a generated gradient              string tmp = tk.mIdentStr;              bool isLegacy = false;              if (StringBeginsWith(tmp' "-moz-")) {                tmp = tmp.Substring(5);                isLegacy = true;              }              bool isRepeating = false;              if (StringBeginsWith(tmp' "repeating-")) {                tmp = tmp.Substring(10);                isRepeating = true;              }                        if (tmp.LowerCaseEqualsLiteral("linear-gradient")) {                return ParseLinearGradient(ref aValue' isRepeating' isLegacy);              }              if (tmp.LowerCaseEqualsLiteral("radial-gradient")) {                return ParseRadialGradient(ref aValue' isRepeating' isLegacy);              }            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseVariant,The following statement contains a magic number: if ((aVariantMask & VARIANT_GRADIENT) != 0 &&                nsCSSTokenType.Function == tk.mType) {              // a generated gradient              string tmp = tk.mIdentStr;              bool isLegacy = false;              if (StringBeginsWith(tmp' "-moz-")) {                tmp = tmp.Substring(5);                isLegacy = true;              }              bool isRepeating = false;              if (StringBeginsWith(tmp' "repeating-")) {                tmp = tmp.Substring(10);                isRepeating = true;              }                        if (tmp.LowerCaseEqualsLiteral("linear-gradient")) {                return ParseLinearGradient(ref aValue' isRepeating' isLegacy);              }              if (tmp.LowerCaseEqualsLiteral("radial-gradient")) {                return ParseRadialGradient(ref aValue' isRepeating' isLegacy);              }            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseCounter,The following statement contains a magic number: for (;;) {              if (!GetToken(true)) {                break;              }              if (nsCSSTokenType.Ident != mToken.mType) {                UngetToken();                break;              }                        nsCSSValue[] val =                new nsCSSValue[unit == nsCSSUnit.Counter ? 2 : 3];                        val[0].SetStringValue(mToken.mIdentStr' nsCSSUnit.Ident);                        if (nsCSSUnit.Counters == unit) {                // must have a comma and then a separator string                if (!ExpectSymbol('''' true) || !GetToken(true)) {                  break;                }                if (nsCSSTokenType.String != mToken.mType) {                  UngetToken();                  break;                }                val[1].SetStringValue(mToken.mIdentStr' nsCSSUnit.String);              }                        // get optional type              int32_t type = nsStyle.ListStyleDecimal;              if (ExpectSymbol('''' true)) {                if (!GetToken(true)) {                  break;                }                nsCSSKeyword keyword;                if (nsCSSTokenType.Ident != mToken.mType ||                    (keyword = nsCSSKeywords.LookupKeyword(mToken.mIdentStr)) ==                      nsCSSKeyword.Unknown ||                    !nsCSSProps.FindKeyword(keyword' nsCSSProps.kListStyleKTable' ref type)) {                  UngetToken();                  break;                }              }                        int32_t typeItem = nsCSSUnit.Counters == unit ? 2 : 1;              val[typeItem].SetIntValue(type' nsCSSUnit.Enumerated);                        if (!ExpectSymbol(')'' true)) {                break;              }                        aValue.SetArrayValue(val' unit);              return true;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseCounter,The following statement contains a magic number: for (;;) {              if (!GetToken(true)) {                break;              }              if (nsCSSTokenType.Ident != mToken.mType) {                UngetToken();                break;              }                        nsCSSValue[] val =                new nsCSSValue[unit == nsCSSUnit.Counter ? 2 : 3];                        val[0].SetStringValue(mToken.mIdentStr' nsCSSUnit.Ident);                        if (nsCSSUnit.Counters == unit) {                // must have a comma and then a separator string                if (!ExpectSymbol('''' true) || !GetToken(true)) {                  break;                }                if (nsCSSTokenType.String != mToken.mType) {                  UngetToken();                  break;                }                val[1].SetStringValue(mToken.mIdentStr' nsCSSUnit.String);              }                        // get optional type              int32_t type = nsStyle.ListStyleDecimal;              if (ExpectSymbol('''' true)) {                if (!GetToken(true)) {                  break;                }                nsCSSKeyword keyword;                if (nsCSSTokenType.Ident != mToken.mType ||                    (keyword = nsCSSKeywords.LookupKeyword(mToken.mIdentStr)) ==                      nsCSSKeyword.Unknown ||                    !nsCSSProps.FindKeyword(keyword' nsCSSProps.kListStyleKTable' ref type)) {                  UngetToken();                  break;                }              }                        int32_t typeItem = nsCSSUnit.Counters == unit ? 2 : 1;              val[typeItem].SetIntValue(type' nsCSSUnit.Enumerated);                        if (!ExpectSymbol(')'' true)) {                break;              }                        aValue.SetArrayValue(val' unit);              return true;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseCounter,The following statement contains a magic number: for (;;) {              if (!GetToken(true)) {                break;              }              if (nsCSSTokenType.Ident != mToken.mType) {                UngetToken();                break;              }                        nsCSSValue[] val =                new nsCSSValue[unit == nsCSSUnit.Counter ? 2 : 3];                        val[0].SetStringValue(mToken.mIdentStr' nsCSSUnit.Ident);                        if (nsCSSUnit.Counters == unit) {                // must have a comma and then a separator string                if (!ExpectSymbol('''' true) || !GetToken(true)) {                  break;                }                if (nsCSSTokenType.String != mToken.mType) {                  UngetToken();                  break;                }                val[1].SetStringValue(mToken.mIdentStr' nsCSSUnit.String);              }                        // get optional type              int32_t type = nsStyle.ListStyleDecimal;              if (ExpectSymbol('''' true)) {                if (!GetToken(true)) {                  break;                }                nsCSSKeyword keyword;                if (nsCSSTokenType.Ident != mToken.mType ||                    (keyword = nsCSSKeywords.LookupKeyword(mToken.mIdentStr)) ==                      nsCSSKeyword.Unknown ||                    !nsCSSProps.FindKeyword(keyword' nsCSSProps.kListStyleKTable' ref type)) {                  UngetToken();                  break;                }              }                        int32_t typeItem = nsCSSUnit.Counters == unit ? 2 : 1;              val[typeItem].SetIntValue(type' nsCSSUnit.Enumerated);                        if (!ExpectSymbol(')'' true)) {                break;              }                        aValue.SetArrayValue(val' unit);              return true;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseAttr,The following statement contains a magic number: if (nsCSSTokenType.Ident == mToken.mType) {  // attr name or namespace              string holdIdent = mToken.mIdentStr;              if (ExpectSymbol('|'' false)) {  // namespace                int32_t nameSpaceID = GetNamespaceIdForPrefix(holdIdent);                if (nameSpaceID == nsNameSpace.Unknown) {                  return false;                }                attr.AppendInt(nameSpaceID' 10);                attr.Append('|');                if (! GetToken(false)) {                  { if (!mSuppressErrors) mReporter.ReportUnexpected("PEAttributeNameEOF"); };                  return false;                }                if (nsCSSTokenType.Ident == mToken.mType) {                  attr.Append(mToken.mIdentStr);                }                else {                  { if (!mSuppressErrors) mReporter.ReportUnexpected("PEAttributeNameExpected"' mToken); };                  UngetToken();                  return false;                }              }              else {  // no namespace                attr.AssignLiteral(holdIdent);              }            }            else if (mToken.IsSymbol('*')) {  // namespace wildcard              // Wildcard namespace makes no sense here and is not allowed              { if (!mSuppressErrors) mReporter.ReportUnexpected("PEAttributeNameExpected"' mToken); };              UngetToken();              return false;            }            else if (mToken.IsSymbol('|')) {  // explicit NO namespace              if (! GetToken(false)) {                { if (!mSuppressErrors) mReporter.ReportUnexpected("PEAttributeNameEOF"); };                return false;              }              if (nsCSSTokenType.Ident == mToken.mType) {                attr.Append(mToken.mIdentStr);              }              else {                { if (!mSuppressErrors) mReporter.ReportUnexpected("PEAttributeNameExpected"' mToken); };                UngetToken();                return false;              }            }            else {              { if (!mSuppressErrors) mReporter.ReportUnexpected("PEAttributeNameOrNamespaceExpected"' mToken); };              UngetToken();              return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseImageRect,The following statement contains a magic number: for (;;) {              var newFunction = new nsCSSValue();              const uint32_t kNumArgs = 5;              nsCSSValue[] func =                newFunction.InitFunction(nsCSSKeyword.MozImageRect' kNumArgs);                        // func[0] is reserved for the function name.              nsCSSValue url    = func[1];              nsCSSValue top    = func[2];              nsCSSValue right  = func[3];              nsCSSValue bottom = func[4];              nsCSSValue left   = func[5];                        string urlString = "";              if (!ParseURLOrString(ref urlString) ||                  !SetValueToURL(ref url' urlString) ||                  !ExpectSymbol('''' true)) {                break;              }                        const int32_t VARIANT_SIDE = VARIANT_NUMBER | VARIANT_PERCENT;              if (!ParseNonNegativeVariant(ref top' VARIANT_SIDE' null) ||                  !ExpectSymbol('''' true) ||                  !ParseNonNegativeVariant(ref right' VARIANT_SIDE' null) ||                  !ExpectSymbol('''' true) ||                  !ParseNonNegativeVariant(ref bottom' VARIANT_SIDE' null) ||                  !ExpectSymbol('''' true) ||                  !ParseNonNegativeVariant(ref left' VARIANT_SIDE' null) ||                  !ExpectSymbol(')'' true))                break;                        aImage = newFunction;              return true;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseImageRect,The following statement contains a magic number: for (;;) {              var newFunction = new nsCSSValue();              const uint32_t kNumArgs = 5;              nsCSSValue[] func =                newFunction.InitFunction(nsCSSKeyword.MozImageRect' kNumArgs);                        // func[0] is reserved for the function name.              nsCSSValue url    = func[1];              nsCSSValue top    = func[2];              nsCSSValue right  = func[3];              nsCSSValue bottom = func[4];              nsCSSValue left   = func[5];                        string urlString = "";              if (!ParseURLOrString(ref urlString) ||                  !SetValueToURL(ref url' urlString) ||                  !ExpectSymbol('''' true)) {                break;              }                        const int32_t VARIANT_SIDE = VARIANT_NUMBER | VARIANT_PERCENT;              if (!ParseNonNegativeVariant(ref top' VARIANT_SIDE' null) ||                  !ExpectSymbol('''' true) ||                  !ParseNonNegativeVariant(ref right' VARIANT_SIDE' null) ||                  !ExpectSymbol('''' true) ||                  !ParseNonNegativeVariant(ref bottom' VARIANT_SIDE' null) ||                  !ExpectSymbol('''' true) ||                  !ParseNonNegativeVariant(ref left' VARIANT_SIDE' null) ||                  !ExpectSymbol(')'' true))                break;                        aImage = newFunction;              return true;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseImageRect,The following statement contains a magic number: for (;;) {              var newFunction = new nsCSSValue();              const uint32_t kNumArgs = 5;              nsCSSValue[] func =                newFunction.InitFunction(nsCSSKeyword.MozImageRect' kNumArgs);                        // func[0] is reserved for the function name.              nsCSSValue url    = func[1];              nsCSSValue top    = func[2];              nsCSSValue right  = func[3];              nsCSSValue bottom = func[4];              nsCSSValue left   = func[5];                        string urlString = "";              if (!ParseURLOrString(ref urlString) ||                  !SetValueToURL(ref url' urlString) ||                  !ExpectSymbol('''' true)) {                break;              }                        const int32_t VARIANT_SIDE = VARIANT_NUMBER | VARIANT_PERCENT;              if (!ParseNonNegativeVariant(ref top' VARIANT_SIDE' null) ||                  !ExpectSymbol('''' true) ||                  !ParseNonNegativeVariant(ref right' VARIANT_SIDE' null) ||                  !ExpectSymbol('''' true) ||                  !ParseNonNegativeVariant(ref bottom' VARIANT_SIDE' null) ||                  !ExpectSymbol('''' true) ||                  !ParseNonNegativeVariant(ref left' VARIANT_SIDE' null) ||                  !ExpectSymbol(')'' true))                break;                        aImage = newFunction;              return true;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseImageRect,The following statement contains a magic number: for (;;) {              var newFunction = new nsCSSValue();              const uint32_t kNumArgs = 5;              nsCSSValue[] func =                newFunction.InitFunction(nsCSSKeyword.MozImageRect' kNumArgs);                        // func[0] is reserved for the function name.              nsCSSValue url    = func[1];              nsCSSValue top    = func[2];              nsCSSValue right  = func[3];              nsCSSValue bottom = func[4];              nsCSSValue left   = func[5];                        string urlString = "";              if (!ParseURLOrString(ref urlString) ||                  !SetValueToURL(ref url' urlString) ||                  !ExpectSymbol('''' true)) {                break;              }                        const int32_t VARIANT_SIDE = VARIANT_NUMBER | VARIANT_PERCENT;              if (!ParseNonNegativeVariant(ref top' VARIANT_SIDE' null) ||                  !ExpectSymbol('''' true) ||                  !ParseNonNegativeVariant(ref right' VARIANT_SIDE' null) ||                  !ExpectSymbol('''' true) ||                  !ParseNonNegativeVariant(ref bottom' VARIANT_SIDE' null) ||                  !ExpectSymbol('''' true) ||                  !ParseNonNegativeVariant(ref left' VARIANT_SIDE' null) ||                  !ExpectSymbol(')'' true))                break;                        aImage = newFunction;              return true;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseImageRect,The following statement contains a magic number: for (;;) {              var newFunction = new nsCSSValue();              const uint32_t kNumArgs = 5;              nsCSSValue[] func =                newFunction.InitFunction(nsCSSKeyword.MozImageRect' kNumArgs);                        // func[0] is reserved for the function name.              nsCSSValue url    = func[1];              nsCSSValue top    = func[2];              nsCSSValue right  = func[3];              nsCSSValue bottom = func[4];              nsCSSValue left   = func[5];                        string urlString = "";              if (!ParseURLOrString(ref urlString) ||                  !SetValueToURL(ref url' urlString) ||                  !ExpectSymbol('''' true)) {                break;              }                        const int32_t VARIANT_SIDE = VARIANT_NUMBER | VARIANT_PERCENT;              if (!ParseNonNegativeVariant(ref top' VARIANT_SIDE' null) ||                  !ExpectSymbol('''' true) ||                  !ParseNonNegativeVariant(ref right' VARIANT_SIDE' null) ||                  !ExpectSymbol('''' true) ||                  !ParseNonNegativeVariant(ref bottom' VARIANT_SIDE' null) ||                  !ExpectSymbol('''' true) ||                  !ParseNonNegativeVariant(ref left' VARIANT_SIDE' null) ||                  !ExpectSymbol(')'' true))                break;                        aImage = newFunction;              return true;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBoxProperties,The following statement contains a magic number: switch (count) {              case 1: // Make right == top                result.mRight = result.mTop;                goto case 2;              case 2: // Make bottom == top                result.mBottom = result.mTop;                goto case 3;              case 3: // Make left == right                result.mLeft = result.mRight;              break;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBoxProperties,The following statement contains a magic number: switch (count) {              case 1: // Make right == top                result.mRight = result.mTop;                goto case 2;              case 2: // Make bottom == top                result.mBottom = result.mTop;                goto case 3;              case 3: // Make left == right                result.mLeft = result.mRight;              break;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBoxProperties,The following statement contains a magic number: switch (count) {              case 1: // Make right == top                result.mRight = result.mTop;                goto case 2;              case 2: // Make bottom == top                result.mBottom = result.mTop;                goto case 3;              case 3: // Make left == right                result.mLeft = result.mRight;              break;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBoxProperties,The following statement contains a magic number: switch (count) {              case 1: // Make right == top                result.mRight = result.mTop;                goto case 2;              case 2: // Make bottom == top                result.mBottom = result.mTop;                goto case 3;              case 3: // Make left == right                result.mLeft = result.mRight;              break;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseGroupedBoxProperty,The following statement contains a magic number: switch (count) {              case 1: // Make right == top                result.mRight = result.mTop;                goto case 2;              case 2: // Make bottom == top                result.mBottom = result.mTop;                goto case 3;              case 3: // Make left == right                result.mLeft = result.mRight;              break;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseGroupedBoxProperty,The following statement contains a magic number: switch (count) {              case 1: // Make right == top                result.mRight = result.mTop;                goto case 2;              case 2: // Make bottom == top                result.mBottom = result.mTop;                goto case 3;              case 3: // Make left == right                result.mLeft = result.mRight;              break;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseGroupedBoxProperty,The following statement contains a magic number: switch (count) {              case 1: // Make right == top                result.mRight = result.mTop;                goto case 2;              case 2: // Make bottom == top                result.mBottom = result.mTop;                goto case 3;              case 3: // Make left == right                result.mLeft = result.mRight;              break;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseGroupedBoxProperty,The following statement contains a magic number: switch (count) {              case 1: // Make right == top                result.mRight = result.mTop;                goto case 2;              case 2: // Make bottom == top                result.mBottom = result.mTop;                goto case 3;              case 3: // Make left == right                result.mLeft = result.mRight;              break;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseDirectionalBoxProperty,The following statement contains a magic number: Debug.Assert(subprops[3] == nsCSSProperty.Unknown'                         "not box property with physical vs. logical cascading");
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseDirectionalBoxProperty,The following statement contains a magic number: AppendValue(subprops[2]' typeVal);
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBoxCornerRadii,The following statement contains a magic number: switch (countX) {              case 1: dimenX.mRight = dimenX.mTop;  // top-right same as top-left' and                goto case 2;              case 2: dimenX.mBottom = dimenX.mTop; // bottom-right same as top-left' and                 goto case 3;              case 3: dimenX.mLeft = dimenX.mRight; // bottom-left same as top-right              break;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBoxCornerRadii,The following statement contains a magic number: switch (countX) {              case 1: dimenX.mRight = dimenX.mTop;  // top-right same as top-left' and                goto case 2;              case 2: dimenX.mBottom = dimenX.mTop; // bottom-right same as top-left' and                 goto case 3;              case 3: dimenX.mLeft = dimenX.mRight; // bottom-left same as top-right              break;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBoxCornerRadii,The following statement contains a magic number: switch (countX) {              case 1: dimenX.mRight = dimenX.mTop;  // top-right same as top-left' and                goto case 2;              case 2: dimenX.mBottom = dimenX.mTop; // bottom-right same as top-left' and                 goto case 3;              case 3: dimenX.mLeft = dimenX.mRight; // bottom-left same as top-right              break;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBoxCornerRadii,The following statement contains a magic number: switch (countX) {              case 1: dimenX.mRight = dimenX.mTop;  // top-right same as top-left' and                goto case 2;              case 2: dimenX.mBottom = dimenX.mTop; // bottom-right same as top-left' and                 goto case 3;              case 3: dimenX.mLeft = dimenX.mRight; // bottom-left same as top-right              break;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBoxCornerRadii,The following statement contains a magic number: switch (countY) {              case 1: dimenY.mRight = dimenY.mTop;  // top-right same as top-left' and                goto case 2;              case 2: dimenY.mBottom = dimenY.mTop; // bottom-right same as top-left' and                 goto case 3;              case 3: dimenY.mLeft = dimenY.mRight; // bottom-left same as top-right              break;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBoxCornerRadii,The following statement contains a magic number: switch (countY) {              case 1: dimenY.mRight = dimenY.mTop;  // top-right same as top-left' and                goto case 2;              case 2: dimenY.mBottom = dimenY.mTop; // bottom-right same as top-left' and                 goto case 3;              case 3: dimenY.mLeft = dimenY.mRight; // bottom-left same as top-right              break;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBoxCornerRadii,The following statement contains a magic number: switch (countY) {              case 1: dimenY.mRight = dimenY.mTop;  // top-right same as top-left' and                goto case 2;              case 2: dimenY.mBottom = dimenY.mTop; // bottom-right same as top-left' and                 goto case 3;              case 3: dimenY.mLeft = dimenY.mRight; // bottom-left same as top-right              break;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBoxCornerRadii,The following statement contains a magic number: switch (countY) {              case 1: dimenY.mRight = dimenY.mTop;  // top-right same as top-left' and                goto case 2;              case 2: dimenY.mBottom = dimenY.mTop; // bottom-right same as top-left' and                 goto case 3;              case 3: dimenY.mLeft = dimenY.mRight; // bottom-left same as top-right              break;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBackgroundItem,The following statement contains a magic number: nsCSSValue[] positionArr = new nsCSSValue[4];
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBackgroundItem,The following statement contains a magic number: positionArr[3].SetPercentValue(0.0f);
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBackgroundPositionValues,The following statement contains a magic number: nsCSSValue[] value = new nsCSSValue[4];
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBackgroundPositionValues,The following statement contains a magic number: nsCSSValue xEdge   = value[0]'                       xOffset = value[1]'                       yEdge   = value[2]'                       yOffset = value[3];
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBackgroundPositionValues,The following statement contains a magic number: nsCSSValue xEdge   = value[0]'                       xOffset = value[1]'                       yEdge   = value[2]'                       yOffset = value[3];
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBackgroundPositionValues,The following statement contains a magic number: for (int32_t i = 0; i < 4; i++) {              if (!ParseVariant(ref value[i]' VARIANT_LPCALC | VARIANT_KEYWORD'                                nsCSSProps.kBackgroundPositionKTable)) {                break;              }              ++valueCount;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBackgroundPositionValues,The following statement contains a magic number: switch (valueCount) {              case 4:                // "If three or four values are given' then each <percentage> or <length>                // represents an offset and must be preceded by a keyword' which specifies                // from which edge the offset is given."                if (nsCSSUnit.Enumerated != xEdge.GetUnit() ||                    BG_CENTER == xEdge.GetIntValue() ||                    nsCSSUnit.Enumerated == xOffset.GetUnit() ||                    nsCSSUnit.Enumerated != yEdge.GetUnit() ||                    BG_CENTER == yEdge.GetIntValue() ||                    nsCSSUnit.Enumerated == yOffset.GetUnit()) {                  return false;                }                break;              case 3:                // "If three or four values are given' then each <percentage> or<length>                // represents an offset and must be preceded by a keyword' which specifies                // from which edge the offset is given." ... "If three values are given'                // the missing offset is assumed to be zero."                if (nsCSSUnit.Enumerated != value[1].GetUnit()) {                  // keyword offset keyword                  // Second value is non-keyword' thus first value must be a non-center                  // keyword.                  if (nsCSSUnit.Enumerated != value[0].GetUnit() ||                      BG_CENTER == value[0].GetIntValue()) {                    return false;                  }                            // Remaining value must be a keyword.                  if (nsCSSUnit.Enumerated != value[2].GetUnit()) {                    return false;                  }                            yOffset.Reset(); // Everything else is in the correct position.                } else if (nsCSSUnit.Enumerated != value[2].GetUnit()) {                  // keyword keyword offset                  // Third value is non-keyword' thus second value must be non-center                  // keyword.                  if (BG_CENTER == value[1].GetIntValue()) {                    return false;                  }                            // Remaining value must be a keyword.                  if (nsCSSUnit.Enumerated != value[0].GetUnit()) {                    return false;                  }                            // Move the values to the correct position in the array.                  value[3] = value[2]; // yOffset                  value[2] = value[1]; // yEdge                  value[1].Reset(); // xOffset                } else {                  return false;                }                break;              case 2:                // "If two values are given and at least one value is not a keyword' then                // the first value represents the horizontal position (or offset) and the                // second represents the vertical position (or offset)"                if (nsCSSUnit.Enumerated == value[0].GetUnit()) {                  if (nsCSSUnit.Enumerated == value[1].GetUnit()) {                    // keyword keyword                    value[2] = value[1]; // move yEdge to correct position                    xOffset.Reset();                    yOffset.Reset();                  } else {                    // keyword offset                    // First value must represent horizontal position.                    if (((BG_TOP | BG_BOTTOM) & value[0].GetIntValue()) != 0) {                      return false;                    }                    value[3] = value[1]; // move yOffset to correct position                    xOffset.Reset();                    yEdge.Reset();                  }                } else {                  if (nsCSSUnit.Enumerated == value[1].GetUnit()) {                    // offset keyword                    // Second value must represent vertical position.                    if (((BG_LEFT | BG_RIGHT) & value[1].GetIntValue()) != 0) {                      return false;                    }                    value[2] = value[1]; // move yEdge to correct position                    value[1] = value[0]; // move xOffset to correct position                    xEdge.Reset();                    yOffset.Reset();                  } else {                    // offset offset                    value[3] = value[1]; // move yOffset to correct position                    value[1] = value[0]; // move xOffset to correct position                    xEdge.Reset();                    yEdge.Reset();                  }                }                break;              case 1:                // "If only one value is specified' the second value is assumed to be                // center."                if (nsCSSUnit.Enumerated == value[0].GetUnit()) {                  xOffset.Reset();                } else {                  value[1] = value[0]; // move xOffset to correct position                  xEdge.Reset();                }                yEdge.SetIntValue(nsStyle.BgPositionCenter' nsCSSUnit.Enumerated);                yOffset.Reset();                break;              default:                return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBackgroundPositionValues,The following statement contains a magic number: switch (valueCount) {              case 4:                // "If three or four values are given' then each <percentage> or <length>                // represents an offset and must be preceded by a keyword' which specifies                // from which edge the offset is given."                if (nsCSSUnit.Enumerated != xEdge.GetUnit() ||                    BG_CENTER == xEdge.GetIntValue() ||                    nsCSSUnit.Enumerated == xOffset.GetUnit() ||                    nsCSSUnit.Enumerated != yEdge.GetUnit() ||                    BG_CENTER == yEdge.GetIntValue() ||                    nsCSSUnit.Enumerated == yOffset.GetUnit()) {                  return false;                }                break;              case 3:                // "If three or four values are given' then each <percentage> or<length>                // represents an offset and must be preceded by a keyword' which specifies                // from which edge the offset is given." ... "If three values are given'                // the missing offset is assumed to be zero."                if (nsCSSUnit.Enumerated != value[1].GetUnit()) {                  // keyword offset keyword                  // Second value is non-keyword' thus first value must be a non-center                  // keyword.                  if (nsCSSUnit.Enumerated != value[0].GetUnit() ||                      BG_CENTER == value[0].GetIntValue()) {                    return false;                  }                            // Remaining value must be a keyword.                  if (nsCSSUnit.Enumerated != value[2].GetUnit()) {                    return false;                  }                            yOffset.Reset(); // Everything else is in the correct position.                } else if (nsCSSUnit.Enumerated != value[2].GetUnit()) {                  // keyword keyword offset                  // Third value is non-keyword' thus second value must be non-center                  // keyword.                  if (BG_CENTER == value[1].GetIntValue()) {                    return false;                  }                            // Remaining value must be a keyword.                  if (nsCSSUnit.Enumerated != value[0].GetUnit()) {                    return false;                  }                            // Move the values to the correct position in the array.                  value[3] = value[2]; // yOffset                  value[2] = value[1]; // yEdge                  value[1].Reset(); // xOffset                } else {                  return false;                }                break;              case 2:                // "If two values are given and at least one value is not a keyword' then                // the first value represents the horizontal position (or offset) and the                // second represents the vertical position (or offset)"                if (nsCSSUnit.Enumerated == value[0].GetUnit()) {                  if (nsCSSUnit.Enumerated == value[1].GetUnit()) {                    // keyword keyword                    value[2] = value[1]; // move yEdge to correct position                    xOffset.Reset();                    yOffset.Reset();                  } else {                    // keyword offset                    // First value must represent horizontal position.                    if (((BG_TOP | BG_BOTTOM) & value[0].GetIntValue()) != 0) {                      return false;                    }                    value[3] = value[1]; // move yOffset to correct position                    xOffset.Reset();                    yEdge.Reset();                  }                } else {                  if (nsCSSUnit.Enumerated == value[1].GetUnit()) {                    // offset keyword                    // Second value must represent vertical position.                    if (((BG_LEFT | BG_RIGHT) & value[1].GetIntValue()) != 0) {                      return false;                    }                    value[2] = value[1]; // move yEdge to correct position                    value[1] = value[0]; // move xOffset to correct position                    xEdge.Reset();                    yOffset.Reset();                  } else {                    // offset offset                    value[3] = value[1]; // move yOffset to correct position                    value[1] = value[0]; // move xOffset to correct position                    xEdge.Reset();                    yEdge.Reset();                  }                }                break;              case 1:                // "If only one value is specified' the second value is assumed to be                // center."                if (nsCSSUnit.Enumerated == value[0].GetUnit()) {                  xOffset.Reset();                } else {                  value[1] = value[0]; // move xOffset to correct position                  xEdge.Reset();                }                yEdge.SetIntValue(nsStyle.BgPositionCenter' nsCSSUnit.Enumerated);                yOffset.Reset();                break;              default:                return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBackgroundPositionValues,The following statement contains a magic number: switch (valueCount) {              case 4:                // "If three or four values are given' then each <percentage> or <length>                // represents an offset and must be preceded by a keyword' which specifies                // from which edge the offset is given."                if (nsCSSUnit.Enumerated != xEdge.GetUnit() ||                    BG_CENTER == xEdge.GetIntValue() ||                    nsCSSUnit.Enumerated == xOffset.GetUnit() ||                    nsCSSUnit.Enumerated != yEdge.GetUnit() ||                    BG_CENTER == yEdge.GetIntValue() ||                    nsCSSUnit.Enumerated == yOffset.GetUnit()) {                  return false;                }                break;              case 3:                // "If three or four values are given' then each <percentage> or<length>                // represents an offset and must be preceded by a keyword' which specifies                // from which edge the offset is given." ... "If three values are given'                // the missing offset is assumed to be zero."                if (nsCSSUnit.Enumerated != value[1].GetUnit()) {                  // keyword offset keyword                  // Second value is non-keyword' thus first value must be a non-center                  // keyword.                  if (nsCSSUnit.Enumerated != value[0].GetUnit() ||                      BG_CENTER == value[0].GetIntValue()) {                    return false;                  }                            // Remaining value must be a keyword.                  if (nsCSSUnit.Enumerated != value[2].GetUnit()) {                    return false;                  }                            yOffset.Reset(); // Everything else is in the correct position.                } else if (nsCSSUnit.Enumerated != value[2].GetUnit()) {                  // keyword keyword offset                  // Third value is non-keyword' thus second value must be non-center                  // keyword.                  if (BG_CENTER == value[1].GetIntValue()) {                    return false;                  }                            // Remaining value must be a keyword.                  if (nsCSSUnit.Enumerated != value[0].GetUnit()) {                    return false;                  }                            // Move the values to the correct position in the array.                  value[3] = value[2]; // yOffset                  value[2] = value[1]; // yEdge                  value[1].Reset(); // xOffset                } else {                  return false;                }                break;              case 2:                // "If two values are given and at least one value is not a keyword' then                // the first value represents the horizontal position (or offset) and the                // second represents the vertical position (or offset)"                if (nsCSSUnit.Enumerated == value[0].GetUnit()) {                  if (nsCSSUnit.Enumerated == value[1].GetUnit()) {                    // keyword keyword                    value[2] = value[1]; // move yEdge to correct position                    xOffset.Reset();                    yOffset.Reset();                  } else {                    // keyword offset                    // First value must represent horizontal position.                    if (((BG_TOP | BG_BOTTOM) & value[0].GetIntValue()) != 0) {                      return false;                    }                    value[3] = value[1]; // move yOffset to correct position                    xOffset.Reset();                    yEdge.Reset();                  }                } else {                  if (nsCSSUnit.Enumerated == value[1].GetUnit()) {                    // offset keyword                    // Second value must represent vertical position.                    if (((BG_LEFT | BG_RIGHT) & value[1].GetIntValue()) != 0) {                      return false;                    }                    value[2] = value[1]; // move yEdge to correct position                    value[1] = value[0]; // move xOffset to correct position                    xEdge.Reset();                    yOffset.Reset();                  } else {                    // offset offset                    value[3] = value[1]; // move yOffset to correct position                    value[1] = value[0]; // move xOffset to correct position                    xEdge.Reset();                    yEdge.Reset();                  }                }                break;              case 1:                // "If only one value is specified' the second value is assumed to be                // center."                if (nsCSSUnit.Enumerated == value[0].GetUnit()) {                  xOffset.Reset();                } else {                  value[1] = value[0]; // move xOffset to correct position                  xEdge.Reset();                }                yEdge.SetIntValue(nsStyle.BgPositionCenter' nsCSSUnit.Enumerated);                yOffset.Reset();                break;              default:                return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBackgroundPositionValues,The following statement contains a magic number: switch (valueCount) {              case 4:                // "If three or four values are given' then each <percentage> or <length>                // represents an offset and must be preceded by a keyword' which specifies                // from which edge the offset is given."                if (nsCSSUnit.Enumerated != xEdge.GetUnit() ||                    BG_CENTER == xEdge.GetIntValue() ||                    nsCSSUnit.Enumerated == xOffset.GetUnit() ||                    nsCSSUnit.Enumerated != yEdge.GetUnit() ||                    BG_CENTER == yEdge.GetIntValue() ||                    nsCSSUnit.Enumerated == yOffset.GetUnit()) {                  return false;                }                break;              case 3:                // "If three or four values are given' then each <percentage> or<length>                // represents an offset and must be preceded by a keyword' which specifies                // from which edge the offset is given." ... "If three values are given'                // the missing offset is assumed to be zero."                if (nsCSSUnit.Enumerated != value[1].GetUnit()) {                  // keyword offset keyword                  // Second value is non-keyword' thus first value must be a non-center                  // keyword.                  if (nsCSSUnit.Enumerated != value[0].GetUnit() ||                      BG_CENTER == value[0].GetIntValue()) {                    return false;                  }                            // Remaining value must be a keyword.                  if (nsCSSUnit.Enumerated != value[2].GetUnit()) {                    return false;                  }                            yOffset.Reset(); // Everything else is in the correct position.                } else if (nsCSSUnit.Enumerated != value[2].GetUnit()) {                  // keyword keyword offset                  // Third value is non-keyword' thus second value must be non-center                  // keyword.                  if (BG_CENTER == value[1].GetIntValue()) {                    return false;                  }                            // Remaining value must be a keyword.                  if (nsCSSUnit.Enumerated != value[0].GetUnit()) {                    return false;                  }                            // Move the values to the correct position in the array.                  value[3] = value[2]; // yOffset                  value[2] = value[1]; // yEdge                  value[1].Reset(); // xOffset                } else {                  return false;                }                break;              case 2:                // "If two values are given and at least one value is not a keyword' then                // the first value represents the horizontal position (or offset) and the                // second represents the vertical position (or offset)"                if (nsCSSUnit.Enumerated == value[0].GetUnit()) {                  if (nsCSSUnit.Enumerated == value[1].GetUnit()) {                    // keyword keyword                    value[2] = value[1]; // move yEdge to correct position                    xOffset.Reset();                    yOffset.Reset();                  } else {                    // keyword offset                    // First value must represent horizontal position.                    if (((BG_TOP | BG_BOTTOM) & value[0].GetIntValue()) != 0) {                      return false;                    }                    value[3] = value[1]; // move yOffset to correct position                    xOffset.Reset();                    yEdge.Reset();                  }                } else {                  if (nsCSSUnit.Enumerated == value[1].GetUnit()) {                    // offset keyword                    // Second value must represent vertical position.                    if (((BG_LEFT | BG_RIGHT) & value[1].GetIntValue()) != 0) {                      return false;                    }                    value[2] = value[1]; // move yEdge to correct position                    value[1] = value[0]; // move xOffset to correct position                    xEdge.Reset();                    yOffset.Reset();                  } else {                    // offset offset                    value[3] = value[1]; // move yOffset to correct position                    value[1] = value[0]; // move xOffset to correct position                    xEdge.Reset();                    yEdge.Reset();                  }                }                break;              case 1:                // "If only one value is specified' the second value is assumed to be                // center."                if (nsCSSUnit.Enumerated == value[0].GetUnit()) {                  xOffset.Reset();                } else {                  value[1] = value[0]; // move xOffset to correct position                  xEdge.Reset();                }                yEdge.SetIntValue(nsStyle.BgPositionCenter' nsCSSUnit.Enumerated);                yOffset.Reset();                break;              default:                return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBackgroundPositionValues,The following statement contains a magic number: switch (valueCount) {              case 4:                // "If three or four values are given' then each <percentage> or <length>                // represents an offset and must be preceded by a keyword' which specifies                // from which edge the offset is given."                if (nsCSSUnit.Enumerated != xEdge.GetUnit() ||                    BG_CENTER == xEdge.GetIntValue() ||                    nsCSSUnit.Enumerated == xOffset.GetUnit() ||                    nsCSSUnit.Enumerated != yEdge.GetUnit() ||                    BG_CENTER == yEdge.GetIntValue() ||                    nsCSSUnit.Enumerated == yOffset.GetUnit()) {                  return false;                }                break;              case 3:                // "If three or four values are given' then each <percentage> or<length>                // represents an offset and must be preceded by a keyword' which specifies                // from which edge the offset is given." ... "If three values are given'                // the missing offset is assumed to be zero."                if (nsCSSUnit.Enumerated != value[1].GetUnit()) {                  // keyword offset keyword                  // Second value is non-keyword' thus first value must be a non-center                  // keyword.                  if (nsCSSUnit.Enumerated != value[0].GetUnit() ||                      BG_CENTER == value[0].GetIntValue()) {                    return false;                  }                            // Remaining value must be a keyword.                  if (nsCSSUnit.Enumerated != value[2].GetUnit()) {                    return false;                  }                            yOffset.Reset(); // Everything else is in the correct position.                } else if (nsCSSUnit.Enumerated != value[2].GetUnit()) {                  // keyword keyword offset                  // Third value is non-keyword' thus second value must be non-center                  // keyword.                  if (BG_CENTER == value[1].GetIntValue()) {                    return false;                  }                            // Remaining value must be a keyword.                  if (nsCSSUnit.Enumerated != value[0].GetUnit()) {                    return false;                  }                            // Move the values to the correct position in the array.                  value[3] = value[2]; // yOffset                  value[2] = value[1]; // yEdge                  value[1].Reset(); // xOffset                } else {                  return false;                }                break;              case 2:                // "If two values are given and at least one value is not a keyword' then                // the first value represents the horizontal position (or offset) and the                // second represents the vertical position (or offset)"                if (nsCSSUnit.Enumerated == value[0].GetUnit()) {                  if (nsCSSUnit.Enumerated == value[1].GetUnit()) {                    // keyword keyword                    value[2] = value[1]; // move yEdge to correct position                    xOffset.Reset();                    yOffset.Reset();                  } else {                    // keyword offset                    // First value must represent horizontal position.                    if (((BG_TOP | BG_BOTTOM) & value[0].GetIntValue()) != 0) {                      return false;                    }                    value[3] = value[1]; // move yOffset to correct position                    xOffset.Reset();                    yEdge.Reset();                  }                } else {                  if (nsCSSUnit.Enumerated == value[1].GetUnit()) {                    // offset keyword                    // Second value must represent vertical position.                    if (((BG_LEFT | BG_RIGHT) & value[1].GetIntValue()) != 0) {                      return false;                    }                    value[2] = value[1]; // move yEdge to correct position                    value[1] = value[0]; // move xOffset to correct position                    xEdge.Reset();                    yOffset.Reset();                  } else {                    // offset offset                    value[3] = value[1]; // move yOffset to correct position                    value[1] = value[0]; // move xOffset to correct position                    xEdge.Reset();                    yEdge.Reset();                  }                }                break;              case 1:                // "If only one value is specified' the second value is assumed to be                // center."                if (nsCSSUnit.Enumerated == value[0].GetUnit()) {                  xOffset.Reset();                } else {                  value[1] = value[0]; // move xOffset to correct position                  xEdge.Reset();                }                yEdge.SetIntValue(nsStyle.BgPositionCenter' nsCSSUnit.Enumerated);                yOffset.Reset();                break;              default:                return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBackgroundPositionValues,The following statement contains a magic number: switch (valueCount) {              case 4:                // "If three or four values are given' then each <percentage> or <length>                // represents an offset and must be preceded by a keyword' which specifies                // from which edge the offset is given."                if (nsCSSUnit.Enumerated != xEdge.GetUnit() ||                    BG_CENTER == xEdge.GetIntValue() ||                    nsCSSUnit.Enumerated == xOffset.GetUnit() ||                    nsCSSUnit.Enumerated != yEdge.GetUnit() ||                    BG_CENTER == yEdge.GetIntValue() ||                    nsCSSUnit.Enumerated == yOffset.GetUnit()) {                  return false;                }                break;              case 3:                // "If three or four values are given' then each <percentage> or<length>                // represents an offset and must be preceded by a keyword' which specifies                // from which edge the offset is given." ... "If three values are given'                // the missing offset is assumed to be zero."                if (nsCSSUnit.Enumerated != value[1].GetUnit()) {                  // keyword offset keyword                  // Second value is non-keyword' thus first value must be a non-center                  // keyword.                  if (nsCSSUnit.Enumerated != value[0].GetUnit() ||                      BG_CENTER == value[0].GetIntValue()) {                    return false;                  }                            // Remaining value must be a keyword.                  if (nsCSSUnit.Enumerated != value[2].GetUnit()) {                    return false;                  }                            yOffset.Reset(); // Everything else is in the correct position.                } else if (nsCSSUnit.Enumerated != value[2].GetUnit()) {                  // keyword keyword offset                  // Third value is non-keyword' thus second value must be non-center                  // keyword.                  if (BG_CENTER == value[1].GetIntValue()) {                    return false;                  }                            // Remaining value must be a keyword.                  if (nsCSSUnit.Enumerated != value[0].GetUnit()) {                    return false;                  }                            // Move the values to the correct position in the array.                  value[3] = value[2]; // yOffset                  value[2] = value[1]; // yEdge                  value[1].Reset(); // xOffset                } else {                  return false;                }                break;              case 2:                // "If two values are given and at least one value is not a keyword' then                // the first value represents the horizontal position (or offset) and the                // second represents the vertical position (or offset)"                if (nsCSSUnit.Enumerated == value[0].GetUnit()) {                  if (nsCSSUnit.Enumerated == value[1].GetUnit()) {                    // keyword keyword                    value[2] = value[1]; // move yEdge to correct position                    xOffset.Reset();                    yOffset.Reset();                  } else {                    // keyword offset                    // First value must represent horizontal position.                    if (((BG_TOP | BG_BOTTOM) & value[0].GetIntValue()) != 0) {                      return false;                    }                    value[3] = value[1]; // move yOffset to correct position                    xOffset.Reset();                    yEdge.Reset();                  }                } else {                  if (nsCSSUnit.Enumerated == value[1].GetUnit()) {                    // offset keyword                    // Second value must represent vertical position.                    if (((BG_LEFT | BG_RIGHT) & value[1].GetIntValue()) != 0) {                      return false;                    }                    value[2] = value[1]; // move yEdge to correct position                    value[1] = value[0]; // move xOffset to correct position                    xEdge.Reset();                    yOffset.Reset();                  } else {                    // offset offset                    value[3] = value[1]; // move yOffset to correct position                    value[1] = value[0]; // move xOffset to correct position                    xEdge.Reset();                    yEdge.Reset();                  }                }                break;              case 1:                // "If only one value is specified' the second value is assumed to be                // center."                if (nsCSSUnit.Enumerated == value[0].GetUnit()) {                  xOffset.Reset();                } else {                  value[1] = value[0]; // move xOffset to correct position                  xEdge.Reset();                }                yEdge.SetIntValue(nsStyle.BgPositionCenter' nsCSSUnit.Enumerated);                yOffset.Reset();                break;              default:                return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBackgroundPositionValues,The following statement contains a magic number: switch (valueCount) {              case 4:                // "If three or four values are given' then each <percentage> or <length>                // represents an offset and must be preceded by a keyword' which specifies                // from which edge the offset is given."                if (nsCSSUnit.Enumerated != xEdge.GetUnit() ||                    BG_CENTER == xEdge.GetIntValue() ||                    nsCSSUnit.Enumerated == xOffset.GetUnit() ||                    nsCSSUnit.Enumerated != yEdge.GetUnit() ||                    BG_CENTER == yEdge.GetIntValue() ||                    nsCSSUnit.Enumerated == yOffset.GetUnit()) {                  return false;                }                break;              case 3:                // "If three or four values are given' then each <percentage> or<length>                // represents an offset and must be preceded by a keyword' which specifies                // from which edge the offset is given." ... "If three values are given'                // the missing offset is assumed to be zero."                if (nsCSSUnit.Enumerated != value[1].GetUnit()) {                  // keyword offset keyword                  // Second value is non-keyword' thus first value must be a non-center                  // keyword.                  if (nsCSSUnit.Enumerated != value[0].GetUnit() ||                      BG_CENTER == value[0].GetIntValue()) {                    return false;                  }                            // Remaining value must be a keyword.                  if (nsCSSUnit.Enumerated != value[2].GetUnit()) {                    return false;                  }                            yOffset.Reset(); // Everything else is in the correct position.                } else if (nsCSSUnit.Enumerated != value[2].GetUnit()) {                  // keyword keyword offset                  // Third value is non-keyword' thus second value must be non-center                  // keyword.                  if (BG_CENTER == value[1].GetIntValue()) {                    return false;                  }                            // Remaining value must be a keyword.                  if (nsCSSUnit.Enumerated != value[0].GetUnit()) {                    return false;                  }                            // Move the values to the correct position in the array.                  value[3] = value[2]; // yOffset                  value[2] = value[1]; // yEdge                  value[1].Reset(); // xOffset                } else {                  return false;                }                break;              case 2:                // "If two values are given and at least one value is not a keyword' then                // the first value represents the horizontal position (or offset) and the                // second represents the vertical position (or offset)"                if (nsCSSUnit.Enumerated == value[0].GetUnit()) {                  if (nsCSSUnit.Enumerated == value[1].GetUnit()) {                    // keyword keyword                    value[2] = value[1]; // move yEdge to correct position                    xOffset.Reset();                    yOffset.Reset();                  } else {                    // keyword offset                    // First value must represent horizontal position.                    if (((BG_TOP | BG_BOTTOM) & value[0].GetIntValue()) != 0) {                      return false;                    }                    value[3] = value[1]; // move yOffset to correct position                    xOffset.Reset();                    yEdge.Reset();                  }                } else {                  if (nsCSSUnit.Enumerated == value[1].GetUnit()) {                    // offset keyword                    // Second value must represent vertical position.                    if (((BG_LEFT | BG_RIGHT) & value[1].GetIntValue()) != 0) {                      return false;                    }                    value[2] = value[1]; // move yEdge to correct position                    value[1] = value[0]; // move xOffset to correct position                    xEdge.Reset();                    yOffset.Reset();                  } else {                    // offset offset                    value[3] = value[1]; // move yOffset to correct position                    value[1] = value[0]; // move xOffset to correct position                    xEdge.Reset();                    yEdge.Reset();                  }                }                break;              case 1:                // "If only one value is specified' the second value is assumed to be                // center."                if (nsCSSUnit.Enumerated == value[0].GetUnit()) {                  xOffset.Reset();                } else {                  value[1] = value[0]; // move xOffset to correct position                  xEdge.Reset();                }                yEdge.SetIntValue(nsStyle.BgPositionCenter' nsCSSUnit.Enumerated);                yOffset.Reset();                break;              default:                return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBackgroundPositionValues,The following statement contains a magic number: switch (valueCount) {              case 4:                // "If three or four values are given' then each <percentage> or <length>                // represents an offset and must be preceded by a keyword' which specifies                // from which edge the offset is given."                if (nsCSSUnit.Enumerated != xEdge.GetUnit() ||                    BG_CENTER == xEdge.GetIntValue() ||                    nsCSSUnit.Enumerated == xOffset.GetUnit() ||                    nsCSSUnit.Enumerated != yEdge.GetUnit() ||                    BG_CENTER == yEdge.GetIntValue() ||                    nsCSSUnit.Enumerated == yOffset.GetUnit()) {                  return false;                }                break;              case 3:                // "If three or four values are given' then each <percentage> or<length>                // represents an offset and must be preceded by a keyword' which specifies                // from which edge the offset is given." ... "If three values are given'                // the missing offset is assumed to be zero."                if (nsCSSUnit.Enumerated != value[1].GetUnit()) {                  // keyword offset keyword                  // Second value is non-keyword' thus first value must be a non-center                  // keyword.                  if (nsCSSUnit.Enumerated != value[0].GetUnit() ||                      BG_CENTER == value[0].GetIntValue()) {                    return false;                  }                            // Remaining value must be a keyword.                  if (nsCSSUnit.Enumerated != value[2].GetUnit()) {                    return false;                  }                            yOffset.Reset(); // Everything else is in the correct position.                } else if (nsCSSUnit.Enumerated != value[2].GetUnit()) {                  // keyword keyword offset                  // Third value is non-keyword' thus second value must be non-center                  // keyword.                  if (BG_CENTER == value[1].GetIntValue()) {                    return false;                  }                            // Remaining value must be a keyword.                  if (nsCSSUnit.Enumerated != value[0].GetUnit()) {                    return false;                  }                            // Move the values to the correct position in the array.                  value[3] = value[2]; // yOffset                  value[2] = value[1]; // yEdge                  value[1].Reset(); // xOffset                } else {                  return false;                }                break;              case 2:                // "If two values are given and at least one value is not a keyword' then                // the first value represents the horizontal position (or offset) and the                // second represents the vertical position (or offset)"                if (nsCSSUnit.Enumerated == value[0].GetUnit()) {                  if (nsCSSUnit.Enumerated == value[1].GetUnit()) {                    // keyword keyword                    value[2] = value[1]; // move yEdge to correct position                    xOffset.Reset();                    yOffset.Reset();                  } else {                    // keyword offset                    // First value must represent horizontal position.                    if (((BG_TOP | BG_BOTTOM) & value[0].GetIntValue()) != 0) {                      return false;                    }                    value[3] = value[1]; // move yOffset to correct position                    xOffset.Reset();                    yEdge.Reset();                  }                } else {                  if (nsCSSUnit.Enumerated == value[1].GetUnit()) {                    // offset keyword                    // Second value must represent vertical position.                    if (((BG_LEFT | BG_RIGHT) & value[1].GetIntValue()) != 0) {                      return false;                    }                    value[2] = value[1]; // move yEdge to correct position                    value[1] = value[0]; // move xOffset to correct position                    xEdge.Reset();                    yOffset.Reset();                  } else {                    // offset offset                    value[3] = value[1]; // move yOffset to correct position                    value[1] = value[0]; // move xOffset to correct position                    xEdge.Reset();                    yEdge.Reset();                  }                }                break;              case 1:                // "If only one value is specified' the second value is assumed to be                // center."                if (nsCSSUnit.Enumerated == value[0].GetUnit()) {                  xOffset.Reset();                } else {                  value[1] = value[0]; // move xOffset to correct position                  xEdge.Reset();                }                yEdge.SetIntValue(nsStyle.BgPositionCenter' nsCSSUnit.Enumerated);                yOffset.Reset();                break;              default:                return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBackgroundPositionValues,The following statement contains a magic number: switch (valueCount) {              case 4:                // "If three or four values are given' then each <percentage> or <length>                // represents an offset and must be preceded by a keyword' which specifies                // from which edge the offset is given."                if (nsCSSUnit.Enumerated != xEdge.GetUnit() ||                    BG_CENTER == xEdge.GetIntValue() ||                    nsCSSUnit.Enumerated == xOffset.GetUnit() ||                    nsCSSUnit.Enumerated != yEdge.GetUnit() ||                    BG_CENTER == yEdge.GetIntValue() ||                    nsCSSUnit.Enumerated == yOffset.GetUnit()) {                  return false;                }                break;              case 3:                // "If three or four values are given' then each <percentage> or<length>                // represents an offset and must be preceded by a keyword' which specifies                // from which edge the offset is given." ... "If three values are given'                // the missing offset is assumed to be zero."                if (nsCSSUnit.Enumerated != value[1].GetUnit()) {                  // keyword offset keyword                  // Second value is non-keyword' thus first value must be a non-center                  // keyword.                  if (nsCSSUnit.Enumerated != value[0].GetUnit() ||                      BG_CENTER == value[0].GetIntValue()) {                    return false;                  }                            // Remaining value must be a keyword.                  if (nsCSSUnit.Enumerated != value[2].GetUnit()) {                    return false;                  }                            yOffset.Reset(); // Everything else is in the correct position.                } else if (nsCSSUnit.Enumerated != value[2].GetUnit()) {                  // keyword keyword offset                  // Third value is non-keyword' thus second value must be non-center                  // keyword.                  if (BG_CENTER == value[1].GetIntValue()) {                    return false;                  }                            // Remaining value must be a keyword.                  if (nsCSSUnit.Enumerated != value[0].GetUnit()) {                    return false;                  }                            // Move the values to the correct position in the array.                  value[3] = value[2]; // yOffset                  value[2] = value[1]; // yEdge                  value[1].Reset(); // xOffset                } else {                  return false;                }                break;              case 2:                // "If two values are given and at least one value is not a keyword' then                // the first value represents the horizontal position (or offset) and the                // second represents the vertical position (or offset)"                if (nsCSSUnit.Enumerated == value[0].GetUnit()) {                  if (nsCSSUnit.Enumerated == value[1].GetUnit()) {                    // keyword keyword                    value[2] = value[1]; // move yEdge to correct position                    xOffset.Reset();                    yOffset.Reset();                  } else {                    // keyword offset                    // First value must represent horizontal position.                    if (((BG_TOP | BG_BOTTOM) & value[0].GetIntValue()) != 0) {                      return false;                    }                    value[3] = value[1]; // move yOffset to correct position                    xOffset.Reset();                    yEdge.Reset();                  }                } else {                  if (nsCSSUnit.Enumerated == value[1].GetUnit()) {                    // offset keyword                    // Second value must represent vertical position.                    if (((BG_LEFT | BG_RIGHT) & value[1].GetIntValue()) != 0) {                      return false;                    }                    value[2] = value[1]; // move yEdge to correct position                    value[1] = value[0]; // move xOffset to correct position                    xEdge.Reset();                    yOffset.Reset();                  } else {                    // offset offset                    value[3] = value[1]; // move yOffset to correct position                    value[1] = value[0]; // move xOffset to correct position                    xEdge.Reset();                    yEdge.Reset();                  }                }                break;              case 1:                // "If only one value is specified' the second value is assumed to be                // center."                if (nsCSSUnit.Enumerated == value[0].GetUnit()) {                  xOffset.Reset();                } else {                  value[1] = value[0]; // move xOffset to correct position                  xEdge.Reset();                }                yEdge.SetIntValue(nsStyle.BgPositionCenter' nsCSSUnit.Enumerated);                yOffset.Reset();                break;              default:                return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBackgroundPositionValues,The following statement contains a magic number: switch (valueCount) {              case 4:                // "If three or four values are given' then each <percentage> or <length>                // represents an offset and must be preceded by a keyword' which specifies                // from which edge the offset is given."                if (nsCSSUnit.Enumerated != xEdge.GetUnit() ||                    BG_CENTER == xEdge.GetIntValue() ||                    nsCSSUnit.Enumerated == xOffset.GetUnit() ||                    nsCSSUnit.Enumerated != yEdge.GetUnit() ||                    BG_CENTER == yEdge.GetIntValue() ||                    nsCSSUnit.Enumerated == yOffset.GetUnit()) {                  return false;                }                break;              case 3:                // "If three or four values are given' then each <percentage> or<length>                // represents an offset and must be preceded by a keyword' which specifies                // from which edge the offset is given." ... "If three values are given'                // the missing offset is assumed to be zero."                if (nsCSSUnit.Enumerated != value[1].GetUnit()) {                  // keyword offset keyword                  // Second value is non-keyword' thus first value must be a non-center                  // keyword.                  if (nsCSSUnit.Enumerated != value[0].GetUnit() ||                      BG_CENTER == value[0].GetIntValue()) {                    return false;                  }                            // Remaining value must be a keyword.                  if (nsCSSUnit.Enumerated != value[2].GetUnit()) {                    return false;                  }                            yOffset.Reset(); // Everything else is in the correct position.                } else if (nsCSSUnit.Enumerated != value[2].GetUnit()) {                  // keyword keyword offset                  // Third value is non-keyword' thus second value must be non-center                  // keyword.                  if (BG_CENTER == value[1].GetIntValue()) {                    return false;                  }                            // Remaining value must be a keyword.                  if (nsCSSUnit.Enumerated != value[0].GetUnit()) {                    return false;                  }                            // Move the values to the correct position in the array.                  value[3] = value[2]; // yOffset                  value[2] = value[1]; // yEdge                  value[1].Reset(); // xOffset                } else {                  return false;                }                break;              case 2:                // "If two values are given and at least one value is not a keyword' then                // the first value represents the horizontal position (or offset) and the                // second represents the vertical position (or offset)"                if (nsCSSUnit.Enumerated == value[0].GetUnit()) {                  if (nsCSSUnit.Enumerated == value[1].GetUnit()) {                    // keyword keyword                    value[2] = value[1]; // move yEdge to correct position                    xOffset.Reset();                    yOffset.Reset();                  } else {                    // keyword offset                    // First value must represent horizontal position.                    if (((BG_TOP | BG_BOTTOM) & value[0].GetIntValue()) != 0) {                      return false;                    }                    value[3] = value[1]; // move yOffset to correct position                    xOffset.Reset();                    yEdge.Reset();                  }                } else {                  if (nsCSSUnit.Enumerated == value[1].GetUnit()) {                    // offset keyword                    // Second value must represent vertical position.                    if (((BG_LEFT | BG_RIGHT) & value[1].GetIntValue()) != 0) {                      return false;                    }                    value[2] = value[1]; // move yEdge to correct position                    value[1] = value[0]; // move xOffset to correct position                    xEdge.Reset();                    yOffset.Reset();                  } else {                    // offset offset                    value[3] = value[1]; // move yOffset to correct position                    value[1] = value[0]; // move xOffset to correct position                    xEdge.Reset();                    yEdge.Reset();                  }                }                break;              case 1:                // "If only one value is specified' the second value is assumed to be                // center."                if (nsCSSUnit.Enumerated == value[0].GetUnit()) {                  xOffset.Reset();                } else {                  value[1] = value[0]; // move xOffset to correct position                  xEdge.Reset();                }                yEdge.SetIntValue(nsStyle.BgPositionCenter' nsCSSUnit.Enumerated);                yOffset.Reset();                break;              default:                return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBackgroundPositionValues,The following statement contains a magic number: switch (valueCount) {              case 4:                // "If three or four values are given' then each <percentage> or <length>                // represents an offset and must be preceded by a keyword' which specifies                // from which edge the offset is given."                if (nsCSSUnit.Enumerated != xEdge.GetUnit() ||                    BG_CENTER == xEdge.GetIntValue() ||                    nsCSSUnit.Enumerated == xOffset.GetUnit() ||                    nsCSSUnit.Enumerated != yEdge.GetUnit() ||                    BG_CENTER == yEdge.GetIntValue() ||                    nsCSSUnit.Enumerated == yOffset.GetUnit()) {                  return false;                }                break;              case 3:                // "If three or four values are given' then each <percentage> or<length>                // represents an offset and must be preceded by a keyword' which specifies                // from which edge the offset is given." ... "If three values are given'                // the missing offset is assumed to be zero."                if (nsCSSUnit.Enumerated != value[1].GetUnit()) {                  // keyword offset keyword                  // Second value is non-keyword' thus first value must be a non-center                  // keyword.                  if (nsCSSUnit.Enumerated != value[0].GetUnit() ||                      BG_CENTER == value[0].GetIntValue()) {                    return false;                  }                            // Remaining value must be a keyword.                  if (nsCSSUnit.Enumerated != value[2].GetUnit()) {                    return false;                  }                            yOffset.Reset(); // Everything else is in the correct position.                } else if (nsCSSUnit.Enumerated != value[2].GetUnit()) {                  // keyword keyword offset                  // Third value is non-keyword' thus second value must be non-center                  // keyword.                  if (BG_CENTER == value[1].GetIntValue()) {                    return false;                  }                            // Remaining value must be a keyword.                  if (nsCSSUnit.Enumerated != value[0].GetUnit()) {                    return false;                  }                            // Move the values to the correct position in the array.                  value[3] = value[2]; // yOffset                  value[2] = value[1]; // yEdge                  value[1].Reset(); // xOffset                } else {                  return false;                }                break;              case 2:                // "If two values are given and at least one value is not a keyword' then                // the first value represents the horizontal position (or offset) and the                // second represents the vertical position (or offset)"                if (nsCSSUnit.Enumerated == value[0].GetUnit()) {                  if (nsCSSUnit.Enumerated == value[1].GetUnit()) {                    // keyword keyword                    value[2] = value[1]; // move yEdge to correct position                    xOffset.Reset();                    yOffset.Reset();                  } else {                    // keyword offset                    // First value must represent horizontal position.                    if (((BG_TOP | BG_BOTTOM) & value[0].GetIntValue()) != 0) {                      return false;                    }                    value[3] = value[1]; // move yOffset to correct position                    xOffset.Reset();                    yEdge.Reset();                  }                } else {                  if (nsCSSUnit.Enumerated == value[1].GetUnit()) {                    // offset keyword                    // Second value must represent vertical position.                    if (((BG_LEFT | BG_RIGHT) & value[1].GetIntValue()) != 0) {                      return false;                    }                    value[2] = value[1]; // move yEdge to correct position                    value[1] = value[0]; // move xOffset to correct position                    xEdge.Reset();                    yOffset.Reset();                  } else {                    // offset offset                    value[3] = value[1]; // move yOffset to correct position                    value[1] = value[0]; // move xOffset to correct position                    xEdge.Reset();                    yEdge.Reset();                  }                }                break;              case 1:                // "If only one value is specified' the second value is assumed to be                // center."                if (nsCSSUnit.Enumerated == value[0].GetUnit()) {                  xOffset.Reset();                } else {                  value[1] = value[0]; // move xOffset to correct position                  xEdge.Reset();                }                yEdge.SetIntValue(nsStyle.BgPositionCenter' nsCSSUnit.Enumerated);                yOffset.Reset();                break;              default:                return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBackgroundPositionValues,The following statement contains a magic number: switch (valueCount) {              case 4:                // "If three or four values are given' then each <percentage> or <length>                // represents an offset and must be preceded by a keyword' which specifies                // from which edge the offset is given."                if (nsCSSUnit.Enumerated != xEdge.GetUnit() ||                    BG_CENTER == xEdge.GetIntValue() ||                    nsCSSUnit.Enumerated == xOffset.GetUnit() ||                    nsCSSUnit.Enumerated != yEdge.GetUnit() ||                    BG_CENTER == yEdge.GetIntValue() ||                    nsCSSUnit.Enumerated == yOffset.GetUnit()) {                  return false;                }                break;              case 3:                // "If three or four values are given' then each <percentage> or<length>                // represents an offset and must be preceded by a keyword' which specifies                // from which edge the offset is given." ... "If three values are given'                // the missing offset is assumed to be zero."                if (nsCSSUnit.Enumerated != value[1].GetUnit()) {                  // keyword offset keyword                  // Second value is non-keyword' thus first value must be a non-center                  // keyword.                  if (nsCSSUnit.Enumerated != value[0].GetUnit() ||                      BG_CENTER == value[0].GetIntValue()) {                    return false;                  }                            // Remaining value must be a keyword.                  if (nsCSSUnit.Enumerated != value[2].GetUnit()) {                    return false;                  }                            yOffset.Reset(); // Everything else is in the correct position.                } else if (nsCSSUnit.Enumerated != value[2].GetUnit()) {                  // keyword keyword offset                  // Third value is non-keyword' thus second value must be non-center                  // keyword.                  if (BG_CENTER == value[1].GetIntValue()) {                    return false;                  }                            // Remaining value must be a keyword.                  if (nsCSSUnit.Enumerated != value[0].GetUnit()) {                    return false;                  }                            // Move the values to the correct position in the array.                  value[3] = value[2]; // yOffset                  value[2] = value[1]; // yEdge                  value[1].Reset(); // xOffset                } else {                  return false;                }                break;              case 2:                // "If two values are given and at least one value is not a keyword' then                // the first value represents the horizontal position (or offset) and the                // second represents the vertical position (or offset)"                if (nsCSSUnit.Enumerated == value[0].GetUnit()) {                  if (nsCSSUnit.Enumerated == value[1].GetUnit()) {                    // keyword keyword                    value[2] = value[1]; // move yEdge to correct position                    xOffset.Reset();                    yOffset.Reset();                  } else {                    // keyword offset                    // First value must represent horizontal position.                    if (((BG_TOP | BG_BOTTOM) & value[0].GetIntValue()) != 0) {                      return false;                    }                    value[3] = value[1]; // move yOffset to correct position                    xOffset.Reset();                    yEdge.Reset();                  }                } else {                  if (nsCSSUnit.Enumerated == value[1].GetUnit()) {                    // offset keyword                    // Second value must represent vertical position.                    if (((BG_LEFT | BG_RIGHT) & value[1].GetIntValue()) != 0) {                      return false;                    }                    value[2] = value[1]; // move yEdge to correct position                    value[1] = value[0]; // move xOffset to correct position                    xEdge.Reset();                    yOffset.Reset();                  } else {                    // offset offset                    value[3] = value[1]; // move yOffset to correct position                    value[1] = value[0]; // move xOffset to correct position                    xEdge.Reset();                    yEdge.Reset();                  }                }                break;              case 1:                // "If only one value is specified' the second value is assumed to be                // center."                if (nsCSSUnit.Enumerated == value[0].GetUnit()) {                  xOffset.Reset();                } else {                  value[1] = value[0]; // move xOffset to correct position                  xEdge.Reset();                }                yEdge.SetIntValue(nsStyle.BgPositionCenter' nsCSSUnit.Enumerated);                yOffset.Reset();                break;              default:                return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBorderSide,The following statement contains a magic number: uint32_t numProps = 3;
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBorderSide,The following statement contains a magic number: if ((found & 2) == 0) { // Provide default border-style              values[1].SetIntValue(nsStyle.BorderStyleNone' nsCSSUnit.Enumerated);            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBorderSide,The following statement contains a magic number: if ((found & 4) == 0) { // text color will be used              values[2].SetIntValue(nsStyle.ColorMozUseTextColor' nsCSSUnit.Enumerated);            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBorderSide,The following statement contains a magic number: if ((found & 4) == 0) { // text color will be used              values[2].SetIntValue(nsStyle.ColorMozUseTextColor' nsCSSUnit.Enumerated);            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBorderSide,The following statement contains a magic number: if (aSetAllSides) {              /*TODO: static*/ nsCSSProperty[] kBorderSources = {                nsCSSProperty.BorderLeftColorLtrSource'                nsCSSProperty.BorderLeftColorRtlSource'                nsCSSProperty.BorderRightColorLtrSource'                nsCSSProperty.BorderRightColorRtlSource'                nsCSSProperty.BorderLeftStyleLtrSource'                nsCSSProperty.BorderLeftStyleRtlSource'                nsCSSProperty.BorderRightStyleLtrSource'                nsCSSProperty.BorderRightStyleRtlSource'                nsCSSProperty.BorderLeftWidthLtrSource'                nsCSSProperty.BorderLeftWidthRtlSource'                nsCSSProperty.BorderRightWidthLtrSource'                nsCSSProperty.BorderRightWidthRtlSource'                nsCSSProperty.Unknown              };                        InitBoxPropsAsPhysical(kBorderSources);                        // Parsing "border" shorthand; set all four sides to the same thing              for (int32_t index = 0; index < 4; index++) {                Debug.Assert(numProps == 3' "This code needs updating");                AppendValue(kBorderWidthIDs[index]' values[0]);                AppendValue(kBorderStyleIDs[index]' values[1]);                AppendValue(kBorderColorIDs[index]' values[2]);              }                        /*TODO: static*/ nsCSSProperty[] kBorderColorsProps = {                nsCSSProperty.BorderTopColors'                nsCSSProperty.BorderRightColors'                nsCSSProperty.BorderBottomColors'                nsCSSProperty.BorderLeftColors              };                        // Set the other properties that the border shorthand sets to their              // initial values.              var extraValue = new nsCSSValue();              switch (values[0].GetUnit()) {              case nsCSSUnit.Inherit:              case nsCSSUnit.Initial:                extraValue = values[0];                // Set value of border-image properties to initial/inherit                AppendValue(nsCSSProperty.BorderImageSource' extraValue);                AppendValue(nsCSSProperty.BorderImageSlice' extraValue);                AppendValue(nsCSSProperty.BorderImageWidth' extraValue);                AppendValue(nsCSSProperty.BorderImageOutset' extraValue);                AppendValue(nsCSSProperty.BorderImageRepeat' extraValue);                break;              default:                extraValue.SetNoneValue();                SetBorderImageInitialValues();                break;              }              for (Side side = nsStyle.SideTop; side <= nsStyle.SideLeft; side++) {                AppendValue(kBorderColorsProps[(int)side]' extraValue);              }            }            else {              // Just set our one side              for (int32_t index = 0; index < numProps; index++) {                AppendValue(aPropIDs[(int)index]' values[index]);              }            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBorderSide,The following statement contains a magic number: if (aSetAllSides) {              /*TODO: static*/ nsCSSProperty[] kBorderSources = {                nsCSSProperty.BorderLeftColorLtrSource'                nsCSSProperty.BorderLeftColorRtlSource'                nsCSSProperty.BorderRightColorLtrSource'                nsCSSProperty.BorderRightColorRtlSource'                nsCSSProperty.BorderLeftStyleLtrSource'                nsCSSProperty.BorderLeftStyleRtlSource'                nsCSSProperty.BorderRightStyleLtrSource'                nsCSSProperty.BorderRightStyleRtlSource'                nsCSSProperty.BorderLeftWidthLtrSource'                nsCSSProperty.BorderLeftWidthRtlSource'                nsCSSProperty.BorderRightWidthLtrSource'                nsCSSProperty.BorderRightWidthRtlSource'                nsCSSProperty.Unknown              };                        InitBoxPropsAsPhysical(kBorderSources);                        // Parsing "border" shorthand; set all four sides to the same thing              for (int32_t index = 0; index < 4; index++) {                Debug.Assert(numProps == 3' "This code needs updating");                AppendValue(kBorderWidthIDs[index]' values[0]);                AppendValue(kBorderStyleIDs[index]' values[1]);                AppendValue(kBorderColorIDs[index]' values[2]);              }                        /*TODO: static*/ nsCSSProperty[] kBorderColorsProps = {                nsCSSProperty.BorderTopColors'                nsCSSProperty.BorderRightColors'                nsCSSProperty.BorderBottomColors'                nsCSSProperty.BorderLeftColors              };                        // Set the other properties that the border shorthand sets to their              // initial values.              var extraValue = new nsCSSValue();              switch (values[0].GetUnit()) {              case nsCSSUnit.Inherit:              case nsCSSUnit.Initial:                extraValue = values[0];                // Set value of border-image properties to initial/inherit                AppendValue(nsCSSProperty.BorderImageSource' extraValue);                AppendValue(nsCSSProperty.BorderImageSlice' extraValue);                AppendValue(nsCSSProperty.BorderImageWidth' extraValue);                AppendValue(nsCSSProperty.BorderImageOutset' extraValue);                AppendValue(nsCSSProperty.BorderImageRepeat' extraValue);                break;              default:                extraValue.SetNoneValue();                SetBorderImageInitialValues();                break;              }              for (Side side = nsStyle.SideTop; side <= nsStyle.SideLeft; side++) {                AppendValue(kBorderColorsProps[(int)side]' extraValue);              }            }            else {              // Just set our one side              for (int32_t index = 0; index < numProps; index++) {                AppendValue(aPropIDs[(int)index]' values[index]);              }            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBorderSide,The following statement contains a magic number: if (aSetAllSides) {              /*TODO: static*/ nsCSSProperty[] kBorderSources = {                nsCSSProperty.BorderLeftColorLtrSource'                nsCSSProperty.BorderLeftColorRtlSource'                nsCSSProperty.BorderRightColorLtrSource'                nsCSSProperty.BorderRightColorRtlSource'                nsCSSProperty.BorderLeftStyleLtrSource'                nsCSSProperty.BorderLeftStyleRtlSource'                nsCSSProperty.BorderRightStyleLtrSource'                nsCSSProperty.BorderRightStyleRtlSource'                nsCSSProperty.BorderLeftWidthLtrSource'                nsCSSProperty.BorderLeftWidthRtlSource'                nsCSSProperty.BorderRightWidthLtrSource'                nsCSSProperty.BorderRightWidthRtlSource'                nsCSSProperty.Unknown              };                        InitBoxPropsAsPhysical(kBorderSources);                        // Parsing "border" shorthand; set all four sides to the same thing              for (int32_t index = 0; index < 4; index++) {                Debug.Assert(numProps == 3' "This code needs updating");                AppendValue(kBorderWidthIDs[index]' values[0]);                AppendValue(kBorderStyleIDs[index]' values[1]);                AppendValue(kBorderColorIDs[index]' values[2]);              }                        /*TODO: static*/ nsCSSProperty[] kBorderColorsProps = {                nsCSSProperty.BorderTopColors'                nsCSSProperty.BorderRightColors'                nsCSSProperty.BorderBottomColors'                nsCSSProperty.BorderLeftColors              };                        // Set the other properties that the border shorthand sets to their              // initial values.              var extraValue = new nsCSSValue();              switch (values[0].GetUnit()) {              case nsCSSUnit.Inherit:              case nsCSSUnit.Initial:                extraValue = values[0];                // Set value of border-image properties to initial/inherit                AppendValue(nsCSSProperty.BorderImageSource' extraValue);                AppendValue(nsCSSProperty.BorderImageSlice' extraValue);                AppendValue(nsCSSProperty.BorderImageWidth' extraValue);                AppendValue(nsCSSProperty.BorderImageOutset' extraValue);                AppendValue(nsCSSProperty.BorderImageRepeat' extraValue);                break;              default:                extraValue.SetNoneValue();                SetBorderImageInitialValues();                break;              }              for (Side side = nsStyle.SideTop; side <= nsStyle.SideLeft; side++) {                AppendValue(kBorderColorsProps[(int)side]' extraValue);              }            }            else {              // Just set our one side              for (int32_t index = 0; index < numProps; index++) {                AppendValue(aPropIDs[(int)index]' values[index]);              }            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseDirectionalBorderSide,The following statement contains a magic number: uint32_t numProps = 3;
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseDirectionalBorderSide,The following statement contains a magic number: if ((found & 2) == 0) { // Provide default border-style              values[1].SetIntValue(nsStyle.BorderStyleNone' nsCSSUnit.Enumerated);            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseDirectionalBorderSide,The following statement contains a magic number: if ((found & 4) == 0) { // text color will be used              values[2].SetIntValue(nsStyle.ColorMozUseTextColor' nsCSSUnit.Enumerated);            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseDirectionalBorderSide,The following statement contains a magic number: if ((found & 4) == 0) { // text color will be used              values[2].SetIntValue(nsStyle.ColorMozUseTextColor' nsCSSUnit.Enumerated);            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseDirectionalBorderSide,The following statement contains a magic number: for (int32_t index = 0; index < numProps; index++) {              nsCSSProperty[] subprops =                nsCSSProps.SubpropertyEntryFor(aPropIDs[index + numProps]);              Debug.Assert(subprops[3] == nsCSSProperty.Unknown'                           "not box property with physical vs. logical cascading");              AppendValue(subprops[0]' values[index]);              var typeVal = new nsCSSValue(aSourceType' nsCSSUnit.Enumerated);              AppendValue(subprops[1]' typeVal);              AppendValue(subprops[2]' typeVal);            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseDirectionalBorderSide,The following statement contains a magic number: for (int32_t index = 0; index < numProps; index++) {              nsCSSProperty[] subprops =                nsCSSProps.SubpropertyEntryFor(aPropIDs[index + numProps]);              Debug.Assert(subprops[3] == nsCSSProperty.Unknown'                           "not box property with physical vs. logical cascading");              AppendValue(subprops[0]' values[index]);              var typeVal = new nsCSSValue(aSourceType' nsCSSUnit.Enumerated);              AppendValue(subprops[1]' typeVal);              AppendValue(subprops[2]' typeVal);            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseCalcAdditiveExpression,The following statement contains a magic number: for (;;) {              bool haveWS = false;              if (!ParseCalcMultiplicativeExpression(ref storage' ref aVariantMask' ref haveWS))                return false;                        if (!haveWS || !GetToken(false))                return true;              nsCSSUnit unit = 0;              if (mToken.IsSymbol('+')) {                unit = nsCSSUnit.CalcPlus;              } else if (mToken.IsSymbol('-')) {                unit = nsCSSUnit.CalcMinus;              } else {                UngetToken();                return true;              }              if (!RequireWhitespace())                return false;                        nsCSSValue[] arr = new nsCSSValue[2];              arr[0] = aValue;              storage = arr[1];              aValue.SetArrayValue(arr' unit);            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseCalcMultiplicativeExpression,The following statement contains a magic number: for (;;) {              int32_t variantMask = 0;              if (afterDivision || gotValue) {                variantMask = VARIANT_NUMBER;              } else {                variantMask = aVariantMask | VARIANT_NUMBER;              }              if (!ParseCalcTerm(ref storage' ref variantMask))                return false;              Debug.Assert(variantMask != 0'                                "ParseCalcTerm did not set variantMask appropriately");                                      if ((variantMask & VARIANT_NUMBER) != 0) {                // Simplify the value immediately so we can check for division by                // zero.                var ops = new ReduceNumberCalcOps();                float number = CommonUtil.ComputeCalc(storage' ops);                if (number == 0.0 && afterDivision)                  return false;                storage.SetFloatValue(number' nsCSSUnit.Number);              } else {                gotValue = true;                          if (storage != aValue) {                  // Simplify any numbers in the Times_L position (which are                  // not simplified by the check above).                  Debug.Assert(storage == aValue.GetArrayValue().Item(1)'                                    "unexpected relationship to current storage");                  nsCSSValue leftValue = aValue.GetArrayValue().Item(0);                  var ops = new ReduceNumberCalcOps();                  float number = CommonUtil.ComputeCalc(leftValue' ops);                  leftValue.SetFloatValue(number' nsCSSUnit.Number);                }              }                        bool hadWS = RequireWhitespace();              if (!GetToken(false)) {                aHadFinalWS = hadWS;                break;              }              nsCSSUnit unit = 0;              if (mToken.IsSymbol('*')) {                unit = gotValue ? nsCSSUnit.CalcTimesR : nsCSSUnit.CalcTimesL;                afterDivision = false;              } else if (mToken.IsSymbol('/')) {                unit = nsCSSUnit.CalcDivided;                afterDivision = true;              } else {                UngetToken();                aHadFinalWS = hadWS;                break;              }                        nsCSSValue[] arr = new nsCSSValue[2];              arr[0] = aValue;              storage = arr[1];              aValue.SetArrayValue(arr' unit);            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseRect,The following statement contains a magic number: if (mToken.mType == nsCSSTokenType.Ident) {              nsCSSKeyword keyword = nsCSSKeywords.LookupKeyword(mToken.mIdentStr);              switch (keyword) {                case nsCSSKeyword.Auto:                  if (!ExpectEndProperty()) {                    return false;                  }                  val.SetAutoValue();                  break;                case nsCSSKeyword.Inherit:                  if (!ExpectEndProperty()) {                    return false;                  }                  val.SetInheritValue();                  break;                case nsCSSKeyword.Initial:                case nsCSSKeyword.MozInitial:                  if (!ExpectEndProperty()) {                    return false;                  }                  val.SetInitialValue();                  break;                default:                  UngetToken();                  return false;              }            } else if (mToken.mType == nsCSSTokenType.Function &&                       mToken.mIdentStr.LowerCaseEqualsLiteral("rect")) {              nsCSSRect rect = val.SetRectValue();              bool useCommas = false;              for (Side side = nsStyle.SideTop; side <= nsStyle.SideLeft; side++) {                if (! ParseVariant(rect.GetSide(side)' v => rect.SetSide(side' v)'                                   VARIANT_AL' null)) {                  return false;                }                if (side == 0) {                  useCommas = ExpectSymbol('''' true);                } else if (useCommas && (int)side < 3) {                  // Skip optional commas between elements' but only if the first                  // separator was a comma.                  if (!ExpectSymbol('''' true)) {                    return false;                  }                }              }              if (!ExpectSymbol(')'' true)) {                return false;              }              if (!ExpectEndProperty()) {                return false;              }            } else {              UngetToken();              return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseColumns,The following statement contains a magic number: if ((found & (1|2|4)) == (1|2|4) &&                values[0].GetUnit() ==  nsCSSUnit.Auto) {              // We filled all 3 values' which is invalid              return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseColumns,The following statement contains a magic number: if ((found & (1|2|4)) == (1|2|4) &&                values[0].GetUnit() ==  nsCSSUnit.Auto) {              // We filled all 3 values' which is invalid              return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseColumns,The following statement contains a magic number: if ((found & (1|2|4)) == (1|2|4) &&                values[0].GetUnit() ==  nsCSSUnit.Auto) {              // We filled all 3 values' which is invalid              return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseColumns,The following statement contains a magic number: if ((found & (1|2|4)) == (1|2|4) &&                values[0].GetUnit() ==  nsCSSUnit.Auto) {              // We filled all 3 values' which is invalid              return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseColumns,The following statement contains a magic number: if ((found & 2) == 0) {              // Provide auto column-count              values[1].SetAutoValue();            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseColumns,The following statement contains a magic number: if ((found & 4) == 0) {              // Provide auto column-width              values[2].SetAutoValue();            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseColumns,The following statement contains a magic number: if ((found & 4) == 0) {              // Provide auto column-width              values[2].SetAutoValue();            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseCursor,The following statement contains a magic number: if (ParseVariant(ref value' VARIANT_INHERIT' null)) {              // 'inherit' and 'initial' must be alone              if (!ExpectEndProperty()) {                return false;              }            } else {              nsCSSValueList cur = value.SetListValue();              for (;;) {                if (!ParseVariant(ref cur.mValue' VARIANT_UK' nsCSSProps.kCursorKTable)) {                  return false;                }                if (cur.mValue.GetUnit() != nsCSSUnit.Url) { // keyword must be last                  if (ExpectEndProperty()) {                    break;                  }                  return false;                }                          // We have a URL' so make a value array with three values.                nsCSSValue[] val = new nsCSSValue[3];                val[0] = cur.mValue;                          // Parse optional x and y position of cursor hotspot (css3-ui).                if (ParseVariant(ref val[1]' VARIANT_NUMBER' null)) {                  // If we have one number' we must have two.                  if (!ParseVariant(ref val[2]' VARIANT_NUMBER' null)) {                    return false;                  }                }                cur.mValue.SetArrayValue(val' nsCSSUnit.Array);                          if (!ExpectSymbol('''' true)) { // url must not be last                  return false;                }                cur.mNext = new nsCSSValueList();                cur = cur.mNext;              }            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseCursor,The following statement contains a magic number: if (ParseVariant(ref value' VARIANT_INHERIT' null)) {              // 'inherit' and 'initial' must be alone              if (!ExpectEndProperty()) {                return false;              }            } else {              nsCSSValueList cur = value.SetListValue();              for (;;) {                if (!ParseVariant(ref cur.mValue' VARIANT_UK' nsCSSProps.kCursorKTable)) {                  return false;                }                if (cur.mValue.GetUnit() != nsCSSUnit.Url) { // keyword must be last                  if (ExpectEndProperty()) {                    break;                  }                  return false;                }                          // We have a URL' so make a value array with three values.                nsCSSValue[] val = new nsCSSValue[3];                val[0] = cur.mValue;                          // Parse optional x and y position of cursor hotspot (css3-ui).                if (ParseVariant(ref val[1]' VARIANT_NUMBER' null)) {                  // If we have one number' we must have two.                  if (!ParseVariant(ref val[2]' VARIANT_NUMBER' null)) {                    return false;                  }                }                cur.mValue.SetArrayValue(val' nsCSSUnit.Array);                          if (!ExpectSymbol('''' true)) { // url must not be last                  return false;                }                cur.mNext = new nsCSSValueList();                cur = cur.mNext;              }            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseFont,The following statement contains a magic number: uint32_t numProps = 3;
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseFont,The following statement contains a magic number: if ((found & 2) == 0) {              // Provide default font-variant              values[1].SetIntValue(nsFont.VARIANT_NORMAL' nsCSSUnit.Enumerated);            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseFont,The following statement contains a magic number: if ((found & 4) == 0) {              // Provide default font-weight              values[2].SetIntValue(nsFont.WEIGHT_NORMAL' nsCSSUnit.Enumerated);            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseFont,The following statement contains a magic number: if ((found & 4) == 0) {              // Provide default font-weight              values[2].SetIntValue(nsFont.WEIGHT_NORMAL' nsCSSUnit.Enumerated);            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseFont,The following statement contains a magic number: using (/*var compound = */new nsAutoParseCompoundProperty(this)) {                if (ParseFamily(ref family)) {                if ((nsCSSUnit.Inherit != family.GetUnit()) && (nsCSSUnit.Initial != family.GetUnit()) &&                    ExpectEndProperty()) {                  AppendValue(nsCSSProperty.XSystemFont' new nsCSSValue(nsCSSUnit.None));                  AppendValue(nsCSSProperty.FontFamily' family);                  AppendValue(nsCSSProperty.FontStyle' values[0]);                  AppendValue(nsCSSProperty.FontVariant' values[1]);                  AppendValue(nsCSSProperty.FontWeight' values[2]);                  AppendValue(nsCSSProperty.FontSize' size);                  AppendValue(nsCSSProperty.LineHeight' lineHeight);                  AppendValue(nsCSSProperty.FontStretch'                              new nsCSSValue(nsFont.STRETCH_NORMAL' nsCSSUnit.Enumerated));                  AppendValue(nsCSSProperty.FontSizeAdjust' new nsCSSValue(nsCSSUnit.None));                  AppendValue(nsCSSProperty.FontFeatureSettings' new nsCSSValue(nsCSSUnit.Normal));                  AppendValue(nsCSSProperty.FontLanguageOverride' new nsCSSValue(nsCSSUnit.Normal));                  return true;                }              }              return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseFontWeight,The following statement contains a magic number: if (ParseVariant(ref aValue' VARIANT_HKI | VARIANT_SYSFONT'                             nsCSSProps.kFontWeightKTable)) {              if (nsCSSUnit.Integer == aValue.GetUnit()) { // ensure unit value                int32_t intValue = aValue.GetIntValue();                if ((100 <= intValue) &&                    (intValue <= 900) &&                    (0 == (intValue % 100))) {                  return true;                } else {                  UngetToken();                  return false;                }              }              return true;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseFontWeight,The following statement contains a magic number: if (ParseVariant(ref aValue' VARIANT_HKI | VARIANT_SYSFONT'                             nsCSSProps.kFontWeightKTable)) {              if (nsCSSUnit.Integer == aValue.GetUnit()) { // ensure unit value                int32_t intValue = aValue.GetIntValue();                if ((100 <= intValue) &&                    (intValue <= 900) &&                    (0 == (intValue % 100))) {                  return true;                } else {                  UngetToken();                  return false;                }              }              return true;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseFontWeight,The following statement contains a magic number: if (ParseVariant(ref aValue' VARIANT_HKI | VARIANT_SYSFONT'                             nsCSSProps.kFontWeightKTable)) {              if (nsCSSUnit.Integer == aValue.GetUnit()) { // ensure unit value                int32_t intValue = aValue.GetIntValue();                if ((100 <= intValue) &&                    (intValue <= 900) &&                    (0 == (intValue % 100))) {                  return true;                } else {                  UngetToken();                  return false;                }              }              return true;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseListStyle,The following statement contains a magic number: if ((found & (1|2|8)) == (1|2|8)) {              if (values[0].GetUnit() == nsCSSUnit.None) {                // We found a 'none' plus another value for both of                // 'list-style-type' and 'list-style-image'.  This is a parse                // error' since the 'none' has to count for at least one of them.                return false;              } else {                Debug.Assert(found == (1|2|4|8) && values[0] == values[1] &&                             values[0] == values[2] && values[0] == values[3]'                             "should be a special value");              }            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseListStyle,The following statement contains a magic number: if ((found & (1|2|8)) == (1|2|8)) {              if (values[0].GetUnit() == nsCSSUnit.None) {                // We found a 'none' plus another value for both of                // 'list-style-type' and 'list-style-image'.  This is a parse                // error' since the 'none' has to count for at least one of them.                return false;              } else {                Debug.Assert(found == (1|2|4|8) && values[0] == values[1] &&                             values[0] == values[2] && values[0] == values[3]'                             "should be a special value");              }            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseListStyle,The following statement contains a magic number: if ((found & (1|2|8)) == (1|2|8)) {              if (values[0].GetUnit() == nsCSSUnit.None) {                // We found a 'none' plus another value for both of                // 'list-style-type' and 'list-style-image'.  This is a parse                // error' since the 'none' has to count for at least one of them.                return false;              } else {                Debug.Assert(found == (1|2|4|8) && values[0] == values[1] &&                             values[0] == values[2] && values[0] == values[3]'                             "should be a special value");              }            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseListStyle,The following statement contains a magic number: if ((found & (1|2|8)) == (1|2|8)) {              if (values[0].GetUnit() == nsCSSUnit.None) {                // We found a 'none' plus another value for both of                // 'list-style-type' and 'list-style-image'.  This is a parse                // error' since the 'none' has to count for at least one of them.                return false;              } else {                Debug.Assert(found == (1|2|4|8) && values[0] == values[1] &&                             values[0] == values[2] && values[0] == values[3]'                             "should be a special value");              }            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseListStyle,The following statement contains a magic number: if ((found & (1|2|8)) == (1|2|8)) {              if (values[0].GetUnit() == nsCSSUnit.None) {                // We found a 'none' plus another value for both of                // 'list-style-type' and 'list-style-image'.  This is a parse                // error' since the 'none' has to count for at least one of them.                return false;              } else {                Debug.Assert(found == (1|2|4|8) && values[0] == values[1] &&                             values[0] == values[2] && values[0] == values[3]'                             "should be a special value");              }            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseListStyle,The following statement contains a magic number: if ((found & (1|2|8)) == (1|2|8)) {              if (values[0].GetUnit() == nsCSSUnit.None) {                // We found a 'none' plus another value for both of                // 'list-style-type' and 'list-style-image'.  This is a parse                // error' since the 'none' has to count for at least one of them.                return false;              } else {                Debug.Assert(found == (1|2|4|8) && values[0] == values[1] &&                             values[0] == values[2] && values[0] == values[3]'                             "should be a special value");              }            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseListStyle,The following statement contains a magic number: if ((found & (1|2|8)) == (1|2|8)) {              if (values[0].GetUnit() == nsCSSUnit.None) {                // We found a 'none' plus another value for both of                // 'list-style-type' and 'list-style-image'.  This is a parse                // error' since the 'none' has to count for at least one of them.                return false;              } else {                Debug.Assert(found == (1|2|4|8) && values[0] == values[1] &&                             values[0] == values[2] && values[0] == values[3]'                             "should be a special value");              }            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseListStyle,The following statement contains a magic number: if ((found & (1|2|8)) == (1|2|8)) {              if (values[0].GetUnit() == nsCSSUnit.None) {                // We found a 'none' plus another value for both of                // 'list-style-type' and 'list-style-image'.  This is a parse                // error' since the 'none' has to count for at least one of them.                return false;              } else {                Debug.Assert(found == (1|2|4|8) && values[0] == values[1] &&                             values[0] == values[2] && values[0] == values[3]'                             "should be a special value");              }            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseListStyle,The following statement contains a magic number: if ((found & (1|2|8)) == (1|2|8)) {              if (values[0].GetUnit() == nsCSSUnit.None) {                // We found a 'none' plus another value for both of                // 'list-style-type' and 'list-style-image'.  This is a parse                // error' since the 'none' has to count for at least one of them.                return false;              } else {                Debug.Assert(found == (1|2|4|8) && values[0] == values[1] &&                             values[0] == values[2] && values[0] == values[3]'                             "should be a special value");              }            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseListStyle,The following statement contains a magic number: if ((found & 2) == 0) {              if ((found & 1) != 0) {                values[1].SetIntValue(nsStyle.ListStyleNone' nsCSSUnit.Enumerated);              } else {                values[1].SetIntValue(nsStyle.ListStyleDisc' nsCSSUnit.Enumerated);              }            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseListStyle,The following statement contains a magic number: if ((found & 4) == 0) {              values[2].SetIntValue(nsStyle.ListStylePositionOutside'                                    nsCSSUnit.Enumerated);            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseListStyle,The following statement contains a magic number: if ((found & 4) == 0) {              values[2].SetIntValue(nsStyle.ListStylePositionOutside'                                    nsCSSUnit.Enumerated);            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseListStyle,The following statement contains a magic number: if ((found & 8) == 0) {              values[3].SetNoneValue();            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseListStyle,The following statement contains a magic number: if ((found & 8) == 0) {              values[3].SetNoneValue();            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseOutline,The following statement contains a magic number: uint32_t numProps = 3;
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseOutline,The following statement contains a magic number: if ((found & 2) == 0) { // Provide default outline-style              values[1].SetIntValue(nsStyle.BorderStyleNone' nsCSSUnit.Enumerated);            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseOutline,The following statement contains a magic number: if ((found & 4) == 0) { // Provide default outline-width              values[2].SetIntValue(nsStyle.BorderWidthMedium' nsCSSUnit.Enumerated);            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseOutline,The following statement contains a magic number: if ((found & 4) == 0) { // Provide default outline-width              values[2].SetIntValue(nsStyle.BorderWidthMedium' nsCSSUnit.Enumerated);            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseTextDecoration,The following statement contains a magic number: switch (value.GetUnit()) {              case nsCSSUnit.Enumerated: {                // We shouldn't accept decoration line style and color via                // text-decoration.                color.SetIntValue(nsStyle.ColorMozUseTextColor'                                  nsCSSUnit.Enumerated);                style.SetIntValue(nsStyle.TextDecorationStyleSolid'                                  nsCSSUnit.Enumerated);                          int32_t intValue = value.GetIntValue();                if (intValue == eDecorationNone) {                  blink.SetIntValue(nsStyle.TextBlinkNone' nsCSSUnit.Enumerated);                  line.SetIntValue(nsStyle.TextDecorationLineNone'                                   nsCSSUnit.Enumerated);                  break;                }                          // look for more keywords                var keyword = new nsCSSValue();                int32_t index = 0;                for (index = 0; index < 3; index++) {                  if (!ParseEnum(ref keyword' kTextDecorationKTable)) {                    break;                  }                  int32_t newValue = keyword.GetIntValue();                  if (newValue == eDecorationNone || ((newValue & intValue) != 0)) {                    // 'none' keyword in conjuction with others is not allowed' and                    // duplicate keyword is not allowed.                    return false;                  }                  intValue |= newValue;                }                          blink.SetIntValue((intValue & eDecorationBlink) != 0 ?                                    nsStyle.TextBlinkBlink : nsStyle.TextBlinkNone'                                  nsCSSUnit.Enumerated);                line.SetIntValue((intValue & ~eDecorationBlink)' nsCSSUnit.Enumerated);                break;              }                goto default;              default:                blink = line = color = style = value;                break;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseTextDecorationLine,The following statement contains a magic number: if (ParseVariant(ref aValue' VARIANT_HK' nsCSSProps.kTextDecorationLineKTable)) {              if (nsCSSUnit.Enumerated == aValue.GetUnit()) {                int32_t intValue = aValue.GetIntValue();                if (intValue != nsStyle.TextDecorationLineNone) {                  // look for more keywords                  var keyword = new nsCSSValue();                  int32_t index = 0;                  for (index = 0; index < 2; index++) {                    if (ParseEnum(ref keyword' nsCSSProps.kTextDecorationLineKTable)) {                      int32_t newValue = keyword.GetIntValue();                      if (newValue == nsStyle.TextDecorationLineNone ||                          ((newValue & intValue) != 0)) {                        // 'none' keyword in conjuction with others is not allowed' and                        // duplicate keyword is not allowed.                        return false;                      }                      intValue |= newValue;                    }                    else {                      break;                    }                  }                  aValue.SetIntValue(intValue' nsCSSUnit.Enumerated);                }              }              return true;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The following statement contains a magic number: const int eTwoLengthPercentCalcs = 2;
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The following statement contains a magic number: const int eTwoLengthPercentCalcsOneLengthCalc = 3;
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The following statement contains a magic number: const int eAngle = 4;
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The following statement contains a magic number: const int eTwoAngles = 5;
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The following statement contains a magic number: const int eNumber = 6;
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The following statement contains a magic number: const int ePositiveLength = 7;
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The following statement contains a magic number: const int eTwoNumbers = 8;
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The following statement contains a magic number: const int eThreeNumbers = 9;
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The following statement contains a magic number: const int eThreeNumbersOneAngle = 10;
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The following statement contains a magic number: const int eMatrix = 11;
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The following statement contains a magic number: const int eMatrixPrefixed = 12;
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The following statement contains a magic number: const int eMatrix3d = 13;
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The following statement contains a magic number: const int eMatrix3dPrefixed = 14;
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The following statement contains a magic number: const int eNumVariantMasks = 15;
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The following statement contains a magic number: const int32_t kMaxElemsPerFunction = 16;
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The following statement contains a magic number: switch (aToken) {            case nsCSSKeyword.Translatex:            case nsCSSKeyword.Translatey:              /* Exactly one length or percent. */              variantIndex = eLengthPercentCalc;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Translatez:              /* Exactly one length */              variantIndex = eLengthCalc;              aMinElems = 1;              aMaxElems = 1;              aIs3D = true;              break;            case nsCSSKeyword.Translate3d:              /* Exactly two lengthds or percents and a number */              variantIndex = eTwoLengthPercentCalcsOneLengthCalc;              aMinElems = 3;              aMaxElems = 3;              aIs3D = true;              break;            case nsCSSKeyword.Scalez:              aIs3D = true;              goto case nsCSSKeyword.Scalex;            case nsCSSKeyword.Scalex:            case nsCSSKeyword.Scaley:              /* Exactly one scale factor. */              variantIndex = eNumber;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Scale3d:              /* Exactly three scale factors. */              variantIndex = eThreeNumbers;              aMinElems = 3;              aMaxElems = 3;              aIs3D = true;              break;            case nsCSSKeyword.Rotatex:            case nsCSSKeyword.Rotatey:              aIs3D = true;              goto case nsCSSKeyword.Rotate;            case nsCSSKeyword.Rotate:            case nsCSSKeyword.Rotatez:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Rotate3d:              variantIndex = eThreeNumbersOneAngle;              aMinElems = 4;              aMaxElems = 4;              aIs3D = true;              break;            case nsCSSKeyword.Translate:              /* One or two lengths or percents. */              variantIndex = eTwoLengthPercentCalcs;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Skew:              /* Exactly one or two angles. */              variantIndex = eTwoAngles;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Scale:              /* One or two scale factors. */              variantIndex = eTwoNumbers;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Skewx:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Skewy:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Matrix:              /* Six values' all numbers. */              variantIndex = aIsPrefixed ? eMatrixPrefixed : eMatrix;              aMinElems = 6;              aMaxElems = 6;              break;            case nsCSSKeyword.Matrix3d:              /* 16 matrix values' all numbers */              variantIndex = aIsPrefixed ? eMatrix3dPrefixed : eMatrix3d;              aMinElems = 6;              aMaxElems = 6;              aIs3D = true;              break;            case nsCSSKeyword.Perspective:              /* Exactly one scale number. */              variantIndex = ePositiveLength;              aMinElems = 1;              aMaxElems = 1;              aIs3D = true;              break;            default:              /* Oh dear' we didn't match.  Report an error. */              return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The following statement contains a magic number: switch (aToken) {            case nsCSSKeyword.Translatex:            case nsCSSKeyword.Translatey:              /* Exactly one length or percent. */              variantIndex = eLengthPercentCalc;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Translatez:              /* Exactly one length */              variantIndex = eLengthCalc;              aMinElems = 1;              aMaxElems = 1;              aIs3D = true;              break;            case nsCSSKeyword.Translate3d:              /* Exactly two lengthds or percents and a number */              variantIndex = eTwoLengthPercentCalcsOneLengthCalc;              aMinElems = 3;              aMaxElems = 3;              aIs3D = true;              break;            case nsCSSKeyword.Scalez:              aIs3D = true;              goto case nsCSSKeyword.Scalex;            case nsCSSKeyword.Scalex:            case nsCSSKeyword.Scaley:              /* Exactly one scale factor. */              variantIndex = eNumber;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Scale3d:              /* Exactly three scale factors. */              variantIndex = eThreeNumbers;              aMinElems = 3;              aMaxElems = 3;              aIs3D = true;              break;            case nsCSSKeyword.Rotatex:            case nsCSSKeyword.Rotatey:              aIs3D = true;              goto case nsCSSKeyword.Rotate;            case nsCSSKeyword.Rotate:            case nsCSSKeyword.Rotatez:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Rotate3d:              variantIndex = eThreeNumbersOneAngle;              aMinElems = 4;              aMaxElems = 4;              aIs3D = true;              break;            case nsCSSKeyword.Translate:              /* One or two lengths or percents. */              variantIndex = eTwoLengthPercentCalcs;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Skew:              /* Exactly one or two angles. */              variantIndex = eTwoAngles;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Scale:              /* One or two scale factors. */              variantIndex = eTwoNumbers;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Skewx:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Skewy:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Matrix:              /* Six values' all numbers. */              variantIndex = aIsPrefixed ? eMatrixPrefixed : eMatrix;              aMinElems = 6;              aMaxElems = 6;              break;            case nsCSSKeyword.Matrix3d:              /* 16 matrix values' all numbers */              variantIndex = aIsPrefixed ? eMatrix3dPrefixed : eMatrix3d;              aMinElems = 6;              aMaxElems = 6;              aIs3D = true;              break;            case nsCSSKeyword.Perspective:              /* Exactly one scale number. */              variantIndex = ePositiveLength;              aMinElems = 1;              aMaxElems = 1;              aIs3D = true;              break;            default:              /* Oh dear' we didn't match.  Report an error. */              return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The following statement contains a magic number: switch (aToken) {            case nsCSSKeyword.Translatex:            case nsCSSKeyword.Translatey:              /* Exactly one length or percent. */              variantIndex = eLengthPercentCalc;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Translatez:              /* Exactly one length */              variantIndex = eLengthCalc;              aMinElems = 1;              aMaxElems = 1;              aIs3D = true;              break;            case nsCSSKeyword.Translate3d:              /* Exactly two lengthds or percents and a number */              variantIndex = eTwoLengthPercentCalcsOneLengthCalc;              aMinElems = 3;              aMaxElems = 3;              aIs3D = true;              break;            case nsCSSKeyword.Scalez:              aIs3D = true;              goto case nsCSSKeyword.Scalex;            case nsCSSKeyword.Scalex:            case nsCSSKeyword.Scaley:              /* Exactly one scale factor. */              variantIndex = eNumber;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Scale3d:              /* Exactly three scale factors. */              variantIndex = eThreeNumbers;              aMinElems = 3;              aMaxElems = 3;              aIs3D = true;              break;            case nsCSSKeyword.Rotatex:            case nsCSSKeyword.Rotatey:              aIs3D = true;              goto case nsCSSKeyword.Rotate;            case nsCSSKeyword.Rotate:            case nsCSSKeyword.Rotatez:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Rotate3d:              variantIndex = eThreeNumbersOneAngle;              aMinElems = 4;              aMaxElems = 4;              aIs3D = true;              break;            case nsCSSKeyword.Translate:              /* One or two lengths or percents. */              variantIndex = eTwoLengthPercentCalcs;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Skew:              /* Exactly one or two angles. */              variantIndex = eTwoAngles;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Scale:              /* One or two scale factors. */              variantIndex = eTwoNumbers;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Skewx:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Skewy:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Matrix:              /* Six values' all numbers. */              variantIndex = aIsPrefixed ? eMatrixPrefixed : eMatrix;              aMinElems = 6;              aMaxElems = 6;              break;            case nsCSSKeyword.Matrix3d:              /* 16 matrix values' all numbers */              variantIndex = aIsPrefixed ? eMatrix3dPrefixed : eMatrix3d;              aMinElems = 6;              aMaxElems = 6;              aIs3D = true;              break;            case nsCSSKeyword.Perspective:              /* Exactly one scale number. */              variantIndex = ePositiveLength;              aMinElems = 1;              aMaxElems = 1;              aIs3D = true;              break;            default:              /* Oh dear' we didn't match.  Report an error. */              return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The following statement contains a magic number: switch (aToken) {            case nsCSSKeyword.Translatex:            case nsCSSKeyword.Translatey:              /* Exactly one length or percent. */              variantIndex = eLengthPercentCalc;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Translatez:              /* Exactly one length */              variantIndex = eLengthCalc;              aMinElems = 1;              aMaxElems = 1;              aIs3D = true;              break;            case nsCSSKeyword.Translate3d:              /* Exactly two lengthds or percents and a number */              variantIndex = eTwoLengthPercentCalcsOneLengthCalc;              aMinElems = 3;              aMaxElems = 3;              aIs3D = true;              break;            case nsCSSKeyword.Scalez:              aIs3D = true;              goto case nsCSSKeyword.Scalex;            case nsCSSKeyword.Scalex:            case nsCSSKeyword.Scaley:              /* Exactly one scale factor. */              variantIndex = eNumber;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Scale3d:              /* Exactly three scale factors. */              variantIndex = eThreeNumbers;              aMinElems = 3;              aMaxElems = 3;              aIs3D = true;              break;            case nsCSSKeyword.Rotatex:            case nsCSSKeyword.Rotatey:              aIs3D = true;              goto case nsCSSKeyword.Rotate;            case nsCSSKeyword.Rotate:            case nsCSSKeyword.Rotatez:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Rotate3d:              variantIndex = eThreeNumbersOneAngle;              aMinElems = 4;              aMaxElems = 4;              aIs3D = true;              break;            case nsCSSKeyword.Translate:              /* One or two lengths or percents. */              variantIndex = eTwoLengthPercentCalcs;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Skew:              /* Exactly one or two angles. */              variantIndex = eTwoAngles;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Scale:              /* One or two scale factors. */              variantIndex = eTwoNumbers;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Skewx:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Skewy:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Matrix:              /* Six values' all numbers. */              variantIndex = aIsPrefixed ? eMatrixPrefixed : eMatrix;              aMinElems = 6;              aMaxElems = 6;              break;            case nsCSSKeyword.Matrix3d:              /* 16 matrix values' all numbers */              variantIndex = aIsPrefixed ? eMatrix3dPrefixed : eMatrix3d;              aMinElems = 6;              aMaxElems = 6;              aIs3D = true;              break;            case nsCSSKeyword.Perspective:              /* Exactly one scale number. */              variantIndex = ePositiveLength;              aMinElems = 1;              aMaxElems = 1;              aIs3D = true;              break;            default:              /* Oh dear' we didn't match.  Report an error. */              return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The following statement contains a magic number: switch (aToken) {            case nsCSSKeyword.Translatex:            case nsCSSKeyword.Translatey:              /* Exactly one length or percent. */              variantIndex = eLengthPercentCalc;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Translatez:              /* Exactly one length */              variantIndex = eLengthCalc;              aMinElems = 1;              aMaxElems = 1;              aIs3D = true;              break;            case nsCSSKeyword.Translate3d:              /* Exactly two lengthds or percents and a number */              variantIndex = eTwoLengthPercentCalcsOneLengthCalc;              aMinElems = 3;              aMaxElems = 3;              aIs3D = true;              break;            case nsCSSKeyword.Scalez:              aIs3D = true;              goto case nsCSSKeyword.Scalex;            case nsCSSKeyword.Scalex:            case nsCSSKeyword.Scaley:              /* Exactly one scale factor. */              variantIndex = eNumber;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Scale3d:              /* Exactly three scale factors. */              variantIndex = eThreeNumbers;              aMinElems = 3;              aMaxElems = 3;              aIs3D = true;              break;            case nsCSSKeyword.Rotatex:            case nsCSSKeyword.Rotatey:              aIs3D = true;              goto case nsCSSKeyword.Rotate;            case nsCSSKeyword.Rotate:            case nsCSSKeyword.Rotatez:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Rotate3d:              variantIndex = eThreeNumbersOneAngle;              aMinElems = 4;              aMaxElems = 4;              aIs3D = true;              break;            case nsCSSKeyword.Translate:              /* One or two lengths or percents. */              variantIndex = eTwoLengthPercentCalcs;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Skew:              /* Exactly one or two angles. */              variantIndex = eTwoAngles;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Scale:              /* One or two scale factors. */              variantIndex = eTwoNumbers;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Skewx:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Skewy:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Matrix:              /* Six values' all numbers. */              variantIndex = aIsPrefixed ? eMatrixPrefixed : eMatrix;              aMinElems = 6;              aMaxElems = 6;              break;            case nsCSSKeyword.Matrix3d:              /* 16 matrix values' all numbers */              variantIndex = aIsPrefixed ? eMatrix3dPrefixed : eMatrix3d;              aMinElems = 6;              aMaxElems = 6;              aIs3D = true;              break;            case nsCSSKeyword.Perspective:              /* Exactly one scale number. */              variantIndex = ePositiveLength;              aMinElems = 1;              aMaxElems = 1;              aIs3D = true;              break;            default:              /* Oh dear' we didn't match.  Report an error. */              return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The following statement contains a magic number: switch (aToken) {            case nsCSSKeyword.Translatex:            case nsCSSKeyword.Translatey:              /* Exactly one length or percent. */              variantIndex = eLengthPercentCalc;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Translatez:              /* Exactly one length */              variantIndex = eLengthCalc;              aMinElems = 1;              aMaxElems = 1;              aIs3D = true;              break;            case nsCSSKeyword.Translate3d:              /* Exactly two lengthds or percents and a number */              variantIndex = eTwoLengthPercentCalcsOneLengthCalc;              aMinElems = 3;              aMaxElems = 3;              aIs3D = true;              break;            case nsCSSKeyword.Scalez:              aIs3D = true;              goto case nsCSSKeyword.Scalex;            case nsCSSKeyword.Scalex:            case nsCSSKeyword.Scaley:              /* Exactly one scale factor. */              variantIndex = eNumber;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Scale3d:              /* Exactly three scale factors. */              variantIndex = eThreeNumbers;              aMinElems = 3;              aMaxElems = 3;              aIs3D = true;              break;            case nsCSSKeyword.Rotatex:            case nsCSSKeyword.Rotatey:              aIs3D = true;              goto case nsCSSKeyword.Rotate;            case nsCSSKeyword.Rotate:            case nsCSSKeyword.Rotatez:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Rotate3d:              variantIndex = eThreeNumbersOneAngle;              aMinElems = 4;              aMaxElems = 4;              aIs3D = true;              break;            case nsCSSKeyword.Translate:              /* One or two lengths or percents. */              variantIndex = eTwoLengthPercentCalcs;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Skew:              /* Exactly one or two angles. */              variantIndex = eTwoAngles;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Scale:              /* One or two scale factors. */              variantIndex = eTwoNumbers;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Skewx:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Skewy:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Matrix:              /* Six values' all numbers. */              variantIndex = aIsPrefixed ? eMatrixPrefixed : eMatrix;              aMinElems = 6;              aMaxElems = 6;              break;            case nsCSSKeyword.Matrix3d:              /* 16 matrix values' all numbers */              variantIndex = aIsPrefixed ? eMatrix3dPrefixed : eMatrix3d;              aMinElems = 6;              aMaxElems = 6;              aIs3D = true;              break;            case nsCSSKeyword.Perspective:              /* Exactly one scale number. */              variantIndex = ePositiveLength;              aMinElems = 1;              aMaxElems = 1;              aIs3D = true;              break;            default:              /* Oh dear' we didn't match.  Report an error. */              return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The following statement contains a magic number: switch (aToken) {            case nsCSSKeyword.Translatex:            case nsCSSKeyword.Translatey:              /* Exactly one length or percent. */              variantIndex = eLengthPercentCalc;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Translatez:              /* Exactly one length */              variantIndex = eLengthCalc;              aMinElems = 1;              aMaxElems = 1;              aIs3D = true;              break;            case nsCSSKeyword.Translate3d:              /* Exactly two lengthds or percents and a number */              variantIndex = eTwoLengthPercentCalcsOneLengthCalc;              aMinElems = 3;              aMaxElems = 3;              aIs3D = true;              break;            case nsCSSKeyword.Scalez:              aIs3D = true;              goto case nsCSSKeyword.Scalex;            case nsCSSKeyword.Scalex:            case nsCSSKeyword.Scaley:              /* Exactly one scale factor. */              variantIndex = eNumber;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Scale3d:              /* Exactly three scale factors. */              variantIndex = eThreeNumbers;              aMinElems = 3;              aMaxElems = 3;              aIs3D = true;              break;            case nsCSSKeyword.Rotatex:            case nsCSSKeyword.Rotatey:              aIs3D = true;              goto case nsCSSKeyword.Rotate;            case nsCSSKeyword.Rotate:            case nsCSSKeyword.Rotatez:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Rotate3d:              variantIndex = eThreeNumbersOneAngle;              aMinElems = 4;              aMaxElems = 4;              aIs3D = true;              break;            case nsCSSKeyword.Translate:              /* One or two lengths or percents. */              variantIndex = eTwoLengthPercentCalcs;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Skew:              /* Exactly one or two angles. */              variantIndex = eTwoAngles;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Scale:              /* One or two scale factors. */              variantIndex = eTwoNumbers;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Skewx:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Skewy:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Matrix:              /* Six values' all numbers. */              variantIndex = aIsPrefixed ? eMatrixPrefixed : eMatrix;              aMinElems = 6;              aMaxElems = 6;              break;            case nsCSSKeyword.Matrix3d:              /* 16 matrix values' all numbers */              variantIndex = aIsPrefixed ? eMatrix3dPrefixed : eMatrix3d;              aMinElems = 6;              aMaxElems = 6;              aIs3D = true;              break;            case nsCSSKeyword.Perspective:              /* Exactly one scale number. */              variantIndex = ePositiveLength;              aMinElems = 1;              aMaxElems = 1;              aIs3D = true;              break;            default:              /* Oh dear' we didn't match.  Report an error. */              return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The following statement contains a magic number: switch (aToken) {            case nsCSSKeyword.Translatex:            case nsCSSKeyword.Translatey:              /* Exactly one length or percent. */              variantIndex = eLengthPercentCalc;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Translatez:              /* Exactly one length */              variantIndex = eLengthCalc;              aMinElems = 1;              aMaxElems = 1;              aIs3D = true;              break;            case nsCSSKeyword.Translate3d:              /* Exactly two lengthds or percents and a number */              variantIndex = eTwoLengthPercentCalcsOneLengthCalc;              aMinElems = 3;              aMaxElems = 3;              aIs3D = true;              break;            case nsCSSKeyword.Scalez:              aIs3D = true;              goto case nsCSSKeyword.Scalex;            case nsCSSKeyword.Scalex:            case nsCSSKeyword.Scaley:              /* Exactly one scale factor. */              variantIndex = eNumber;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Scale3d:              /* Exactly three scale factors. */              variantIndex = eThreeNumbers;              aMinElems = 3;              aMaxElems = 3;              aIs3D = true;              break;            case nsCSSKeyword.Rotatex:            case nsCSSKeyword.Rotatey:              aIs3D = true;              goto case nsCSSKeyword.Rotate;            case nsCSSKeyword.Rotate:            case nsCSSKeyword.Rotatez:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Rotate3d:              variantIndex = eThreeNumbersOneAngle;              aMinElems = 4;              aMaxElems = 4;              aIs3D = true;              break;            case nsCSSKeyword.Translate:              /* One or two lengths or percents. */              variantIndex = eTwoLengthPercentCalcs;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Skew:              /* Exactly one or two angles. */              variantIndex = eTwoAngles;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Scale:              /* One or two scale factors. */              variantIndex = eTwoNumbers;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Skewx:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Skewy:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Matrix:              /* Six values' all numbers. */              variantIndex = aIsPrefixed ? eMatrixPrefixed : eMatrix;              aMinElems = 6;              aMaxElems = 6;              break;            case nsCSSKeyword.Matrix3d:              /* 16 matrix values' all numbers */              variantIndex = aIsPrefixed ? eMatrix3dPrefixed : eMatrix3d;              aMinElems = 6;              aMaxElems = 6;              aIs3D = true;              break;            case nsCSSKeyword.Perspective:              /* Exactly one scale number. */              variantIndex = ePositiveLength;              aMinElems = 1;              aMaxElems = 1;              aIs3D = true;              break;            default:              /* Oh dear' we didn't match.  Report an error. */              return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The following statement contains a magic number: switch (aToken) {            case nsCSSKeyword.Translatex:            case nsCSSKeyword.Translatey:              /* Exactly one length or percent. */              variantIndex = eLengthPercentCalc;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Translatez:              /* Exactly one length */              variantIndex = eLengthCalc;              aMinElems = 1;              aMaxElems = 1;              aIs3D = true;              break;            case nsCSSKeyword.Translate3d:              /* Exactly two lengthds or percents and a number */              variantIndex = eTwoLengthPercentCalcsOneLengthCalc;              aMinElems = 3;              aMaxElems = 3;              aIs3D = true;              break;            case nsCSSKeyword.Scalez:              aIs3D = true;              goto case nsCSSKeyword.Scalex;            case nsCSSKeyword.Scalex:            case nsCSSKeyword.Scaley:              /* Exactly one scale factor. */              variantIndex = eNumber;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Scale3d:              /* Exactly three scale factors. */              variantIndex = eThreeNumbers;              aMinElems = 3;              aMaxElems = 3;              aIs3D = true;              break;            case nsCSSKeyword.Rotatex:            case nsCSSKeyword.Rotatey:              aIs3D = true;              goto case nsCSSKeyword.Rotate;            case nsCSSKeyword.Rotate:            case nsCSSKeyword.Rotatez:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Rotate3d:              variantIndex = eThreeNumbersOneAngle;              aMinElems = 4;              aMaxElems = 4;              aIs3D = true;              break;            case nsCSSKeyword.Translate:              /* One or two lengths or percents. */              variantIndex = eTwoLengthPercentCalcs;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Skew:              /* Exactly one or two angles. */              variantIndex = eTwoAngles;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Scale:              /* One or two scale factors. */              variantIndex = eTwoNumbers;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Skewx:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Skewy:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Matrix:              /* Six values' all numbers. */              variantIndex = aIsPrefixed ? eMatrixPrefixed : eMatrix;              aMinElems = 6;              aMaxElems = 6;              break;            case nsCSSKeyword.Matrix3d:              /* 16 matrix values' all numbers */              variantIndex = aIsPrefixed ? eMatrix3dPrefixed : eMatrix3d;              aMinElems = 6;              aMaxElems = 6;              aIs3D = true;              break;            case nsCSSKeyword.Perspective:              /* Exactly one scale number. */              variantIndex = ePositiveLength;              aMinElems = 1;              aMaxElems = 1;              aIs3D = true;              break;            default:              /* Oh dear' we didn't match.  Report an error. */              return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The following statement contains a magic number: switch (aToken) {            case nsCSSKeyword.Translatex:            case nsCSSKeyword.Translatey:              /* Exactly one length or percent. */              variantIndex = eLengthPercentCalc;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Translatez:              /* Exactly one length */              variantIndex = eLengthCalc;              aMinElems = 1;              aMaxElems = 1;              aIs3D = true;              break;            case nsCSSKeyword.Translate3d:              /* Exactly two lengthds or percents and a number */              variantIndex = eTwoLengthPercentCalcsOneLengthCalc;              aMinElems = 3;              aMaxElems = 3;              aIs3D = true;              break;            case nsCSSKeyword.Scalez:              aIs3D = true;              goto case nsCSSKeyword.Scalex;            case nsCSSKeyword.Scalex:            case nsCSSKeyword.Scaley:              /* Exactly one scale factor. */              variantIndex = eNumber;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Scale3d:              /* Exactly three scale factors. */              variantIndex = eThreeNumbers;              aMinElems = 3;              aMaxElems = 3;              aIs3D = true;              break;            case nsCSSKeyword.Rotatex:            case nsCSSKeyword.Rotatey:              aIs3D = true;              goto case nsCSSKeyword.Rotate;            case nsCSSKeyword.Rotate:            case nsCSSKeyword.Rotatez:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Rotate3d:              variantIndex = eThreeNumbersOneAngle;              aMinElems = 4;              aMaxElems = 4;              aIs3D = true;              break;            case nsCSSKeyword.Translate:              /* One or two lengths or percents. */              variantIndex = eTwoLengthPercentCalcs;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Skew:              /* Exactly one or two angles. */              variantIndex = eTwoAngles;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Scale:              /* One or two scale factors. */              variantIndex = eTwoNumbers;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Skewx:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Skewy:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Matrix:              /* Six values' all numbers. */              variantIndex = aIsPrefixed ? eMatrixPrefixed : eMatrix;              aMinElems = 6;              aMaxElems = 6;              break;            case nsCSSKeyword.Matrix3d:              /* 16 matrix values' all numbers */              variantIndex = aIsPrefixed ? eMatrix3dPrefixed : eMatrix3d;              aMinElems = 6;              aMaxElems = 6;              aIs3D = true;              break;            case nsCSSKeyword.Perspective:              /* Exactly one scale number. */              variantIndex = ePositiveLength;              aMinElems = 1;              aMaxElems = 1;              aIs3D = true;              break;            default:              /* Oh dear' we didn't match.  Report an error. */              return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The following statement contains a magic number: switch (aToken) {            case nsCSSKeyword.Translatex:            case nsCSSKeyword.Translatey:              /* Exactly one length or percent. */              variantIndex = eLengthPercentCalc;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Translatez:              /* Exactly one length */              variantIndex = eLengthCalc;              aMinElems = 1;              aMaxElems = 1;              aIs3D = true;              break;            case nsCSSKeyword.Translate3d:              /* Exactly two lengthds or percents and a number */              variantIndex = eTwoLengthPercentCalcsOneLengthCalc;              aMinElems = 3;              aMaxElems = 3;              aIs3D = true;              break;            case nsCSSKeyword.Scalez:              aIs3D = true;              goto case nsCSSKeyword.Scalex;            case nsCSSKeyword.Scalex:            case nsCSSKeyword.Scaley:              /* Exactly one scale factor. */              variantIndex = eNumber;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Scale3d:              /* Exactly three scale factors. */              variantIndex = eThreeNumbers;              aMinElems = 3;              aMaxElems = 3;              aIs3D = true;              break;            case nsCSSKeyword.Rotatex:            case nsCSSKeyword.Rotatey:              aIs3D = true;              goto case nsCSSKeyword.Rotate;            case nsCSSKeyword.Rotate:            case nsCSSKeyword.Rotatez:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Rotate3d:              variantIndex = eThreeNumbersOneAngle;              aMinElems = 4;              aMaxElems = 4;              aIs3D = true;              break;            case nsCSSKeyword.Translate:              /* One or two lengths or percents. */              variantIndex = eTwoLengthPercentCalcs;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Skew:              /* Exactly one or two angles. */              variantIndex = eTwoAngles;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Scale:              /* One or two scale factors. */              variantIndex = eTwoNumbers;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Skewx:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Skewy:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Matrix:              /* Six values' all numbers. */              variantIndex = aIsPrefixed ? eMatrixPrefixed : eMatrix;              aMinElems = 6;              aMaxElems = 6;              break;            case nsCSSKeyword.Matrix3d:              /* 16 matrix values' all numbers */              variantIndex = aIsPrefixed ? eMatrix3dPrefixed : eMatrix3d;              aMinElems = 6;              aMaxElems = 6;              aIs3D = true;              break;            case nsCSSKeyword.Perspective:              /* Exactly one scale number. */              variantIndex = ePositiveLength;              aMinElems = 1;              aMaxElems = 1;              aIs3D = true;              break;            default:              /* Oh dear' we didn't match.  Report an error. */              return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The following statement contains a magic number: switch (aToken) {            case nsCSSKeyword.Translatex:            case nsCSSKeyword.Translatey:              /* Exactly one length or percent. */              variantIndex = eLengthPercentCalc;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Translatez:              /* Exactly one length */              variantIndex = eLengthCalc;              aMinElems = 1;              aMaxElems = 1;              aIs3D = true;              break;            case nsCSSKeyword.Translate3d:              /* Exactly two lengthds or percents and a number */              variantIndex = eTwoLengthPercentCalcsOneLengthCalc;              aMinElems = 3;              aMaxElems = 3;              aIs3D = true;              break;            case nsCSSKeyword.Scalez:              aIs3D = true;              goto case nsCSSKeyword.Scalex;            case nsCSSKeyword.Scalex:            case nsCSSKeyword.Scaley:              /* Exactly one scale factor. */              variantIndex = eNumber;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Scale3d:              /* Exactly three scale factors. */              variantIndex = eThreeNumbers;              aMinElems = 3;              aMaxElems = 3;              aIs3D = true;              break;            case nsCSSKeyword.Rotatex:            case nsCSSKeyword.Rotatey:              aIs3D = true;              goto case nsCSSKeyword.Rotate;            case nsCSSKeyword.Rotate:            case nsCSSKeyword.Rotatez:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Rotate3d:              variantIndex = eThreeNumbersOneAngle;              aMinElems = 4;              aMaxElems = 4;              aIs3D = true;              break;            case nsCSSKeyword.Translate:              /* One or two lengths or percents. */              variantIndex = eTwoLengthPercentCalcs;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Skew:              /* Exactly one or two angles. */              variantIndex = eTwoAngles;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Scale:              /* One or two scale factors. */              variantIndex = eTwoNumbers;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Skewx:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Skewy:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Matrix:              /* Six values' all numbers. */              variantIndex = aIsPrefixed ? eMatrixPrefixed : eMatrix;              aMinElems = 6;              aMaxElems = 6;              break;            case nsCSSKeyword.Matrix3d:              /* 16 matrix values' all numbers */              variantIndex = aIsPrefixed ? eMatrix3dPrefixed : eMatrix3d;              aMinElems = 6;              aMaxElems = 6;              aIs3D = true;              break;            case nsCSSKeyword.Perspective:              /* Exactly one scale number. */              variantIndex = ePositiveLength;              aMinElems = 1;              aMaxElems = 1;              aIs3D = true;              break;            default:              /* Oh dear' we didn't match.  Report an error. */              return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,GetFunctionParseInformation,The following statement contains a magic number: switch (aToken) {            case nsCSSKeyword.Translatex:            case nsCSSKeyword.Translatey:              /* Exactly one length or percent. */              variantIndex = eLengthPercentCalc;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Translatez:              /* Exactly one length */              variantIndex = eLengthCalc;              aMinElems = 1;              aMaxElems = 1;              aIs3D = true;              break;            case nsCSSKeyword.Translate3d:              /* Exactly two lengthds or percents and a number */              variantIndex = eTwoLengthPercentCalcsOneLengthCalc;              aMinElems = 3;              aMaxElems = 3;              aIs3D = true;              break;            case nsCSSKeyword.Scalez:              aIs3D = true;              goto case nsCSSKeyword.Scalex;            case nsCSSKeyword.Scalex:            case nsCSSKeyword.Scaley:              /* Exactly one scale factor. */              variantIndex = eNumber;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Scale3d:              /* Exactly three scale factors. */              variantIndex = eThreeNumbers;              aMinElems = 3;              aMaxElems = 3;              aIs3D = true;              break;            case nsCSSKeyword.Rotatex:            case nsCSSKeyword.Rotatey:              aIs3D = true;              goto case nsCSSKeyword.Rotate;            case nsCSSKeyword.Rotate:            case nsCSSKeyword.Rotatez:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Rotate3d:              variantIndex = eThreeNumbersOneAngle;              aMinElems = 4;              aMaxElems = 4;              aIs3D = true;              break;            case nsCSSKeyword.Translate:              /* One or two lengths or percents. */              variantIndex = eTwoLengthPercentCalcs;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Skew:              /* Exactly one or two angles. */              variantIndex = eTwoAngles;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Scale:              /* One or two scale factors. */              variantIndex = eTwoNumbers;              aMinElems = 1;              aMaxElems = 2;              break;            case nsCSSKeyword.Skewx:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Skewy:              /* Exactly one angle. */              variantIndex = eAngle;              aMinElems = 1;              aMaxElems = 1;              break;            case nsCSSKeyword.Matrix:              /* Six values' all numbers. */              variantIndex = aIsPrefixed ? eMatrixPrefixed : eMatrix;              aMinElems = 6;              aMaxElems = 6;              break;            case nsCSSKeyword.Matrix3d:              /* 16 matrix values' all numbers */              variantIndex = aIsPrefixed ? eMatrix3dPrefixed : eMatrix3d;              aMinElems = 6;              aMaxElems = 6;              aIs3D = true;              break;            case nsCSSKeyword.Perspective:              /* Exactly one scale number. */              variantIndex = ePositiveLength;              aMinElems = 1;              aMaxElems = 1;              aIs3D = true;              break;            default:              /* Oh dear' we didn't match.  Report an error. */              return false;            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseTransitionTimingFunctionValues,The following statement contains a magic number: nsCSSValue[] val = new nsCSSValue[4];
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseTransitionTimingFunctionValues,The following statement contains a magic number: val[2].SetFloatValue(x2' nsCSSUnit.Number);
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseTransitionTimingFunctionValues,The following statement contains a magic number: val[3].SetFloatValue(y2' nsCSSUnit.Number);
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseTransitionStepTimingFunctionValues,The following statement contains a magic number: nsCSSValue[] val = new nsCSSValue[2];
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseAnimationOrTransitionShorthand,The following statement contains a magic number: const size_t maxNumProperties = 7;
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseTransition,The following statement contains a magic number: initialValues[2].SetFloatValue(0.0' nsCSSUnit.Seconds);
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseTransition,The following statement contains a magic number: initialValues[3].SetAllValue();
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseTransition,The following statement contains a magic number: {              Debug.Assert(kTransitionProperties[3] ==                                  nsCSSProperty.TransitionProperty'                                "array index mismatch");              nsCSSValueList l = values[3].GetListValue();              bool multipleItems = l.mNext != null;              do {                nsCSSValue val = l.mValue;                if (val.GetUnit() == nsCSSUnit.None) {                  if (multipleItems) {                    // This is a syntax error.                    return false;                  }                            // Unbox a solitary 'none'.                  values[3].SetNoneValue();                  break;                }                if (val.GetUnit() == nsCSSUnit.Ident) {                  string str = val.GetStringBufferValue();                  if (str.EqualsLiteral("inherit") || str.EqualsLiteral("initial")) {                    return false;                  }                }              } while ((l = l.mNext) != null);            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseTransition,The following statement contains a magic number: {              Debug.Assert(kTransitionProperties[3] ==                                  nsCSSProperty.TransitionProperty'                                "array index mismatch");              nsCSSValueList l = values[3].GetListValue();              bool multipleItems = l.mNext != null;              do {                nsCSSValue val = l.mValue;                if (val.GetUnit() == nsCSSUnit.None) {                  if (multipleItems) {                    // This is a syntax error.                    return false;                  }                            // Unbox a solitary 'none'.                  values[3].SetNoneValue();                  break;                }                if (val.GetUnit() == nsCSSUnit.Ident) {                  string str = val.GetStringBufferValue();                  if (str.EqualsLiteral("inherit") || str.EqualsLiteral("initial")) {                    return false;                  }                }              } while ((l = l.mNext) != null);            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseTransition,The following statement contains a magic number: {              Debug.Assert(kTransitionProperties[3] ==                                  nsCSSProperty.TransitionProperty'                                "array index mismatch");              nsCSSValueList l = values[3].GetListValue();              bool multipleItems = l.mNext != null;              do {                nsCSSValue val = l.mValue;                if (val.GetUnit() == nsCSSUnit.None) {                  if (multipleItems) {                    // This is a syntax error.                    return false;                  }                            // Unbox a solitary 'none'.                  values[3].SetNoneValue();                  break;                }                if (val.GetUnit() == nsCSSUnit.Ident) {                  string str = val.GetStringBufferValue();                  if (str.EqualsLiteral("inherit") || str.EqualsLiteral("initial")) {                    return false;                  }                }              } while ((l = l.mNext) != null);            }
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseAnimation,The following statement contains a magic number: initialValues[2].SetFloatValue(0.0' nsCSSUnit.Seconds);
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseAnimation,The following statement contains a magic number: initialValues[3].SetIntValue(nsStyle.AnimationDirectionNormal' nsCSSUnit.Enumerated);
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseAnimation,The following statement contains a magic number: initialValues[4].SetIntValue(nsStyle.AnimationFillModeNone' nsCSSUnit.Enumerated);
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseAnimation,The following statement contains a magic number: initialValues[5].SetFloatValue(1.0f' nsCSSUnit.Number);
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseAnimation,The following statement contains a magic number: initialValues[6].SetNoneValue();
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseShadowItem,The following statement contains a magic number: const int IndexRadius = 2;
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseShadowItem,The following statement contains a magic number: const int IndexSpread = 3;
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseShadowItem,The following statement contains a magic number: const int IndexColor = 4;
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseShadowItem,The following statement contains a magic number: const int IndexInset = 5;
Magic Number,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseShadowItem,The following statement contains a magic number: nsCSSValue[] val = new nsCSSValue[6];
Magic Number,Alba.CsCss.Style,nsCSSProps,C:\repos\Athari_CsCss\Alba.CsCss\Style\nsCSSProps.cs,FindIndexOfKeyword,The following statement contains a magic number: while ((CssKeyword)(aTable[index]) != CssKeyword.Unknown) {                  if ((CssKeyword)(aTable[index]) == aKeyword)                      return index;                  index += 2;              }
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,IsOpenCharClass,The following statement contains a magic number: return ch >= 0 && (ch >= 128 || (gLexTable[ch] & cls) != 0);
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,IsClosedCharClass,The following statement contains a magic number: return ch >= 0 && ch < 128 && (gLexTable[ch] & cls) != 0;
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,HexDigitValue,The following statement contains a magic number: if (IsDigit(ch)) {              return DecimalDigitValue(ch);            } else {              // Note: c&7 just keeps the low three bits which causes              // upper and lower case alphabetics to both yield their              // "relative to 10" value for computing the hex value.              return (ch & 0x7) + 9;            }
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,AdvanceLine,The following statement contains a magic number: if (mBuffer[mOffset]   == '\r' && mOffset + 1 < mCount &&                mBuffer[mOffset+1] == '\n')              mOffset += 2;            else              mOffset += 1;
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,SkipComment,The following statement contains a magic number: Advance(2);
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,SkipComment,The following statement contains a magic number: for (;;) {              int32_t ch = Peek();              if (ch < 0) {                mReporter.ReportUnexpectedEOF("PECommentEOF");                return;              }              if (ch == '*' && Peek(1) == '/') {                Advance(2);                return;              }              if (IsVertSpace(ch)) {                AdvanceLine();              } else {                Advance();              }            }
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,GatherEscape,The following statement contains a magic number: if (!IsHexDigit(ch)) {              // "Any character (except a hexadecimal digit' linefeed' carriage              // return' or form feed) can be escaped with a backslash to remove              // its special meaning." -- CSS2.1 section 4.1.3              Advance(2);              aOutput.Append(ch);              return true;            }
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,GatherEscape,The following statement contains a magic number: do {              val = val * 16 + HexDigitValue(ch);              i++;              Advance();              ch = Peek();            } while (i < 6 && IsHexDigit(ch));
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,GatherEscape,The following statement contains a magic number: do {              val = val * 16 + HexDigitValue(ch);              i++;              Advance();              ch = Peek();            } while (i < 6 && IsHexDigit(ch));
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,ScanNumber,The following statement contains a magic number: if (!gotDot) {              // Scan the integer part of the mantissa.              Debug.Assert(IsDigit(c)' "should have been excluded by logic above");              do {                intPart = 10*intPart + DecimalDigitValue(c);                Advance();                c = Peek();              } while (IsDigit(c));                        gotDot = (c == '.') && IsDigit(Peek(1));            }
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,ScanNumber,The following statement contains a magic number: if (gotDot) {              // Scan the fractional part of the mantissa.              Advance();              c = Peek();              Debug.Assert(IsDigit(c)' "should have been excluded by logic above");              // Power of ten by which we need to divide our next digit              double divisor = 10;              do {                fracPart += DecimalDigitValue(c) / divisor;                divisor *= 10;                Advance();                c = Peek();              } while (IsDigit(c));            }
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,ScanNumber,The following statement contains a magic number: if (gotDot) {              // Scan the fractional part of the mantissa.              Advance();              c = Peek();              Debug.Assert(IsDigit(c)' "should have been excluded by logic above");              // Power of ten by which we need to divide our next digit              double divisor = 10;              do {                fracPart += DecimalDigitValue(c) / divisor;                divisor *= 10;                Advance();                c = Peek();              } while (IsDigit(c));            }
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,ScanNumber,The following statement contains a magic number: if (IsSVGMode() && (c == 'e' || c == 'E')) {              int32_t expSignChar = Peek(1);              int32_t nextChar = Peek(2);              if (IsDigit(expSignChar) ||                  ((expSignChar == '-' || expSignChar == '+') && IsDigit(nextChar))) {                gotE = true;                if (expSignChar == '-') {                  expSign = -1;                }                Advance(); // consumes the E                if (expSignChar == '-' || expSignChar == '+') {                  Advance();                  c = nextChar;                } else {                  c = expSignChar;                }                Debug.Assert(IsDigit(c)' "should have been excluded by logic above");                do {                  exponent = 10*exponent + DecimalDigitValue(c);                  Advance();                  c = Peek();                } while (IsDigit(c));              }            }
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,ScanNumber,The following statement contains a magic number: if (IsSVGMode() && (c == 'e' || c == 'E')) {              int32_t expSignChar = Peek(1);              int32_t nextChar = Peek(2);              if (IsDigit(expSignChar) ||                  ((expSignChar == '-' || expSignChar == '+') && IsDigit(nextChar))) {                gotE = true;                if (expSignChar == '-') {                  expSign = -1;                }                Advance(); // consumes the E                if (expSignChar == '-' || expSignChar == '+') {                  Advance();                  c = nextChar;                } else {                  c = expSignChar;                }                Debug.Assert(IsDigit(c)' "should have been excluded by logic above");                do {                  exponent = 10*exponent + DecimalDigitValue(c);                  Advance();                  c = Peek();                } while (IsDigit(c));              }            }
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,ScanNumber,The following statement contains a magic number: if (gotE) {              // Explicitly cast expSign*exponent to double to avoid issues with              // overloaded Math.Pow() on Windows.              value *= Math.Pow(10.0' ((double)(expSign * exponent)));            } else if (!gotDot) {              // Clamp values outside of integer range.              if (sign > 0) {                aToken.mInteger = ((int32_t)(Math.Min(intPart' ((double)(Int32.MaxValue)))));              } else {                aToken.mInteger = ((int32_t)(Math.Max(-intPart' ((double)(Int32.MinValue)))));              }              aToken.mIntegerValid = true;            }
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,ScanURange,The following statement contains a magic number: int32_t ch = Peek(2);
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,ScanURange,The following statement contains a magic number: Advance(2);
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,ScanURange,The following statement contains a magic number: do {              aResult.mIdent.Append(ch);              if (IsHexDigit(ch)) {                if (haveQues) {                  valid = false; // All question marks should be at the end.                }                low = low*16 + HexDigitValue(ch);                high = high*16 + HexDigitValue(ch);              } else {                haveQues = true;                low = low*16 + 0x0;                high = high*16 + 0xF;              }                        i++;              Advance();              ch = Peek();            } while (i < 6 && (IsHexDigit(ch) || ch == '?'));
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,ScanURange,The following statement contains a magic number: do {              aResult.mIdent.Append(ch);              if (IsHexDigit(ch)) {                if (haveQues) {                  valid = false; // All question marks should be at the end.                }                low = low*16 + HexDigitValue(ch);                high = high*16 + HexDigitValue(ch);              } else {                haveQues = true;                low = low*16 + 0x0;                high = high*16 + 0xF;              }                        i++;              Advance();              ch = Peek();            } while (i < 6 && (IsHexDigit(ch) || ch == '?'));
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,ScanURange,The following statement contains a magic number: do {              aResult.mIdent.Append(ch);              if (IsHexDigit(ch)) {                if (haveQues) {                  valid = false; // All question marks should be at the end.                }                low = low*16 + HexDigitValue(ch);                high = high*16 + HexDigitValue(ch);              } else {                haveQues = true;                low = low*16 + 0x0;                high = high*16 + 0xF;              }                        i++;              Advance();              ch = Peek();            } while (i < 6 && (IsHexDigit(ch) || ch == '?'));
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,ScanURange,The following statement contains a magic number: do {              aResult.mIdent.Append(ch);              if (IsHexDigit(ch)) {                if (haveQues) {                  valid = false; // All question marks should be at the end.                }                low = low*16 + HexDigitValue(ch);                high = high*16 + HexDigitValue(ch);              } else {                haveQues = true;                low = low*16 + 0x0;                high = high*16 + 0xF;              }                        i++;              Advance();              ch = Peek();            } while (i < 6 && (IsHexDigit(ch) || ch == '?'));
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,ScanURange,The following statement contains a magic number: do {              aResult.mIdent.Append(ch);              if (IsHexDigit(ch)) {                if (haveQues) {                  valid = false; // All question marks should be at the end.                }                low = low*16 + HexDigitValue(ch);                high = high*16 + HexDigitValue(ch);              } else {                haveQues = true;                low = low*16 + 0x0;                high = high*16 + 0xF;              }                        i++;              Advance();              ch = Peek();            } while (i < 6 && (IsHexDigit(ch) || ch == '?'));
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,ScanURange,The following statement contains a magic number: if (ch == '-' && IsHexDigit(Peek(1))) {              if (haveQues) {                valid = false;              }                        aResult.mIdent.Append(ch);              Advance();              ch = Peek();              high = 0;              i = 0;              do {                aResult.mIdent.Append(ch);                high = high*16 + HexDigitValue(ch);                          i++;                Advance();                ch = Peek();              } while (i < 6 && IsHexDigit(ch));            }
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,ScanURange,The following statement contains a magic number: if (ch == '-' && IsHexDigit(Peek(1))) {              if (haveQues) {                valid = false;              }                        aResult.mIdent.Append(ch);              Advance();              ch = Peek();              high = 0;              i = 0;              do {                aResult.mIdent.Append(ch);                high = high*16 + HexDigitValue(ch);                          i++;                Advance();                ch = Peek();              } while (i < 6 && IsHexDigit(ch));            }
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,Next,The following statement contains a magic number: if (ch == 'u' || ch == 'U') {              int32_t c2 = Peek(1);              int32_t c3 = Peek(2);              if (c2 == '+' && (IsHexDigit(c3) || c3 == '?')) {                return ScanURange(aToken);              }              return ScanIdent(aToken);            }
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,Next,The following statement contains a magic number: if (ch == '+') {              int32_t c2 = Peek(1);              if (IsDigit(c2) || (c2 == '.' && IsDigit(Peek(2)))) {                return ScanNumber(aToken);              }            }
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,Next,The following statement contains a magic number: if (ch == '-') {              int32_t c2 = Peek(1);              int32_t c3 = Peek(2);              if (IsIdentStart(c2)) {                return ScanIdent(aToken);              }              if (IsDigit(c2) || (c2 == '.' && IsDigit(c3))) {                return ScanNumber(aToken);              }              if (c2 == '-' && c3 == '>') {                Advance(3);                aToken.mType = nsCSSTokenType.HTMLComment;                aToken.mIdent.AssignLiteral("-.");                return true;              }            }
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,Next,The following statement contains a magic number: if (ch == '-') {              int32_t c2 = Peek(1);              int32_t c3 = Peek(2);              if (IsIdentStart(c2)) {                return ScanIdent(aToken);              }              if (IsDigit(c2) || (c2 == '.' && IsDigit(c3))) {                return ScanNumber(aToken);              }              if (c2 == '-' && c3 == '>') {                Advance(3);                aToken.mType = nsCSSTokenType.HTMLComment;                aToken.mIdent.AssignLiteral("-.");                return true;              }            }
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,Next,The following statement contains a magic number: if (ch == '<' && Peek(1) == '!' && Peek(2) == '-' && Peek(3) == '-') {              Advance(4);              aToken.mType = nsCSSTokenType.HTMLComment;              aToken.mIdent.AssignLiteral("<!--");              return true;            }
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,Next,The following statement contains a magic number: if (ch == '<' && Peek(1) == '!' && Peek(2) == '-' && Peek(3) == '-') {              Advance(4);              aToken.mType = nsCSSTokenType.HTMLComment;              aToken.mIdent.AssignLiteral("<!--");              return true;            }
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,Next,The following statement contains a magic number: if (ch == '<' && Peek(1) == '!' && Peek(2) == '-' && Peek(3) == '-') {              Advance(4);              aToken.mType = nsCSSTokenType.HTMLComment;              aToken.mIdent.AssignLiteral("<!--");              return true;            }
Magic Number,Alba.CsCss.Style,CssScanner,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssScanner.conv.cs,Next,The following statement contains a magic number: if (opType != nsCSSTokenType.Symbol && Peek(1) == '=') {              aToken.mType = opType;              Advance(2);              return true;            }
Magic Number,Alba.CsCss.Style,CssToken,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssToken.conv.cs,AppendToString,The following statement contains a magic number: switch (mType) {              case nsCSSTokenType.Ident:                nsStyleUtil.AppendEscapedCSSIdent(mIdent' aBuffer);                break;                        case nsCSSTokenType.AtKeyword:                aBuffer.Append('@');                nsStyleUtil.AppendEscapedCSSIdent(mIdent' aBuffer);                break;                        case nsCSSTokenType.ID:              case nsCSSTokenType.Hash:                aBuffer.Append('#');                nsStyleUtil.AppendEscapedCSSIdent(mIdent' aBuffer);                break;                        case nsCSSTokenType.Function:                nsStyleUtil.AppendEscapedCSSIdent(mIdent' aBuffer);                aBuffer.Append('(');                break;                        case nsCSSTokenType.URL:              case nsCSSTokenType.Bad_URL:                aBuffer.AppendLiteral("url(");                if (mSymbol != ((PRUnichar)(0))) {                  nsStyleUtil.AppendEscapedCSSString(mIdent' aBuffer' mSymbol);                } else {                  aBuffer.Append(mIdent);                }                if (mType == nsCSSTokenType.URL) {                  aBuffer.Append(((PRUnichar)(')')));                }                break;                        case nsCSSTokenType.Number:                if (mIntegerValid) {                  aBuffer.AppendInt(mInteger' 10);                } else {                  aBuffer.AppendFloat(mNumber);                }                break;                        case nsCSSTokenType.Percentage:                aBuffer.AppendFloat(mNumber * 100.0f);                aBuffer.Append(((PRUnichar)('%')));                break;                        case nsCSSTokenType.Dimension:                if (mIntegerValid) {                  aBuffer.AppendInt(mInteger' 10);                } else {                  aBuffer.AppendFloat(mNumber);                }                nsStyleUtil.AppendEscapedCSSIdent(mIdent' aBuffer);                break;                        case nsCSSTokenType.Bad_String:                nsStyleUtil.AppendEscapedCSSString(mIdent' aBuffer' mSymbol);                // remove the trailing quote character                aBuffer.Truncate(aBuffer.Length() - 1);                break;                        case nsCSSTokenType.String:                nsStyleUtil.AppendEscapedCSSString(mIdent' aBuffer' mSymbol);                break;                        case nsCSSTokenType.Symbol:                aBuffer.Append(mSymbol);                break;                        case nsCSSTokenType.Whitespace:                aBuffer.Append(' ');                break;                        case nsCSSTokenType.HTMLComment:              case nsCSSTokenType.URange:                aBuffer.Append(mIdent);                break;                        case nsCSSTokenType.Includes:                aBuffer.AppendLiteral("~=");                break;              case nsCSSTokenType.Dashmatch:                aBuffer.AppendLiteral("|=");                break;              case nsCSSTokenType.Beginsmatch:                aBuffer.AppendLiteral("^=");                break;              case nsCSSTokenType.Endsmatch:                aBuffer.AppendLiteral("$=");                break;              case nsCSSTokenType.Containsmatch:                aBuffer.AppendLiteral("*=");                break;                        default:                throw new Exception("invalid token type");                break;            }
Magic Number,Alba.CsCss.Style,CssToken,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\CssToken.conv.cs,AppendToString,The following statement contains a magic number: switch (mType) {              case nsCSSTokenType.Ident:                nsStyleUtil.AppendEscapedCSSIdent(mIdent' aBuffer);                break;                        case nsCSSTokenType.AtKeyword:                aBuffer.Append('@');                nsStyleUtil.AppendEscapedCSSIdent(mIdent' aBuffer);                break;                        case nsCSSTokenType.ID:              case nsCSSTokenType.Hash:                aBuffer.Append('#');                nsStyleUtil.AppendEscapedCSSIdent(mIdent' aBuffer);                break;                        case nsCSSTokenType.Function:                nsStyleUtil.AppendEscapedCSSIdent(mIdent' aBuffer);                aBuffer.Append('(');                break;                        case nsCSSTokenType.URL:              case nsCSSTokenType.Bad_URL:                aBuffer.AppendLiteral("url(");                if (mSymbol != ((PRUnichar)(0))) {                  nsStyleUtil.AppendEscapedCSSString(mIdent' aBuffer' mSymbol);                } else {                  aBuffer.Append(mIdent);                }                if (mType == nsCSSTokenType.URL) {                  aBuffer.Append(((PRUnichar)(')')));                }                break;                        case nsCSSTokenType.Number:                if (mIntegerValid) {                  aBuffer.AppendInt(mInteger' 10);                } else {                  aBuffer.AppendFloat(mNumber);                }                break;                        case nsCSSTokenType.Percentage:                aBuffer.AppendFloat(mNumber * 100.0f);                aBuffer.Append(((PRUnichar)('%')));                break;                        case nsCSSTokenType.Dimension:                if (mIntegerValid) {                  aBuffer.AppendInt(mInteger' 10);                } else {                  aBuffer.AppendFloat(mNumber);                }                nsStyleUtil.AppendEscapedCSSIdent(mIdent' aBuffer);                break;                        case nsCSSTokenType.Bad_String:                nsStyleUtil.AppendEscapedCSSString(mIdent' aBuffer' mSymbol);                // remove the trailing quote character                aBuffer.Truncate(aBuffer.Length() - 1);                break;                        case nsCSSTokenType.String:                nsStyleUtil.AppendEscapedCSSString(mIdent' aBuffer' mSymbol);                break;                        case nsCSSTokenType.Symbol:                aBuffer.Append(mSymbol);                break;                        case nsCSSTokenType.Whitespace:                aBuffer.Append(' ');                break;                        case nsCSSTokenType.HTMLComment:              case nsCSSTokenType.URange:                aBuffer.Append(mIdent);                break;                        case nsCSSTokenType.Includes:                aBuffer.AppendLiteral("~=");                break;              case nsCSSTokenType.Dashmatch:                aBuffer.AppendLiteral("|=");                break;              case nsCSSTokenType.Beginsmatch:                aBuffer.AppendLiteral("^=");                break;              case nsCSSTokenType.Endsmatch:                aBuffer.AppendLiteral("$=");                break;              case nsCSSTokenType.Containsmatch:                aBuffer.AppendLiteral("*=");                break;                        default:                throw new Exception("invalid token type");                break;            }
Magic Number,Alba.CsCss.Style,CssStyle,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\nsStyle.nsIWidget.conv.cs,HALF_CORNER_IS_X,The following statement contains a magic number: return var % 2 == 0;
Magic Number,Alba.CsCss.Style,CssStyle,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\nsStyle.nsIWidget.conv.cs,HALF_TO_FULL_CORNER,The following statement contains a magic number: return var / 2;
Magic Number,Alba.CsCss.Style,CssStyle,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\nsStyle.nsIWidget.conv.cs,FULL_TO_HALF_CORNER,The following statement contains a magic number: return var * 2 + (vert != 0 ? 1 : 0);
Magic Number,Alba.CsCss.Style,CssStyle,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\nsStyle.nsIWidget.conv.cs,SIDE_IS_VERTICAL,The following statement contains a magic number: return side % 2 != 0;
Magic Number,Alba.CsCss.Style,CssStyle,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\nsStyle.nsIWidget.conv.cs,SIDE_TO_FULL_CORNER,The following statement contains a magic number: return (side + (second != 0 ? 1 : 0)) % 4;
Magic Number,Alba.CsCss.Style,CssStyle,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\nsStyle.nsIWidget.conv.cs,SIDE_TO_HALF_CORNER,The following statement contains a magic number: return ((side + (second != 0 ? 1 : 0)) * 2 + (side + (parallel ? 0 : 1)) % 2) % 8;
Magic Number,Alba.CsCss.Style,CssStyle,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\nsStyle.nsIWidget.conv.cs,SIDE_TO_HALF_CORNER,The following statement contains a magic number: return ((side + (second != 0 ? 1 : 0)) * 2 + (side + (parallel ? 0 : 1)) % 2) % 8;
Magic Number,Alba.CsCss.Style,CssStyle,C:\repos\Athari_CsCss\Alba.CsCss\Style\Original\nsStyle.nsIWidget.conv.cs,SIDE_TO_HALF_CORNER,The following statement contains a magic number: return ((side + (second != 0 ? 1 : 0)) * 2 + (side + (parallel ? 0 : 1)) % 2) % 8;
Magic Number,Alba.CsCss.Style,CssValue,C:\repos\Athari_CsCss\Alba.CsCss\Style\Values\CssValue.cs,GetAngleValueInRadians,The following statement contains a magic number: switch (GetUnit()) {                  case CssUnit.Radian:                      return (float)angle;                  case CssUnit.Turn:                      return (float)(angle * 2 * Math.PI);                  case CssUnit.Degree:                      return (float)(angle * Math.PI / 180.0);                  case CssUnit.Grad:                      return (float)(angle * Math.PI / 200.0);                  default:                      return (float)0.0;              }
Magic Number,Alba.CsCss.Style,CssValue,C:\repos\Athari_CsCss\Alba.CsCss\Style\Values\CssValue.cs,GetAngleValueInRadians,The following statement contains a magic number: switch (GetUnit()) {                  case CssUnit.Radian:                      return (float)angle;                  case CssUnit.Turn:                      return (float)(angle * 2 * Math.PI);                  case CssUnit.Degree:                      return (float)(angle * Math.PI / 180.0);                  case CssUnit.Grad:                      return (float)(angle * Math.PI / 200.0);                  default:                      return (float)0.0;              }
Magic Number,Alba.CsCss.Style,CssValue,C:\repos\Athari_CsCss\Alba.CsCss\Style\Values\CssValue.cs,GetAngleValueInRadians,The following statement contains a magic number: switch (GetUnit()) {                  case CssUnit.Radian:                      return (float)angle;                  case CssUnit.Turn:                      return (float)(angle * 2 * Math.PI);                  case CssUnit.Degree:                      return (float)(angle * Math.PI / 180.0);                  case CssUnit.Grad:                      return (float)(angle * Math.PI / 200.0);                  default:                      return (float)0.0;              }
Magic Number,Alba.CsCss.Style,CssValue,C:\repos\Athari_CsCss\Alba.CsCss\Style\Values\CssValue.cs,GetHashCode,The following statement contains a magic number: return unchecked(((int)mUnit * 397) ^ (mValue != null ? mValue.GetHashCode() : 0));
Missing Default,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseMediaQueryExpression,The following switch statement is missing a default case: switch (feature.mValueType) {              case nsMediaFeature.ValueType.Length:                rv = ParseNonNegativeVariant(ref expr.mValue' VARIANT_LENGTH' null);                break;              case nsMediaFeature.ValueType.Integer:              case nsMediaFeature.ValueType.BoolInteger:                rv = ParseNonNegativeVariant(ref expr.mValue' VARIANT_INTEGER' null);                // Enforce extra restrictions for eBoolInteger                if (rv &&                    feature.mValueType == nsMediaFeature.ValueType.BoolInteger &&                    expr.mValue.GetIntValue() > 1)                  rv = false;                break;              case nsMediaFeature.ValueType.Float:                rv = ParseNonNegativeVariant(ref expr.mValue' VARIANT_NUMBER' null);                break;              case nsMediaFeature.ValueType.IntRatio:                {                  // Two integers separated by '/'' with optional whitespace on                  // either side of the '/'.                  nsCSSValue[] a = new nsCSSValue[2];                  expr.mValue.SetArrayValue(a' nsCSSUnit.Array);                  // We don't bother with ParseNonNegativeVariant since we have to                  // check for != 0 as well; no need to worry about the UngetToken                  // since we're throwing out up to the next ')' anyway.                  rv = ParseVariant(ref a[0]' VARIANT_INTEGER' null) &&                       a[0].GetIntValue() > 0 &&                       ExpectSymbol('/'' true) &&                       ParseVariant(ref a[1]' VARIANT_INTEGER' null) &&                       a[1].GetIntValue() > 0;                }                break;              case nsMediaFeature.ValueType.Resolution:                rv = GetToken(true);                if (!rv)                  break;                rv = mToken.mType == nsCSSTokenType.Dimension && mToken.mNumber > 0.0f;                if (!rv) {                  UngetToken();                  break;                }                // No worries about whether unitless zero is allowed' since the                // value must be positive (and we checked that above).                Debug.Assert(!mToken.mIdentStr.IsEmpty()' "unit lied");                if (mToken.mIdentStr.LowerCaseEqualsLiteral("dpi")) {                  expr.mValue.SetFloatValue(mToken.mNumber' nsCSSUnit.Inch);                } else if (mToken.mIdentStr.LowerCaseEqualsLiteral("dppx")) {                  expr.mValue.SetFloatValue(mToken.mNumber' nsCSSUnit.Pixel);                } else if (mToken.mIdentStr.LowerCaseEqualsLiteral("dpcm")) {                  expr.mValue.SetFloatValue(mToken.mNumber' nsCSSUnit.Centimeter);                } else {                  rv = false;                }                break;              case nsMediaFeature.ValueType.Enumerated:                rv = ParseVariant(ref expr.mValue' VARIANT_KEYWORD'                                  feature.mData.mKeywordTable);                break;              case nsMediaFeature.ValueType.Ident:                rv = ParseVariant(ref expr.mValue' VARIANT_IDENTIFIER' null);                break;            }
Missing Default,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBoxProperties,The following switch statement is missing a default case: switch (count) {              case 1: // Make right == top                result.mRight = result.mTop;                goto case 2;              case 2: // Make bottom == top                result.mBottom = result.mTop;                goto case 3;              case 3: // Make left == right                result.mLeft = result.mRight;              break;            }
Missing Default,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseGroupedBoxProperty,The following switch statement is missing a default case: switch (count) {              case 1: // Make right == top                result.mRight = result.mTop;                goto case 2;              case 2: // Make bottom == top                result.mBottom = result.mTop;                goto case 3;              case 3: // Make left == right                result.mLeft = result.mRight;              break;            }
Missing Default,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBoxCornerRadii,The following switch statement is missing a default case: switch (countX) {              case 1: dimenX.mRight = dimenX.mTop;  // top-right same as top-left' and                goto case 2;              case 2: dimenX.mBottom = dimenX.mTop; // bottom-right same as top-left' and                 goto case 3;              case 3: dimenX.mLeft = dimenX.mRight; // bottom-left same as top-right              break;            }
Missing Default,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseBoxCornerRadii,The following switch statement is missing a default case: switch (countY) {              case 1: dimenY.mRight = dimenY.mTop;  // top-right same as top-left' and                goto case 2;              case 2: dimenY.mBottom = dimenY.mTop; // bottom-right same as top-left' and                 goto case 3;              case 3: dimenY.mLeft = dimenY.mRight; // bottom-left same as top-right              break;            }
Missing Default,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseFontDescriptorValue,The following switch statement is missing a default case: switch (aDescID) {              // These four are similar to the properties of the same name'              // possibly with more restrictions on the values they can take.                          case nsCSSFontDesc.Family: {              if (!ParseFamily(ref aValue) ||                  aValue.GetUnit() != nsCSSUnit.Families)                return false;                        // the style parameters to the nsFont constructor are ignored'              // because it's only being used to call EnumerateFamilies              string valueStr = "";              aValue.GetStringValue(ref valueStr);              var font = new nsFont(valueStr' 0' 0' 0' 0' 0' 0);              var dat = new ExtractFirstFamilyData();                        font.EnumerateFamilies(ExtractFirstFamily' (object) dat);              if (!dat.mGood)                return false;                        aValue.SetStringValue(dat.mFamilyName' nsCSSUnit.String);              return true;            }                        goto case nsCSSFontDesc.Style;            case nsCSSFontDesc.Style:              // property is VARIANT_HMK|VARIANT_SYSFONT              return ParseVariant(ref aValue' VARIANT_KEYWORD | VARIANT_NORMAL'                                  nsCSSProps.kFontStyleKTable);                      case nsCSSFontDesc.Weight:              return (ParseFontWeight(ref aValue) &&                      aValue.GetUnit() != nsCSSUnit.Inherit &&                      aValue.GetUnit() != nsCSSUnit.Initial &&                      (aValue.GetUnit() != nsCSSUnit.Enumerated ||                       (aValue.GetIntValue() != nsStyle.FontWeightBolder &&                        aValue.GetIntValue() != nsStyle.FontWeightLighter)));                      case nsCSSFontDesc.Stretch:              // property is VARIANT_HK|VARIANT_SYSFONT              return ParseVariant(ref aValue' VARIANT_KEYWORD'                                  nsCSSProps.kFontStretchKTable);                        // These two are unique to @font-face and have their own special grammar.              goto case nsCSSFontDesc.Src;            case nsCSSFontDesc.Src:              return ParseFontSrc(ref aValue);                      case nsCSSFontDesc.UnicodeRange:              return ParseFontRanges(ref aValue);                      case nsCSSFontDesc.FontFeatureSettings:              return ParseFontFeatureSettings(ref aValue);                      case nsCSSFontDesc.FontLanguageOverride:              return ParseVariant(ref aValue' VARIANT_NORMAL | VARIANT_STRING' null);                      case nsCSSFontDesc.UNKNOWN:            case nsCSSFontDesc.COUNT:              Debug.Fail("bad nsCSSFontDesc code");              break;            }
Missing Default,Alba.CsCss.Style,CssParser,C:\repos\Athari_CsCss\Alba.CsCss\Style\CssParser.cs,ParseOverflow,The following switch statement is missing a default case: switch(overflow.GetIntValue()) {                case nsStyle.OverflowScrollbarsHorizontal:                  overflowX.SetIntValue(nsStyle.OverflowScroll' nsCSSUnit.Enumerated);                  overflowY.SetIntValue(nsStyle.OverflowHidden' nsCSSUnit.Enumerated);                  break;                case nsStyle.OverflowScrollbarsVertical:                  overflowX.SetIntValue(nsStyle.OverflowHidden' nsCSSUnit.Enumerated);                  overflowY.SetIntValue(nsStyle.OverflowScroll' nsCSSUnit.Enumerated);                  break;              }
