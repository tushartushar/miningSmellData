Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Accord.Extensions.Imaging.Algorithms.LINE2D,FeatureMap,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\FeatureMap.cs,RetainImportantQuantizedOrientations,Cyclomatic complexity of the method is 11
Complex Method,DotImaging,Platform,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\DotImaging\Platform.cs,AddDllSearchPath,Cyclomatic complexity of the method is 9
Complex Method,DotImaging,Platform,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\DotImaging\Platform.cs,GetModuleFormatString,Cyclomatic complexity of the method is 12
Complex Method,MoreLinq,MoreEnumerable,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\MoreLinq\MoreEnumerable.MaxBy.cs,MaxBy,Cyclomatic complexity of the method is 9
Long Parameter List,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,matchTemplate,The method has 5 parameters.
Long Parameter List,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,createMatches,The method has 6 parameters.
Long Parameter List,Accord.Extensions.Imaging.Algorithms.LINE2D,FeatureMap,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\FeatureMap.cs,OrImageBits,The method has 5 parameters.
Long Parameter List,Accord.Extensions.Imaging.Algorithms.LINE2D,ImageTemplatePyramid,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\Template\ImageTemplate\ImageTemplatePyramid.cs,CreatePyramid,The method has 5 parameters.
Long Parameter List,Accord.Extensions.Imaging.Algorithms.LINE2D,ImageTemplatePyramid,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\Template\ImageTemplate\ImageTemplatePyramid.cs,CreatePyramidFromPreparedBWImage,The method has 5 parameters.
Long Parameter List,Accord.Extensions.Imaging.Algorithms.LINE2D,ImageTemplatePyramid,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\Template\ImageTemplate\ImageTemplatePyramid.cs,CreatePyramid,The method has 5 parameters.
Long Parameter List,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,computeColor,The method has 6 parameters.
Long Parameter List,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,computeGray,The method has 6 parameters.
Long Statement,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,MatchTemplate,The length of the statement  "		throw new Exception ("Number of pyramids in linear pyramid must match the number of templates in template pyramid!" + "\n" + "Check if the number of neighborhood per level is the same as the number of features per level for template!"); " is 236.
Long Statement,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,MatchTemplate,The length of the statement  "	pyrMatches [lowestLevelIdx] = matchTemplate (linPyr.PyramidalMaps [lowestLevelIdx]' templPyr.Templates [lowestLevelIdx]' searchArea' minMatchingPercentage' true); " is 162.
Long Statement,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,MatchTemplate,The length of the statement  "		for (int candidateIdx = 0; candidateIdx < pyrMatches [pyrLevel + 1].Count; candidateIdx++)//for every candidate of previous pyramid level... " is 140.
Long Statement,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,MatchTemplate,The length of the statement  "			var foundCandidates = matchTemplate (linPyr.PyramidalMaps [pyrLevel]' template' searchArea' minMatchingPercentage' pyrLevel != 0/*filter partial object for all levels except for the original one*/); " is 198.
Long Statement,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,matchTemplate,The length of the statement  "	var foundCandidates = createMatches (template' linMaps.NeigborhoodSize' foundMatchPoints' offset' rawScores' rawScoreScale); " is 124.
Long Statement,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,calculateSimilarityMap,The length of the statement  "	Debug.Assert (template.Size.Width + searchArea.X < maps.ImageSize.Width && template.Size.Height + searchArea.Y < maps.ImageSize.Height); " is 136.
Long Statement,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,calculateSimilarityMap,The length of the statement  "			bool finalAdd = (template.Features.Length % GlobalParameters.MAX_SUPPORTED_NUM_OF_FEATURES_ADDDED_AS_BYTE != 0) ? true : false; " is 127.
Long Statement,Accord.Extensions.Imaging.Algorithms.LINE2D,ImageTemplateWithMask,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\Template\ImageTemplate\ImageTemplateWithMask.cs,ReadXml,The length of the statement  "		this.BinaryMask = (Gray<byte>['])(new XmlSerializer (typeof(Image<Gray<byte>>))).Deserialize (new StringReader (binaryMaskData)); " is 129.
Long Statement,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMapPyramid,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\QueryImage\LinearizedMapPyramid.cs,CreatePyramid,The length of the statement  "	neigborhoodPerLevel = (neigborhoodPerLevel == null || neigborhoodPerLevel.Length == 0) ? DEFAULT_NEGBORHOOD_PER_LEVEL : neigborhoodPerLevel; " is 140.
Long Statement,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMaps,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\QueryImage\LinearizedMaps.cs,CalculateSimilarity,The length of the statement  "	while (((destAngles << numOfLeftShifts) & sourceAngle) == 0 && numOfLeftShifts < GlobalParameters.MAX_FEATURE_SIMILARITY) { " is 123.
Long Statement,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMaps,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\QueryImage\LinearizedMaps.cs,CalculateSimilarity,The length of the statement  "	while (((destAngles >> numOfRightShifts) & sourceAngle) == 0 && numOfRightShifts < GlobalParameters.MAX_FEATURE_SIMILARITY) { " is 125.
Long Statement,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMaps,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\QueryImage\LinearizedMaps.cs,CalculateSimilarity,The length of the statement  "	byte similarity = (byte)(GlobalParameters.MAX_FEATURE_SIMILARITY - System.Math.Min (numOfLeftShifts' numOfRightShifts)); " is 120.
Long Statement,Accord.Extensions.Imaging.Algorithms.LINE2D,FeatureMap,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\FeatureMap.cs,RetainImportantQuantizedOrientations,The length of the statement  "						for (byte histBinIdx = 0; histBinIdx < GlobalParameters.NUM_OF_QUNATIZED_ORIENTATIONS/*discard invalid orientation*/; histBinIdx++) { " is 133.
Long Statement,Accord.Extensions.Imaging.Algorithms.LINE2D,FeatureMap,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\FeatureMap.cs,Calculate,The length of the statement  "	Gray<byte>['] importantQuantizedOrient = FeatureMap.RetainImportantQuantizedOrientations (quantizedOrient' minSameOrientations); " is 128.
Long Statement,Accord.Extensions.Imaging.Algorithms.LINE2D,ImageTemplatePyramid,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\Template\ImageTemplate\ImageTemplatePyramid.cs,CreatePyramid,The length of the statement  "		var newTemplate = templateCreationFunc (image' minNumberOfFeatures' maxNumberOfFeaturesPerLevel [pyrLevel]' classLabel); " is 120.
Long Statement,DotImaging,PathExtensions,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\DotImaging\PathExtensions.cs,GetRelativeFilePath,The length of the statement  "		if (String.Equals (currDirInfo.FullName.Trim (Path.DirectorySeparatorChar)' dirInfo.FullName.Trim (Path.DirectorySeparatorChar))) " is 129.
Long Statement,DotImaging,PathExtensions,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\DotImaging\PathExtensions.cs,NormalizePathDelimiters,The length of the statement  "	return path.Replace ("//"' normalizedDelimiter).Replace (@"\"' normalizedDelimiter).Replace (@"\\"' normalizedDelimiter).Replace (@"/"' normalizedDelimiter); " is 157.
Long Statement,DotImaging,Platform,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\DotImaging\Platform.cs,getRunningPlatform,The length of the statement  "		if (Directory.Exists ("/Applications") & Directory.Exists ("/System") & Directory.Exists ("/Users") & Directory.Exists ("/Volumes")) " is 132.
Long Statement,DotImaging,Platform,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\DotImaging\Platform.cs,AddDllSearchPath,The length of the statement  "	Environment.SetEnvironmentVariable (path' Environment.GetEnvironmentVariable (path) + Path.PathSeparator + dllDirectory); " is 121.
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,MatchTemplate,The following statement contains a magic number: for (int pyrLevel = (lowestLevelIdx - 1); pyrLevel >= 0; pyrLevel--) {  	LinearizedMaps maps = linPyr.PyramidalMaps [pyrLevel];  	ITemplate template = templPyr.Templates [pyrLevel];  	Size imageValidSize = maps.ImageValidSize;  	pyrMatches [pyrLevel] = new List<Match> ();  	int previousNeigborhood = linPyr.PyramidalMaps [pyrLevel + 1].NeigborhoodSize;  	for (int candidateIdx = 0; candidateIdx < pyrMatches [pyrLevel + 1].Count; candidateIdx++)//for every candidate of previous pyramid level...  	 {  		//translate match to lower pyrmaid level  		Match canidate = pyrMatches [pyrLevel + 1] [candidateIdx];  		canidate.X = canidate.X * 2 + 1;  		canidate.Y = canidate.Y * 2 + 1;  		canidate.Template = template;  		//translate search area to lower pyramid level  		searchArea = new Rectangle//in originalImageSize coordinate system  		 {  			X = System.Math.Max (0' canidate.X - previousNeigborhood)'  			Y = System.Math.Max (0' canidate.Y - previousNeigborhood)'  			Width = previousNeigborhood * 2'  			Height = previousNeigborhood * 2  		};  		searchArea = searchArea.Intersect (imageValidSize);  		var foundCandidates = matchTemplate (linPyr.PyramidalMaps [pyrLevel]' template' searchArea' minMatchingPercentage' pyrLevel != 0/*filter partial object for all levels except for the original one*/);  		pyrMatches [pyrLevel].AddRange (foundCandidates);  	}  }  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,MatchTemplate,The following statement contains a magic number: for (int pyrLevel = (lowestLevelIdx - 1); pyrLevel >= 0; pyrLevel--) {  	LinearizedMaps maps = linPyr.PyramidalMaps [pyrLevel];  	ITemplate template = templPyr.Templates [pyrLevel];  	Size imageValidSize = maps.ImageValidSize;  	pyrMatches [pyrLevel] = new List<Match> ();  	int previousNeigborhood = linPyr.PyramidalMaps [pyrLevel + 1].NeigborhoodSize;  	for (int candidateIdx = 0; candidateIdx < pyrMatches [pyrLevel + 1].Count; candidateIdx++)//for every candidate of previous pyramid level...  	 {  		//translate match to lower pyrmaid level  		Match canidate = pyrMatches [pyrLevel + 1] [candidateIdx];  		canidate.X = canidate.X * 2 + 1;  		canidate.Y = canidate.Y * 2 + 1;  		canidate.Template = template;  		//translate search area to lower pyramid level  		searchArea = new Rectangle//in originalImageSize coordinate system  		 {  			X = System.Math.Max (0' canidate.X - previousNeigborhood)'  			Y = System.Math.Max (0' canidate.Y - previousNeigborhood)'  			Width = previousNeigborhood * 2'  			Height = previousNeigborhood * 2  		};  		searchArea = searchArea.Intersect (imageValidSize);  		var foundCandidates = matchTemplate (linPyr.PyramidalMaps [pyrLevel]' template' searchArea' minMatchingPercentage' pyrLevel != 0/*filter partial object for all levels except for the original one*/);  		pyrMatches [pyrLevel].AddRange (foundCandidates);  	}  }  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,MatchTemplate,The following statement contains a magic number: for (int pyrLevel = (lowestLevelIdx - 1); pyrLevel >= 0; pyrLevel--) {  	LinearizedMaps maps = linPyr.PyramidalMaps [pyrLevel];  	ITemplate template = templPyr.Templates [pyrLevel];  	Size imageValidSize = maps.ImageValidSize;  	pyrMatches [pyrLevel] = new List<Match> ();  	int previousNeigborhood = linPyr.PyramidalMaps [pyrLevel + 1].NeigborhoodSize;  	for (int candidateIdx = 0; candidateIdx < pyrMatches [pyrLevel + 1].Count; candidateIdx++)//for every candidate of previous pyramid level...  	 {  		//translate match to lower pyrmaid level  		Match canidate = pyrMatches [pyrLevel + 1] [candidateIdx];  		canidate.X = canidate.X * 2 + 1;  		canidate.Y = canidate.Y * 2 + 1;  		canidate.Template = template;  		//translate search area to lower pyramid level  		searchArea = new Rectangle//in originalImageSize coordinate system  		 {  			X = System.Math.Max (0' canidate.X - previousNeigborhood)'  			Y = System.Math.Max (0' canidate.Y - previousNeigborhood)'  			Width = previousNeigborhood * 2'  			Height = previousNeigborhood * 2  		};  		searchArea = searchArea.Intersect (imageValidSize);  		var foundCandidates = matchTemplate (linPyr.PyramidalMaps [pyrLevel]' template' searchArea' minMatchingPercentage' pyrLevel != 0/*filter partial object for all levels except for the original one*/);  		pyrMatches [pyrLevel].AddRange (foundCandidates);  	}  }  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,MatchTemplate,The following statement contains a magic number: for (int pyrLevel = (lowestLevelIdx - 1); pyrLevel >= 0; pyrLevel--) {  	LinearizedMaps maps = linPyr.PyramidalMaps [pyrLevel];  	ITemplate template = templPyr.Templates [pyrLevel];  	Size imageValidSize = maps.ImageValidSize;  	pyrMatches [pyrLevel] = new List<Match> ();  	int previousNeigborhood = linPyr.PyramidalMaps [pyrLevel + 1].NeigborhoodSize;  	for (int candidateIdx = 0; candidateIdx < pyrMatches [pyrLevel + 1].Count; candidateIdx++)//for every candidate of previous pyramid level...  	 {  		//translate match to lower pyrmaid level  		Match canidate = pyrMatches [pyrLevel + 1] [candidateIdx];  		canidate.X = canidate.X * 2 + 1;  		canidate.Y = canidate.Y * 2 + 1;  		canidate.Template = template;  		//translate search area to lower pyramid level  		searchArea = new Rectangle//in originalImageSize coordinate system  		 {  			X = System.Math.Max (0' canidate.X - previousNeigborhood)'  			Y = System.Math.Max (0' canidate.Y - previousNeigborhood)'  			Width = previousNeigborhood * 2'  			Height = previousNeigborhood * 2  		};  		searchArea = searchArea.Intersect (imageValidSize);  		var foundCandidates = matchTemplate (linPyr.PyramidalMaps [pyrLevel]' template' searchArea' minMatchingPercentage' pyrLevel != 0/*filter partial object for all levels except for the original one*/);  		pyrMatches [pyrLevel].AddRange (foundCandidates);  	}  }  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,MatchTemplate,The following statement contains a magic number: for (int candidateIdx = 0; candidateIdx < pyrMatches [pyrLevel + 1].Count; candidateIdx++)//for every candidate of previous pyramid level...   {  	//translate match to lower pyrmaid level  	Match canidate = pyrMatches [pyrLevel + 1] [candidateIdx];  	canidate.X = canidate.X * 2 + 1;  	canidate.Y = canidate.Y * 2 + 1;  	canidate.Template = template;  	//translate search area to lower pyramid level  	searchArea = new Rectangle//in originalImageSize coordinate system  	 {  		X = System.Math.Max (0' canidate.X - previousNeigborhood)'  		Y = System.Math.Max (0' canidate.Y - previousNeigborhood)'  		Width = previousNeigborhood * 2'  		Height = previousNeigborhood * 2  	};  	searchArea = searchArea.Intersect (imageValidSize);  	var foundCandidates = matchTemplate (linPyr.PyramidalMaps [pyrLevel]' template' searchArea' minMatchingPercentage' pyrLevel != 0/*filter partial object for all levels except for the original one*/);  	pyrMatches [pyrLevel].AddRange (foundCandidates);  }  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,MatchTemplate,The following statement contains a magic number: for (int candidateIdx = 0; candidateIdx < pyrMatches [pyrLevel + 1].Count; candidateIdx++)//for every candidate of previous pyramid level...   {  	//translate match to lower pyrmaid level  	Match canidate = pyrMatches [pyrLevel + 1] [candidateIdx];  	canidate.X = canidate.X * 2 + 1;  	canidate.Y = canidate.Y * 2 + 1;  	canidate.Template = template;  	//translate search area to lower pyramid level  	searchArea = new Rectangle//in originalImageSize coordinate system  	 {  		X = System.Math.Max (0' canidate.X - previousNeigborhood)'  		Y = System.Math.Max (0' canidate.Y - previousNeigborhood)'  		Width = previousNeigborhood * 2'  		Height = previousNeigborhood * 2  	};  	searchArea = searchArea.Intersect (imageValidSize);  	var foundCandidates = matchTemplate (linPyr.PyramidalMaps [pyrLevel]' template' searchArea' minMatchingPercentage' pyrLevel != 0/*filter partial object for all levels except for the original one*/);  	pyrMatches [pyrLevel].AddRange (foundCandidates);  }  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,MatchTemplate,The following statement contains a magic number: for (int candidateIdx = 0; candidateIdx < pyrMatches [pyrLevel + 1].Count; candidateIdx++)//for every candidate of previous pyramid level...   {  	//translate match to lower pyrmaid level  	Match canidate = pyrMatches [pyrLevel + 1] [candidateIdx];  	canidate.X = canidate.X * 2 + 1;  	canidate.Y = canidate.Y * 2 + 1;  	canidate.Template = template;  	//translate search area to lower pyramid level  	searchArea = new Rectangle//in originalImageSize coordinate system  	 {  		X = System.Math.Max (0' canidate.X - previousNeigborhood)'  		Y = System.Math.Max (0' canidate.Y - previousNeigborhood)'  		Width = previousNeigborhood * 2'  		Height = previousNeigborhood * 2  	};  	searchArea = searchArea.Intersect (imageValidSize);  	var foundCandidates = matchTemplate (linPyr.PyramidalMaps [pyrLevel]' template' searchArea' minMatchingPercentage' pyrLevel != 0/*filter partial object for all levels except for the original one*/);  	pyrMatches [pyrLevel].AddRange (foundCandidates);  }  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,MatchTemplate,The following statement contains a magic number: for (int candidateIdx = 0; candidateIdx < pyrMatches [pyrLevel + 1].Count; candidateIdx++)//for every candidate of previous pyramid level...   {  	//translate match to lower pyrmaid level  	Match canidate = pyrMatches [pyrLevel + 1] [candidateIdx];  	canidate.X = canidate.X * 2 + 1;  	canidate.Y = canidate.Y * 2 + 1;  	canidate.Template = template;  	//translate search area to lower pyramid level  	searchArea = new Rectangle//in originalImageSize coordinate system  	 {  		X = System.Math.Max (0' canidate.X - previousNeigborhood)'  		Y = System.Math.Max (0' canidate.Y - previousNeigborhood)'  		Width = previousNeigborhood * 2'  		Height = previousNeigborhood * 2  	};  	searchArea = searchArea.Intersect (imageValidSize);  	var foundCandidates = matchTemplate (linPyr.PyramidalMaps [pyrLevel]' template' searchArea' minMatchingPercentage' pyrLevel != 0/*filter partial object for all levels except for the original one*/);  	pyrMatches [pyrLevel].AddRange (foundCandidates);  }  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,MatchTemplate,The following statement contains a magic number: canidate.X = canidate.X * 2 + 1;  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,MatchTemplate,The following statement contains a magic number: canidate.Y = canidate.Y * 2 + 1;  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,MatchTemplate,The following statement contains a magic number: searchArea = new Rectangle//in originalImageSize coordinate system   {  	X = System.Math.Max (0' canidate.X - previousNeigborhood)'  	Y = System.Math.Max (0' canidate.Y - previousNeigborhood)'  	Width = previousNeigborhood * 2'  	Height = previousNeigborhood * 2  };  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,MatchTemplate,The following statement contains a magic number: searchArea = new Rectangle//in originalImageSize coordinate system   {  	X = System.Math.Max (0' canidate.X - previousNeigborhood)'  	Y = System.Math.Max (0' canidate.Y - previousNeigborhood)'  	Width = previousNeigborhood * 2'  	Height = previousNeigborhood * 2  };  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,ImageTemplateWithMask,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\Template\ImageTemplate\ImageTemplateWithMask.cs,Initialize,The following statement contains a magic number: this.BinaryMask = this.BinaryMask.ThresholdToZero ((byte)(255 * 0.75)' (byte)255);  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,ImageTemplateWithMask,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\Template\ImageTemplate\ImageTemplateWithMask.cs,Initialize,The following statement contains a magic number: this.BinaryMask = this.BinaryMask.ThresholdToZero ((byte)(255 * 0.75)' (byte)255);  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,ImageTemplateWithMask,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\Template\ImageTemplate\ImageTemplateWithMask.cs,Initialize,The following statement contains a magic number: this.BinaryMask = this.BinaryMask.ThresholdToZero ((byte)(255 * 0.75)' (byte)255);  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GlobalParameters,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\GlobalParameters.cs,GlobalParameters,The following statement contains a magic number: Debug.Assert (NUM_OF_QUNATIZED_ORIENTATIONS <= 8/*(num of bits in byte)*/);  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMaps,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\QueryImage\LinearizedMaps.cs,ComputeSimilarityAngleTable,The following statement contains a magic number: for (int angleIdx = 0; angleIdx < GlobalParameters.NUM_OF_QUNATIZED_ORIENTATIONS; angleIdx++) {  	for (int destAngles = 0; destAngles < 256; destAngles++) {  		similarityTable [angleIdx' destAngles] = CalculateSimilarity ((byte)destAngles' (byte)(1 << angleIdx));  	}  }  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMaps,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\QueryImage\LinearizedMaps.cs,ComputeSimilarityAngleTable,The following statement contains a magic number: for (int destAngles = 0; destAngles < 256; destAngles++) {  	similarityTable [angleIdx' destAngles] = CalculateSimilarity ((byte)destAngles' (byte)(1 << angleIdx));  }  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,FeatureMap,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\FeatureMap.cs,CalculateAngleQuantizationTable,The following statement contains a magic number: for (int angle = 0; angle <= 360; angle++) {  	int directedAngle;  	directedAngle = (int)System.Math.Round (2f * GlobalParameters.NUM_OF_QUNATIZED_ORIENTATIONS / 360 * angle);  	directedAngle &= 7;  	angleQuantizationTable [angle] = (byte)directedAngle;  }  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,FeatureMap,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\FeatureMap.cs,CalculateAngleQuantizationTable,The following statement contains a magic number: for (int angle = 0; angle <= 360; angle++) {  	int directedAngle;  	directedAngle = (int)System.Math.Round (2f * GlobalParameters.NUM_OF_QUNATIZED_ORIENTATIONS / 360 * angle);  	directedAngle &= 7;  	angleQuantizationTable [angle] = (byte)directedAngle;  }  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,FeatureMap,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\FeatureMap.cs,CalculateAngleQuantizationTable,The following statement contains a magic number: for (int angle = 0; angle <= 360; angle++) {  	int directedAngle;  	directedAngle = (int)System.Math.Round (2f * GlobalParameters.NUM_OF_QUNATIZED_ORIENTATIONS / 360 * angle);  	directedAngle &= 7;  	angleQuantizationTable [angle] = (byte)directedAngle;  }  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,FeatureMap,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\FeatureMap.cs,CalculateAngleQuantizationTable,The following statement contains a magic number: directedAngle = (int)System.Math.Round (2f * GlobalParameters.NUM_OF_QUNATIZED_ORIENTATIONS / 360 * angle);  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,FeatureMap,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\FeatureMap.cs,CalculateAngleQuantizationTable,The following statement contains a magic number: directedAngle &= 7;  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,FeatureMap,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\FeatureMap.cs,RetainImportantQuantizedOrientations,The following statement contains a magic number: if (minSameOrientations < 0 || minSameOrientations > 9/*3x3 neigborhood*/)  	throw new Exception ("Minimal number of same orientations should be in: [0..9].");  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,ImageTemplate,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\Template\ImageTemplate\ImageTemplate.cs,ExtractTemplate,The following statement contains a magic number: return FilterScatteredFeatures (candidates' maxNumOfFeatures' 5);  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,Compute,The following statement contains a magic number: using (var uFrame = frame.Lock ()) {  	ParallelLauncher.Launch (thread => {  		computeColor (thread' (byte*)uFrame.ImageData' uFrame.Stride' orientationImage' _magnitudeSqrImage' minSqrMagnitude);  	}' frame.Width () - 2 * kernelRadius' frame.Height () - 2 * kernelRadius);  }  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,Compute,The following statement contains a magic number: using (var uFrame = frame.Lock ()) {  	ParallelLauncher.Launch (thread => {  		computeColor (thread' (byte*)uFrame.ImageData' uFrame.Stride' orientationImage' _magnitudeSqrImage' minSqrMagnitude);  	}' frame.Width () - 2 * kernelRadius' frame.Height () - 2 * kernelRadius);  }  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,Compute,The following statement contains a magic number: ParallelLauncher.Launch (thread => {  	computeColor (thread' (byte*)uFrame.ImageData' uFrame.Stride' orientationImage' _magnitudeSqrImage' minSqrMagnitude);  }' frame.Width () - 2 * kernelRadius' frame.Height () - 2 * kernelRadius);  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,Compute,The following statement contains a magic number: ParallelLauncher.Launch (thread => {  	computeColor (thread' (byte*)uFrame.ImageData' uFrame.Stride' orientationImage' _magnitudeSqrImage' minSqrMagnitude);  }' frame.Width () - 2 * kernelRadius' frame.Height () - 2 * kernelRadius);  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,computeColor,The following statement contains a magic number: frame = frame + frameStride * thread.Y + thread.X * 3/*sizeof(Bgr<byte>)*/;  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,computeColor,The following statement contains a magic number: for (int ch = 0; ch < 3; ch++) {  	var srcPtr = frame + ch;  	int sumX = 0' sumY = 0;  	for (int r = 0; r < 3; r++) {  		var chPtr = srcPtr;  		for (int c = 0; c < 3; c++) {  			sumX += *chPtr * Sobel_3x3_X [r' c];  			sumY += *chPtr * Sobel_3x3_Y [r' c];  			chPtr += 3 * sizeof(byte);  		}  		srcPtr = (byte*)srcPtr + frameStride;  	}  	//sumX >>= 3; sumY >>= 3; //divide by 8 (normalize kernel)  	var grad = sumX * sumX + sumY * sumY;  	if (grad > maxMagSqr) {  		maxMagSqr = grad;  		maxDx = sumX;  		maxDy = sumY;  	}  }  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,computeColor,The following statement contains a magic number: for (int ch = 0; ch < 3; ch++) {  	var srcPtr = frame + ch;  	int sumX = 0' sumY = 0;  	for (int r = 0; r < 3; r++) {  		var chPtr = srcPtr;  		for (int c = 0; c < 3; c++) {  			sumX += *chPtr * Sobel_3x3_X [r' c];  			sumY += *chPtr * Sobel_3x3_Y [r' c];  			chPtr += 3 * sizeof(byte);  		}  		srcPtr = (byte*)srcPtr + frameStride;  	}  	//sumX >>= 3; sumY >>= 3; //divide by 8 (normalize kernel)  	var grad = sumX * sumX + sumY * sumY;  	if (grad > maxMagSqr) {  		maxMagSqr = grad;  		maxDx = sumX;  		maxDy = sumY;  	}  }  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,computeColor,The following statement contains a magic number: for (int ch = 0; ch < 3; ch++) {  	var srcPtr = frame + ch;  	int sumX = 0' sumY = 0;  	for (int r = 0; r < 3; r++) {  		var chPtr = srcPtr;  		for (int c = 0; c < 3; c++) {  			sumX += *chPtr * Sobel_3x3_X [r' c];  			sumY += *chPtr * Sobel_3x3_Y [r' c];  			chPtr += 3 * sizeof(byte);  		}  		srcPtr = (byte*)srcPtr + frameStride;  	}  	//sumX >>= 3; sumY >>= 3; //divide by 8 (normalize kernel)  	var grad = sumX * sumX + sumY * sumY;  	if (grad > maxMagSqr) {  		maxMagSqr = grad;  		maxDx = sumX;  		maxDy = sumY;  	}  }  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,computeColor,The following statement contains a magic number: for (int ch = 0; ch < 3; ch++) {  	var srcPtr = frame + ch;  	int sumX = 0' sumY = 0;  	for (int r = 0; r < 3; r++) {  		var chPtr = srcPtr;  		for (int c = 0; c < 3; c++) {  			sumX += *chPtr * Sobel_3x3_X [r' c];  			sumY += *chPtr * Sobel_3x3_Y [r' c];  			chPtr += 3 * sizeof(byte);  		}  		srcPtr = (byte*)srcPtr + frameStride;  	}  	//sumX >>= 3; sumY >>= 3; //divide by 8 (normalize kernel)  	var grad = sumX * sumX + sumY * sumY;  	if (grad > maxMagSqr) {  		maxMagSqr = grad;  		maxDx = sumX;  		maxDy = sumY;  	}  }  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,computeColor,The following statement contains a magic number: for (int r = 0; r < 3; r++) {  	var chPtr = srcPtr;  	for (int c = 0; c < 3; c++) {  		sumX += *chPtr * Sobel_3x3_X [r' c];  		sumY += *chPtr * Sobel_3x3_Y [r' c];  		chPtr += 3 * sizeof(byte);  	}  	srcPtr = (byte*)srcPtr + frameStride;  }  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,computeColor,The following statement contains a magic number: for (int r = 0; r < 3; r++) {  	var chPtr = srcPtr;  	for (int c = 0; c < 3; c++) {  		sumX += *chPtr * Sobel_3x3_X [r' c];  		sumY += *chPtr * Sobel_3x3_Y [r' c];  		chPtr += 3 * sizeof(byte);  	}  	srcPtr = (byte*)srcPtr + frameStride;  }  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,computeColor,The following statement contains a magic number: for (int r = 0; r < 3; r++) {  	var chPtr = srcPtr;  	for (int c = 0; c < 3; c++) {  		sumX += *chPtr * Sobel_3x3_X [r' c];  		sumY += *chPtr * Sobel_3x3_Y [r' c];  		chPtr += 3 * sizeof(byte);  	}  	srcPtr = (byte*)srcPtr + frameStride;  }  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,computeColor,The following statement contains a magic number: for (int c = 0; c < 3; c++) {  	sumX += *chPtr * Sobel_3x3_X [r' c];  	sumY += *chPtr * Sobel_3x3_Y [r' c];  	chPtr += 3 * sizeof(byte);  }  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,computeColor,The following statement contains a magic number: for (int c = 0; c < 3; c++) {  	sumX += *chPtr * Sobel_3x3_X [r' c];  	sumY += *chPtr * Sobel_3x3_Y [r' c];  	chPtr += 3 * sizeof(byte);  }  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,computeColor,The following statement contains a magic number: chPtr += 3 * sizeof(byte);  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,Compute,The following statement contains a magic number: using (var uFrame = frame.Lock ()) {  	ParallelLauncher.Launch (thread => {  		computeGray (thread' (byte*)uFrame.ImageData' uFrame.Stride' orientationImage' _magnitudeSqrImage' minSqrMagnitude);  	}' frame.Width () - 2 * kernelRadius' frame.Height () - 2 * kernelRadius);  }  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,Compute,The following statement contains a magic number: using (var uFrame = frame.Lock ()) {  	ParallelLauncher.Launch (thread => {  		computeGray (thread' (byte*)uFrame.ImageData' uFrame.Stride' orientationImage' _magnitudeSqrImage' minSqrMagnitude);  	}' frame.Width () - 2 * kernelRadius' frame.Height () - 2 * kernelRadius);  }  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,Compute,The following statement contains a magic number: ParallelLauncher.Launch (thread => {  	computeGray (thread' (byte*)uFrame.ImageData' uFrame.Stride' orientationImage' _magnitudeSqrImage' minSqrMagnitude);  }' frame.Width () - 2 * kernelRadius' frame.Height () - 2 * kernelRadius);  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,Compute,The following statement contains a magic number: ParallelLauncher.Launch (thread => {  	computeGray (thread' (byte*)uFrame.ImageData' uFrame.Stride' orientationImage' _magnitudeSqrImage' minSqrMagnitude);  }' frame.Width () - 2 * kernelRadius' frame.Height () - 2 * kernelRadius);  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,computeGray,The following statement contains a magic number: for (int r = 0; r < 3; r++) {  	for (int c = 0; c < 3; c++) {  		sumX += srcPtr [c] * Sobel_3x3_X [r' c];  		sumY += srcPtr [c] * Sobel_3x3_Y [r' c];  	}  	srcPtr = (byte*)srcPtr + frameStride;  }  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,computeGray,The following statement contains a magic number: for (int r = 0; r < 3; r++) {  	for (int c = 0; c < 3; c++) {  		sumX += srcPtr [c] * Sobel_3x3_X [r' c];  		sumY += srcPtr [c] * Sobel_3x3_Y [r' c];  	}  	srcPtr = (byte*)srcPtr + frameStride;  }  
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,computeGray,The following statement contains a magic number: for (int c = 0; c < 3; c++) {  	sumX += srcPtr [c] * Sobel_3x3_X [r' c];  	sumY += srcPtr [c] * Sobel_3x3_Y [r' c];  }  
Missing Default,DotImaging,Platform,F:\newReposMay17\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\DotImaging\Platform.cs,AddDllSearchPath,The following switch statement is missing a default case: switch (RunningPlatform) {  case OperatingSystem.Windows:  	path = "PATH";  	break;  case OperatingSystem.MacOS:  	path = "LD_LIBRARY_PATH";  	break;  case OperatingSystem.Linux:  	path = "DYLD_FRAMEWORK_PATH";  	break;  }  
