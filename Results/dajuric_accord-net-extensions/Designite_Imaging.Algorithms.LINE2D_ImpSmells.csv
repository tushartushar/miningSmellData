Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,matchTemplate,The method has 5 parameters. Parameters: linMaps' template' searchArea' minMatchingPercentage' filterPartialObjects
Long Parameter List,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,createMatches,The method has 6 parameters. Parameters: template' neigborhood' mapPositions' offset' rawScores' rawScoreScale
Long Parameter List,Accord.Extensions.Imaging.Algorithms.LINE2D,FeatureMap,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\FeatureMap.cs,OrImageBits,The method has 5 parameters. Parameters: srcAddr' dstAddr' imgStride' subImageWidth' subImageHeight
Long Parameter List,Accord.Extensions.Imaging.Algorithms.LINE2D,ImageTemplatePyramid<T>,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\Template\ImageTemplate\ImageTemplatePyramid.cs,CreatePyramid,The method has 5 parameters. Parameters: sourceImage' classLabel' minFeatureStrength' minNumberOfFeatures' maxNumberOfFeaturesPerLevel
Long Parameter List,Accord.Extensions.Imaging.Algorithms.LINE2D,ImageTemplatePyramid<T>,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\Template\ImageTemplate\ImageTemplatePyramid.cs,CreatePyramidFromPreparedBWImage,The method has 5 parameters. Parameters: sourceImage' classLabel' minFeatureStrength' minNumberOfFeatures' maxNumberOfFeaturesPerLevel
Long Parameter List,Accord.Extensions.Imaging.Algorithms.LINE2D,ImageTemplatePyramid<T>,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\Template\ImageTemplate\ImageTemplatePyramid.cs,CreatePyramid,The method has 5 parameters. Parameters: sourceImage' classLabel' templateCreationFunc' minNumberOfFeatures' maxNumberOfFeaturesPerLevel
Long Parameter List,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,computeColor,The method has 6 parameters. Parameters: thread' frame' frameStride' orientationImage' magnitudeSqrImage' minSqrMagnitude
Long Parameter List,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,computeGray,The method has 6 parameters. Parameters: thread' frame' frameStride' orientationImage' magnitudeSqrImage' minSqrMagnitude
Long Identifier,Accord.Extensions.Imaging.Algorithms.LINE2D,GlobalParameters,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\GlobalParameters.cs,,The length of the parameter MAX_SUPPORTED_NUM_OF_FEATURES_ADDDED_AS_BYTE is 44.
Long Identifier,Accord.Extensions.Imaging.Algorithms.LINE2D,ImageTemplatePyramid<T>,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\Template\ImageTemplate\ImageTemplatePyramid.cs,,The length of the parameter DEFAULT_MAX_FEATURES_PER_LEVEL is 30.
Long Statement,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,MatchTemplate,The length of the statement  "                throw new Exception("Number of pyramids in linear pyramid must match the number of templates in template pyramid!" + "\n" +  " is 123.
Long Statement,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,MatchTemplate,The length of the statement  "            pyrMatches[lowestLevelIdx] = matchTemplate(linPyr.PyramidalMaps[lowestLevelIdx]' templPyr.Templates[lowestLevelIdx]' searchArea' minMatchingPercentage' true); " is 158.
Long Statement,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,MatchTemplate,The length of the statement  "                for (int candidateIdx = 0; candidateIdx < pyrMatches[pyrLevel+1].Count; candidateIdx++) //for every candidate of previous pyramid level... " is 138.
Long Statement,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,MatchTemplate,The length of the statement  "                    var foundCandidates = matchTemplate(linPyr.PyramidalMaps[pyrLevel]' template' searchArea' minMatchingPercentage' pyrLevel != 0 /*filter partial object for all levels except for the original one*/); " is 197.
Long Statement,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,matchTemplate,The length of the statement  "            var foundCandidates = createMatches(template' linMaps.NeigborhoodSize' foundMatchPoints' offset' rawScores' rawScoreScale); " is 123.
Long Statement,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,calculateSimilarityMap,The length of the statement  "                bool finalAdd = (template.Features.Length % GlobalParameters.MAX_SUPPORTED_NUM_OF_FEATURES_ADDDED_AS_BYTE != 0) ? true : false; " is 127.
Long Statement,Accord.Extensions.Imaging.Algorithms.LINE2D,ImageTemplateWithMask,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\Template\ImageTemplate\ImageTemplateWithMask.cs,ReadXml,The length of the statement  "                this.BinaryMask = (Gray<byte>['])(new XmlSerializer(typeof(Image<Gray<byte>>))).Deserialize(new StringReader(binaryMaskData)); " is 126.
Long Statement,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMapPyramid,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\QueryImage\LinearizedMapPyramid.cs,CreatePyramid,The length of the statement  "            neigborhoodPerLevel = (neigborhoodPerLevel == null || neigborhoodPerLevel.Length == 0) ? DEFAULT_NEGBORHOOD_PER_LEVEL : neigborhoodPerLevel; " is 140.
Long Statement,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMaps,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\QueryImage\LinearizedMaps.cs,CalculateSimilarity,The length of the statement  "            while ( ((destAngles << numOfLeftShifts) & sourceAngle) == 0 && numOfLeftShifts < GlobalParameters.MAX_FEATURE_SIMILARITY) " is 122.
Long Statement,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMaps,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\QueryImage\LinearizedMaps.cs,CalculateSimilarity,The length of the statement  "            while (((destAngles >> numOfRightShifts) & sourceAngle) == 0 && numOfRightShifts < GlobalParameters.MAX_FEATURE_SIMILARITY) " is 123.
Long Statement,Accord.Extensions.Imaging.Algorithms.LINE2D,FeatureMap,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\FeatureMap.cs,QuantizeOrientations,The length of the statement  "                        qOrinetUnfilteredPtr[i] = AngleQuantizationTable[angle]; //[0-360] -> [...] -> [0-7] (for mapping see "CalculateAngleQuantizationTable()") " is 138.
Long Statement,Accord.Extensions.Imaging.Algorithms.LINE2D,FeatureMap,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\FeatureMap.cs,RetainImportantQuantizedOrientations,The length of the statement  "                            histogram[qOrinetUnfilteredPtr[-qOrinetStride - 1]]++; histogram[qOrinetUnfilteredPtr[-qOrinetStride + 0]]++; histogram[qOrinetUnfilteredPtr[-qOrinetStride + 1]]++; " is 164.
Long Statement,Accord.Extensions.Imaging.Algorithms.LINE2D,FeatureMap,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\FeatureMap.cs,RetainImportantQuantizedOrientations,The length of the statement  "                            histogram[qOrinetUnfilteredPtr[+qOrinetStride - 1]]++; histogram[qOrinetUnfilteredPtr[+qOrinetStride + 0]]++; histogram[qOrinetUnfilteredPtr[+qOrinetStride + 1]]++; " is 164.
Long Statement,Accord.Extensions.Imaging.Algorithms.LINE2D,FeatureMap,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\FeatureMap.cs,RetainImportantQuantizedOrientations,The length of the statement  "                            for (byte histBinIdx = 0; histBinIdx < GlobalParameters.NUM_OF_QUNATIZED_ORIENTATIONS /*discard invalid orientation*/; histBinIdx++) " is 132.
Long Statement,Accord.Extensions.Imaging.Algorithms.LINE2D,FeatureMap,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\FeatureMap.cs,Calculate,The length of the statement  "            Gray<byte>['] importantQuantizedOrient = FeatureMap.RetainImportantQuantizedOrientations(quantizedOrient' minSameOrientations); " is 127.
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,MatchTemplate,The following statement contains a magic number: for (int pyrLevel = (lowestLevelIdx - 1); pyrLevel >= 0; pyrLevel--)              {                  LinearizedMaps maps = linPyr.PyramidalMaps[pyrLevel];                  ITemplate template = templPyr.Templates[pyrLevel];                  Size imageValidSize = maps.ImageValidSize;                  pyrMatches[pyrLevel] = new List<Match>();                    int previousNeigborhood = linPyr.PyramidalMaps[pyrLevel + 1].NeigborhoodSize;                    for (int candidateIdx = 0; candidateIdx < pyrMatches[pyrLevel+1].Count; candidateIdx++) //for every candidate of previous pyramid level...                  {                      //translate match to lower pyrmaid level                      Match canidate = pyrMatches[pyrLevel + 1][candidateIdx];                      canidate.X = canidate.X * 2 + 1;                      canidate.Y = canidate.Y * 2 + 1;                      canidate.Template = template;                        //translate search area to lower pyramid level                      searchArea = new Rectangle //in originalImageSize coordinate system                      {                          X = System.Math.Max(0' canidate.X - previousNeigborhood)'                          Y = System.Math.Max(0' canidate.Y - previousNeigborhood)'                          Width = previousNeigborhood * 2'                           Height = previousNeigborhood * 2                      };                      searchArea = searchArea.Intersect(imageValidSize);                        var foundCandidates = matchTemplate(linPyr.PyramidalMaps[pyrLevel]' template' searchArea' minMatchingPercentage' pyrLevel != 0 /*filter partial object for all levels except for the original one*/);                      pyrMatches[pyrLevel].AddRange(foundCandidates);                  }              }
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,MatchTemplate,The following statement contains a magic number: for (int pyrLevel = (lowestLevelIdx - 1); pyrLevel >= 0; pyrLevel--)              {                  LinearizedMaps maps = linPyr.PyramidalMaps[pyrLevel];                  ITemplate template = templPyr.Templates[pyrLevel];                  Size imageValidSize = maps.ImageValidSize;                  pyrMatches[pyrLevel] = new List<Match>();                    int previousNeigborhood = linPyr.PyramidalMaps[pyrLevel + 1].NeigborhoodSize;                    for (int candidateIdx = 0; candidateIdx < pyrMatches[pyrLevel+1].Count; candidateIdx++) //for every candidate of previous pyramid level...                  {                      //translate match to lower pyrmaid level                      Match canidate = pyrMatches[pyrLevel + 1][candidateIdx];                      canidate.X = canidate.X * 2 + 1;                      canidate.Y = canidate.Y * 2 + 1;                      canidate.Template = template;                        //translate search area to lower pyramid level                      searchArea = new Rectangle //in originalImageSize coordinate system                      {                          X = System.Math.Max(0' canidate.X - previousNeigborhood)'                          Y = System.Math.Max(0' canidate.Y - previousNeigborhood)'                          Width = previousNeigborhood * 2'                           Height = previousNeigborhood * 2                      };                      searchArea = searchArea.Intersect(imageValidSize);                        var foundCandidates = matchTemplate(linPyr.PyramidalMaps[pyrLevel]' template' searchArea' minMatchingPercentage' pyrLevel != 0 /*filter partial object for all levels except for the original one*/);                      pyrMatches[pyrLevel].AddRange(foundCandidates);                  }              }
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,MatchTemplate,The following statement contains a magic number: for (int pyrLevel = (lowestLevelIdx - 1); pyrLevel >= 0; pyrLevel--)              {                  LinearizedMaps maps = linPyr.PyramidalMaps[pyrLevel];                  ITemplate template = templPyr.Templates[pyrLevel];                  Size imageValidSize = maps.ImageValidSize;                  pyrMatches[pyrLevel] = new List<Match>();                    int previousNeigborhood = linPyr.PyramidalMaps[pyrLevel + 1].NeigborhoodSize;                    for (int candidateIdx = 0; candidateIdx < pyrMatches[pyrLevel+1].Count; candidateIdx++) //for every candidate of previous pyramid level...                  {                      //translate match to lower pyrmaid level                      Match canidate = pyrMatches[pyrLevel + 1][candidateIdx];                      canidate.X = canidate.X * 2 + 1;                      canidate.Y = canidate.Y * 2 + 1;                      canidate.Template = template;                        //translate search area to lower pyramid level                      searchArea = new Rectangle //in originalImageSize coordinate system                      {                          X = System.Math.Max(0' canidate.X - previousNeigborhood)'                          Y = System.Math.Max(0' canidate.Y - previousNeigborhood)'                          Width = previousNeigborhood * 2'                           Height = previousNeigborhood * 2                      };                      searchArea = searchArea.Intersect(imageValidSize);                        var foundCandidates = matchTemplate(linPyr.PyramidalMaps[pyrLevel]' template' searchArea' minMatchingPercentage' pyrLevel != 0 /*filter partial object for all levels except for the original one*/);                      pyrMatches[pyrLevel].AddRange(foundCandidates);                  }              }
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,MatchTemplate,The following statement contains a magic number: for (int pyrLevel = (lowestLevelIdx - 1); pyrLevel >= 0; pyrLevel--)              {                  LinearizedMaps maps = linPyr.PyramidalMaps[pyrLevel];                  ITemplate template = templPyr.Templates[pyrLevel];                  Size imageValidSize = maps.ImageValidSize;                  pyrMatches[pyrLevel] = new List<Match>();                    int previousNeigborhood = linPyr.PyramidalMaps[pyrLevel + 1].NeigborhoodSize;                    for (int candidateIdx = 0; candidateIdx < pyrMatches[pyrLevel+1].Count; candidateIdx++) //for every candidate of previous pyramid level...                  {                      //translate match to lower pyrmaid level                      Match canidate = pyrMatches[pyrLevel + 1][candidateIdx];                      canidate.X = canidate.X * 2 + 1;                      canidate.Y = canidate.Y * 2 + 1;                      canidate.Template = template;                        //translate search area to lower pyramid level                      searchArea = new Rectangle //in originalImageSize coordinate system                      {                          X = System.Math.Max(0' canidate.X - previousNeigborhood)'                          Y = System.Math.Max(0' canidate.Y - previousNeigborhood)'                          Width = previousNeigborhood * 2'                           Height = previousNeigborhood * 2                      };                      searchArea = searchArea.Intersect(imageValidSize);                        var foundCandidates = matchTemplate(linPyr.PyramidalMaps[pyrLevel]' template' searchArea' minMatchingPercentage' pyrLevel != 0 /*filter partial object for all levels except for the original one*/);                      pyrMatches[pyrLevel].AddRange(foundCandidates);                  }              }
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMemoryDetectorExtensions,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Detector.cs,createMatches,The following statement contains a magic number: int allignment = neigborhood / 2;
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,Match<T>,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Match\Match.cs,GetCenter,The following statement contains a magic number: Point matchCenter = new Point(matchRect.X + matchRect.Width / 2' matchRect.Y + matchRect.Height / 2);
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,Match<T>,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\Detector\Match\Match.cs,GetCenter,The following statement contains a magic number: Point matchCenter = new Point(matchRect.X + matchRect.Width / 2' matchRect.Y + matchRect.Height / 2);
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,Feature,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\Template\Base\Feature.cs,GetAngleIndex,The following statement contains a magic number: const int MAX_NUM_OF_SHIFTS = 8;
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,ImageTemplateWithMask,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\Template\ImageTemplate\ImageTemplateWithMask.cs,Initialize,The following statement contains a magic number: this.BinaryMask = this.BinaryMask.ThresholdToZero((byte)(255 * 0.75)' (byte)255);
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,ImageTemplateWithMask,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\Template\ImageTemplate\ImageTemplateWithMask.cs,Initialize,The following statement contains a magic number: this.BinaryMask = this.BinaryMask.ThresholdToZero((byte)(255 * 0.75)' (byte)255);
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,ImageTemplateWithMask,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\Template\ImageTemplate\ImageTemplateWithMask.cs,Initialize,The following statement contains a magic number: this.BinaryMask = this.BinaryMask.ThresholdToZero((byte)(255 * 0.75)' (byte)255);
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GlobalParameters,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\GlobalParameters.cs,GlobalParameters,The following statement contains a magic number: Debug.Assert(NUM_OF_QUNATIZED_ORIENTATIONS <= 8 /*(num of bits in byte)*/);
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMaps,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\QueryImage\LinearizedMaps.cs,ComputeSimilarityAngleTable,The following statement contains a magic number: byte['] similarityTable = new byte[GlobalParameters.NUM_OF_QUNATIZED_ORIENTATIONS' 256];
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,LinearizedMaps,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\QueryImage\LinearizedMaps.cs,ComputeSimilarityAngleTable,The following statement contains a magic number: for (int angleIdx = 0; angleIdx < GlobalParameters.NUM_OF_QUNATIZED_ORIENTATIONS; angleIdx++)              {                  for (int destAngles = 0; destAngles < 256; destAngles++)                  {                      similarityTable[angleIdx' destAngles] = CalculateSimilarity((byte)destAngles' (byte)(1 << angleIdx));                  }              }
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,FeatureMap,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\FeatureMap.cs,CalculateAngleQuantizationTable,The following statement contains a magic number: byte[] angleQuantizationTable = new byte[360 + 1/*0..360*/ + 1/*invalid orientation*/];
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,FeatureMap,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\FeatureMap.cs,CalculateAngleQuantizationTable,The following statement contains a magic number: for (int angle = 0; angle <= 360; angle++)                {                  int directedAngle;                    directedAngle = (int)System.Math.Round(2f * GlobalParameters.NUM_OF_QUNATIZED_ORIENTATIONS / 360 * angle);                  directedAngle &= 7;                             angleQuantizationTable[angle] = (byte)directedAngle;              }
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,FeatureMap,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\FeatureMap.cs,CalculateAngleQuantizationTable,The following statement contains a magic number: for (int angle = 0; angle <= 360; angle++)                {                  int directedAngle;                    directedAngle = (int)System.Math.Round(2f * GlobalParameters.NUM_OF_QUNATIZED_ORIENTATIONS / 360 * angle);                  directedAngle &= 7;                             angleQuantizationTable[angle] = (byte)directedAngle;              }
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,FeatureMap,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\FeatureMap.cs,CalculateAngleQuantizationTable,The following statement contains a magic number: for (int angle = 0; angle <= 360; angle++)                {                  int directedAngle;                    directedAngle = (int)System.Math.Round(2f * GlobalParameters.NUM_OF_QUNATIZED_ORIENTATIONS / 360 * angle);                  directedAngle &= 7;                             angleQuantizationTable[angle] = (byte)directedAngle;              }
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,FeatureMap,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\FeatureMap.cs,RetainImportantQuantizedOrientations,The following statement contains a magic number: if (minSameOrientations < 0 || minSameOrientations > 9 /*3x3 neigborhood*/)                  throw new Exception("Minimal number of same orientations should be in: [0..9].");
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,ImageTemplate,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\Template\ImageTemplate\ImageTemplate.cs,ExtractTemplate,The following statement contains a magic number: return FilterScatteredFeatures(candidates' maxNumOfFeatures' 5);
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,ImageTemplate,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\Template\ImageTemplate\ImageTemplate.cs,FilterScatteredFeatures,The following statement contains a magic number: int distance = 50;
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,Compute,The following statement contains a magic number: using (var uFrame = frame.Lock())              {                  ParallelLauncher.Launch(thread =>                   {                      computeColor(thread' (byte*)uFrame.ImageData' uFrame.Stride' orientationImage' _magnitudeSqrImage' minSqrMagnitude);                  }'                   frame.Width() - 2 * kernelRadius' frame.Height() - 2 * kernelRadius);              }
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,Compute,The following statement contains a magic number: using (var uFrame = frame.Lock())              {                  ParallelLauncher.Launch(thread =>                   {                      computeColor(thread' (byte*)uFrame.ImageData' uFrame.Stride' orientationImage' _magnitudeSqrImage' minSqrMagnitude);                  }'                   frame.Width() - 2 * kernelRadius' frame.Height() - 2 * kernelRadius);              }
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,computeColor,The following statement contains a magic number: frame = frame + frameStride * thread.Y + thread.X * 3 /*sizeof(Bgr<byte>)*/;
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,computeColor,The following statement contains a magic number: for (int ch = 0; ch < 3; ch++)              {                  var srcPtr = frame + ch;                    int sumX = 0' sumY = 0;                  for (int r = 0; r < 3; r++)                  {                      var chPtr = srcPtr;                      for (int c = 0; c < 3; c++)                      {                          sumX += *chPtr * Sobel_3x3_X[r' c];                          sumY += *chPtr * Sobel_3x3_Y[r' c];                            chPtr += 3 * sizeof(byte);                      }                        srcPtr = (byte*)srcPtr + frameStride;                  }                  //sumX >>= 3; sumY >>= 3; //divide by 8 (normalize kernel)                    var grad = sumX * sumX + sumY * sumY;                  if (grad > maxMagSqr)                  {                      maxMagSqr = grad;                      maxDx = sumX;                      maxDy = sumY;                  }              }
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,computeColor,The following statement contains a magic number: for (int ch = 0; ch < 3; ch++)              {                  var srcPtr = frame + ch;                    int sumX = 0' sumY = 0;                  for (int r = 0; r < 3; r++)                  {                      var chPtr = srcPtr;                      for (int c = 0; c < 3; c++)                      {                          sumX += *chPtr * Sobel_3x3_X[r' c];                          sumY += *chPtr * Sobel_3x3_Y[r' c];                            chPtr += 3 * sizeof(byte);                      }                        srcPtr = (byte*)srcPtr + frameStride;                  }                  //sumX >>= 3; sumY >>= 3; //divide by 8 (normalize kernel)                    var grad = sumX * sumX + sumY * sumY;                  if (grad > maxMagSqr)                  {                      maxMagSqr = grad;                      maxDx = sumX;                      maxDy = sumY;                  }              }
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,computeColor,The following statement contains a magic number: for (int ch = 0; ch < 3; ch++)              {                  var srcPtr = frame + ch;                    int sumX = 0' sumY = 0;                  for (int r = 0; r < 3; r++)                  {                      var chPtr = srcPtr;                      for (int c = 0; c < 3; c++)                      {                          sumX += *chPtr * Sobel_3x3_X[r' c];                          sumY += *chPtr * Sobel_3x3_Y[r' c];                            chPtr += 3 * sizeof(byte);                      }                        srcPtr = (byte*)srcPtr + frameStride;                  }                  //sumX >>= 3; sumY >>= 3; //divide by 8 (normalize kernel)                    var grad = sumX * sumX + sumY * sumY;                  if (grad > maxMagSqr)                  {                      maxMagSqr = grad;                      maxDx = sumX;                      maxDy = sumY;                  }              }
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,computeColor,The following statement contains a magic number: for (int ch = 0; ch < 3; ch++)              {                  var srcPtr = frame + ch;                    int sumX = 0' sumY = 0;                  for (int r = 0; r < 3; r++)                  {                      var chPtr = srcPtr;                      for (int c = 0; c < 3; c++)                      {                          sumX += *chPtr * Sobel_3x3_X[r' c];                          sumY += *chPtr * Sobel_3x3_Y[r' c];                            chPtr += 3 * sizeof(byte);                      }                        srcPtr = (byte*)srcPtr + frameStride;                  }                  //sumX >>= 3; sumY >>= 3; //divide by 8 (normalize kernel)                    var grad = sumX * sumX + sumY * sumY;                  if (grad > maxMagSqr)                  {                      maxMagSqr = grad;                      maxDx = sumX;                      maxDy = sumY;                  }              }
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,Compute,The following statement contains a magic number: using (var uFrame = frame.Lock())              {                  ParallelLauncher.Launch(thread =>                  {                      computeGray(thread' (byte*)uFrame.ImageData' uFrame.Stride' orientationImage' _magnitudeSqrImage' minSqrMagnitude);                  }'                  frame.Width() - 2 * kernelRadius' frame.Height() - 2 * kernelRadius);              }
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,Compute,The following statement contains a magic number: using (var uFrame = frame.Lock())              {                  ParallelLauncher.Launch(thread =>                  {                      computeGray(thread' (byte*)uFrame.ImageData' uFrame.Stride' orientationImage' _magnitudeSqrImage' minSqrMagnitude);                  }'                  frame.Width() - 2 * kernelRadius' frame.Height() - 2 * kernelRadius);              }
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,computeGray,The following statement contains a magic number: for (int r = 0; r < 3; r++)              {                  for (int c = 0; c < 3; c++)                  {                      sumX += srcPtr[c] * Sobel_3x3_X[r' c];                      sumY += srcPtr[c] * Sobel_3x3_Y[r' c];                  }                    srcPtr = (byte*)srcPtr + frameStride;              }
Magic Number,Accord.Extensions.Imaging.Algorithms.LINE2D,GradientComputation,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\FeatureExtraction\GradientComputation.cs,computeGray,The following statement contains a magic number: for (int r = 0; r < 3; r++)              {                  for (int c = 0; c < 3; c++)                  {                      sumX += srcPtr[c] * Sobel_3x3_X[r' c];                      sumY += srcPtr[c] * Sobel_3x3_Y[r' c];                  }                    srcPtr = (byte*)srcPtr + frameStride;              }
Missing Default,DotImaging,Platform,C:\repos\dajuric_accord-net-extensions\Source\ImageProcessing\FastTemplateMatching\DotImaging\Platform.cs,AddDllSearchPath,The following switch statement is missing a default case: switch (RunningPlatform)              {                  case OperatingSystem.Windows:                      path = "PATH";                        break;                  case OperatingSystem.MacOS:                      path = "LD_LIBRARY_PATH";                      break;                  case OperatingSystem.Linux:                      path = "DYLD_FRAMEWORK_PATH";                      break;              }
